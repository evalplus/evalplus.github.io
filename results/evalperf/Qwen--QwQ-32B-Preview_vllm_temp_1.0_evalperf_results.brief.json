{"date": "2024-11-30 05:28", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 83.40946214084755, "dps_norm": 79.22630813689112, "pass@1": 83.72033898305085}, "eval": {"HumanEval/9": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until the given moment in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    max_val = numbers[0]\n    result = [max_val]\n    for num in numbers[1:]:\n        if num > max_val:\n            max_val = num\n        result.append(max_val)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_val = numbers[0]\n    result = [max_val]\n    \n    for num in numbers[1:]:\n        if num > max_val:\n            max_val = num\n        result.append(max_val)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until the given moment in the sequence.\"\"\"\n    if not numbers:\n        return []\n    \n    max_list = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        max_list.append(current_max)\n    \n    return max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until the given moment in the sequence.\n    \n    Parameters:\n    numbers (List[int]): A list of integers.\n    \n    Returns:\n    List[int]: A list containing the rolling maximum elements.\n    \n    Example:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until the given moment in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list containing the rolling maximum elements.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until the given moment in the sequence.\"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    max_so_far = numbers[0]\n    result = [max_so_far]\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/0": {"dps": 52.325581395348834, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, there are any two numbers closer to each other than the given threshold.\n\n    Args:\n        numbers: A list of floating-point numbers.\n        threshold: A floating-point number representing the maximum allowed distance between any two numbers.\n\n    Returns:\n        A boolean value indicating whether any two numbers in the list are closer to each other than the threshold.\n\n    Examples:\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n    \"\"\"\n\n    # Sort the list of numbers to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n        threshold (float): The threshold distance to check for closeness.\n\n    Returns:\n        bool: True if any two numbers are closer to each other than the threshold, False otherwise.\n    \"\"\"\n    # Sort the list to make it easier to find closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Check if any two numbers in the list are closer to each other than the threshold.\n    # We sort the list first to make it easier to check for close elements.\n    sorted_numbers = sorted(numbers)\n    # Then we iterate through the sorted list, checking the difference between\n    # consecutive elements.\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, any two numbers are closer to each other than the given threshold.\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Sort the list of numbers\n    numbers.sort()\n    \n    # Iterate through the sorted list and check if any two consecutive numbers are closer than the threshold\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, there are any two numbers closer to each other than the given threshold.\n\n    Args:\n    numbers: A list of floating-point numbers.\n    threshold: A floating-point number representing the maximum allowed distance between any two numbers.\n\n    Returns:\n    A boolean value indicating whether any two numbers in the list are closer to each other than the threshold.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list of numbers to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Sort the list of numbers\n    numbers_sorted = sorted(numbers)\n    \n    # Iterate through the sorted list and check if any two consecutive numbers are closer than the threshold\n    for i in range(len(numbers_sorted) - 1):\n        if numbers_sorted[i+1] - numbers_sorted[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than given threshold.\n\n    Args:\n        numbers (List[float]): List of floating-point numbers.\n        threshold (float): The maximum allowed distance between any two numbers.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, there are any two numbers closer to each other than the given threshold.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n    threshold (float): The threshold distance to check between any two numbers.\n\n    Returns:\n    bool: True if any two numbers are closer to each other than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list of numbers to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n        threshold (float): The minimum required distance between any two numbers.\n\n    Returns:\n        bool: True if any two numbers are closer to each other than the threshold, False otherwise.\n\n    Examples:\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n    \"\"\"\n    # Sort the list to make it easier to find closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check distances between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    :param numbers: List of floating-point numbers.\n    :param threshold: The maximum allowed distance between any two numbers.\n    :return: True if any two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to find closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check distances between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    Args:\n    numbers: A list of floating-point numbers.\n    threshold: A floating-point number representing the maximum allowed distance between any two numbers.\n\n    Returns:\n    A boolean value indicating whether any two numbers are closer than the threshold.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(1, len(numbers_sorted)):\n        if numbers_sorted[i] - numbers_sorted[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    :param numbers: List of floating point numbers.\n    :param threshold: A floating point number representing the maximum allowed distance between any two numbers.\n    :return: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n\n    # Sort the list of numbers to make it easier to find closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    Args:\n        numbers: A list of floating-point numbers.\n        threshold: A floating-point number representing the maximum allowed distance\n        between any two numbers.\n\n    Returns:\n        A boolean value indicating whether any two numbers in the list are closer to each\n        other than the threshold.\n\n    Examples:\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Sort the list to make it easier to find closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check if any two consecutive numbers are closer than the threshold\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    Args:\n    numbers (List[float]): A list of floating-point numbers.\n    threshold (float): The threshold distance to check against.\n\n    Returns:\n    bool: True if any two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check if any adjacent elements are closer than the threshold\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n        threshold (float): The threshold distance to check between numbers.\n\n    Returns:\n        bool: True if any two numbers are closer to each other than the threshold, False otherwise.\n\n    Examples:\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n    \"\"\"\n    # Sort the list to make it easier to find closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check distances between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Sort the list to make it easier to find closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check if any two consecutive numbers are closer than the threshold\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 69.88924050632912, "dps_norm": 75.83333333333333, "pass@1": 91.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # or raise an exception, depending on the desired behavior\n    mean_val = sum(numbers) / n\n    return sum(abs(x - mean_val) for x in numbers) / n", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ValueError(\"Input list must not be empty.\")\n    mean_value = sum(numbers) / len(numbers)\n    return sum(abs(x - mean_value) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty.\")\n    \n    mean_val = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean_val) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\nimport numpy as np\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # or raise an error, depending on requirements\n    mean_val = np.mean(numbers)\n    mad = np.mean(np.abs(np.array(numbers) - mean_val))\n    return float(mad)", "matching_cluster_idx": 5}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Calculate the Mean Absolute Deviation around the mean of the dataset.\n\n    Mean Absolute Deviation (MAD) is the average absolute difference between\n    each element and the mean of the dataset. It is calculated as:\n    MAD = (1/n) * sum(|x - x_mean|) for all x in the dataset\n\n    Args:\n        numbers (List[float]): A list of numerical values.\n\n    Returns:\n        float: The Mean Absolute Deviation of the dataset.\n\n    Examples:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n        >>> mean_absolute_deviation([1.5, 2.5, 3.5])\n        0.6666666666666666\n        >>> mean_absolute_deviation([10.0, 12.0, 23.0, 23.5, 16.0])\n        4.9\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list must not be empty.\")\n    \n    mean_value = mean(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    mad = mean(deviations)\n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        return 0.0  # or could raise an error, depending on requirements\n    mean_val = sum(numbers) / len(numbers)\n    return sum(abs(x - mean_val) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Calculate Mean Absolute Deviation around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n    numbers: A list of floating-point numbers.\n    \n    Returns:\n    The Mean Absolute Deviation as a floating-point number.\n    \"\"\"\n    if not numbers:\n        return 0.0  # or consider raising an error for empty lists\n    \n    mean_value = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # or raise an error, depending on requirements\n    mean_value = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean_value = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    absolute_differences = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of these absolute differences\n    mad = sum(absolute_differences) / len(absolute_differences)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # or consider raising an error for empty list\n    \n    mean_value = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean_val = sum(numbers) / len(numbers)\n    return sum(abs(x - mean_val) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Calculate the Mean Absolute Deviation (MAD) for a list of numbers.\n\n    MAD is the average of the absolute differences between each number and the mean of the dataset.\n\n    Args:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    float: The Mean Absolute Deviation of the numbers.\n\n    Example:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average |x - x_mean|\n\n    Args:\n        numbers (List[float]): List of numbers to calculate MAD.\n\n    Returns:\n        float: Mean Absolute Deviation.\n\n    Examples:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n        >>> mean_absolute_deviation([1.5, 2.5, 3.5])\n        0.6666666666666666\n        >>> mean_absolute_deviation([10.0, 12.0, 23.0, 23.0, 16.0, 23.0, 21.0, 16.0])\n        4.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list must not be empty.\")\n\n    mean_value = sum(numbers) / len(numbers)\n    total_deviation = sum(abs(x - mean_value) for x in numbers)\n    return total_deviation / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # or could raise an error, depending on requirements\n    mean_value = mean(numbers)\n    return mean([abs(x - mean_value) for x in numbers])", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate the Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average |x - x_mean|\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    mean_val = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean_val) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    mean_val = sum(numbers) / len(numbers)\n    return sum(abs(x - mean_val) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # or consider raising an error for empty list\n\n    mean_val = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean_val) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \n    Calculate the Mean Absolute Deviation (MAD) around the mean of a given list of numbers.\n    \n    MAD is the average absolute difference between each element and the mean of the dataset.\n    Formula: MAD = average |x - x_mean|\n    \n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n    \n    Returns:\n    float: The Mean Absolute Deviation of the input numbers.\n    \n    Examples:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([1.5, 2.5, 3.5])\n    0.6666666666666666\n    \"\"\"\n    if not numbers:\n        return 0.0  # or raise an error, depending on the desired behavior\n    \n    mean_value = mean(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    mad = mean(deviations)\n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Calculate Mean Absolute Deviation around the mean of the dataset.\n    \n    Mean Absolute Deviation (MAD) is the average absolute difference between\n    each element and the mean of the dataset:\n    MAD = average | x - x_mean |\n    \n    Args:\n    numbers: A list of floating-point numbers.\n    \n    Returns:\n    The Mean Absolute Deviation of the dataset.\n    \n    Example:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list must not be empty.\")\n    \n    mean_value = statistics.mean(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    mad = statistics.mean(deviations)\n    return mad", "matching_cluster_idx": 0}]}, "HumanEval/16": {"dps": 96.74418604651163, "dps_norm": 97.22222222222223, "pass@1": 90.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    if not isinstance(string, str):\n        raise ValueError(\"Input must be a string.\")\n    \n    # Normalize the string to lowercase to ignore case differences\n    normalized_string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(normalized_string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\"\"\"\n    if not string:\n        return 0\n    \n    # Normalize the string to lower case to ignore case differences\n    normalized_string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(normalized_string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\"\"\"\n    if not string:\n        return 0\n    lower_string = string.lower()\n    return len(set(lower_string))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    # Convert the string to lowercase to make the function case-insensitive\n    string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set()\n    \n    # Iterate through each character in the string\n    for char in string:\n        # Add the character to the set\n        unique_chars.add(char)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(s: str) -> int:\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string.\")\n    return len(set(s.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    if not string:\n        return 0\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(s: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\"\"\"\n    if not s:\n        return 0\n    # Normalize the string to lower case to ignore case differences\n    normalized_str = s.lower()\n    # Use a set to store unique characters\n    unique_chars = set(normalized_str)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    Args:\n    string (str): The input string to analyze.\n\n    Returns:\n    int: The number of distinct characters in the string, ignoring case.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to ignore case differences\n    lower_case_string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(lower_case_string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    if not isinstance(string, str):\n        raise ValueError(\"Input must be a string.\")\n    # Normalize the string to lowercase to ignore case differences\n    normalized_string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(normalized_string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # Convert the string to lower case to make it case-insensitive\n    string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\"\"\"\n    if not string:\n        return 0\n    \n    # Convert the string to lower case to make it case-insensitive\n    string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(string)\n    \n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to ignore the case differences\n    string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    if not isinstance(string, str):\n        raise ValueError(\"Input must be a string.\")\n    \n    # Normalize the string to lowercase to ignore case differences\n    normalized_string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(normalized_string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    Args:\n        string (str): The input string to analyze.\n\n    Returns:\n        int: The number of distinct characters in the string, ignoring case.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    lower_case_string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(lower_case_string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    if not string:\n        return 0\n\n    # Convert string to lower case to make it case-insensitive\n    string = string.lower()\n\n    # Use a set to store unique characters\n    unique_chars = set(string)\n\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    if not string:\n        return 0\n\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n\n    # Use a set to store unique characters\n    unique_chars = set(string)\n\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    if not isinstance(string, str):\n        raise TypeError('Input must be a string')\n    \n    if not string:\n        return 0  # No characters in an empty string\n\n    # Normalize the string to lowercase to ignore case differences\n    normalized_string = string.lower()\n\n    # Use a set to store unique characters\n    unique_chars = set(normalized_string)\n\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 96.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n    \n    sorted_numbers = sorted(numbers)\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_difference = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_difference < min_difference:\n            min_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers_sorted = sorted(numbers)\n    closest_pair = None\n    min_distance = float('inf')\n    for i in range(len(numbers_sorted) - 1):\n        current_distance = numbers_sorted[i+1] - numbers_sorted[i]\n        if current_distance < min_distance:\n            min_distance = current_distance\n            closest_pair = (numbers_sorted[i], numbers_sorted[i+1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_difference = sorted_numbers[1] - sorted_numbers[0]\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_difference < min_difference:\n            min_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers to make it easier to find the closest pair\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_difference = sorted_numbers[1] - sorted_numbers[0]\n    \n    # Iterate through the sorted list and find the pair with the smallest difference\n    for num1, num2 in zip(sorted_numbers, sorted_numbers[1:]):\n        difference = num2 - num1\n        if difference < min_difference:\n            min_difference = difference\n            closest_pair = (num1, num2)\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport sys\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    sorted_numbers = sorted(numbers)\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = sys.float_info.max\n    \n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\nimport math\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the closest pair with the first two elements\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_distance = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for num1, num2 in zip(sorted_numbers, sorted_numbers[1:]):\n        distance = abs(num2 - num1)\n        if distance < min_distance:\n            min_distance = distance\n            closest_pair = (num1, num2)\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    sorted_numbers = sorted(numbers)\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_distance = sorted_numbers[1] - sorted_numbers[0]\n    \n    for i in range(1, len(sorted_numbers) - 1):\n        current_distance = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_distance < min_distance:\n            min_distance = current_distance\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n    \n    sorted_numbers = sorted(numbers)\n    closest_pair = None\n    min_distance = float('inf')\n    \n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if diff < min_distance:\n            min_distance = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n\n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_difference = sorted_numbers[1] - sorted_numbers[0]\n\n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_difference < min_difference:\n            min_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to make finding the closest elements easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for num1, num2 in zip(sorted_numbers, sorted_numbers[1:]):\n        diff = num2 - num1\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (num1, num2)\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom math import isclose\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    closest_pair = None\n    min_distance = float('inf')\n    \n    for i in range(len(sorted_numbers) - 1):\n        current_distance = sorted_numbers[i+1] - sorted_numbers[i]\n        if current_distance < min_distance:\n            min_distance = current_distance\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    # Handle the case where the closest elements are equal\n    if isclose(closest_pair[0], closest_pair[1], rel_tol=1e-9):\n        return (closest_pair[0], closest_pair[1])\n    else:\n        return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each other and return them in order (smaller number, larger number).\n\n    Args:\n    numbers: A list of float numbers with at least two elements.\n\n    Returns:\n    A tuple containing the two closest numbers in ascending order.\n\n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_difference = sorted_numbers[1] - sorted_numbers[0]\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_difference < min_difference:\n            min_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the closest pair with the first two elements\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < smallest_diff:\n            smallest_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the closest pair with the first two elements\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = closest_pair[1] - closest_pair[0]\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for num1, num2 in zip(sorted_numbers, sorted_numbers[1:]):\n        diff = num2 - num1\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (num1, num2)\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to make finding the closest elements easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for num1, num2 in zip(sorted_numbers, sorted_numbers[1:]):\n        diff = abs(num2 - num1)\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (num1, num2)\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    sorted_numbers = sorted(numbers)\n    closest_pair = None\n    smallest_diff = float('inf')\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < smallest_diff:\n            smallest_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_difference = sorted_numbers[1] - sorted_numbers[0]\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_difference < min_difference:\n            min_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers_sorted = sorted(numbers)\n    min_diff = float('inf')\n    result = (None, None)\n    for i in range(len(numbers_sorted) - 1):\n        diff = numbers_sorted[i + 1] - numbers_sorted[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers_sorted[i], numbers_sorted[i + 1])\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 77.31292517006803, "dps_norm": 46.25, "pass@1": 99.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The number to find the largest divisor for.\n\n    Returns:\n        int: The largest divisor of n that is smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(80)\n        40\n        >>> largest_divisor(13)\n        1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    raise ValueError(\"No divisor found for n\")", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    # Start from the largest possible divisor, which is n // 2\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # if no divisor is found, which should only happen when n is 1 or 0", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start checking from n-1 down to 1\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1 (though this should only happen for n=1)", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(80)\n        40\n        >>> largest_divisor(13)\n        1\n        >>> largest_divisor(100)\n        50\n        >>> largest_divisor(1)\n        1\n    \"\"\"\n    if n <= 1:\n        return 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case no divisor is found, though this should never happen for n > 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    # Start from the largest possible divisor, which is n//2\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # if no divisor is found, which should only happen when n is 1 or 0", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start checking from n-1 down to 1\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1 (though for n > 1, there should be at least 1)", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n\n    Args:\n    n (int): The number to find the largest divisor for.\n\n    Returns:\n    int: The largest divisor of n that is smaller than n.\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(80)\n    40\n    >>> largest_divisor(13)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    raise ValueError(\"No divisor found for n\")", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(80)\n    40\n    >>> largest_divisor(13)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input should be greater than 1.\")\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    # The largest divisor of n, smaller than n, is n//2 if n is even, or the largest prime factor if n is prime.\n    # For simplicity, iterate from n-1 down to 1 and return the first divisor.\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1 (though for n > 1, there should always be a divisor)", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\"\"\"\n    # Start checking from n-1 down to 1\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\"\"\"\n    if n <= 1:\n        raise ValueError(\"No divisor exists for n <= 1\")\n    # Start from the largest possible divisor, which is n//2\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    raise ValueError(\"No divisor found for n\")", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start from the largest possible divisor, which is n//2\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1, as 1 divides all integers", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(8)\n    4\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    1\n    \"\"\"\n    if n <= 1:\n        return 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # This line should theoretically never be reached due to the inclusion of 1 in the loop", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(80)\n    40\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    # Start from half of n and go downwards to find the largest divisor\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, which should only happen when n is 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(80)\n    40\n    >>> largest_divisor(13)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # This line should theoretically never be reached due to the above loop", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(80)\n    40\n    >>> largest_divisor(13)\n    1\n    \"\"\"\n    # Start checking from n-1 down to 1\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1 (though this should only happen for n=1)", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The number to find the largest divisor for.\n\n    Returns:\n        int: The largest divisor of n that is smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(49)\n        7\n        >>> largest_divisor(2)\n        1\n    \"\"\"\n    # Start from the largest possible divisor that is smaller than n, which is n//2\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1, since 1 divides all integers.", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The number to find the largest divisor for.\n\n    Returns:\n        int: The largest divisor of n that is smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(16)\n        8\n        >>> largest_divisor(17)\n        1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    raise ValueError(\"No divisor found for n={}\".format(n))", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The number to find the largest divisor for.\n\n    Returns:\n        int: The largest divisor of n that is smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(80)\n        40\n        >>> largest_divisor(13)\n        1\n        >>> largest_divisor(100)\n        50\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    raise ValueError(\"No divisor found for n={}\".format(n))", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    Args:\n        n (int): The number to find the largest divisor for.\n        \n    Returns:\n        int: The largest divisor of n that is smaller than n.\n        \n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(28)\n        14\n        >>> largest_divisor(13)\n        1\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer greater than 0.\")\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, which should only happen for n=1", "matching_cluster_idx": 4}]}, "HumanEval/26": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    frequency = {}\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): The input list of integers.\n\n    Returns:\n        List[int]: A list with duplicates removed, preserving the order of unique elements.\n\n    Example:\n        >>> remove_duplicates([1, 2, 3, 2, 4])\n        [1, 3, 4]\n    \"\"\"\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    result = []\n    for num in numbers:\n        if frequency[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    \n    Examples:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([5, 5, 5, 5, 5])\n    []\n    >>> remove_duplicates([10, 20, 30, 40, 50])\n    [10, 20, 30, 40, 50]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1, 1])\n    []\n    >>> remove_duplicates([2, 3, 2, 4, 6, 3])\n    [4, 6]\n    \"\"\"\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    frequency = {}\n    for number in numbers:\n        frequency[number] = frequency.get(number, 0) + 1\n    return [number for number in numbers if frequency[number] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): The input list of integers.\n\n    Returns:\n        List[int]: A list with duplicates removed, preserving the order of unique elements.\n\n    Examples:\n        >>> remove_duplicates([1, 2, 3, 2, 4])\n        [1, 3, 4]\n        >>> remove_duplicates([5, 5, 5, 5, 5])\n        []\n        >>> remove_duplicates([10, 20, 30, 40, 50])\n        [10, 20, 30, 40, 50]\n        >>> remove_duplicates([])\n        []\n    \"\"\"\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([1, 2, 3, 4])\n    [1, 2, 3, 4]\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    \n    Parameters:\n    numbers (List[int]): The input list of integers.\n    \n    Returns:\n    List[int]: A list of integers with duplicates removed, preserving the order.\n    \n    Example:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    \"\"\"\n    # Count the occurrences of each number\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    # Collect numbers that occur only once, preserving their order\n    result = [num for num in numbers if counts[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): The input list of integers.\n\n    Returns:\n        List[int]: A new list with duplicates removed.\n\n    Examples:\n        >>> remove_duplicates([1, 2, 3, 2, 4])\n        [1, 3, 4]\n        >>> remove_duplicates([5, 5, 5, 5, 5])\n        []\n        >>> remove_duplicates([10, 20, 30, 40, 50])\n        [10, 20, 30, 40, 50]\n        >>> remove_duplicates([])\n        []\n    \"\"\"\n    # Count the occurrences of each number\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    # Collect numbers that occur only once, preserving their order\n    result = [num for num in numbers if counts[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    \n    Args:\n    numbers: A list of integers.\n    \n    Returns:\n    A list of integers with duplicates removed.\n    \n    Example:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): The input list of integers.\n\n    Returns:\n        List[int]: A new list with duplicates removed, preserving the order of unique elements.\n\n    Examples:\n        >>> remove_duplicates([1, 2, 3, 2, 4])\n        [1, 3, 4]\n        >>> remove_duplicates([5, 5, 5, 5, 5])\n        []\n        >>> remove_duplicates([10, 20, 30, 40, 50])\n        [10, 20, 30, 40, 50]\n    \"\"\"\n    from collections import Counter\n\n    # Count the occurrences of each number in the list\n    counts = Counter(numbers)\n\n    # Filter out numbers that occur only once, preserving their order\n    result = [num for num in numbers if counts[num] == 1]\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    frequency = {}\n    for number in numbers:\n        frequency[number] = frequency.get(number, 0) + 1\n    return [number for number in numbers if frequency[number] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    \n    Examples:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([5, 5, 5, 5, 5])\n    []\n    >>> remove_duplicates([10, 20, 30, 40, 50])\n    [10, 20, 30, 40, 50]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1, 1])\n    []\n    >>> remove_duplicates([2, 3, 2, 4, 6, 3])\n    [4, 6]\n    \"\"\"\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n    return [num for num in numbers if frequency[num] == 1]", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 97.46835443037975, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n\n    Args:\n        n (int): The number to check for primality.\n\n    Returns:\n        bool: True if n is prime, False otherwise.\n\n    Examples:\n        >>> is_prime(6)\n        False\n        >>> is_prime(101)\n        True\n        >>> is_prime(11)\n        True\n        >>> is_prime(13441)\n        True\n        >>> is_prime(61)\n        True\n        >>> is_prime(4)\n        False\n        >>> is_prime(1)\n        False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n\n    Examples:\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n\n    Examples:\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": 97.22222222222223, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    \n    # Create a copy of the original list to modify\n    result = l.copy()\n    \n    # Update the sorted elements back into the result list\n    sorted_index = 0\n    for i in range(0, len(l), 3):\n        result[i] = sorted_divisible[sorted_index]\n        sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    l_prime = l.copy()\n    # Replace elements at indices divisible by three with sorted ones\n    for i, val in enumerate(sorted_divisible_by_three):\n        l_prime[i * 3] = val\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a copy of the original list to modify\n    l_prime = l.copy()\n    \n    # Replace elements at indices divisible by three with sorted values\n    sorted_index = 0\n    for index in range(0, len(l), 3):\n        if sorted_index < len(sorted_divisible_by_three):\n            l_prime[index] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three (0-based index)\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    result = l[:]\n    # Replace the sorted elements back into their positions\n    sorted_index = 0\n    for i in range(0, len(result), 3):\n        result[i] = sorted_divisible[sorted_index]\n        sorted_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    \n    # Create a copy of the original list to modify\n    result = l.copy()\n    \n    # Replace the sorted elements back into their positions\n    sorted_index = 0\n    for i in range(0, len(l), 3):\n        result[i] = sorted_divisible[sorted_index]\n        sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    l_prime = l[:]\n    # Replace the elements at indices divisible by three with the sorted ones\n    for i, value in enumerate(sorted_divisible_by_three):\n        l_prime[i * 3] = value\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at positions divisible by three (0-based index)\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    result = l.copy()\n    # Update the positions divisible by three with sorted values\n    for i, val in enumerate(sorted_divisible):\n        result[i * 3] = val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    l_prime = l.copy()\n    # Replace the elements at indices divisible by three with the sorted ones\n    for i, val in enumerate(sorted_divisible_by_three):\n        l_prime[i * 3] = val\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a copy of the original list to modify\n    l_prime = l.copy()\n    \n    # Replace the elements at indices divisible by three with the sorted ones\n    for i, value in enumerate(sorted_divisible_by_three):\n        l_prime[i * 3] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    \n    # Create a copy of the original list to modify\n    result = l.copy()\n    \n    # Replace the sorted elements back into their positions\n    sorted_index = 0\n    for i in range(0, len(l), 3):\n        if sorted_index < len(sorted_divisible):\n            result[i] = sorted_divisible[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    result = l.copy()\n    # Replace the sorted elements back into their positions\n    sorted_index = 0\n    for i in range(0, len(l), 3):\n        result[i] = sorted_divisible[sorted_index]\n        sorted_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three (0-based)\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    result = l.copy()\n    # Replace the sorted elements back into their positions\n    sorted_index = 0\n    for i in range(0, len(l), 3):\n        result[i] = sorted_divisible[sorted_index]\n        sorted_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three (0-based index)\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    result = l.copy()\n    # Replace the sorted elements back into their positions\n    sorted_index = 0\n    for i in range(0, len(l), 3):\n        result[i] = sorted_divisible[sorted_index]\n        sorted_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    \n    # Create a copy of the original list to modify\n    result = l.copy()\n    \n    # Replace the sorted elements back into their positions\n    sorted_index = 0\n    for i in range(0, len(l), 3):\n        result[i] = sorted_divisible[sorted_index]\n        sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three (0-based)\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    result = l[:]\n    # Replace the sorted elements back into their positions\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible[sorted_index]\n            sorted_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    result = l.copy()\n    # Replace the sorted elements back into their positions\n    sorted_index = 0\n    for i in range(0, len(l), 3):\n        result[i] = sorted_divisible[sorted_index]\n        sorted_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    result = l[:]\n    # Replace the sorted elements back into their positions\n    sorted_index = 0\n    for i in range(0, len(result), 3):\n        result[i] = sorted_divisible[sorted_index]\n        sorted_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at positions divisible by three (0-based index)\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    result = l[:]\n    # Replace the sorted elements back into their positions\n    sorted_index = 0\n    for i in range(0, len(result), 3):\n        result[i] = sorted_divisible[sorted_index]\n        sorted_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    result = l[:]\n    # Replace the sorted elements back into their positions\n    sorted_index = 0\n    for i in range(0, len(result), 3):\n        result[i] = sorted_divisible[sorted_index]\n        sorted_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_three)\n    # Create a copy of the original list to modify\n    result = l[:]\n    # Replace the sorted elements back into the result list at the correct positions\n    sorted_index = 0\n    for i in range(0, len(l), 3):\n        result[i] = sorted_divisible[sorted_index]\n        sorted_index += 1\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 95.47169811320755, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n\n    Args:\n        l (list): The input list containing elements.\n\n    Returns:\n        list: A list of unique elements sorted in ascending order.\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    # Use set to remove duplicates and then convert back to list\n    unique_list = list(set(l))\n    # Sort the list in ascending order\n    unique_list.sort()\n    return unique_list", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Create a set from the list to remove duplicates\n    unique_set = set(l)\n    # Convert the set back to a list and sort it\n    sorted_unique_list = sorted(list(unique_set))\n    return sorted_unique_list", "matching_cluster_idx": 3}, {"solution": "def unique(l: list):\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    Args:\n    l (list): The input list containing elements of any hashable type.\n\n    Returns:\n    list: A list of unique elements from the input list, sorted in ascending order.\n\n    Example:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list and sort it\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list and sort it\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n\n    Args:\n    l (list): The input list containing elements of any hashable type.\n\n    Returns:\n    list: A list of unique elements from the input list, sorted in ascending order.\n\n    Example:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Use a set to remove duplicates and then convert it back to a sorted list\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n\n    Args:\n        l (list): The input list containing elements of any hashable type.\n\n    Returns:\n        list: A list of unique elements from the input list, sorted in ascending order.\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n        >>> unique(['apple', 'banana', 'apple', 'cherry'])\n        ['apple', 'banana', 'cherry']\n        >>> unique([1.1, 2.2, 3.3, 2.2, 1.1])\n        [1.1, 2.2, 3.3]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Use a set to remove duplicates and then convert it back to a sorted list\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # First, create a set from the list to remove duplicates\n    unique_set = set(l)\n    # Then, convert the set back to a list\n    unique_list = list(unique_set)\n    # Sort the list in ascending order\n    unique_list.sort()\n    # Return the sorted list of unique elements\n    return unique_list", "matching_cluster_idx": 4}, {"solution": "def unique(lst: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(lst))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def fizz_buzz(n: int):\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Parameters:\n    n (int): The upper limit (exclusive) to check for numbers divisible by 11 or 13.\n    \n    Returns:\n    int: The count of digit 7 appearances in the specified numbers.\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    :param n: int - the upper limit (exclusive) to check for numbers divisible by 11 or 13.\n    :return: int - the count of digit 7 appearances in the specified numbers.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: The upper limit (exclusive) to check for numbers divisible by 11 or 13.\n    :return: The count of digit 7 appearances in those numbers.\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n\n    # Initialize a counter for the occurrences of '7'\n    count = 0\n\n    # Iterate through numbers less than n\n    for num in range(1, n):\n        # Check if the number is divisible by 11 or 13\n        if num % 11 == 0 or num % 13 == 0:\n            # Convert the number to a string to count '7's\n            num_str = str(num)\n            # Count the occurrences of '7' in the string\n            count += num_str.count('7')\n    # Return the total count of '7's\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    :param n: Upper limit (exclusive) to check for numbers divisible by 11 or 13.\n    :return: Count of digit 7 appearances in qualifying numbers.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Parameters:\n    n (int): The upper limit (exclusive) to check for numbers divisible by 11 or 13.\n    \n    Returns:\n    int: The total count of digit '7' appearances in the specified numbers.\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 94.92635024549918, "dps_norm": 90.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the extracted elements\n    even_indices_elements_sorted = sorted(even_indices_elements)\n    # Create the result list by placing sorted elements back at even indices\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices_elements_sorted[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the elements from even indices\n    sorted_even_elements = sorted(even_indices_elements)\n    # Create the result list with sorted even indices and original odd indices\n    result = []\n    even_iter = iter(sorted_even_elements)\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Even index: take from sorted even elements\n            result.append(next(even_iter))\n        else:\n            # Odd index: take from original list\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the elements from even indices\n    even_indices_elements_sorted = sorted(even_indices_elements)\n    # Create the result list with sorted even indices and original odd indices\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices_elements_sorted[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the extracted elements\n    even_indices_elements_sorted = sorted(even_indices_elements)\n    # Create the resulting list\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Place the next sorted even index element\n            result.append(even_indices_elements_sorted[even_index])\n            even_index += 1\n        else:\n            # Place the original odd index element\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the extracted elements\n    sorted_even_elements = sorted(even_indices_elements)\n    # Create the resulting list\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Place the next sorted even element\n            result.append(sorted_even_elements[even_index])\n            even_index += 1\n        else:\n            # Place the original odd index element\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the elements from even indices\n    sorted_even_elements = sorted(even_indices_elements)\n    # Create the result list with sorted even indices and original odd indices\n    result = []\n    even_iter = iter(sorted_even_elements)\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Even index: take from sorted even elements\n            result.append(next(even_iter))\n        else:\n            # Odd index: take from original list\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the elements from even indices\n    sorted_even_elements = sorted(even_indices_elements)\n    \n    # Create the result list with the same size as the original list\n    result = [None] * len(l)\n    \n    # Fill in the sorted even indices elements and keep odd indices as is\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Even index, assign the next sorted even element\n            result[i] = sorted_even_elements[even_index]\n            even_index += 1\n        else:\n            # Odd index, keep the original value\n            result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the extracted elements\n    sorted_even_elements = sorted(even_indices_elements)\n    # Create the resulting list with sorted evens and original odds\n    result = []\n    even_idx = 0\n    for idx in range(len(l)):\n        if idx % 2 == 0:\n            # Place the next sorted even element\n            result.append(sorted_even_elements[even_idx])\n            even_idx += 1\n        else:\n            # Place the original odd index element\n            result.append(l[idx])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = sorted(l[::2])\n    odd_indices = l[1::2]\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices.pop(0))\n        else:\n            result.append(odd_indices.pop(0))\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    even_indices_sorted = sorted(even_indices)\n    result = []\n    even_index = 0\n    for index, value in enumerate(l):\n        if index % 2 == 0:\n            result.append(even_indices_sorted[even_index])\n            even_index += 1\n        else:\n            result.append(value)\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the extracted elements\n    sorted_even_elements = sorted(even_indices_elements)\n    # Create the resulting list\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Place the next sorted even element\n            result.append(sorted_even_elements[even_index])\n            even_index += 1\n        else:\n            # Place the original odd index element\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the elements from even indices\n    sorted_even_elements = sorted(even_indices_elements)\n    \n    # Create a list to hold the result\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # If index is even, take the next sorted even element\n            result.append(sorted_even_elements[even_index])\n            even_index += 1\n        else:\n            # If index is odd, take the original odd element\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the extracted elements\n    sorted_even_elements = sorted(even_indices_elements)\n    # Create the resulting list\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Place the next sorted even element\n            result.append(sorted_even_elements[even_index])\n            even_index += 1\n        else:\n            # Keep the odd index element as is\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the elements from even indices\n    sorted_even_elements = sorted(even_indices_elements)\n    # Create the result list\n    result = []\n    even_idx = 0\n    for idx in range(len(l)):\n        if idx % 2 == 0:\n            # Place the next sorted even element\n            result.append(sorted_even_elements[even_idx])\n            even_idx += 1\n        else:\n            # Keep the original odd index element\n            result.append(l[idx])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the extracted elements\n    sorted_even_elements = sorted(even_indices_elements)\n    # Prepare a list to hold the result\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Place the next sorted even element\n            result.append(sorted_even_elements[even_index])\n            even_index += 1\n        else:\n            # Place the original odd index element\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the elements from even indices\n    even_indices_elements_sorted = sorted(even_indices_elements)\n    # Create the result list with sorted even indices and original odd indices\n    result = []\n    even_counter = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices_elements_sorted[even_counter])\n            even_counter += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = [i for i in range(0, len(l), 2)]\n    even_values = [l[i] for i in even_indices]\n    even_values_sorted = sorted(even_values)\n    \n    l_sorted = l.copy()\n    for idx, val in zip(even_indices, even_values_sorted):\n        l_sorted[idx] = val\n    return l_sorted", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    even_indices_values_sorted = sorted(even_indices_values)\n    \n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices_values_sorted[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the extracted elements\n    sorted_even_elements = sorted(even_indices_elements)\n    # Create the resulting list\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Place the next sorted even element\n            result.append(sorted_even_elements.pop(0))\n        else:\n            # Place the original odd index element\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    even_indices_values_sorted = sorted(even_indices_values)\n    \n    result = l.copy()\n    for i, val in enumerate(even_indices_values_sorted):\n        result[i*2] = val\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 95.11764705882354, "dps_norm": 96.0, "pass@1": 87.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    if n == 0:\n        return 1 % p  # 2^0 is 1, modulo p\n    result = 1\n    base = 2 % p\n    while n > 0:\n        if n % 2 == 1:  # If n is odd, multiply base with result\n            result = (result * base) % p\n        base = (base * base) % p  # Square the base\n        n //= 2  # Divide n by 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Calculate 2 raised to the power of n, modulo p.\n    \n    Parameters:\n    n (int): The exponent to which 2 is raised.\n    p (int): The modulus to be applied to 2**n.\n    \n    Returns:\n    int: The result of (2**n) % p.\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    if n < 0:\n        # Negative exponent handling\n        if p == 1:\n            return 0  # Special case where p=1, anything mod 1 is 0\n        # Find modular inverse of 2 modulo p\n        mod_inv = pow(2, p - 2, p)\n        return pow(mod_inv, -n, p)\n    else:\n        return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    if p == 1:\n        return 0\n    num = 1\n    for _ in range(n):\n        num = (num * 2) % p\n    return num", "matching_cluster_idx": 0}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Compute 2^n modulo p.\n\n    Parameters:\n    n (int): Exponent to which 2 is raised.\n    p (int): Modulus.\n\n    Returns:\n    int: The result of (2^n) mod p.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    # Using Python's built-in pow function for efficiency\n    # pow(base, exponent, modulus) computes (base^exponent) % modulus\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    if n == 0:\n        return 1 % p  # Handle the case when n is 0\n    base = 2 % p\n    result = 1\n    while n > 0:\n        if n % 2 == 1:  # If n is odd, multiply base with result\n            result = (result * base) % p\n        base = (base * base) % p  # Square the base\n        n //= 2  # Divide n by 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of (2^n) mod p.\n\n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    # Since we are calculating (2^n) % p, we can use Python's built-in pow function\n    # which is efficient and handles large numbers well.\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    if n < 0:\n        # Negative exponent handling\n        if p == 1:\n            raise ValueError(\"Modulo by 1 is undefined.\")\n        # Calculate the modular inverse of 2 modulo p\n        mod_inverse = pow(2, p - 2, p)\n        return pow(mod_inverse, -n, p)\n    else:\n        # Positive exponent handling\n        return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Calculate 2^n modulo p.\n\n    Args:\n    n (int): The exponent to raise 2 to.\n    p (int): The modulus to apply.\n\n    Returns:\n    int: The result of (2^n) mod p.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0  # Since any number modulo 1 is 0\n    if n == 0:\n        return 1 % p  # 2^0 is 1, then modulo p\n    # Compute 2^n modulo p using Python's built-in pow function for efficiency\n    # pow(base, exp, mod) uses modular exponentiation\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    if p == 1:\n        return 0  # Since any number modulo 1 is 0\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    Args:\n    text (str): The input string from which vowels need to be removed.\n    \n    Returns:\n    str: The input string with all vowels removed.\n    \n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    Args:\n    text (str): The input string from which vowels need to be removed.\n    \n    Returns:\n    str: The input string with all vowels removed.\n    \n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    Parameters:\n    text (str): The input string from which vowels need to be removed.\n    \n    Returns:\n    str: The input string with all vowels removed.\n    \n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    Parameters:\n    text (str): The input string from which vowels need to be removed.\n    \n    Returns:\n    str: The input string with all vowels removed.\n    \n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 72.55319148936171, "dps_norm": 82.85714285714286, "pass@1": 20.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Count characters in both strings\n    from collections import Counter\n    counter0 = Counter(s0)\n    counter1 = Counter(s1)\n    \n    # Check if the sets of unique characters are the same\n    return set(counter0.keys()) == set(counter1.keys())", "matching_cluster_idx": 2}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings contain exactly the same characters, False otherwise.\n    \n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Create sets of unique characters from both strings\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Count the frequency of each character in both strings\n    from collections import Counter\n    counter0 = Counter(s0)\n    counter1 = Counter(s1)\n    \n    # Check if the sets of unique characters are the same\n    return set(counter0.keys()) == set(counter1.keys())", "matching_cluster_idx": 2}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    :param s0: First input string.\n    :param s1: Second input string.\n    :return: True if both strings consist of the same set of characters, False otherwise.\n    \n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function determines whether two strings contain exactly the same characters,\n    regardless of the order or frequency of those characters. It is case-sensitive.\n    \n    Parameters:\n    - s0 (str): The first string to compare.\n    - s1 (str): The second string to compare.\n    \n    Returns:\n    - bool: True if both strings have the same characters, False otherwise.\n    \n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets to remove duplicates and compare the sets\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function checks if two given strings contain exactly the same characters, \n    regardless of their order or frequency. It returns True if both strings have \n    the same unique characters, and False otherwise.\n    \n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings have the same unique characters, False otherwise.\n    \n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function determines whether two strings contain exactly the same characters,\n    regardless of the order or frequency of those characters. It is case-sensitive.\n    \n    Parameters:\n    - s0 (str): The first string to compare.\n    - s1 (str): The second string to compare.\n    \n    Returns:\n    - bool: True if both strings have the same characters, False otherwise.\n    \"\"\"\n    # Create sets from the strings to eliminate duplicates and ignore order\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function checks if two given strings contain exactly the same characters, \n    regardless of their order or frequency. It returns True if both strings have \n    the same unique characters, and False otherwise.\n    \n    Parameters:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings have the same unique characters, False otherwise.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function determines whether two strings contain exactly the same characters,\n    regardless of the order or frequency of those characters. It is case-sensitive.\n    \n    Parameters:\n    - s0 (str): The first string to compare.\n    - s1 (str): The second string to compare.\n    \n    Returns:\n    - bool: True if both strings have the same characters, False otherwise.\n    \"\"\"\n    \n    # Create sets from the characters in both strings\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Compare the sets directly to check if they have the same characters\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    from collections import Counter\n    # Count the occurrences of each character in both strings\n    counter0 = Counter(s0)\n    counter1 = Counter(s1)\n    # Check if the sets of unique characters are the same\n    return counter0.keys() == counter1.keys()", "matching_cluster_idx": 2}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function determines whether two strings contain exactly the same characters,\n    regardless of the order or frequency of those characters.\n    \n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings have the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets to remove duplicates and compare the sets\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function determines whether two strings contain exactly the same characters,\n    regardless of the order or frequency of those characters. It is case-sensitive.\n    \n    Parameters:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings have the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets to remove duplicates and compare the sets\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Remove duplicates by converting strings to sets\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "from typing import Counter\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Count the frequency of each character in both strings\n    counter0 = Counter(s0)\n    counter1 = Counter(s1)\n    \n    # Get the set of unique characters in both strings\n    chars0 = set(counter0.keys())\n    chars1 = set(counter1.keys())\n    \n    # Check if the sets of unique characters are equal\n    return chars0 == chars1", "matching_cluster_idx": 2}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings contain exactly the same characters, False otherwise.\n    \n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Create sets of unique characters from both strings\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Create a set of unique characters in each string\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function checks if two given strings contain exactly the same characters,\n    regardless of their order or frequency. It returns True if both strings have the\n    same unique set of characters, and False otherwise.\n    \n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings have the same unique characters, False otherwise.\n    \n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "from typing import Counter\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Args:\n    s0 (str): The first string.\n    s1 (str): The second string.\n    \n    Returns:\n    bool: True if both strings have the same characters, False otherwise.\n    \n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    counter0 = Counter(s0)\n    counter1 = Counter(s1)\n    return set(counter0.keys()) == set(counter1.keys())", "matching_cluster_idx": 2}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function checks whether two given strings contain exactly the same characters,\n    regardless of the order or frequency of those characters. It returns True if both strings\n    have the same unique characters, and False otherwise.\n    \n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings have the same unique characters, False otherwise.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    from collections import Counter\n    # Count the occurrences of each character in both strings\n    counter_s0 = Counter(s0)\n    counter_s1 = Counter(s1)\n    \n    # Check if the sets of unique characters are equal\n    return set(counter_s0.keys()) == set(counter_s1.keys())", "matching_cluster_idx": 2}]}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find common elements using set intersection\n    common_elements = set(l1) & set(l2)\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n\n    Args:\n    l1 (list): First input list.\n    l2 (list): Second input list.\n\n    Returns:\n    list: Sorted list of unique elements found in both input lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to remove duplicates and find intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a sorted list\n    result = sorted(list(common_elements))\n    return result", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find unique elements in both lists\n    unique_l1 = set(l1)\n    unique_l2 = set(l2)\n    \n    # Find intersection of both unique sets to get common elements\n    common_elements = unique_l1.intersection(unique_l2)\n    \n    # Return the sorted list of common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    common_set = set1.intersection(set2)\n    \n    # Convert the set back to a sorted list\n    result = sorted(list(common_set))\n    return result", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find intersection\n    common_set = set(l1).intersection(set(l2))\n    # Convert the set back to a sorted list\n    result = sorted(list(common_set))\n    return result", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find intersection\n    common_elements = set(l1).intersection(set(l2))\n    # Convert the set back to a list and sort it\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n\n    Returns:\n    list: A sorted list of unique elements that are common to both input lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use set intersection to find common elements and then sort the result\n    return sorted(set(l1).intersection(set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to remove duplicates and find intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    # Return the sorted list of common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find common elements using set intersection\n    common_elements = set(l1).intersection(set(l2))\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use set intersection to find common elements and then sort the result\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n    l1: First list of elements.\n    l2: Second list of elements.\n\n    Returns:\n    A sorted list containing unique elements that are common to both input lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use set intersection to find common elements and then sort the result\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use set intersection to find common elements and then sort the result\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find the intersection of the two lists\n    common_elements = list(set(l1) & set(l2))\n    # Sort the common elements\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find intersection\n    common_elements = set(l1).intersection(set(l2))\n    # Convert the set back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find common elements using set intersection\n    common_elements = set(l1) & set(l2)\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find common elements using set intersection\n    common_elements = set(l1) & set(l2)\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find the intersection of the two lists and remove duplicates by converting to a set\n    common_elements = set(l1).intersection(l2)\n    # Return the sorted list of common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to remove duplicates and find intersection\n    common_set = set(l1).intersection(set(l2))\n    # Convert the set back to a list and sort it\n    common_list = sorted(list(common_set))\n    return common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use set intersection to find common elements and then sort the result\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find unique elements in both lists using sets\n    unique_l1 = set(l1)\n    unique_l2 = set(l2)\n    \n    # Find intersection of both sets to get common elements\n    common_elements = unique_l1.intersection(unique_l2)\n    \n    # Return the sorted list of common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 95.08680555555556, "dps_norm": 96.11111111111111, "pass@1": 99.0, "profiled": [{"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the smallest prime factor\n    factor = 2\n    last_factor = 1\n    # Divide n by 2 until it's odd\n    while n % factor == 0:\n        last_factor = factor\n        n //= factor\n    # n must be odd at this point, so skip even numbers and check only odd factors\n    factor = 3\n    max_factor = int(n ** 0.5) + 1  # No need to check beyond the square root of n\n    while factor <= max_factor:\n        while n % factor == 0:\n            last_factor = factor\n            n //= factor\n        factor += 2\n    if n > 1:\n        last_factor = n  # n is a prime number greater than 2\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n\n    # Function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Start from the largest possible factor, which is n itself\n    factor = n\n    while factor > 1:\n        if n % factor == 0 and is_prime(factor):\n            return factor\n        factor -= 1", "matching_cluster_idx": 1}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n = n // 2\n    \n    # Now n must be odd, so we can skip one element (Note i = i + 2)\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n        i += 2\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the smallest prime factor\n    factor = 2\n    last_prime = -1\n    while n > 1:\n        # If factor divides n, it's a prime factor\n        if n % factor == 0:\n            last_prime = factor\n            # Divide n by factor until it's no longer divisible\n            while n % factor == 0:\n                n //= factor\n        # Move to the next potential factor\n        factor += 1\n        # Optimization: if factor squared is greater than n, n is prime\n        if factor * factor > n:\n            if n > 1:\n                last_prime = n\n            break\n    return last_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n = n // 2\n    \n    # n must be odd at this point, so a skip of 2 (i = i + 2) can be used\n    i = 3\n    while i * i <= n:\n        # While i divides n, remove i and set largest_prime to i\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n        i += 2\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = 2\n    # Divide n by 2 until it's odd\n    while n % i == 0:\n        n = n // i\n    # Now n is odd, start checking from 3\n    i = 3\n    # Check for odd factors\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n        i += 2\n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = -1\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_prime = i\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime number\n    i = 2\n    # Initialize the largest prime factor\n    largest_prime = 0\n    # Check for divisibility by 2 first to handle even numbers\n    while n % i == 0:\n        largest_prime = i\n        n = n / i\n    # Move to odd numbers starting from 3\n    i = 3\n    # Only need to check up to the square root of n\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n = n / i\n        i += 2\n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n    return int(largest_prime)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime number\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        # If factor divides n, divide n by factor and update last_factor\n        while n % factor == 0:\n            n //= factor\n            last_factor = factor\n        # Increment factor\n        factor += 1\n        # Optimization: if factor squared is greater than n, n is prime\n        if factor * factor > n:\n            if n > 1:\n                last_factor = n\n            break\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    # Start from the smallest possible prime factor\n    factor = 2\n    last_prime = 1\n    while n > 1:\n        if n % factor == 0:\n            # If factor divides n, divide n by factor as many times as possible\n            while n % factor == 0:\n                n //= factor\n            # Check if the factor is prime\n            if is_prime(factor):\n                last_prime = factor\n        factor += 1\n    return last_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return max(factors)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the smallest prime factor\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        # If factor divides n, divide n by factor and update last_factor\n        while n % factor == 0:\n            n //= factor\n            last_factor = factor\n        factor += 1\n        # Optimization: If factor squared is greater than n, n is prime\n        if factor * factor > n:\n            if n > 1:\n                last_factor = n\n            break\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 89.48051948051948, "dps_norm": 61.875, "pass@1": 33.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Return the number of vowels in the string s.\n    Vowels are 'a', 'e', 'i', 'o', 'u', and 'y' only when it is at the end of the word.\n    \n    :param s: string to count vowels in\n    :return: number of vowels in s\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Calculate the number of vowels in the string.\n    \n    Vowels are 'a', 'e', 'i', 'o', 'u'. 'y' is considered a vowel only if it is at the end of the word.\n    \n    Args:\n        s (str): The input string representing a word.\n    \n    Returns:\n        int: The number of vowels in the string.\n    \"\"\"\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Returns the number of vowels in the string. Vowels are 'a', 'e', 'i', 'o', 'u'.\n    'y' is considered a vowel only when it is at the end of the given word.\n\n    :param s: The input string representing a word.\n    :return: The number of vowels in the string.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"encyclopedia\")\n    6\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"SYZYGY\")\n    1\n    \"\"\"\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Counts the number of vowels in a string. Vowels are 'a', 'e', 'i', 'o', 'u'.\n    'y' is considered a vowel only if it is at the end of the string.\n\n    Args:\n        s (str): The input string representing a word.\n\n    Returns:\n        int: The number of vowels in the string.\n\n    Examples:\n        >>> vowels_count(\"abcde\")\n        2\n        >>> vowels_count(\"ACEDY\")\n        3\n        >>> vowels_count(\"ACED\")\n        2\n        >>> vowels_count(\"ABCDY\")\n        2\n        >>> vowels_count(\"AEIOUY\")\n        6\n        >>> vowels_count(\"y\")\n        1\n        >>> vowels_count(\"Y\")\n        1\n        >>> vowels_count(\"\")\n        0\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    s = s.lower()\n    vowels = 'aeiou'\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n    \n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = 'aeiou'\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Count the number of vowels in the string.\n    \n    Vowels are 'a', 'e', 'i', 'o', 'u', and 'y' only if it is at the end of the word.\n    \n    Args:\n        s (str): The input string representing a word.\n        \n    Returns:\n        int: The number of vowels in the string.\n        \n    Examples:\n        >>> vowels_count(\"abcde\")\n        2\n        >>> vowels_count(\"ACEDY\")\n        3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()\n    length = len(s)\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Return the number of vowels in the string. Vowels are 'a', 'e', 'i', 'o', 'u'.\n    'y' is also considered a vowel only when it is at the end of the word.\n\n    :param s: String representing a word.\n    :return: Number of vowels in the string.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = \"aeiou\"\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Count the number of vowels in the given string.\n\n    Vowels are 'a', 'e', 'i', 'o', 'u'. 'y' is considered a vowel only if it is at the end of the string.\n\n    :param s: The input string to check for vowels.\n    :return: The number of vowels in the string.\n\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"hello\")\n    2\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"rhythm\")\n    0\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()\n    length = len(s)\n    for i in range(length):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = 'aeiou'\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Count the number of vowels in a given string. Vowels are 'a', 'e', 'i', 'o', 'u'.\n    Additionally, 'y' is considered a vowel only if it is at the end of the string.\n\n    Args:\n    s (str): The input string representing a word.\n\n    Returns:\n    int: The count of vowels in the string.\n\n    Examples:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"quick\")\n    1\n    >>> vowels_count(\"rhythm\")\n    1\n    >>> vowels_count(\"AEIOUY\")\n    6\n    >>> vowels_count(\"bcdfg\")\n    0\n    >>> vowels_count(\"y\")\n    1\n    >>> vowels_count(\"apple\")\n    2\n    >>> vowels_count(\"\u7f18\")\n    0\n    >>> vowels_count(\"123\")\n    0\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()\n    length = len(s)\n    for char in s:\n        if char in vowels:\n            count += 1\n    if length > 0 and s[-1] == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Count the number of vowels in a string. Vowels are 'a', 'e', 'i', 'o', 'u'.\n    'y' is considered a vowel only if it is at the end of the string.\n    \n    Args:\n    s (str): The input string representing a word.\n    \n    Returns:\n    int: The number of vowels in the string.\n    \n    Examples:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"acceY\")\n    3\n    >>> vowels_count(\"ACED\")\n    3\n    >>> vowels_count(\"YNVT\")\n    0\n    >>> vowels_count(\"y\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"a\")\n    1\n    >>> vowels_count(\"\")\n    0\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Counts the number of vowels in a string, considering 'y' as a vowel only if it is at the end of the string.\n\n    Args:\n    s (str): The input string representing a word.\n\n    Returns:\n    int: The number of vowels in the string.\n\n    Examples:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"quick\")\n    2\n    >>> vowels_count(\"rhythm\")\n    1\n    >>> vowels_count(\"SYZYGY\")\n    1\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Returns the number of vowels in the string.\n    Vowels are 'a', 'e', 'i', 'o', 'u', and 'y' only when it is at the end of the word.\n    \n    :param s: input string representing a word\n    :type s: str\n    :return: number of vowels in the string\n    :rtype: int\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Count the number of vowels in the given string.\n    Vowels are 'a', 'e', 'i', 'o', 'u', and 'y' only if it's at the end of the string.\n    The function is case-insensitive.\n\n    Args:\n    s (str): The input string representing a word.\n\n    Returns:\n    int: The number of vowels in the string.\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()\n    length = len(s)\n    for char in s:\n        if char in vowels:\n            count += 1\n    if length > 0 and s[-1] == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Return the number of vowels in the string s.\n    Vowels are 'a', 'e', 'i', 'o', 'u', and 'y' only if it is at the end of the string.\n\n    :param s: The input string representing a word.\n    :return: The number of vowels in the string.\n\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"AEIOUY\")\n    6\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"hello\")\n    2\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"SYZYGY\")\n    1\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()\n    length = len(s)\n    for char in s:\n        if char in vowels:\n            count += 1\n    if length > 0 and s[-1] == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    This function takes a string representing a word as input and returns the number of vowels in the string.\n    Vowels are 'a', 'e', 'i', 'o', 'u', and 'y' is considered a vowel only when it is at the end of the word.\n\n    Args:\n    s (str): The input word.\n\n    Returns:\n    int: The count of vowels in the word.\n\n    Examples:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"ACEDYing\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"SYZYGY\")\n    1\n    \"\"\"\n\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()\n\n    for char in s:\n        if char in vowels:\n            count += 1\n\n    if s.endswith('y'):\n        count += 1\n\n    # If 'y' is at the end, it's already counted, but need to ensure it's only counted once\n    # However, in the initial approach, it's already counted once correctly, so no further action needed.\n\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1  # Return the first list if totals are equal", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(string) for string in lst1)\n    total_chars_lst2 = sum(len(string) for string in lst2)\n    \n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    This function accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n    If the two lists have the same number of chars, it returns the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1  # If totals are equal, return the first list", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Accepts two lists of strings and returns the list that has \n    total number of characters in all strings of the list less than the other list.\n\n    If the two lists have the same number of characters, return the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total characters in lst1\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    \n    # Calculate total characters in lst2\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare and return the list with fewer total characters\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1  # Return the first list if totals are equal", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Accepts two lists of strings and returns the list with fewer total characters.\n    If both lists have the same number of characters, returns the first list.\n    '''\n    # Calculate total characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1  # Same number of characters, return first list", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1  # Return the first list if counts are equal", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in all strings of lst1\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    # Calculate the total number of characters in all strings of lst2\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1  # Return the first list if both have the same number of characters", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    \n    if len1 < len2:\n        return lst1\n    elif len2 < len1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in all strings of lst1\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    # Calculate the total number of characters in all strings of lst2\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1  # Return the first list if counts are equal", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    \n    if len1 < len2:\n        return lst1\n    elif len2 < len1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # calculate total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # compare and return the list with fewer total characters\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1  # return the first list if totals are equal", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 83.66336633663366, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate through list with index\n    for index, value in enumerate(lst):\n        # Check if index is odd and value is even\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n    lst (list): A list of integers.\n\n    Returns:\n    int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize sum\n    total = 0\n\n    # Iterate through list with index\n    for index, value in enumerate(lst):\n        # Check if index is odd and value is even\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate through list with index\n    for index, value in enumerate(lst):\n        # Check if index is odd and value is even\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index in range(len(lst)):\n        if index % 2 != 0 and lst[index] % 2 == 0:\n            total += lst[index]\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n    lst: A list of integers.\n\n    Returns:\n    The sum of even elements that are located at odd indices in the list.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum\n    total = 0\n\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the value to the total\n            total += value\n\n    # Return the total sum\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate through list with index\n    for index, value in enumerate(lst):\n        # Check if index is odd and value is even\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) --> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) == 2\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate through list with index\n    for index, value in enumerate(lst):\n        # Check if index is odd and value is even\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Adds even elements that are at odd indices in a given list of integers.\n\n    Args:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index in range(len(lst)):\n        if index % 2 != 0 and lst[index] % 2 == 0:\n            total += lst[index]\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    sum = 0\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            sum += lst[i]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize a variable to hold the sum of even elements at odd indices\n    sum_even_at_odd = 0\n\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the value to the sum\n            sum_even_at_odd += value\n\n    # Return the calculated sum\n    return sum_even_at_odd", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize sum\n    sum = 0\n    # Iterate through list with index\n    for index, value in enumerate(lst):\n        # Check if index is odd and value is even\n        if index % 2 != 0 and value % 2 == 0:\n            sum += value\n    return sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to zero\n    total = 0\n\n    # Iterate through the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the value to the total\n            total += value\n\n    # Return the total sum\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to zero\n    total = 0\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the value to the total\n            total += value\n    # Return the total sum\n    return total", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": 85.17006802721089, "dps_norm": 87.0, "pass@1": 22.0, "profiled": [{"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ASCII value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split(' ')\n    \n    # Initialize an empty list to hold the ordered words\n    ordered_words = []\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Convert the word to a list of characters\n        chars = list(word)\n        \n        # Sort the list of characters based on ASCII values\n        chars_sorted = sorted(chars)\n        \n        # Join the sorted characters back into a string\n        ordered_word = ''.join(chars_sorted)\n        \n        # Append the ordered word to the list\n        ordered_words.append(ordered_word)\n    \n    # Join the ordered words back into a single string with spaces\n    ordered_sentence = ' '.join(ordered_words)\n    \n    return ordered_sentence", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Returns a version of the input string where each word has its characters sorted in ascending ASCII order.\n    Preserves the original word order and spacing.\n    \n    Parameters:\n    s (str): The input string to process.\n    \n    Returns:\n    str: A string with each word's characters sorted in ascending ASCII order.\n    \"\"\"\n    def sort_word(word):\n        # Sort the characters in the word based on ASCII values\n        return ''.join(sorted(word))\n    \n    # Split the string into words, sort each word, and join them back with spaces\n    return ' '.join(sort_word(word) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Reorders each word in the input string 's' such that the characters within\n    each word are sorted in ascending ASCII order, while preserving the original\n    word order and spacing.\n\n    Parameters:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A new string where each word is replaced by a sorted version of itself.\n\n    Examples:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words\n    words = s.split(' ')\n    \n    # Initialize a list to hold the transformed words\n    sorted_words = []\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Convert the word to a list of characters\n        char_list = list(word)\n        \n        # Sort the list of characters based on ASCII values\n        char_list.sort()\n        \n        # Convert the sorted list back to a string\n        sorted_word = ''.join(char_list)\n        \n        # Append the sorted word to the list\n        sorted_words.append(sorted_word)\n    \n    # Join the sorted words back into a single string with spaces\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Returns a version of the input string where each word has its characters sorted in ascending ASCII order.\n    Preserves the original word order and spaces.\n    \"\"\"\n    def sort_word(word):\n        # Sort characters in the word based on ASCII values\n        return ''.join(sorted(word))\n    \n    # Split the input string into words\n    words = s.split(' ')\n    \n    # Sort each word and collect them into a list\n    sorted_words = [sort_word(word) for word in words]\n    \n    # Join the sorted words back into a string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ASCII value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [sorted(word, key=lambda c: (c.isalpha(), c)) for word in words]\n    ordered_words = [''.join(word) for word in ordered_words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": -1}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Returns a version of the input string where each word has its characters sorted in ascending ASCII order.\n    Preserves the original word order and spaces.\n    \"\"\"\n    def sort_word(word):\n        # Sort the characters in the word based on ASCII values\n        return ''.join(sorted(word))\n    \n    # Split the input string into words\n    words = s.split(' ')\n    \n    # Sort each word and collect them into a list\n    sorted_words = [sort_word(word) for word in words]\n    \n    # Join the sorted words back into a string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Replaces each word in the input string with a new word where the characters are sorted in ascending ASCII order,\n    while preserving the order of words and spaces in the original string.\n\n    Parameters:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A new string where each word has its characters sorted in ascending ASCII order.\n\n    Examples:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words based on spaces\n    words = s.split(' ')\n    \n    # Initialize an empty list to hold the transformed words\n    transformed_words = []\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Check if the word contains only alphabetic characters\n        if word.isalpha():\n            # Sort the characters in the word in ascending ASCII order and join them back into a string\n            sorted_word = ''.join(sorted(word))\n        else:\n            # For words containing non-alphabetic characters, sort all characters including spaces\n            sorted_word = ''.join(sorted(word))\n        # Append the sorted word to the list of transformed words\n        transformed_words.append(sorted_word)\n    \n    # Join the transformed words back into a single string with spaces in between\n    result = ' '.join(transformed_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Returns a version of the input string where all words have their characters sorted in ascending ASCII order,\n    while preserving the order of words and spaces.\n    \"\"\"\n    def sort_word(word):\n        # Sort the characters in the word based on ASCII values\n        return ''.join(sorted(word))\n    \n    # Split the string into words, sort each word, and then join them back with spaces\n    return ' '.join(sort_word(word) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    for index in range(len(words)):\n        chars = list(words[index])\n        chars.sort(key=lambda x: (x.islower(), x.isupper(), x))\n        words[index] = ''.join(chars)\n    return ' '.join(words)", "matching_cluster_idx": -1}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Returns a version of the input string where each word has its characters sorted in ascending ASCII order.\n    Preserves the original word order and spaces.\n    \"\"\"\n    # Split the input string into words\n    words = s.split(' ')\n    \n    # Initialize an empty list to hold the transformed words\n    transformed_words = []\n    \n    for word in words:\n        # Sort the characters in the word based on ASCII values\n        sorted_chars = sorted(word)\n        # Join the sorted characters back into a string\n        sorted_word = ''.join(sorted_chars)\n        # Append the sorted word to the list\n        transformed_words.append(sorted_word)\n    \n    # Join the transformed words back into a single string with spaces\n    result = ' '.join(transformed_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Returns a version of the input string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in ascending\n    order based on ASCII value. The order of words and blank spaces in the\n    sentence is preserved.\n\n    :param s: The input string to process.\n    :type s: str\n    :return: The ordered version of the input string.\n    :rtype: str\n    \"\"\"\n\n    # Split the input string into words based on spaces.\n    words = s.split(' ')\n\n    # Initialize an empty list to hold the transformed words.\n    transformed_words = []\n\n    # Iterate over each word in the list.\n    for word in words:\n        # Sort the characters in the word based on ASCII values.\n        sorted_chars = sorted(word)\n        # Join the sorted characters back into a string.\n        sorted_word = ''.join(sorted_chars)\n        # Append the sorted word to the list of transformed words.\n        transformed_words.append(sorted_word)\n\n    # Join the transformed words back into a single string with spaces.\n    transformed_sentence = ' '.join(transformed_words)\n\n    return transformed_sentence", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Reorders each word in the input string 's' such that the characters in each word\n    are sorted in ascending order based on their ASCII values. The function preserves\n    the order of words and spaces in the original string.\n\n    Parameters:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A string where each word is replaced with a new word having its characters\n         sorted in ascending ASCII order.\n\n    Examples:\n    >>> anti_shuffle('Hi')\n    'Hi'\n    >>> anti_shuffle('hello')\n    'ehllo'\n    >>> anti_shuffle('Hello World!!!')\n    'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    parts = []\n    current = []\n    for char in s:\n        if char == ' ':\n            if current:\n                parts.append(''.join(current))\n                current = []\n            parts.append(' ')\n        else:\n            current.append(char)\n    if current:\n        parts.append(''.join(current))\n\n    # Sort characters in each word part\n    sorted_parts = []\n    for part in parts:\n        if part == ' ':\n            sorted_parts.append(part)\n        else:\n            sorted_parts.append(''.join(sorted(part)))\n\n    # Join all parts back into a single string\n    return ''.join(sorted_parts)", "matching_cluster_idx": 1}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Returns a version of the input string where each word has its characters sorted in ascending ASCII order.\n    Preserves the original word order and spacing.\n    \"\"\"\n    def sort_word(word):\n        # Sorts the characters in the word based on ASCII values\n        return ''.join(sorted(word))\n    \n    # Split the sentence into words\n    words = s.split(' ')\n    \n    # Sort each word and collect them into a list\n    sorted_words = [sort_word(word) for word in words]\n    \n    # Join the sorted words back into a sentence\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Replaces each word in the input string with a new word where the characters\n    are sorted in ascending ASCII order, while maintaining the original word order\n    and spacing.\n    \n    Parameters:\n    s (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A new string where each word has its characters sorted in ascending ASCII order.\n    \"\"\"\n    # Split the input string into words\n    words = s.split(' ')\n    \n    # Initialize a list to hold the transformed words\n    transformed_words = []\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Convert the word to a list of characters\n        char_list = list(word)\n        \n        # Sort the list of characters based on their ASCII values\n        char_list.sort()\n        \n        # Join the sorted list back into a string\n        sorted_word = ''.join(char_list)\n        \n        # Append the sorted word to the list of transformed words\n        transformed_words.append(sorted_word)\n    \n    # Join the transformed words back into a single string with spaces\n    result = ' '.join(transformed_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ASCII value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\n    def sort_word(word):\n        # Sort characters in the word based on ASCII value\n        return ''.join(sorted(word))\n\n    # Split the input string into words\n    words = s.split(' ')\n    # Sort each word and collect them into a list\n    sorted_words = [sort_word(word) for word in words]\n    # Join the sorted words back into a string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Returns a string with each word's characters sorted in ascending ASCII order.\n    Preserves the original word order and spaces.\n    \"\"\"\n    def sort_word(word):\n        # Split the word into characters, sort them, and join back into a string\n        return ''.join(sorted(word))\n    \n    # Split the input string into words\n    words = s.split(' ')\n    \n    # Sort each word and collect them into a new list\n    sorted_words = [sort_word(word) for word in words]\n    \n    # Join the sorted words back into a string with spaces\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    This function takes a string and returns an ordered version of it.\n    Ordered version of string is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in\n    ascending order based on ASCII value.\n    Note: The order of words and blank spaces in the sentence is maintained.\n    \n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Helo !!!Wdlor'\n    \"\"\"\n    # Split the input string into words based on spaces\n    words = s.split(' ')\n    \n    # Initialize an empty list to hold the ordered words\n    ordered_words = []\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Convert the word to a list of characters\n        char_list = list(word)\n        # Sort the list of characters based on ASCII values\n        char_list.sort()\n        # Join the sorted list back into a string\n        ordered_word = ''.join(char_list)\n        # Append the ordered word to the list\n        ordered_words.append(ordered_word)\n    \n    # Join the ordered words back into a single string with spaces\n    ordered_string = ' '.join(ordered_words)\n    \n    return ordered_string", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words based on spaces\n    words = s.split(' ')\n    \n    # Initialize an empty list to hold the ordered words\n    ordered_words = []\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Sort the characters in the word based on ASCII value\n        sorted_chars = sorted(word)\n        # Join the sorted characters back into a string\n        ordered_word = ''.join(sorted_chars)\n        # Append the ordered word to the list\n        ordered_words.append(ordered_word)\n    \n    # Join the ordered words back into a single string with spaces\n    ordered_s = ' '.join(ordered_words)\n    \n    return ordered_s", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    for i in range(len(words)):\n        chars = list(words[i])\n        chars.sort()\n        words[i] = ''.join(chars)\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    for i in range(len(words)):\n        letters = list(words[i])\n        letters.sort()\n        words[i] = ''.join(letters)\n    return ' '.join(words)", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 93.94812680115274, "dps_norm": 57.142857142857146, "pass@1": 97.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2-dimensional list, which is similar to a matrix,\n    but each row may contain a different number of columns.\n    Given lst and integer x, find all occurrences of x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2) ...], where each tuple\n    is a coordinate (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over the list with index for row number\n    for row_idx, row in enumerate(lst):\n        # Iterate over the row with index for column number\n        for col_idx, value in enumerate(row):\n            # If the value matches x, append the coordinate as a tuple\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n\n    # Sort the coordinates: first by row in ascending order,\n    # then by column in descending order within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Searches for integer x in a 2D list with varying row lengths and returns coordinates of x in a sorted list of tuples.\n    Coordinates are sorted by rows in ascending order, and within the same row, columns are sorted in descending order.\n    \n    Parameters:\n    lst (list of list of int): The 2D list to search within.\n    x (int): The integer to search for.\n    \n    Returns:\n    list of tuples: A list of coordinates (row, column) where x is found, sorted as per the specifications.\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    # Sort coordinates: by row ascending, then by column descending within the row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find the coordinates of integer x in a nested list with varying row lengths.\n    \n    Args:\n    lst: A list of lists, where each sublist represents a row with varying number of columns.\n    x: An integer to locate within the nested list.\n    \n    Returns:\n    A list of tuples, where each tuple represents the (row, column) index of x in lst.\n    The list is sorted by row in ascending order and by column in descending order within each row.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    \n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over the list with index for row number\n    for row_idx, row in enumerate(lst):\n        # Iterate over the row with index for column number\n        for col_idx, value in enumerate(row):\n            # If the value matches x, append the coordinate as a tuple\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort the coordinates: first by row ascending, then by column descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer x in a nested list (matrix with varying row lengths),\n    and returns a list of coordinates (row, column) where x is found.\n    Coordinates are sorted by row in ascending order and by column in descending order within each row.\n\n    :param lst: A list of lists of integers, representing the matrix.\n    :param x: The integer to search for in the matrix.\n    :return: A list of tuples, each tuple containing two integers representing the row and column indices.\n\n    Examples:\n    get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over the list with index for row number\n    for row_index, row in enumerate(lst):\n        # Iterate over the row with index for column number\n        for col_index, value in enumerate(row):\n            # If the value matches x, append the coordinate as a tuple\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates: first by row in ascending order, then by column in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find coordinates of integer x in a 2D list with varying row lengths.\n    Coordinates are sorted by rows in ascending order and by columns in descending order within each row.\n\n    Args:\n    lst: 2D list of integers with varying row lengths.\n    x: Integer to locate in the list.\n\n    Returns:\n    List of tuples, where each tuple represents the coordinate (row, column) of x in lst.\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    # Sort coordinates: ascending by row, descending by column within the row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the positions of an integer x in a 2D list with variable row lengths.\n    Returns a list of tuples representing coordinates (row, column) in ascending row order\n    and descending column order within each row.\n\n    :param lst: 2D list with variable row lengths\n    :param x: integer to find in the list\n    :return: list of tuples (row, column) sorted as per the specified order\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through the list with enumerate to get both index and row\n    for row_idx, row in enumerate(lst):\n        # Iterate through the row with enumerate to get index and element\n        for col_idx, element in enumerate(row):\n            # If the element matches x, append the coordinate to the list\n            if element == x:\n                coordinates.append((row_idx, col_idx))\n\n    # Sort the coordinates: ascending by row, descending by column within the row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find integers x in a 2D list with varying row lengths and return their coordinates.\n    Coordinates are sorted by rows in ascending order and by columns in descending order within each row.\n    \n    :param lst: 2D list with varying number of columns in each row\n    :param x: integer to find in the list\n    :return: list of tuples (row, column), starting with 0, sorted as specified\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    # Sort coordinates: ascending by row, descending by column within the row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list (nested lists with varying column lengths) and an integer x,\n    find all occurrences of x and return their coordinates as tuples (row, column).\n    Coordinates should be sorted by rows in ascending order and,\n    within the same row, sorted by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Initialize an empty list to store coordinates\n    coordinates = []\n\n    # Iterate through each row in the list\n    for row_idx, row in enumerate(lst):\n        # Within each row, iterate through each element\n        for col_idx, value in enumerate(row):\n            # If the element matches the target integer x\n            if value == x:\n                # Append the coordinate as a tuple to the coordinates list\n                coordinates.append((row_idx, col_idx))\n\n    # Sort the coordinates list:\n    # First by row in ascending order, then by column in descending order within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find integers x in the given 2D list and return their coordinates.\n    Coordinates are sorted by rows in ascending order and by columns in descending order within each row.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate through the list with index for row number\n    for row_idx, row in enumerate(lst):\n        # Iterate through the row with index for column number\n        for col_idx, value in enumerate(row):\n            # If the value matches x, append the coordinate as a tuple\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort the coordinates: ascending by row, descending by column within rows\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, val in enumerate(row):\n            if val == x:\n                coordinates.append((row_idx, col_idx))\n    # Sort coordinates initially by rows in ascending order.\n    # Then, for coordinates in the same row, sort by columns in descending order.\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer x in a nested list (2D list with varying row lengths),\n    and returns a list of tuples representing the coordinates (row, column) of each occurrence.\n    The list is sorted by rows in ascending order, and within each row, columns are sorted in descending order.\n\n    Parameters:\n    lst (list of list of int): The 2D list to search within.\n    x (int): The integer to find in the list.\n\n    Returns:\n    list of tuples: A list where each tuple contains two integers representing the row and column indices.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over the list with enumerate to get both index and sublist\n    for row_idx, sub_lst in enumerate(lst):\n        # Iterate over the sublist with enumerate to get index and element\n        for col_idx, elem in enumerate(sub_lst):\n            # If the element matches x, append the coordinate as a tuple\n            if elem == x:\n                coordinates.append((row_idx, col_idx))\n\n    # Sort the coordinates: first by row ascending, then by column descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list (nested lists) and an integer x, find all occurrences of x\n    and return a list of tuples representing their coordinates (row, column).\n    The coordinates should be sorted by rows in ascending order and,\n    within the same row, sorted by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over the list with row index and row value\n    for row_idx, row in enumerate(lst):\n        # Iterate over the row with column index and column value\n        for col_idx, value in enumerate(row):\n            # If the value matches x, append the coordinate as a tuple\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort the coordinates: first by row ascending, then by column descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds coordinates of a given integer x in a 2D list with variable row lengths.\n    The coordinates are returned as a list of tuples (row, column), sorted by row\n    in ascending order and by column in descending order within each row.\n\n    Parameters:\n    lst (list of list of int): The 2D list to search within.\n    x (int): The integer to find in the list.\n\n    Returns:\n    list of tuples: Coordinates of x in the form (row, column), sorted as specified.\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort coordinates: by row ascending, then by column descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    # Sort coordinates initially by rows in ascending order.\n    # Then, for coordinates in the same row, sort by columns in descending order.\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list (nested lists) and an integer x,\n    find all occurrences of x and return their coordinates\n    in a list of tuples sorted by rows in ascending order\n    and columns in descending order within each row.\n    \n    :param lst: 2D list with varying column lengths\n    :param x: integer to find in the list\n    :return: list of tuples (row, column) sorted as specified\n    \"\"\"\n    \n    # List to store the coordinates\n    coordinates = []\n    \n    # Iterate through the list to find the integer x\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort the coordinates:\n    # First by row in ascending order, then by column in descending order within each row\n    coordinates_sorted = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates_sorted", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Function to find all occurrences of integer x in a 2D list with varying row lengths.\n    Returns a list of coordinates (row, column) in ascending row order and descending column order within rows.\n\n    Parameters:\n    lst (list of list of int): The 2D list to search within.\n    x (int): The integer to locate in the list.\n\n    Returns:\n    list of tuples: Each tuple contains (row, column) of the occurrence of x.\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    # Sort coordinates: ascending row, descending column within rows\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer x in a nested list (matrix with varying row lengths),\n    and returns a list of their coordinates (row, column), sorted as per the specified rules.\n    \n    Parameters:\n    lst (list of list of int): The input nested list where each sublist represents a row.\n    x (int): The integer to locate within the list.\n    \n    Returns:\n    list of tuples: A list of tuples, each representing the coordinates (row, column) of x in lst.\n                     The list is sorted by rows in ascending order, and within the same row,\n                     by columns in descending order.\n    \"\"\"\n    \n    # Initialize an empty list to store coordinates\n    coordinates = []\n    \n    # Iterate through the list to find occurrences of x\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort the coordinates: ascending by row, descending by column within the row\n    # We use a custom sort key to achieve this\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Create a list to store the coordinates of x\n    coordinates = []\n    \n    # Iterate over the list with index for row number\n    for i, row in enumerate(lst):\n        # Iterate over the row with index for column number\n        for j, value in enumerate(row):\n            # If the value is equal to x, append the coordinate to the list\n            if value == x:\n                coordinates.append((i, j))\n    \n    # Sort the coordinates by row in ascending order and by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds coordinates of integer x in a nested list with varying row lengths.\n    The coordinates are sorted by rows in ascending order and by columns in descending order within each row.\n\n    Args:\n    lst: A 2D list (nested lists) with varying number of columns in each row.\n    x: An integer to locate within the list.\n\n    Returns:\n    A list of tuples, where each tuple represents the (row, column) index of x in lst.\n    Rows are 0-based indexed and columns are sorted in descending order within each row.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates: ascending by row, descending by column within the row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds coordinates of integer x in a nested list with varying row lengths.\n    Returns a list of tuples (row, column), sorted by rows ascending and columns descending within rows.\n\n    :param lst: A list of lists (2D list) with varying numbers of columns.\n    :param x: Integer to locate within the list.\n    :return: A list of tuples, each representing the coordinate (row, column) of x.\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    # Sort coordinates: ascending by row, descending by column within the row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.64948453608248, "dps_norm": 28.571428571428573, "pass@1": 100.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet by a specified amount.\n    \n    The function takes a string as input and returns a new string where\n    each letter is shifted down by four places in the alphabet. The rotation\n    is done such that it wraps around the alphabet if necessary.\n    \n    For example:\n    - 'a' becomes 'e'\n    - 'y' becomes 'c' (since 'y' + 4 places is 'c')\n    \n    Parameters:\n    - s: The input string to be encrypted.\n    \n    Returns:\n    - The encrypted string.\n    \n    Example usage:\n    - encrypt('hi') returns 'lm'\n    - encrypt('asdfghjkl') returns 'ewhjklnop'\n    - encrypt('gf') returns 'kj'\n    - encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if char.isalpha():\n            # Determine the case of the character\n            offset = 97 if char.islower() else 65\n            # Rotate the character by 4 places\n            rotated = (ord(char) - offset + 4) % 26 + offset\n            encrypted.append(chr(rotated))\n        else:\n            # Non-alphabetic characters are added unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet by a specific number of places.\n    \n    The alphabet is rotated such that each letter is shifted down by two multiplied\n    to two places, which means each letter is shifted down by four places.\n    \n    For example:\n    - 'a' becomes 'e'\n    - 'b' becomes 'f'\n    - ...\n    - 'w' becomes 'a'\n    - 'x' becomes 'b'\n    - 'y' becomes 'c'\n    - 'z' becomes 'd'\n    \n    Non-alphabetical characters are left unchanged.\n    \n    Args:\n        s (str): The input string to be encrypted.\n        \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    shift = 4  # Since two multiplied by two is four\n    encrypted = []\n    \n    for char in s:\n        if char.isalpha():\n            # Determine if the character is uppercase or lowercase\n            offset = 65 if char.isupper() else 97\n            # Rotate the character and handle wrap-around\n            rotated_char = chr((ord(char) - offset + shift) % 26 + offset)\n            encrypted.append(rotated_char)\n        else:\n            # Non-alphabetical characters are added unchanged\n            encrypted.append(char)\n    \n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    # Define the rotation factor\n    rotation_factor = 2 * 2  # two multiplied to two places\n\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\n    # Create a dictionary to map each letter to its rotated counterpart\n    rotated_alphabet = {}\n    for i, letter in enumerate(alphabet):\n        rotated_index = (i + rotation_factor) % len(alphabet)\n        rotated_alphabet[letter] = alphabet[rotated_index]\n\n    # Encrypt the input string\n    encrypted_string = ''\n    for char in s:\n        if char in rotated_alphabet:\n            encrypted_string += rotated_alphabet[char]\n        else:\n            encrypted_string += char  # Non-alphabetic characters remain unchanged\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 4  # two multiplied by two\n    encrypted = \"\"\n    for c in s:\n        if c.isalpha():\n            shifted = ord(c) + shift\n            if c.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n            elif c.isupper():\n                if shifted > ord('Z'):\n                    shifted -= 26\n            encrypted += chr(shifted)\n        else:\n            encrypted += c\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 4  # two multiplied by two\n    result = ''\n    \n    for char in s:\n        if char.isalpha():\n            shifted = ord(char) + shift\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n            elif char.isupper():\n                if shifted > ord('Z'):\n                    shifted -= 26\n            result += chr(shifted)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    shift = 4  # because two multiplied by two is four\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():  # check if the character is a letter\n            # Determine if the character is uppercase or lowercase for correct ASCII range\n            ascii_offset = 65 if char.isupper() else 97\n            # Rotate the character and handle wrap-around using modulo\n            encrypted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n            encrypted += encrypted_char\n        else:\n            # If it's not a letter, keep it as is\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt a string by rotating the alphabet.\n\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places, i.e., 4 places.\n\n    Args:\n        s (str): The input string to encrypt.\n\n    Returns:\n        str: The encrypted string.\n\n    Examples:\n        >>> encrypt('hi')\n        'lm'\n        >>> encrypt('asdfghjkl')\n        'ewhjklnop'\n        >>> encrypt('gf')\n        'kj'\n        >>> encrypt('et')\n        'ix'\n    \"\"\"\n    shift = 4  # two multiplied to two places\n    encrypted = []\n    for char in s:\n        if char.isalpha():\n            # Determine if the character is uppercase or lowercase\n            offset = 65 if char.isupper() else 97\n            # Rotate the character and wrap around using modulo 26\n            encrypted_char = chr((ord(char) - offset + shift) % 26 + offset)\n            encrypted.append(encrypted_char)\n        else:\n            # Non-alphabetic characters are added unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet by a specific number of places.\n\n    The rotation is determined by multiplying two by two, resulting in a shift of four places down the alphabet.\n\n    Args:\n        s (str): The input string to be encrypted.\n\n    Returns:\n        str: The encrypted string.\n\n    Examples:\n        >>> encrypt('hi')\n        'lm'\n        >>> encrypt('asdfghjkl')\n        'ewhjklnop'\n        >>> encrypt('gf')\n        'kj'\n        >>> encrypt('et')\n        'ix'\n    \"\"\"\n    shift = 2 * 2  # Determine the shift amount\n    encrypted = \"\"\n\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Determine the alphabet range (uppercase or lowercase)\n            if char.isupper():\n                start = ord('A')\n            else:\n                start = ord('a')\n            # Calculate the new position with wrapping around the alphabet\n            new_pos = (ord(char) - start + shift) % 26 + start\n            encrypted += chr(new_pos)\n        else:\n            # Non-alphabetic characters are added unchanged\n            encrypted += char\n\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt a string by rotating the alphabet.\n\n    The alphabet should be rotated in a manner such that\n    the letters shift down by two multiplied to two places,\n    which is a shift of four places.\n\n    Args:\n        s (str): The input string to encrypt.\n\n    Returns:\n        str: The encrypted string.\n\n    Examples:\n        >>> encrypt('hi')\n        'lm'\n        >>> encrypt('asdfghjkl')\n        'ewhjklnop'\n        >>> encrypt('gf')\n        'kj'\n        >>> encrypt('et')\n        'ix'\n    \"\"\"\n    shift = 4  # Two multiplied by two\n    encrypted = []\n\n    for char in s:\n        if char.isalpha():\n            # Determine if the character is uppercase or lowercase\n            offset = ord('A') if char.isupper() else ord('a')\n            # Rotate the character and wrap around the alphabet\n            encrypted_char = chr(((ord(char) - offset + shift) % 26) + offset)\n            encrypted.append(encrypted_char)\n        else:\n            # Non-alphabetic characters are added unchanged\n            encrypted.append(char)\n\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    shift = 4  # 2 multiplied by 2\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            offset = (ord(char) - start + shift) % 26\n            encrypted += chr(start + offset)\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n\n    shift = 4  # two multiplied to two places\n    result = \"\"\n\n    for c in s:\n        if c.isalpha():\n            start = ord('a') if c.islower() else ord('A')\n            # Find the rotated position\n            new_pos = (ord(c) - start + shift) % 26 + start\n            result += chr(new_pos)\n        else:\n            result += c  # Non-alphabetic characters are added as is\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet by a specific number of places.\n    \n    The rotation is determined by multiplying two by two, resulting in a shift of four places.\n    For example, 'a' becomes 'e', 'b' becomes 'f', and so on.\n    The function preserves the case of the original letters and ignores non-alphabetic characters.\n    \n    Args:\n        s (str): The string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    shift = 2 * 2  # Determine the shift amount\n    result = []\n    \n    for char in s:\n        if char.isalpha():\n            # Determine if the character is uppercase or lowercase\n            ascii_offset = 65 if char.isupper() else 97\n            # Calculate the new character after shifting\n            encrypted_char = chr(((ord(char) - ascii_offset + shift) % 26) + ascii_offset)\n            result.append(encrypted_char)\n        else:\n            # Non-alphabetic characters are added unchanged\n            result.append(char)\n    \n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet by a specified amount.\n\n    The function takes a string `s` and returns a new string where each\n    letter is shifted down by two multiplied to two places, i.e., four places.\n    The rotation is done in a cyclic manner within the alphabet.\n\n    Args:\n        s (str): The input string to be encrypted.\n\n    Returns:\n        str: The encrypted string.\n\n    Examples:\n        >>> encrypt('hi')\n        'lm'\n        >>> encrypt('asdfghjkl')\n        'ewhjklnop'\n        >>> encrypt('gf')\n        'kj'\n        >>> encrypt('et')\n        'ix'\n    \"\"\"\n    rotation_amount = 2 * 2  # Two multiplied by two places\n    encrypted = []\n    for char in s:\n        if char.isalpha():\n            # Determine the case of the character\n            start = ord('a') if char.islower() else ord('A')\n            # Rotate the character and handle wrap-around\n            shifted = (ord(char) - start + rotation_amount) % 26 + start\n            encrypted.append(chr(shifted))\n        else:\n            # Non-alphabetic characters are added unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    shift = 4  # two multiplied by two\n    result = \"\"\n\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            offset = (ord(char) - start + shift) % 26\n            encrypted_char = chr(start + offset)\n            result += encrypted_char\n        else:\n            result += char\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places, i.e., shift by 4 places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 4  # Since two multiplied by two is four\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Determine if the character is uppercase or lowercase for correct ASCII range\n            ascii_offset = 65 if char.isupper() else 97\n            # Rotate the character and handle wrap-around using modulo\n            encrypted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n            encrypted += encrypted_char\n        else:\n            # If it's not a letter, keep it as is\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 4  # two multiplied by two places\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            shifted = (ord(char) - start + shift) % 26 + start\n            encrypted += chr(shifted)\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    rotation = 4  # two multiplied to two places\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            # Find the rotated position and ensure it wraps around the alphabet\n            encrypted_char = chr((ord(char) - start + rotation) % 26 + start)\n            result += encrypted_char\n        else:\n            result += char  # Non-alphabetic characters are added as is\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places, i.e., by four places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 4  # Since two multiplied by two is four\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Determine if the character is uppercase or lowercase for correct ASCII range\n            ascii_offset = 65 if char.isupper() else 97\n            # Rotate the character and handle wrap-around using modulo\n            shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n            encrypted += shifted_char\n        else:\n            # If it's not a letter, keep it as is\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 4  # two multiplied by two places\n    encrypted_text = \"\"\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            offset = (ord(char) - start + shift) % 26\n            encrypted_char = chr(start + offset)\n            encrypted_text += encrypted_char\n        else:\n            encrypted_text += char\n    return encrypted_text", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet.\n    \n    The alphabet is rotated such that each letter is shifted down by four places\n    (since two multiplied by two is four). The function preserves the case of\n    the letters and ignores non-alphabet characters.\n    \n    Args:\n        s (str): The input string to encrypt.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    \n    def shift_char(c, shift):\n        if c.isalpha():\n            base = ord('a') if c.islower() else ord('A')\n            return chr((ord(c) - base + shift) % 26 + base)\n        else:\n            return c\n    \n    shift = 2 * 2  # As per the problem statement\n    return ''.join(shift_char(c, shift) for c in s)", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 83.96887159533074, "dps_norm": 57.5, "pass@1": 98.0, "profiled": [{"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Handle cases where list is too small to have a second smallest element\n    if len(lst) < 2:\n        return None\n    \n    # Initialize two variables to store the smallest and second smallest elements\n    smallest = float('inf')\n    second_smallest = float('inf')\n    \n    # Iterate through the list\n    for num in lst:\n        # Update smallest and second_smallest accordingly\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    \n    # If second_smallest is still float('inf'), it means there was no second smallest element\n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if not lst or len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Given a list of integers, returns the 2nd smallest element.\n    Returns None if there is no such element.\n    \"\"\"\n    # If the list has less than 2 elements, return None\n    if len(lst) < 2:\n        return None\n    \n    # Initialize two variables to store the smallest and second smallest values\n    min1 = float('inf')\n    min2 = float('inf')\n    \n    for num in lst:\n        # Update min1 and min2 accordingly\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2 and num != min1:\n            min2 = num\n    \n    # If min2 is still inf, it means there was no second smallest element\n    if min2 == float('inf'):\n        return None\n    else:\n        return min2", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    This function finds the second smallest unique integer in a given list.\n    \n    Approach:\n    1. Use a set to eliminate duplicates and obtain unique elements.\n    2. Convert the set back to a list and sort it in ascending order.\n    3. If the sorted list has at least two elements, return the second one; otherwise, return None.\n    \n    Edge Cases:\n    - If the list is empty or has only one unique element, return None.\n    - If the list has multiple duplicates of the same number, return None.\n    \n    Time Complexity: O(n log n) due to sorting.\n    Space Complexity: O(n) for storing the unique elements.\n    \"\"\"\n    unique_lst = sorted(set(lst))\n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 98.98580121703854, "dps_norm": 66.66666666666667, "pass@1": 98.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for string in lst:\n        count = sum(1 for char in string if int(char) % 2 != 0)\n        output = (\n            \"the number of odd elements \"\n            + str(count)\n            + \"n the str\"\n            + str(count)\n            + \"ng \"\n            + str(count)\n            + \" of the \"\n            + str(count)\n            + \"nput.\"\n        )\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    :param lst: List of strings consisting of digits.\n    :return: List of strings with replaced 'i's with counts of odd digits.\n\n    Examples:\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        output = template.format(count, count, count, count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        output = template.format(odd_count, odd_count, odd_count, odd_count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    Examples:\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        output = template.format(count, count, count, count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    Examples:\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        output = template.format(count, count, count, count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        output = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for string in lst:\n        count = sum(1 for char in string if int(char) % 2 != 0)\n        output = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n            count, count, count, count\n        )\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        output = template.format(count, count, count, count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        output = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        output = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for string in lst:\n        count = sum(1 for char in string if int(char) % 2 != 0)\n        output = (\n            \"the number of odd elements \"\n            + str(count)\n            + \"n the str\"\n            + str(count)\n            + \"ng \"\n            + str(count)\n            + \" of the \"\n            + str(count)\n            + \"nput.\"\n        )\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        output = template.format(count, count, count, count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        output = template.format(count, count, count, count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits,\n    return a list. Each element i of the output should be \"the number of\n    odd elements in the string i of the input.\" where all the i's should be\n    replaced by the number of odd digits in the i'th string of the input.\n\n    Examples:\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        result = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        output.append(result)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        formatted = template.format(count, count, count, count)\n        result.append(formatted)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        output = template.format(count, count, count, count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        output = template.format(count, count, count, count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        output = template.format(count, count, count, count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    Examples:\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        replaced = template.format(count, count, count, count)\n        result.append(replaced)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        output = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    This function checks if it's possible to concatenate two strings of parentheses\n    in some order to form a balanced string.\n\n    Parameters:\n    lst (list): A list containing two strings of parentheses.\n\n    Returns:\n    str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    str1, str2 = lst\n    if is_balanced(str1 + str2):\n        return 'Yes'\n    if is_balanced(str2 + str1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Check if it's possible to concatenate two strings of parentheses in some order to form a balanced string.\n    \n    Args:\n    lst: List of two strings, each consisting only of '(' and ')'.\n    \n    Returns:\n    'Yes' if a balanced string can be formed, otherwise 'No'.\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n    \n    # Check both possible concatenations\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_valid(s1, s2):\n        stack = []\n        for char in s1 + s2:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack[-1] != '(':\n                    return False\n                stack.pop()\n        return not stack\n\n    s1, s2 = lst\n    return 'Yes' if is_valid(s1, s2) or is_valid(s2, s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_valid(s1, s2):\n        stack = []\n        for char in s1 + s2:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack[-1] != '(':\n                    return False\n                stack.pop()\n        return not stack\n\n    s1, s2 = lst\n    # Check both possible concatenations\n    if is_valid(s1, s2) or is_valid(s2, s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Determine if concatenating two strings of parentheses in any order results in a balanced string.\n\n    Args:\n    lst (list): A list containing two strings of parentheses.\n\n    Returns:\n    str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    # Check both possible concatenations\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_valid(s1, s2):\n        stack = []\n        for ch in s1 + s2:\n            if ch == '(':\n                stack.append(ch)\n            elif ch == ')':\n                if not stack or stack[-1] != '(':\n                    return False\n                stack.pop()\n        return not stack\n\n    s1, s2 = lst\n    if is_valid(s1, s2):\n        return 'Yes'\n    elif is_valid(s2, s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": 93.27586206896552, "dps_norm": 95.71428571428571, "pass@1": 35.0, "profiled": [{"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Parameters:\n    arr (List[int]): The input array of integers.\n    k (int): The number of maximum elements to return.\n\n    Returns:\n    List[int]: A sorted list of the k largest elements from arr.\n    \"\"\"\n    if k == 0 or not arr:\n        return []\n    \n    # Create a copy of the array and sort it in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements from the sorted array\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    # Check if k is 0 or arr is empty\n    if k == 0 or not arr:\n        return []\n    \n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Get the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # If k is 0 or arr is empty, return an empty list\n    if k == 0 or not arr:\n        return []\n    \n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    top_k = sorted_arr[:k]\n    \n    # Return the sorted list of top k elements in ascending order\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Parameters:\n    arr (list): A list of integers.\n    k (int): A non-negative integer less than or equal to the length of arr.\n\n    Returns:\n    list: A sorted list of the k largest integers from arr.\n    \"\"\"\n    # If k is zero, return an empty list\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order and return\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0 or not arr:\n        return []\n    # Sort the array in descending order and select the first k elements\n    sorted_arr = sorted(arr, reverse=True)\n    # Return the first k elements\n    result = sorted_arr[:k]\n    # Sort the result in ascending order before returning\n    return sorted(result)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: List[int], array of integers\n    :param k: int, number of maximum elements to return\n    :return: List[int], sorted list of k maximum numbers\n    \"\"\"\n    if k == 0 or not arr:\n        return []\n    \n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    result = sorted_arr[:k]\n    \n    # Sort the result in ascending order before returning\n    return sorted(result)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: List[int], the array of integers.\n    :param k: int, the number of maximum elements to return.\n    :return: List[int], sorted list of length k with the maximum elements.\n    \"\"\"\n    if k == 0 or not arr:\n        return []\n    \n    # Sort the array in descending order and select the first k elements\n    sorted_arr = sorted(arr, reverse=True)\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order for the final output\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list\n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0 or not arr:\n        return []\n    \n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    result = sorted_arr[:k]\n    \n    # Return the result sorted in ascending order\n    return sorted(result)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Take the first k elements\n    result = sorted_arr[:k]\n    # Return the result sorted in ascending order\n    return sorted(result)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n        arr (list): List of integers.\n        k (int): Number of maximum elements to return.\n\n    Returns:\n        list: A sorted list of the k maximum elements from arr.\n    \"\"\"\n    if k == 0 or not arr:\n        return []\n    \n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    top_k = sorted_arr[:k]\n    \n    # Return the sorted list of top k elements in ascending order\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Parameters:\n    arr (list): A list of integers.\n    k (int): A non-negative integer less than or equal to the length of arr.\n\n    Returns:\n    list: A sorted list of the k largest integers from arr.\n\n    Examples:\n    >>> maximum([-3, -4, 5], 3)\n    [-4, -3, 5]\n\n    >>> maximum([4, -4, 4], 2)\n    [4, 4]\n\n    >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n    [2]\n    \"\"\"\n    if k == 0:\n        return []\n    # Use the nlargest function from heapq to find the k largest elements\n    # Then sort them in ascending order before returning\n    from heapq import nlargest\n    return sorted(nlargest(k, arr))", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    # Check if k is 0 or arr is empty\n    if k == 0 or not arr:\n        return []\n    \n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    result = sorted_arr[:k]\n    \n    # Sort the result in ascending order before returning\n    return sorted(result)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n\n    # If k is 0, return an empty list\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    result = sorted_arr[:k]\n    \n    # Sort the result in ascending order before returning\n    return sorted(result)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # sort the array in descending order and select the first k elements\n    sorted_arr = sorted(arr, reverse=True)\n    result = sorted_arr[:k]\n    # sort the result in ascending order before returning\n    return sorted(result)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n    arr: List[int] - a list of integers.\n    k: int - a non-negative integer less than or equal to the length of arr.\n\n    Returns:\n    List[int] - a sorted list of the k largest numbers from arr.\n\n    Examples:\n    1. maximum([-3, -4, 5], 3) returns [-4, -3, 5]\n    2. maximum([4, -4, 4], 2) returns [4, 4]\n    3. maximum([-3, 2, 1, 2, -1, -2, 1], 1) returns [2]\n    \"\"\"\n    if k == 0 or not arr:\n        return []\n    \n    # Use a min-heap to keep track of the top k elements\n    from heapq import nlargest\n    top_k = nlargest(k, arr)\n    \n    # Sort the top k elements in ascending order\n    return sorted(top_k)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0 or not arr:\n        return []\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Take the first k elements\n    result = sorted_arr[:k]\n    # Return the result sorted in ascending order\n    return sorted(result)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list\n    of length k with the maximum k numbers in arr.\n\n    Args:\n    arr: List[int] - a list of integers.\n    k: int - a non-negative integer less than or equal to the length of arr.\n\n    Returns:\n    List[int] - a sorted list of the k largest integers from arr.\n\n    Examples:\n    >>> maximum([-3, -4, 5], 3)\n    [-4, -3, 5]\n    >>> maximum([4, -4, 4], 2)\n    [4, 4]\n    >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n    [2]\n    \"\"\"\n    if k == 0 or not arr:\n        return []\n    \n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    result = sorted_arr[:k]\n    \n    # Sort the result in ascending order before returning\n    return sorted(result)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    if k == 0:\n        return []\n    else:\n        # Sort the array in descending order\n        sorted_arr = sorted(arr, reverse=True)\n        # Take the first k elements\n        result = sorted_arr[:k]\n        # Sort the result in ascending order before returning\n        return sorted(result)", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 80.31390134529148, "dps_norm": 59.28571428571429, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    sum = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    sum_odd_even = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum_odd_even += lst[i]\n    return sum_odd_even", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if position is even (0-based index)\n        if index % 2 == 0:\n            # Check if the element is odd\n            if value % 2 == 1:\n                # Add to total sum\n                total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    sum_odd = 0\n    for idx, num in enumerate(lst):\n        if idx % 2 == 0 and num % 2 != 0:\n            sum_odd += num\n    return sum_odd", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Calculate the sum of odd elements located at even positions in a list.\n\n    Args:\n        lst (list of int): A non-empty list of integers.\n\n    Returns:\n        int: The sum of odd elements at even positions.\n\n    Examples:\n        solution([5, 8, 7, 1]) ==> 12\n        solution([3, 3, 3, 3, 3]) ==> 9\n        solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize sum\n    total = 0\n\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if position is even (0-based index)\n        if index % 2 == 0:\n            # Check if the element is odd\n            if value % 2 == 1:\n                # Add to sum\n                total += value\n\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if index is even and value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate through list with index\n    for index, value in enumerate(lst):\n        # Check if position is even (0-based index)\n        if index % 2 == 0:\n            # Check if element is odd\n            if value % 2 == 1:\n                # Add to sum\n                total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Calculate the sum of odd elements located at even positions in a list.\n\n    Args:\n    lst (list of int): A non-empty list of integers.\n\n    Returns:\n    int: The sum of odd elements at even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if position is even (0-based index)\n        if index % 2 == 0:\n            # Check if the element is odd\n            if value % 2 == 1:\n                # Add to total sum\n                total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    # Initialize sum\n    total = 0\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if index is even and value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: Sum of odd elements at even positions.\n\n    Examples:\n        solution([5, 8, 7, 1]) ==> 12\n        solution([3, 3, 3, 3, 3]) ==> 9\n        solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if position is even (0-based index)\n        if index % 2 == 0:\n            # Check if the element is odd\n            if value % 2 == 1:\n                # Add to total\n                total += value\n    # Return the total sum\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    # Initialize the sum\n    total = 0\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even (0-based) and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    sum_odd_even_positions = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            sum_odd_even_positions += value\n    return sum_odd_even_positions", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Args:\n    lst (list): A non-empty list of integers.\n    \n    Returns:\n    int: The sum of odd elements at even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    sum_odd_even_positions = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            sum_odd_even_positions += value\n    return sum_odd_even_positions", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    # First, filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Then, sort the remaining strings first by length, then alphabetically\n    # Since all remaining strings have even lengths, and the problem states\n    # that all words will have the same length, we can sort them alphabetically\n    # directly. However, to generalize, we sort by length first, then alphabetically.\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # First, filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Then, sort the remaining strings by length, and alphabetically if lengths are equal\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # First, filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Then, sort the filtered list by length, and then alphabetically if lengths are equal\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Delete strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list: first by length of each word, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # First, we need to remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Next, we sort the remaining strings by length, then alphabetically\n    # Since all strings now have even lengths, and the problem mentions\n    # that we should sort ascending by length and then alphabetically if lengths are equal,\n    # but it also says \"You may assume that all words will have the same length.\"\n    # However, to cover all cases, I'll implement sorting by length and then alphabetically.\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort the filtered list: first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list: first by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, deletes strings with odd lengths,\n    and returns the list sorted by string length and alphabetically.\n    \n    Args:\n    lst (list of str): The list of strings to process.\n    \n    Returns:\n    list of str: A sorted list of strings with even lengths.\n    \n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list: first by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # First, we need to filter out strings with odd lengths.\n    # We can do this by checking the length of each string and keeping only those with even lengths.\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Next, we need to sort the list based on the specified rules:\n    # - Ascending order by the length of each word.\n    # - If two words have the same length, sort them alphabetically.\n    # Since all words will have the same length according to the problem's assumption,\n    # the sorting will effectively be alphabetical.\n    # However, to handle the general case where lengths might differ, we'll sort by length first and then alphabetically.\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list: first by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function accepts a list of strings as a parameter, deletes the strings\n    that have odd lengths from it, and returns the resulted list with a sorted\n    order. The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates. The order of the list should be ascending by\n    length of each word, and you should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    \n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n\n    # First, filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Then, sort the remaining strings first by length, then alphabetically\n    # Since all even lengths are already even, we sort primarily by length,\n    # then alphabetically as a secondary sort key.\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # First, we need to filter out strings with odd lengths.\n    # We can do this by checking the length of each string and keeping only those with even lengths.\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Next, we need to sort this list.\n    # The sorting should be primarily by the length of the strings in ascending order.\n    # Secondarily, if two strings have the same length, they should be sorted alphabetically.\n    # Since all strings now have even lengths, but potentially different even lengths,\n    # we sort by length first, then alphabetically.\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # First, we need to filter out strings with odd lengths\n    even_len_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Then, we sort the remaining strings by their length and alphabetically\n    # Since all strings have even lengths, and according to the problem, they may have the same length\n    # We sort primarily by length (ascending) and secondarily by alphabetical order\n    sorted_list = sorted(even_len_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings and deletes the strings that have odd lengths.\n    Returns the resulted list sorted by ascending length of each word,\n    and alphabetically if two words have the same length.\n\n    Parameters:\n    lst (list of str): The list of strings to process.\n\n    Returns:\n    list of str: A sorted list of strings with even lengths.\n\n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list by length, then alphabetically\n    even_length_strings.sort(key=lambda s: (len(s), s))\n    \n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths, and returns a sorted list.\n    The list is sorted by the length of the strings in ascending order.\n    If two strings have the same length, they are sorted alphabetically.\n\n    :param lst: List of strings\n    :return: A list of strings sorted by length and alphabetically\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list by length and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list: first by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Sorts a list of strings by length and alphabetically, excluding strings of odd length.\n\n    Args:\n        lst (list of str): The list of strings to sort and filter.\n\n    Returns:\n        list of str: A sorted list containing only strings of even length.\n\n    Example:\n        >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n        ['aa']\n        >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n        ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # First, filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Then, sort the remaining strings by length, and alphabetically if lengths are equal\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 97.79661016949153, "dps_norm": 98.75, "pass@1": 100.0, "profiled": [{"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    elif n <= 3:\n        return False  # 2 and 3 are prime numbers\n    elif n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    elif n <= 3:\n        return False  # 2 and 3 are prime numbers\n    elif n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not primes\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    elif n <= 3:\n        return False  # 2 and 3 are prime numbers\n    elif n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not primes\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    elif n <= 3:\n        return False  # 2 and 3 are prime numbers\n    elif n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"Check if a number is not a prime number.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is not prime, False otherwise.\n\n    Examples:\n        >>> is_not_prime(4)\n        True\n        >>> is_not_prime(5)\n        False\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(num):\n    if num <= 1:\n        return True  # 0 and 1 are not prime numbers\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True  # Found a divisor, hence not prime\n    return False  # No divisors found, hence prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(number):\n    \"\"\"Function to check if a number is not prime.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n    This function determines if the provided number is not a prime number.\n\n    Args:\n        number (int): The number to check for primality.\n\n    Returns:\n        bool: True if the number is not prime, False if it is prime.\n\n    Examples:\n        >>> is_not_prime(4)\n        True\n        >>> is_not_prime(5)\n        False\n    \"\"\"\n    if number <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if number <= 3:\n        return False  # 2 and 3 are prime numbers\n    if number % 2 == 0 or number % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= number:\n        if number % i == 0 or number % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(num: int) -> bool:\n    \"\"\"Check if a number is not a prime number.\n    \n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n    This function returns True if the number is not prime, and False if it is prime.\n    \n    Args:\n        num (int): The number to check.\n    \n    Returns:\n        bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if num <= 3:\n        return False  # 2 and 3 are prime numbers\n    if num % 2 == 0 or num % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    elif n <= 3:\n        return False  # 2 and 3 are prime numbers\n    elif n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"Check if a number is not a prime.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n    This function returns True if the number is not prime, and False otherwise.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not a prime number, False otherwise.\n\n    Examples:\n        >>> is_not_prime(2)\n        False\n        >>> is_not_prime(4)\n        True\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not primes\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(number):\n    \"\"\"\n    This function checks if a number is not prime.\n    \n    Parameters:\n    number (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if number <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if number <= 3:\n        return False  # 2 and 3 are prime numbers\n    if number % 2 == 0 or number % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= number:\n        if number % i == 0 or number % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime.\n    \n    Args:\n        n (int): The number to check.\n    \n    Returns:\n        bool: True if the number is not a prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not primes\n    if n <= 3:\n        return False  # 2 and 3 are primes\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not primes\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not primes\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 96.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest elements\n    largest_nums = heapq.nlargest(n, numbers)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers: List[int] - A list of integers.\n    n: int - The number of largest integers to find.\n    \n    Returns:\n    List[int] - A list of the n largest integers in descending order.\n    \"\"\"\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    import heapq\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    import heapq\n    largest_n = heapq.nlargest(n, numbers)\n    return largest_n\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest elements\n    largest_nums = heapq.nlargest(n, numbers)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    import heapq\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    import heapq\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest numbers\n    largest_nums = heapq.nlargest(n, numbers)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n    nums (list): List of integers.\n    n (int): Number of largest integers to find.\n\n    Returns:\n    list: A list of the n largest integers in descending order.\n    \"\"\"\n    if not nums or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest elements\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest numbers\n    largest_nums = heapq.nlargest(n, numbers)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Parameters:\n    numbers (list): The list of numbers to search through.\n    n (int): The number of largest integers to find.\n\n    Returns:\n    list: A list of the n largest integers in descending order.\n\n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    import heapq\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest to find the n largest numbers and return them in descending order\n    largest_nums = heapq.nlargest(n, numbers)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use nlargest from heapq to find the n largest numbers\n    largest_nums = heapq.nlargest(n, numbers)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest elements\n    largest_nums = heapq.nlargest(n, numbers)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n    numbers: List[int] - A list of integers.\n    n: int - The number of largest integers to find.\n\n    Returns:\n    List[int] - A list containing the n largest integers in descending order.\n\n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    import heapq\n    # Use nlargest from heapq to find the n largest elements\n    largest_nums = heapq.nlargest(n, numbers)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Parameters:\n    - numbers: List[int], the list of numbers to search through.\n    - n: int, the number of largest integers to find.\n\n    Returns:\n    - List[int]: a list of the n largest integers in descending order.\n\n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if not numbers or n <= 0:\n        return []\n    # Use nlargest from heapq to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    return largest_n", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 55.034013605442176, "dps_norm": 51.0, "pass@1": 80.0, "profiled": [{"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    A rotation is defined as moving the first character of the string to the end.\n    For example, rotating 'abc' once results in 'bca'.\n    \n    Args:\n    s (str): The input string to rotate.\n    \n    Returns:\n    int: The minimum number of rotations required to get back the original string.\n    \n    Example:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abab\")\n    2\n    >>> find_Rotations(\"abc\")\n    3\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Parameters:\n    s (str): The input string to rotate.\n    \n    Returns:\n    int: The minimum number of rotations needed to get back the original string.\n    \n    Example:\n    find_Rotations(\"aaaa\") should return 1, as rotating \"aaaa\" by 1 position gives \"aaaa\" again.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Parameters:\n    s (str): The input string to rotate.\n    \n    Returns:\n    int: The minimum number of rotations needed to obtain the same string.\n    \n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abab\")\n    2\n    >>> find_Rotations(\"abc\")\n    3\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Calculate the minimum number of rotations greater than 0 required to get the same string.\n\n    Args:\n    s (str): The input string to rotate.\n\n    Returns:\n    int: The minimum number of rotations required to get the same string.\n\n    Example:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abab\")\n    2\n    >>> find_Rotations(\"abc\")\n    3\n    \"\"\"\n\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    if n <= 1:\n        return 0\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    temp = s + s\n    for i in range(1, n+1):\n        substring = temp[0: n+i]\n        if substring[i:] == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Calculate the minimum number of rotations (greater than 0) required to get the same string.\n\n    :param s: str - the input string\n    :return: int - the minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n\n    # Create a new string by concatenating the string with itself\n    double_s = s + s\n\n    # Loop through the string to find the minimum rotations\n    for i in range(1, len(s) + 1):\n        # Check if a rotation matches the original string\n        if double_s[i:i+len(s)] == s:\n            return i\n\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    if not s:\n        return 0\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string to rotate.\n    \n    Returns:\n    int: The minimum number of rotations needed to obtain the same string.\n    \n    Example:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abab\")\n    2\n    >>> find_Rotations(\"abc\")\n    3\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Parameters:\n    s (str): The input string to rotate.\n    \n    Returns:\n    int: The minimum number of rotations required to get back the original string.\n    \n    Example:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abcd\")\n    4\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations required.\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abab\")\n    2\n    >>> find_Rotations(\"abc\")\n    3\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    # Check if all characters are same\n    if all(c == s[0] for c in s):\n        return 1\n    # Check for rotations\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    if not s:\n        return 0\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # Check if the string is empty\n    if not s:\n        return 0\n\n    # Initialize the number of rotations\n    rotations = 1\n\n    # Create a list of all possible rotations\n    original = s\n    s = s[1:] + s[0]  # Perform the first rotation\n\n    # Check if the rotated string matches the original\n    while s != original:\n        rotations += 1\n        s = s[1:] + s[0]  # Perform the next rotation\n        # If we have cycled through all rotations and back to original\n        if rotations > len(s):\n            return 0\n\n    # Return the number of rotations to get back to original\n    return rotations if rotations > 0 else 0", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Parameters:\n    s (str): The input string to rotate.\n\n    Returns:\n    int: The minimum number of rotations required to obtain the same string.\n\n    Example:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abab\")\n    2\n    >>> find_Rotations(\"abc\")\n    3\n    \"\"\"\n\n    n = len(s)\n    if n == 0:\n        return 0  # No rotation needed for an empty string\n\n    # Concatenate the string with itself to handle rotations\n    doubled_s = s + s\n\n    # Find the minimal rotation by checking substrings\n    for i in range(1, n + 1):\n        # Check if the substring from i to i + n - 1 matches the original string\n        if doubled_s[i:i + n] == s:\n            return i\n\n    return n  # If no rotation found, the entire string needs to be rotated", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Parameters:\n    s (str): The input string to rotate.\n    \n    Returns:\n    int: The minimum number of rotations required to obtain the same string.\n    \n    Example:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abab\")\n    2\n    >>> find_Rotations(\"abc\")\n    3\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Parameters:\n    s (str): The input string to rotate.\n    \n    Returns:\n    int: The minimum number of rotations required to obtain the same string.\n    \n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abab\")\n    2\n    >>> find_Rotations(\"abc\")\n    3\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    :param s: input string consisting of lowercase letters\n    :return: minimum number of rotations required to get the same string\n    \"\"\"\n    if not s:\n        return 0  # No rotation needed for an empty string\n\n    n = len(s)\n    # Check for each possible rotation from 1 to n-1\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i  # Found a rotation that matches the original string\n\n    return n  # Full rotation is needed", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": 95.0, "dps_norm": 95.0, "pass@1": 81.0, "profiled": [{"solution": "def remove_Occ(s, char):\n    first = s.find(char)\n    if first == -1:\n        return s\n    last = s.rfind(char)\n    if first == last:\n        return s[:first] + s[first+1:]\n    else:\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    first = s.find(char)\n    if first == -1:\n        return s  # Character not found, return original string\n    last = s.rfind(char)\n    if first == last:\n        # Only one occurrence, remove it\n        return s[:first] + s[first+1:]\n    else:\n        # Remove first and last occurrences\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Convert the string to a list for mutable operations\n    s_list = list(s)\n    \n    # Find the first occurrence of the character\n    try:\n        first = s_list.index(char)\n        s_list[first] = ''\n    except ValueError:\n        # Character not found, return original string\n        return s\n    \n    # Find the last occurrence of the character\n    try:\n        last = len(s_list) - 1 - s_list[::-1].index(char)\n        s_list[last] = ''\n    except ValueError:\n        # Character not found again, meaning only one occurrence\n        pass\n    \n    # Join the list back into a string\n    return ''.join(s_list)", "matching_cluster_idx": -1}, {"solution": "def remove_Occ(s, c):\n    # Find the first occurrence index\n    first = s.find(c)\n    if first == -1:\n        return s  # Character not found, return original string\n    # Find the last occurrence index\n    last = s.rfind(c)\n    if first == last:\n        # Only one occurrence, remove it\n        return s[:first] + s[first+1:]\n    else:\n        # Multiple occurrences, remove first and last\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    first = s.find(char)\n    if first == -1:\n        return s\n    last = s.rfind(char)\n    if first == last:\n        return s[:first] + s[first+1:]\n    else:\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str1, char):\n    if not str1:\n        return str1  # Return empty string if input is empty\n\n    first_occurrence = str1.find(char)\n    if first_occurrence == -1:\n        return str1  # Character not found, return original string\n\n    last_occurrence = str1.rfind(char)\n    if first_occurrence == last_occurrence:\n        # Only one occurrence, remove it\n        return str1[:first_occurrence] + str1[first_occurrence+1:]\n    else:\n        # Multiple occurrences, remove first and last\n        return str1[:first_occurrence] + str1[first_occurrence+1:last_occurrence] + str1[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    if not s:\n        return s\n    if char not in s:\n        return s\n\n    first_occurrence = s.find(char)\n    last_occurrence = s.rfind(char)\n\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    else:\n        return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    if first == -1:\n        return s\n    last = s.rfind(c)\n    if first == last:\n        return s[:first] + s[first+1:]\n    else:\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    first = string.find(char)\n    if first == -1:\n        return string\n    last = string.rfind(char)\n    part1 = string[:first]\n    part2 = string[first+1:last]\n    part3 = string[last+1:]\n    return part1 + part2 + part3", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # base case\n    if s is None or len(s) == 0:\n        return s\n    first = s.find(char)\n    if first == -1:\n        return s\n    last = s.rfind(char)\n    if first == last:\n        return s[:first] + s[first+1:]\n    else:\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    first_occ = s.find(char)\n    if first_occ == -1:\n        return s\n    last_occ = s.rfind(char)\n    if first_occ == last_occ:\n        return s[:first_occ] + s[first_occ+1:]\n    else:\n        return s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    first = string.find(char)\n    if first == -1:\n        return string\n    last = string.rfind(char)\n    part1 = string[:first]\n    part2 = string[first+1:last]\n    part3 = string[last+1:]\n    return part1 + part2 + part3", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char_to_remove):\n    if not input_string or char_to_remove not in input_string:\n        return input_string\n    \n    # Find the first and last occurrence of the character\n    first_occurrence = input_string.find(char_to_remove)\n    last_occurrence = input_string.rfind(char_to_remove)\n    \n    # Remove the characters at these positions\n    result = input_string[:first_occurrence] + input_string[first_occurrence+1:last_occurrence] + input_string[last_occurrence+1:]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    if not s:\n        return s  # Return the original string if it's empty\n\n    first_occ = s.find(char)\n    if first_occ == -1:\n        return s  # Character not found, return the original string\n\n    last_occ = s.rfind(char)\n    if first_occ == last_occ:\n        # Only one occurrence, remove it\n        return s[:first_occ] + s[first_occ+1:]\n    else:\n        # Multiple occurrences, remove first and last\n        return s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    first_occurrence = input_string.find(char)\n    if first_occurrence == -1:\n        return input_string  # Character not found, return original string\n    last_occurrence = input_string.rfind(char)\n    if first_occurrence == last_occurrence:\n        # Only one occurrence, remove it\n        return input_string[:first_occurrence] + input_string[first_occurrence+1:]\n    else:\n        # Remove first and last occurrences\n        return input_string[:first_occurrence] + input_string[first_occurrence+1:last_occurrence] + input_string[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # Find the first occurrence index\n    first = string.find(char)\n    if first == -1:\n        return string  # Character not found, return original string\n    # Find the last occurrence index, starting from the end\n    last = string.rfind(char)\n    if last == -1:\n        return string  # Character not found, return original string\n    \n    # Build the new string excluding the first and last occurrences\n    new_string = string[:first] + string[first+1:last] + string[last+1:]\n    return new_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    if not s or c not in s:\n        return s\n    first = s.find(c)\n    last = s.rfind(c)\n    if first == last:\n        return s[:first] + s[first+1:]\n    else:\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    first = s.find(char)\n    if first == -1:\n        return s\n    last = s.rfind(char)\n    if first == last:\n        return s[:first] + s[first+1:]\n    else:\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    first = s.find(char)\n    if first == -1:\n        return s  # Character not found, return the original string\n    last = s.rfind(char)\n    if first == last:\n        # Only one occurrence, remove it\n        return s[:first] + s[first+1:]\n    else:\n        # Remove first and last occurrences\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    if first == -1:\n        return s\n    last = s.rfind(c)\n    if first == last:\n        return s[:first] + s[first+1:]\n    else:\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Args:\n    matrix: A list of lists of integers representing the matrix to be sorted.\n\n    Returns:\n    A new matrix sorted in ascending order based on the sum of its rows.\n    \"\"\"\n    # Calculate the sum of each row and pair it with the row\n    sum_rows = [(sum(row), row) for row in matrix]\n    \n    # Sort the list of tuples based on the sum of the row\n    sum_rows_sorted = sorted(sum_rows, key=lambda x: x[0])\n    \n    # Extract the sorted rows\n    sorted_matrix = [row for _, row in sum_rows_sorted]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists of int): The matrix to sort.\n\n    Returns:\n    list of lists of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Args:\n    matrix (list of lists of int): The matrix to sort, where each inner list represents a row.\n\n    Returns:\n    list of lists of int: The sorted matrix.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Args:\n    matrix (list of lists of int): The matrix to sort.\n\n    Returns:\n    list of lists of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Args:\n    matrix (list of lists of int): The matrix to sort.\n\n    Returns:\n    list of lists of int: The sorted matrix.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix (list of lists of int): The matrix to sort, where each inner list represents a row.\n\n    Returns:\n        list of lists of int: The sorted matrix.\n\n    Example:\n        >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n        [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists of int): The matrix to sort.\n\n    Returns:\n    list of lists of int: The sorted matrix.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 98.38414634146342, "dps_norm": 98.75, "pass@1": 54.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    return bool(pattern.match(input_string))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(input_string):\n    if not isinstance(input_string, str):\n        return False\n    parts = input_string.split('_')\n    for part in parts:\n        if not part.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Regular expression pattern to match sequences of lowercase letters joined with underscores\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    return bool(pattern.match(input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    if not isinstance(s, str):\n        return False\n    pattern = \"^[a-z]+(_[a-z]+)*$\"\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    if not isinstance(input_string, str):\n        return False  # Non-string inputs are invalid\n    # Define the pattern: sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    # Match the pattern against the input string\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    if re.match(pattern, s):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = \"^[a-z]+(_[a-z]+)*$\"\n    return bool(re.match(pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    if not isinstance(s, str):\n        return False\n    if not s:\n        return False\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    if re.match(pattern, s):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = \"^[a-z]+(_[a-z]+)*$\"\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    return bool(pattern.match(s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n\n    Parameters:\n    s (str): The input string to be checked.\n\n    Returns:\n    bool: True if the string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    if not s:\n        return False\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = \"^[a-z]+(_[a-z]+)*$\"\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_str):\n    pattern = \"^[a-z]+(_[a-z]+)*$\"\n    return bool(re.match(pattern, input_str))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = \"^[a-z]+(_[a-z]+)*$\"\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = \"^[a-z]+(_[a-z]+)*$\"\n    if re.match(pattern, s):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    match = re.match(pattern, input_string)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    return bool(re.match(r'^[a-z]+(_[a-z]+)*$', s))", "matching_cluster_idx": 7}]}, "Mbpp/19": {"dps": 85.85858585858585, "dps_norm": 92.0, "pass@1": 100.0, "profiled": [{"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if a list contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Using a set to track seen elements\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set from the array to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set with the array\n    # If lengths differ, there are duplicates\n    if len(unique_elements) == len(arr):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Use a set to track seen elements\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    return len(set(arr)) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set with the list\n    # If lengths differ, there are duplicates\n    if len(unique_elements) != len(arr):\n        return True\n    else:\n        return False", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    if len(nums) == len(set(nums)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    num_set = set(nums)\n    if len(num_set) < len(nums):\n        return True\n    else:\n        return False", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set with the original array\n    # If lengths differ, there are duplicates\n    return len(unique_elements) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate integers.\n\n    Args:\n    - arr: List[int], the array of integers to check.\n\n    Returns:\n    - bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}]}, "Mbpp/62": {"dps": 74.5, "dps_norm": 83.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(num_list):\n    if not num_list:\n        return None  # or you could raise an exception for an empty list\n    smallest = num_list[0]\n    for num in num_list:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function takes a list of numbers and returns the smallest number in the list.\n\n    :param lst: List of numbers.\n    :return: The smallest number in the list.\n\n    Example:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    \"\"\"\n    if not lst:  # If the list is empty, return None or raise an exception.\n        return None  # Or you could raise a ValueError(\"List is empty\")\n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The smallest integer in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty.\")\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        return None  # or raise an exception if preferred\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        return None  # or raise an exception if preferred\n    min_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Function to find the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    int: The smallest integer in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"List is empty\")\n    min_num = lst[0]\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(arr):\n    return min(arr)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(arr):\n    if not arr:\n        return None\n    smallest = arr[0]\n    for num in arr:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        raise ValueError(\"List is empty\")\n    min_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        raise ValueError(\"List is empty\")\n    min_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function finds the smallest number in a list.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    int: The smallest integer in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"List is empty\")\n    min_num = lst[0]\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The smallest integer in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    >>> smallest_num([3, 2, 5, 1])\n    1\n    >>> smallest_num([100])\n    100\n    >>> smallest_num([])\n    Traceback (most recent call last):\n    ...\n    ValueError: The list is empty, cannot determine the smallest number.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty, cannot determine the smallest number.\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    min_num = lst[0]\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function finds the smallest number in a list.\n    \n    :param lst: List of numbers\n    :return: The smallest number in the list\n    \"\"\"\n    if not lst:\n        raise ValueError(\"List is empty\")\n    min_num = lst[0]\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    int: The smallest integer in the list.\n    \n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    >>> smallest_num([3, 1, 4, 1, 5, 9])\n    1\n    >>> smallest_num([100, 200, 3, 400])\n    3\n    \"\"\"\n    if not lst:\n        raise ValueError(\"List is empty\")\n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    if not lst:  # if the list is empty, return None or raise an exception\n        return None\n    min_num = lst[0]  # assume the first number is the smallest\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        raise ValueError(\"List is empty\")\n    min_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    This function takes a list of numbers and returns the smallest number in the list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int or float: The smallest number in the list.\n\n    Example:\n        >>> smallest_num([10, 20, 1, 45, 99])\n        1\n    \"\"\"\n    if not nums:\n        raise ValueError(\"List is empty\")\n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(list_of_tuples, k):\n    result = []\n    for tup in list_of_tuples:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    return [t for t in list_of_tuples if all(ele % k == 0 for ele in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Parameters:\n    tuples_list (list of tuples): The list of tuples to check.\n    k (int): The divisor to check for.\n\n    Returns:\n    list of tuples: A list containing only the tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    list_of_tuples: List of tuples containing integers.\n    k: Integer by which the elements in the tuples should be divisible.\n\n    Returns:\n    A list of tuples where each tuple has all elements divisible by k.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    # Initialize an empty list to store the tuples that meet the criteria\n    result = []\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in tup):\n            # If so, append the tuple to the result list\n            result.append(tup)\n    \n    # Return the list of tuples that meet the criteria\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    Parameters:\n    - list_of_tuples: A list of tuples, where each tuple contains integers.\n    - k: An integer to check divisibility against.\n    \n    Returns:\n    - A list of tuples where each tuple has all elements divisible by k.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    list_of_tuples: List of tuples containing integers.\n    k: Integer to check divisibility against.\n\n    Returns:\n    A list of tuples where each tuple's elements are all divisible by k.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k as input.\n    It returns a list of tuples where each tuple contains only elements that are divisible by k.\n    \"\"\"\n    result = []\n    for t in list_of_tuples:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result\nk = 6", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    list_of_tuples: A list of tuples containing integers.\n    k: An integer by which the elements of the tuples should be divisible.\n\n    Returns:\n    A list of tuples where each tuple has all elements divisible by k.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    result = []\n    for tup in lst:\n        if all(ele % k == 0 for ele in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    result = []\n    for tup in list_of_tuples:\n        if all(ele % k == 0 for ele in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    result = []\n    for tup in lst:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    This function takes in a list of tuples and an integer k, and returns a list of tuples where each tuple consists of elements all divisible by k.\n\n    Args:\n    list_of_tuples: A list of tuples containing integers.\n    k: An integer against which the tuple elements are checked for divisibility.\n\n    Returns:\n    A list of tuples where each tuple has all elements divisible by k.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    result = []\n    for tup in list_of_tuples:\n        if all(ele % k == 0 for ele in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k.\n\n    Args:\n    tuples_list: A list of tuples containing integers.\n    k: An integer by which the elements of the tuples should be divisible.\n\n    Returns:\n    A list of tuples where each tuple has all elements divisible by k.\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    list_of_tuples: A list of tuples containing integers.\n    k: An integer by which the elements in the tuples should be divisible.\n\n    Returns:\n    A list of tuples where each tuple's elements are all divisible by k.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    return [t for t in list_of_tuples if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    result = []\n    for tup in list_of_tuples:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.56862745098039, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Get the frequency of all elements in a list as a dictionary.\n\n    Args:\n    lst (list): The list of elements to count frequencies for.\n\n    Returns:\n    dict: A dictionary where keys are the unique elements from the list and values are their frequencies.\n\n    Example:\n    >>> freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Counts the frequency of elements in a list and returns a dictionary with elements as keys and their frequencies as values.\n    :param lst: List of elements to count frequencies for.\n    :return: Dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    return freq", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 79.51219512195122, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def len_log(word_list):\n    # Initialize a variable to hold the length of the longest word\n    max_length = 0\n    # Iterate through each word in the list\n    for word in word_list:\n        # Update max_length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    Parameters:\n    words (list): A list of strings.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0  # Return 0 for an empty list\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    Parameters:\n    words (list): A list of strings.\n\n    Returns:\n    int: The length of the longest word.\n\n    Examples:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    >>> len_log([\"hello\", \"world\", \"\"])\n    5\n    >>> len_log([\"a\", \"ab\", \"abc\"])\n    3\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of strings\n    :return: Integer, length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    This function finds the length of the longest word in a given list of words.\n\n    Parameters:\n    words (list): A list of strings.\n\n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0  # Return 0 for an empty list\n\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    This function finds the length of the longest word in a list of strings.\n\n    Parameters:\n    words (list): A list of words (strings).\n\n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0  # Return 0 if the list is empty\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize a variable to store the maximum length found\n    max_length = 0\n    # Iterate through each word in the list\n    for word in words:\n        # Update the max_length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    This function takes a list of strings and returns the length of the longest string in the list.\n\n    :param words: List of strings\n    :return: Integer, length of the longest string\n    \"\"\"\n    if not words:\n        return 0  # Return 0 if the list is empty\n\n    max_length = len(words[0])  # Initialize with the length of the first word\n\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(list_of_words):\n    # Initialize a variable to hold the length of the longest word\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in list_of_words:\n        # Update max_length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize a variable to hold the length of the longest word\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    Args:\n    words (list): A list of strings.\n\n    Returns:\n    int: The length of the longest word.\n\n    Examples:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    >>> len_log([\"hello\", \"world\", \"programming\"])\n    11\n    >>> len_log([])\n    0\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    Parameters:\n    words (list): A list of strings.\n\n    Returns:\n    int: The length of the longest word.\n\n    Example:\n    >>> len_log([\"python\",\"PHP\",\"bigdata\"])\n    7\n    \"\"\"\n    # Initialize a variable to hold the length of the longest word\n    max_length = 0\n\n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    return max(len(word) for word in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    if not words:\n        return 0\n    max_length = len(words[0])\n    for word in words[1:]:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 78.04878048780488, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None  # Return None if the list is empty\n    # Find the tuple with the smallest second value and return its first value\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None  # or raise an exception if preferred\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None  # Return None for empty list\n    # Find the tuple with the smallest second value and return its first value\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, this function returns the first value of the tuple with the smallest second value.\n    \n    Args:\n    lst: A list of tuples, where each tuple contains at least two elements.\n    \n    Returns:\n    The first element of the tuple with the smallest second element.\n    \n    Example:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    # Find the tuple with the smallest second value\n    min_tuple = min(lst, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None  # Return None if the list is empty\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, this function returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    tuples_list (list of tuples): A list where each tuple contains at least two elements.\n    \n    Returns:\n    The first element of the tuple with the smallest second element.\n    \n    Example:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        raise ValueError(\"The list is empty.\")\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value and return its first value\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    This function takes a list of tuples and returns the first value of the tuple with the smallest second value.\n\n    Parameters:\n    tuples_list (list of tuples): A list where each tuple contains at least two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second element.\n\n    Example:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    # Find the tuple with the smallest second value\n    smallest_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return smallest_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        raise ValueError(\"The list cannot be empty.\")\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Parameters:\n    tuples_list (list of tuples): A list where each tuple contains at least two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second element.\n\n    Example:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        raise ValueError(\"The list cannot be empty.\")\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None  # Return None if the list is empty\n    # Find the tuple with the smallest second value and return its first value\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None  # Return None if the list is empty\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None  # Return None for empty list\n    # Find the tuple with the smallest second value and return its first value\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Parameters:\n    tuples_list (list of tuples): A list where each tuple contains at least two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second element.\n\n    Example:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Find the tuple with the smallest second value\n    smallest = min(lst, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return smallest[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    tuples_list: A list of tuples, where each tuple contains at least two elements.\n    \n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 15.833333333333332, "dps_norm": 34.285714285714285, "pass@1": 100.0, "profiled": [{"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count +=1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Args:\n    n (int): The integer to find divisors for.\n\n    Returns:\n    int: The number of divisors of n.\n\n    Example:\n    >>> divisor(15)\n    4\n    \"\"\"\n\n    count = 0\n    sqrt_n = int(n**0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Find the number of divisors of a given integer.\n\n    Parameters:\n    - n: int, the integer to find divisors for.\n\n    Returns:\n    - int, the number of divisors of n.\n    \"\"\"\n    count = 0\n    sqrt_n = int(n**0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count +=1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/97": {"dps": 99.65811965811966, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def frequency_lists(lists):\n    freq_dict = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    frequency_dict = {}\n    for sublist in nested_list:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    freq_dict = {}\n    for sublist in nested_list:\n        for item in sublist:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    from collections import defaultdict\n    frequency = defaultdict(int)\n    for sublist in lists:\n        for item in sublist:\n            frequency[item] += 1\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    frequency = {}\n    for lst in nested_list:\n        for item in lst:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    from collections import defaultdict\n    frequency = defaultdict(int)\n    for sublist in lists:\n        for item in sublist:\n            frequency[item] += 1\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    freq_dict = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    frequency = {}\n    for sublist in nested_list:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_lists):\n    freq_dict = {}\n    for sublist in nested_lists:\n        for item in sublist:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_lists):\n    frequency = {}\n    for sublist in nested_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for lst in lists:\n        for item in lst:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 74.57792207792208, "dps_norm": 91.66666666666667, "pass@1": 97.0, "profiled": [{"solution": "def add_lists(list_val, tuple_val):\n    return tuple_val + tuple(list_val)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_val, tuple_val):\n    \"\"\"\n    Append the given list to the given tuple and return a new tuple.\n\n    Args:\n    list_val (list): The list to be appended.\n    tuple_val (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing elements of the original tuple followed by elements of the list.\n    \"\"\"\n    # Convert the list to a tuple\n    list_as_tuple = tuple(list_val)\n    \n    # Concatenate the original tuple with the new tuple created from the list\n    result_tuple = tuple_val + list_as_tuple\n    \n    return result_tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_val, tuple_val):\n    # Convert list to tuple\n    list_as_tuple = tuple(list_val)\n    # Append the list (as tuple) to the original tuple\n    result = tuple_val + list_as_tuple\n    return result", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_append, tuple_original):\n    # Convert the list to a tuple\n    list_as_tuple = tuple(list_to_append)\n    \n    # Append the converted tuple to the original tuple\n    result_tuple = tuple_original + list_as_tuple\n    \n    return result_tuple", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends elements of a list to a tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to append to.\n\n    Returns:\n    tuple: A new tuple with elements of 'tup' followed by elements of 'lst'.\n    \"\"\"\n    # Convert the tuple to a list, append the list elements, and convert back to a tuple\n    result = list(tup) + lst\n    return tuple(result)", "matching_cluster_idx": 3}, {"solution": "def add_lists(list_a, tuple_b):\n    \"\"\"\n    Appends the given list to the given tuple and returns a new tuple.\n    \n    Parameters:\n    - list_a: List to be appended to the tuple.\n    - tuple_b: Tuple to which the list will be appended.\n    \n    Returns:\n    - A new tuple with elements of tuple_b followed by elements of list_a.\n    \"\"\"\n    # Convert the list to a tuple\n    list_as_tuple = tuple(list_a)\n    \n    # Concatenate the tuples\n    result_tuple = tuple_b + list_as_tuple\n    \n    return result_tuple", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_val, tuple_val):\n    \"\"\"\n    Appends elements of a list to a tuple and returns a new tuple.\n    \n    Parameters:\n    - list_val: List to be appended.\n    - tuple_val: Tuple to which the list elements will be appended.\n    \n    Returns:\n    - A new tuple containing elements of the original tuple followed by elements of the list.\n    \"\"\"\n    # Convert the tuple to a list to easily append the list_val\n    tuple_as_list = list(tuple_val)\n    tuple_as_list.extend(list_val)\n    \n    # Convert the list back to a tuple\n    result_tuple = tuple(tuple_as_list)\n    \n    return result_tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_param, tuple_param):\n    \"\"\"\n    Appends the given list to the given tuple and returns a new tuple.\n\n    Args:\n    list_param (list): The list to append.\n    tuple_param (tuple): The tuple to append to.\n\n    Returns:\n    tuple: A new tuple consisting of the original tuple followed by the elements of the list.\n    \"\"\"\n    # Convert the list to a tuple and concatenate it to the original tuple\n    new_tuple = tuple_param + tuple(list_param)\n    return new_tuple", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, append the given list, and then convert back to a tuple\n    result = list(tup) + lst\n    return tuple(result)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_add, tuple_to_append_to):\n    # Convert the tuple to a list to allow appending\n    temp_list = list(tuple_to_append_to)\n    # Extend the list with the elements from the list_to_add\n    temp_list.extend(list_to_add)\n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    return result_tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_val, tuple_val):\n    # Convert the list to a tuple\n    list_as_tuple = tuple(list_val)\n    # Concatenate the two tuples\n    result_tuple = tuple_val + list_as_tuple\n    return result_tuple", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_param, tuple_param):\n    # Convert the list to a tuple\n    list_as_tuple = tuple(list_param)\n    # Concatenate the input tuple with the converted tuple\n    result_tuple = tuple_param + list_as_tuple\n    # Return the resulting tuple\n    return result_tuple", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_val, tuple_val):\n    \"\"\"\n    Function to append the given list to the given tuples.\n\n    Args:\n    list_val (list): The list to be appended.\n    tuple_val (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list elements appended to the original tuple.\n\n    Example:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert the list to a tuple\n    list_as_tuple = tuple(list_val)\n    # Concatenate the original tuple with the new tuple\n    result_tuple = tuple_val + list_as_tuple\n    return result_tuple", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_val, tuple_val):\n    # Convert the list to a tuple and concatenate it to the original tuple\n    return tuple_val + tuple(list_val)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_append, tuple_to_add_to):\n    # Convert the tuple to a list to allow modifications\n    tuple_list = list(tuple_to_add_to)\n    \n    # Extend the list with the elements from the list to append\n    tuple_list.extend(list_to_append)\n    \n    # Convert the list back to a tuple\n    result_tuple = tuple(tuple_list)\n    \n    return result_tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, append the given list, then convert back to a tuple\n    result = list(tup) + lst\n    return tuple(result)", "matching_cluster_idx": 3}, {"solution": "def add_lists(list_val, tuple_val):\n    return tuple_val + tuple(list_val)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_data, tuple_data):\n    # Convert the list to a tuple\n    list_as_tuple = tuple(list_data)\n    \n    # Concatenate the input tuple with the converted tuple\n    result_tuple = tuple_data + list_as_tuple\n    \n    return result_tuple", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 82.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged = sorted(list1 + list2 + list3)\n    return merged", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Parameters:\n    - list1: First list of integers.\n    - list2: Second list of integers.\n    - list3: Third list of integers.\n\n    Returns:\n    - A single list containing all elements from the three input lists, sorted in ascending order.\n    \"\"\"\n    # Combine all three lists into one\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_combined = sorted(combined)\n    return sorted_combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    combined = list1 + list2 + list3\n    combined.sort()\n    return combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    combined = list1 + list2 + list3\n    sorted_combined = sorted(combined)\n    return sorted_combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged = sorted(list1 + list2 + list3)\n    return merged", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Args:\n    - list1: First list of integers.\n    - list2: Second list of integers.\n    - list3: Third list of integers.\n\n    Returns:\n    - A single list containing all elements from the three lists, sorted in ascending order.\n    \"\"\"\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    combined_list.sort()\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged = sorted(list1 + list2 + list3)\n    return merged", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_combined = sorted(combined)\n    return sorted_combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_combined = sorted(combined)\n    return sorted_combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Parameters:\n    list1 (list): The first list to be merged.\n    list2 (list): The second list to be merged.\n    list3 (list): The third list to be merged.\n\n    Returns:\n    list: A single sorted list containing all elements from the three input lists.\n\n    Examples:\n    >>> merge_sorted_list([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48])\n    [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]\n    \"\"\"\n\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the combined list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Parameters:\n    - list1: First list of integers.\n    - list2: Second list of integers.\n    - list3: Third list of integers.\n\n    Returns:\n    - A single sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all three lists into one\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_combined = sorted(combined)\n    return sorted_combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged = sorted(list1 + list2 + list3)\n    return merged", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 99.44615384615385, "dps_norm": 88.75, "pass@1": 100.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        if not common_elements:\n            break\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Convert the first sublist to a set for comparison\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining sublists\n    for sublist in nested_lists[1:]:\n        # Convert the sublist to a set and intersect with common_elements\n        common_elements.intersection_update(sublist)\n    \n    # Return the common elements as a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    common_elements = set(nested_lists[0])\n    for sublist in nested_lists[1:]:\n        common_elements &= set(sublist)\n        if not common_elements:\n            break\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    Args:\n    nested_lists: A list of lists containing elements.\n\n    Returns:\n    A list containing the common elements found in all the sublists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Convert the first sublist to a set for comparison\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining sublists\n    for sublist in nested_lists[1:]:\n        # Convert the sublist to a set and intersect with the current common_elements set\n        common_elements &= set(sublist)\n        \n        # Early termination if no common elements are left\n        if not common_elements:\n            break\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    common_elements = set(nested_lists[0])\n    \n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n        if not common_elements:\n            break  # Early exit if no common elements are found\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    common_elements = set(nested_lists[0])\n    \n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n        if not common_elements:\n            break  # No need to check further if no common elements are left\n    \n    return list(common_elements)", "matching_cluster_idx": 7}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        if not common_elements:\n            break\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    common_elements = set(nested_lists[0])\n    \n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n        if not common_elements:\n            break  # Early exit if no common elements are found\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Assuming lists is a list of lists\n    # Find the intersection of all sublists\n    if not lists:\n        return []\n    # Start with the set of the first list\n    common_elements = set(lists[0])\n    # Intersect with the sets of the remaining lists\n    for sublist in lists[1:]:\n        common_elements &= set(sublist)\n        # Early termination if no common elements are left\n        if not common_elements:\n            break\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    common_elements = set(nested_lists[0])\n    \n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n        if not common_elements:\n            break  # No need to check further if no common elements are left\n    \n    return list(common_elements)", "matching_cluster_idx": 7}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        if not common_elements:\n            break\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    common_elements = set(nested_lists[0])\n    \n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n        if not common_elements:\n            break  # Early exit if no common elements are found\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    common_elements = set(nested_lists[0])\n    \n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n        if not common_elements:\n            break  # Early exit if no common elements are found\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n    \n    Args:\n    nested_lists: a list of lists containing elements to check for commonality.\n    \n    Returns:\n    A set containing the common elements found in all the nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n    \n    # Start with the set of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Intersect with sets of the remaining lists\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        \n        # Early termination if no common elements are left\n        if not common_elements:\n            break\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(list_of_lists):\n    if not list_of_lists:\n        return []\n    \n    # Convert the first sublist to a set for comparison\n    common_elements = set(list_of_lists[0])\n    \n    # Iterate over the remaining sublists\n    for sublist in list_of_lists[1:]:\n        # Convert the sublist to a set and intersect with the common_elements set\n        common_elements &= set(sublist)\n        \n        # Early termination if no common elements are left\n        if not common_elements:\n            return []\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    common_elements = set(nested_lists[0])\n    \n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n        if not common_elements:\n            break  # Early exit if no common elements are found\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Find the intersection of all lists\n    if not lists:\n        return []\n    common_elements = set(lists[0])\n    for lst in lists[1:]:\n        common_elements &= set(lst)\n        if not common_elements:\n            break  # No need to proceed if no common elements are found\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    common_elements = set(nested_lists[0])\n    \n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n        if not common_elements:\n            break  # Early exit if no common elements are found\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    common_elements = set(nested_lists[0])\n    \n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n        if not common_elements:\n            break  # Early exit if no common elements are found\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    common_elements = set(nested_lists[0])\n    \n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n        if not common_elements:\n            break  # Early exit if no common elements are found\n    \n    return list(common_elements)", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.63619402985074, "dps_norm": 86.07142857142857, "pass@1": 84.0, "profiled": [{"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a specified limit.\n    \n    Amicable numbers are two different numbers so related that the sum of the proper divisors\n    of each is equal to the other number. (A proper divisor of a number is a positive divisor other than the number itself.\n    For example, the proper divisors of 6 are 1, 2, and 3.)\n    \n    This function finds all such amicable numbers below a given limit and returns their sum.\n    \n    Parameters:\n    - limit (int): The upper limit up to which amicable numbers are to be found and summed.\n    \n    Returns:\n    - int: The sum of all amicable numbers below the specified limit.\n    \"\"\"\n    def sum_of_divisors(n):\n        \"\"\"Return the sum of proper divisors of n.\"\"\"\n        divisors_sum = 1  # 1 is a proper divisor for all n > 1\n        sqrt_n = int(n**0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    amicable_sum = 0\n    for num in range(2, limit):\n        partner = sum_of_divisors(num)\n        if partner > num and sum_of_divisors(partner) == num:\n            amicable_sum += num + partner\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a given limit.\n    \n    Amicable numbers are two different numbers so related that the sum of the proper divisors \n    of each is equal to the other number. (A proper divisor of a number is a positive factor \n    of that number other than the number itself. For example, the proper divisors of 6 are 1, 2, \n    and 3.) For example, the smallest pair of amicable numbers is (220, 284); \n    for 220, the sum of its proper divisors is 1 + 2 + 4 + 5 + 10 + 11 + 20 + 22 + 44 + 55 + 110 = 284, \n    and for 284, the sum of its proper divisors is 1 + 2 + 4 + 71 + 142 = 220.\n    \n    This function finds all such amicable number pairs where both numbers are less than the \n    given limit and returns their sum.\n    \n    Parameters:\n    - limit: int, the upper bound to check for amicable numbers.\n    \n    Returns:\n    - int, the sum of all amicable numbers found within the limit.\n    \"\"\"\n    def sum_of_divisors(n):\n        \"\"\"Return the sum of proper divisors of n.\"\"\"\n        divisors_sum = 1  # Start with 1 because it's a proper divisor for all n > 1\n        sqrt_n = int(n**0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    amicable_sum = 0\n    for num in range(2, limit):\n        partner = sum_of_divisors(num)\n        if partner > num and sum_of_divisors(partner) == num:\n            amicable_sum += num + partner\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a given limit.\n    \n    Amicable numbers are two different numbers so related that the sum of the proper divisors\n    of each is equal to the other number. (A proper divisor of a number is a positive factor\n    of that number other than the number itself. For example, the proper divisors of 6 are 1, 2, and 3.)\n    \n    :param limit: int - the upper limit to find amicable numbers\n    :return: int - the sum of all amicable numbers up to the limit\n    \"\"\"\n    if limit < 1:\n        return 0\n    \n    # Function to calculate the sum of proper divisors of n\n    def sum_proper_divisors(n):\n        sum_div = 1  # 1 is a proper divisor for all n > 1\n        sqrt_n = int(n**0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                sum_div += i\n                if i != n // i:\n                    sum_div += n // i\n        return sum_div\n    \n    amicable_sum = 0\n    amicable_pairs = set()\n    \n    for num in range(2, limit + 1):\n        if num in amicable_pairs:\n            continue\n        sum_div = sum_proper_divisors(num)\n        if sum_div != num and sum_proper_divisors(sum_div) == num:\n            amicable_pairs.add(num)\n            amicable_pairs.add(sum_div)\n    \n    for pair in amicable_pairs:\n        if pair <= limit:\n            amicable_sum += pair\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def get_divisors_sum(n):\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            sum += i\n            if i != n // i:\n                sum += n // i\n        i += 1\n    return sum\ndef amicable_numbers_sum(limit):\n    sum = 0\n    for num in range(2, limit):\n        div_sum = get_divisors_sum(num)\n        if div_sum != num and get_divisors_sum(div_sum) == num:\n            sum += num\n    return sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a given limit.\n    \n    Amicable numbers are two different numbers so related that the sum of the proper divisors \n    of each is equal to the other number. (A proper divisor of a number is a positive factor \n    of that number other than the number itself. For example, the proper divisors of 6 are 1, 2, \n    and 3.)\n    \n    This function finds all such amicable numbers pairs where both numbers are less than the \n    given limit and returns their sum.\n    \n    Parameters:\n    - limit: int, the upper bound to look for amicable numbers.\n    \n    Returns:\n    - int, the sum of all amicable numbers found below the given limit.\n    \"\"\"\n    \n    def sum_of_divisors(n):\n        \"\"\"Return the sum of proper divisors of n.\"\"\"\n        divisors_sum = 1  # 1 is a proper divisor for all n > 1\n        sqrt_n = int(n**0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n\n    amicable_sum = 0\n    for num in range(2, limit):\n        partner = sum_of_divisors(num)\n        if partner > num and sum_of_divisors(partner) == num:\n            amicable_sum += num + partner\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a given limit.\n    \n    Amicable numbers are two different numbers so related that the sum of the proper divisors \n    of each is equal to the other number. (A proper divisor of a number is a positive factor \n    of that number other than the number itself. For example, the proper divisors of 6 are 1, 2, \n    and 3.)\n    \n    :param limit: The upper bound of the range to look for amicable numbers.\n    :return: The sum of all amicable numbers up to the limit.\n    \"\"\"\n    sum_amicable = 0\n    for num in range(2, limit + 1):\n        partner = sum(get_proper_divisors(num))\n        if partner > num and sum(get_proper_divisors(partner)) == num:\n            sum_amicable += num + partner\n    return sum_amicable\ndef get_proper_divisors(n):\n    \"\"\"\n    Get all proper divisors of a given number.\n    \n    :param n: The number to find the proper divisors for.\n    :return: A list of proper divisors of n.\n    \"\"\"\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a given limit.\n\n    Amicable numbers are two different numbers so related that the sum of the proper divisors\n    of each is equal to the other number. (A proper divisor of a number is a positive factor\n    of that number other than the number itself. For example, the proper divisors of 6 are 1, 2, and 3.)\n\n    Parameters:\n    - limit: int, the upper limit up to which amicable numbers are to be found and summed.\n\n    Returns:\n    - int, the sum of all amicable numbers up to the given limit.\n    \"\"\"\n\n    def sum_of_proper_divisors(n):\n        \"\"\"\n        Calculate the sum of proper divisors of a given number.\n\n        Parameters:\n        - n: int, the number for which to calculate the sum of proper divisors.\n\n        Returns:\n        - int, the sum of proper divisors of n.\n        \"\"\"\n        sum_div = 1  # 1 is a proper divisor for all n > 1\n        sqrt_n = int(n**0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                sum_div += i\n                if i != n // i:\n                    sum_div += n // i\n        return sum_div\n\n    amicable_sum = 0\n    amicable_numbers = set()\n    for num in range(2, limit):\n        if num not in amicable_numbers:\n            partner = sum_of_proper_divisors(num)\n            if partner != num and sum_of_proper_divisors(partner) == num:\n                amicable_numbers.update([num, partner])\n                amicable_sum += num + partner\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a given limit.\n    \n    Amicable numbers are two different numbers so related that the sum of the proper divisors \n    of each is equal to the other number. (A proper divisor of a number is a positive factor \n    of that number other than the number itself. For example, the proper divisors of 6 are 1, 2, \n    and 3.)\n    \n    :param limit: Upper limit to find amicable numbers.\n    :return: Sum of all amicable numbers within the given limit.\n    \"\"\"\n    \n    def sum_of_proper_divisors(n):\n        \"\"\"Return the sum of proper divisors of n.\"\"\"\n        sum_div = 1  # 1 is a proper divisor for all n > 1\n        sqrt_n = int(n**0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                sum_div += i\n                if i != n // i:\n                    sum_div += n // i\n        return sum_div\n\n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        sum_div = sum_of_proper_divisors(num)\n        if sum_div != num and sum_of_proper_divisors(sum_div) == num:\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a given limit.\n    \n    Amicable numbers are two different numbers so related that the sum of the proper divisors\n    of each is equal to the other number. (A proper divisor of a number is a positive divisor other than the number itself.\n    For example, the proper divisors of 6 are 1, 2, and 3.)\n    \n    :param limit: int - the upper limit to find amicable numbers\n    :return: int - the sum of all amicable numbers up to the limit\n    \"\"\"\n    def sum_proper_divisors(n):\n        divisors_sum = 1  # Start with 1 because it's a proper divisor for all n > 1\n        sqrt_n = int(n**0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    amicable_sum = 0\n    for num in range(2, limit):\n        partner = sum_proper_divisors(num)\n        if partner > num and sum_proper_divisors(partner) == num:\n            amicable_sum += num + partner\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a given limit.\n\n    Amicable numbers are two different numbers so related that the sum of the proper divisors\n    of each is equal to the other number. (A proper divisor of a number is a positive divisor other than the number itself.)\n\n    For example, the smallest pair of amicable numbers is (220, 284); for these numbers,\n    the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110, of which the sum is 284;\n    and the proper divisors of 284 are 1, 2, 4, 71, and 142, of which the sum is 220.\n\n    :param limit: int - the upper limit up to which to find amicable numbers\n    :return: int - the sum of all amicable numbers up to the limit\n    \"\"\"\n\n    def sum_proper_divisors(n):\n        \"\"\"\n        Calculate the sum of proper divisors of a given number.\n\n        :param n: int - the number to calculate the sum of proper divisors for\n        :return: int - the sum of proper divisors of n\n        \"\"\"\n        sum_div = 1  # 1 is a proper divisor for all n > 1\n        sqrt_n = int(n ** 0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                sum_div += i\n                if i != n // i:\n                    sum_div += n // i\n        return sum_div\n\n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        sum_d = sum_proper_divisors(num)\n        if sum_d != num and sum_proper_divisors(sum_d) == num:\n            amicable_sum += num\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a given limit.\n    \n    Amicable numbers are two different numbers so related that the sum of the proper divisors \n    of each is equal to the other number. This function finds all such numbers up to the limit \n    and returns their sum.\n    \n    :param limit: int - the upper bound to check for amicable numbers\n    :return: int - the sum of all amicable numbers within the limit\n    \"\"\"\n    if limit < 1:\n        return 0\n\n    # Create a list to store the sum of proper divisors for each number\n    divisor_sum = [0] * (limit + 1)\n    for num in range(1, limit + 1):\n        for multiple in range(2 * num, limit + 1, num):\n            divisor_sum[multiple] += num\n\n    amicable_sum = 0\n    checked = set()\n    for num in range(2, limit + 1):\n        if num in checked:\n            continue\n        ami_pair = divisor_sum[num]\n        if ami_pair > num and ami_pair <= limit and divisor_sum[ami_pair] == num:\n            amicable_sum += num + ami_pair\n            checked.add(ami_pair)\n    return amicable_sum", "matching_cluster_idx": 12}, {"solution": "def get_divisors(n):\n    \"\"\"Helper function to get the sum of proper divisors of n.\"\"\"\n    sum = 1  # 1 is a proper divisor for n > 1\n    sqrt_n = int(n ** 0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            sum += i\n            if i != n // i:  # Add the quotient only if it's different\n                sum += n // i\n    return sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculate the sum of all amicable numbers up to the given limit.\"\"\"\n    if limit < 1:\n        return 0\n    \n    # Initialize a list to keep track of visited numbers and their partners\n    visited = [False] * (limit + 1)\n    total_sum = 0\n    \n    for num in range(2, limit + 1):\n        if not visited[num]:\n            partner = get_divisors(num)\n            if partner != num and get_divisors(partner) == num and partner <= limit:\n                # Both num and partner are amicable, and within the limit\n                total_sum += num + partner\n                # Mark both as visited to avoid double counting\n                visited[num] = True\n                visited[partner] = True\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a specified limit.\n    \n    Amicable numbers are two different numbers so related that the sum of the proper divisors\n    of each is equal to the other number. (A proper divisor of a number is a positive factor\n    of that number other than the number itself. For example, the proper divisors of 6 are 1, 2, and 3.)\n    \n    :param limit: The upper bound of the range to look for amicable numbers.\n    :return: The sum of all amicable numbers within the specified range.\n    \"\"\"\n    \n    def sum_of_divisors(n):\n        \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n        divisors_sum = 1  # 1 is a proper divisor for all n > 1\n        sqrt_n = int(n ** 0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        partner = sum_of_divisors(num)\n        if partner > num and sum_of_divisors(partner) == num:\n            amicable_sum += num + partner\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def get_divisors_sum(n):\n    \"\"\"Return sum of proper divisors of n.\"\"\"\n    sum = 1  # 1 is a proper divisor for n > 1\n    sqrt_n = int(n ** 0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            sum += i\n            if i != n // i:  # add the quotient only if it's different from i\n                sum += n // i\n    return sum\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a given limit.\n    \n    Amicable numbers are two different numbers so related that the sum of the proper divisors\n    of each is equal to the other number. (A proper divisor of a number is a positive divisor\n    other than the number itself.)\n    \n    :param limit: upper limit to search for amicable numbers\n    :return: sum of all amicable numbers within the limit\n    \"\"\"\n    if limit < 1:\n        return 0\n    amicable_sum = 0\n    # Use a set to keep track of amicable numbers to avoid duplicates\n    amicable_numbers = set()\n    for num in range(2, limit + 1):\n        if num not in amicable_numbers:\n            div_sum = get_divisors_sum(num)\n            if div_sum != num and get_divisors_sum(div_sum) == num:\n                if div_sum <= limit:\n                    amicable_numbers.add(num)\n                    amicable_numbers.add(div_sum)\n    amicable_sum = sum(amicable_numbers)\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a given limit.\n    \n    Amicable numbers are two different numbers so related that the sum of the proper divisors \n    of each is equal to the other number. (A proper divisor of a number is a positive factor \n    of that number other than the number itself. For example, the proper divisors of 6 are 1, 2, \n    and 3.) For example, the smallest pair of amicable numbers is (220, 284); for they are both \n    equal to the sum of their proper divisors.\n    \n    :param limit: The upper limit to which amicable numbers are to be summed.\n    :return: The sum of all amicable numbers up to the given limit.\n    \"\"\"\n    def sum_of_divisors(n):\n        \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n        sum_div = 1  # 1 is a proper divisor for all n > 1\n        sqrt_n = int(n ** 0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                sum_div += i\n                if i != n // i:\n                    sum_div += n // i\n        return sum_div\n\n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        sum_div = sum_of_divisors(num)\n        if sum_div != num and sum_of_divisors(sum_div) == num:\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a given limit.\n\n    Amicable numbers are two different numbers so related that the sum of the proper divisors\n    of each is equal to the other number. (A proper divisor of a number is a positive factor\n    of that number other than the number itself. For example, the proper divisors of 6 are 1, 2, and 3.)\n\n    :param limit: Upper limit to find amicable numbers\n    :return: Sum of all amicable numbers within the given limit\n    \"\"\"\n    def sum_of_proper_divisors(n):\n        \"\"\"Return the sum of proper divisors of n.\"\"\"\n        divisors_sum = 1  # 1 is a proper divisor for all n > 1\n        sqrt_n = int(n ** 0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n\n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        sum_div = sum_of_proper_divisors(num)\n        if sum_div != num and sum_of_proper_divisors(sum_div) == num:\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers from 1 to the specified limit.\n\n    Args:\n    - limit: int, the upper limit for checking amicable numbers.\n\n    Returns:\n    - int, sum of all amicable numbers within the range.\n    \"\"\"\n    sum_amicable = 0\n    for num in range(2, limit + 1):\n        partner = sum(get_proper_divisors(num))\n        if partner > num and sum(get_proper_divisors(partner)) == num:\n            sum_amicable += num + partner\n    return sum_amicable\ndef get_proper_divisors(n):\n    \"\"\"\n    Get all proper divisors of a number excluding the number itself.\n\n    Args:\n    - n: int, the number to find divisors for.\n\n    Returns:\n    - set, proper divisors of n.\n    \"\"\"\n    divisors = set()\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            if i != n // i and i != 1:\n                divisors.add(n // i)\n    return divisors - {n}", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a specified limit.\n    \n    Amicable numbers are two different numbers so related that the sum of the proper divisors \n    of each is equal to the other number. (A proper divisor of a number is a positive divisor other than the number itself.)\n\n    Parameters:\n    - limit: int, the upper limit up to which to sum amicable numbers.\n\n    Returns:\n    - int, the sum of all amicable numbers up to the limit.\n    \"\"\"\n    def sum_of_divisors(n):\n        sum_div = 1  # Start with 1 because it's a proper divisor for all n > 1\n        sqrt_n = int(n**0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                sum_div += i\n                if i != n // i:  # Add the quotient only if it's different from i\n                    sum_div += n // i\n        return sum_div\n\n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        partner = sum_of_divisors(num)\n        if partner > num and sum_of_divisors(partner) == num:\n            amicable_sum += num + partner\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a specified limit.\n\n    Amicable numbers are two different numbers so related that the sum of the proper divisors\n    of each is equal to the other number.\n\n    Parameters:\n    limit (int): The upper bound of the range to find amicable numbers.\n\n    Returns:\n    int: The sum of all amicable numbers within the specified range.\n    \"\"\"\n\n    def sum_of_divisors(n):\n        \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n        sum_div = 1  # 1 is a proper divisor for all n > 1\n        sqrt_n = int(n ** 0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                sum_div += i\n                if i != n // i:\n                    sum_div += n // i\n        return sum_div\n\n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        sum_div = sum_of_divisors(num)\n        if sum_div != num and sum_of_divisors(sum_div) == num:\n            amicable_sum += num\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def get_divisors_sum(n):\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            sum += i\n            if i != n // i:\n                sum += n // i\n        i += 1\n    return sum\ndef amicable_numbers_sum(limit):\n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        div_sum = get_divisors_sum(num)\n        if div_sum != num and get_divisors_sum(div_sum) == num:\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 99.0, "profiled": [{"solution": "def long_words(n, words):\n    # Split the string into a list of words\n    word_list = words.split()\n    # Use list comprehension to filter words longer than n characters\n    long_words_list = [word for word in word_list if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    \"\"\"\n    This function takes an integer n and a string of words separated by spaces.\n    It returns a list of words that are longer than n characters.\n    \n    :param n: Minimum length of words to be included in the result\n    :param word_list: String containing words separated by spaces\n    :return: List of words longer than n characters\n    \"\"\"\n    # Split the string into a list of words\n    words = word_list.split()\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Check if the word's length is greater than n\n        if len(word) > n:\n            # If so, append it to the result list\n            result.append(word)\n    \n    # Return the result list\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the string into a list of words\n    word_list = words.split()\n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Parameters:\n    n (int): The minimum length a word must have to be included in the result.\n    words (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words that are longer than n characters.\n    \"\"\"\n    # Split the string into a list of words\n    word_list = words.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    \"\"\"\n    This function takes an integer n and a string of words separated by spaces.\n    It returns a list of words that are longer than n characters.\n    \"\"\"\n    # Split the string into a list of words\n    words = word_list.split()\n    \n    # Initialize an empty list to store words longer than n characters\n    long_words_list = []\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Check if the length of the word is greater than n\n        if len(word) > n:\n            # If so, append it to the long_words_list\n            long_words_list.append(word)\n    \n    # Return the list of long words\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the string into a list of words\n    word_list = words.split()\n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    word_list = words.split()\n    result = [word for word in word_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the input string into a list of words\n    word_list = words.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    \n    # Return the result\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Parameters:\n    - n (int): The minimum length a word must have to be included in the result.\n    - words (str): A string containing words separated by spaces.\n\n    Returns:\n    - list: A list of words that are longer than n characters.\n    \"\"\"\n    # Split the string into a list of words\n    word_list = words.split()\n    \n    # Filter words based on length\n    result = [word for word in word_list if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the string into a list of words\n    word_list = words.split()\n    # Use list comprehension to filter words longer than n characters\n    long_words_list = [word for word in word_list if len(word) > n]\n    # Return the list of long words\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Parameters:\n    n (int): The minimum length of words to be included in the result.\n    words (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words that are longer than n characters.\n    \"\"\"\n    # Split the string into a list of words\n    word_list = words.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Function to find words that are longer than n characters from a given list of words.\n    \n    Args:\n    n (int): The minimum length of words to be included in the result.\n    words (str): A string containing words separated by spaces.\n    \n    Returns:\n    list: A list of words that are longer than n characters.\n    \n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the string into words\n    word_list = words.split()\n    \n    # Filter words based on length\n    result = [word for word in word_list if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    This function takes an integer n and a string of words separated by spaces.\n    It returns a list of words that are longer than n characters.\n    \n    :param n: Minimum length of words to be included in the result\n    :param words: String containing words separated by spaces\n    :return: List of words longer than n characters\n    \"\"\"\n    # Split the string into a list of words\n    word_list = words.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    \"\"\"\n    This function takes an integer n and a string of words separated by spaces.\n    It returns a list of words that are longer than n characters.\n    \n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the string into a list of words\n    words = word_list.split()\n    # Use list comprehension to filter words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the input string into a list of words\n    word_list = words.split()\n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    # Return the result list\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    \"\"\"\n    This function takes an integer n and a string of words separated by spaces.\n    It returns a list of words that are longer than n characters.\n    \n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the string into a list of words\n    words = word_list.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Args:\n    n (int): The minimum length of words to include.\n    words (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words that are longer than n characters.\n    \"\"\"\n    # Split the string into a list of words\n    word_list = words.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the input string into a list of words\n    word_list = words.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    \n    # Return the filtered list\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    This function takes an integer n and a string of words separated by spaces.\n    It returns a list of words that are longer than n characters.\n    \n    Example usage:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the string into a list of words\n    word_list = words.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the input string into a list of words\n    word_list = words.split()\n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 69.54081632653062, "dps_norm": 96.0, "pass@1": 76.0, "profiled": [{"solution": "def magic_square_test(square):\n    n = len(square)\n    if n == 0 or any(len(row) != n for row in square):\n        return False\n\n    magic_constant = sum(square[0])\n\n    # Check rows\n    for row in square:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum(square[row][col] for row in range(n)) != magic_constant:\n            return False\n\n    # Check diagonals\n    if sum(square[i][i] for i in range(n)) != magic_constant:\n        return False\n    if sum(square[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(grid):\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(grid[0])\n    \n    # Check rows\n    for row in grid:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check columns\n    for col in range(len(grid[0])):\n        col_sum = sum(row[col] for row in grid)\n        if col_sum != magic_sum:\n            return False\n    \n    # Check diagonals\n    diagonal_sum = sum(grid[i][i] for i in range(len(grid)))\n    if diagonal_sum != magic_sum:\n        return False\n    \n    anti_diagonal_sum = sum(grid[i][len(grid)-1-i] for i in range(len(grid)))\n    if anti_diagonal_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(square):\n    n = len(square)\n    if n == 0 or any(len(row) != n for row in square):\n        return False  # Not a square matrix\n    \n    # Calculate the sum of the first row to use as the magic constant\n    magic_constant = sum(square[0])\n    \n    # Check sums of all rows\n    for row in square:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(square[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(square[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(square[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(mat):\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(mat[0])\n    \n    # Check rows\n    for row in mat:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check columns\n    for col in range(len(mat[0])):\n        col_sum = sum(row[col] for row in mat)\n        if col_sum != magic_sum:\n            return False\n    \n    # Check diagonals\n    diag_sum1 = sum(mat[i][i] for i in range(len(mat)))\n    diag_sum2 = sum(mat[i][len(mat)-1-i] for i in range(len(mat)))\n    if diag_sum1 != magic_sum or diag_sum2 != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Check if it's a square matrix\n    n = len(mat)\n    if any(len(row) != n for row in mat):\n        return False\n\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(mat[0])\n\n    # Check the sums of all rows\n    for row in mat:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sums of all columns\n    for col in range(n):\n        col_sum = sum(mat[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    main_diagonal_sum = sum(mat[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    secondary_diagonal_sum = sum(mat[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(mat):\n    n = len(mat)\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(mat[0])\n    \n    # Check sums of all rows\n    for row in mat:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        col_sum = sum(mat[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    main_diag_sum = sum(mat[i][i] for i in range(n))\n    if main_diag_sum != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    secondary_diag_sum = sum(mat[i][n-1-i] for i in range(n))\n    if secondary_diag_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if n == 0 or any(len(row) != n for row in matrix):\n        return False  # Not a square matrix\n\n    # Calculate the sum of the first row to use as the magic constant\n    magic_const = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_const:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_const:\n            return False\n\n    # Check sum of the main diagonal\n    main_diag_sum = sum(matrix[i][i] for i in range(n))\n    if main_diag_sum != magic_const:\n        return False\n\n    # Check sum of the secondary diagonal\n    secondary_diag_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diag_sum != magic_const:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if n == 0 or any(len(row) != n for row in matrix):\n        return False  # Not a square matrix\n\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n\n    # Check the sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sums of all columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True\nmatrix = [\n    [7, 12, 1, 14],\n    [2, 13, 8, 11],\n    [16, 3, 10, 5],\n    [9, 6, 15, 4]\n]", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(grid):\n    n = len(grid)\n    if n == 0 or any(len(row) != n for row in grid):\n        return False  # Not a square matrix\n\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(grid[0])\n\n    # Check the sums of all rows\n    for row in grid:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sums of all columns\n    for col in range(n):\n        col_sum = sum(grid[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    main_diag_sum = sum(grid[i][i] for i in range(n))\n    if main_diag_sum != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    secondary_diag_sum = sum(grid[i][n - 1 - i] for i in range(n))\n    if secondary_diag_sum != magic_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(mat):\n    n = len(mat)\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(mat[0])\n    \n    # Check sums of all rows\n    for row in mat:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        col_sum = sum(mat[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    main_diag_sum = sum(mat[i][i] for i in range(n))\n    if main_diag_sum != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    sec_diag_sum = sum(mat[i][n-1-i] for i in range(n))\n    if sec_diag_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if n == 0 or any(len(row) != n for row in matrix):\n        return False  # Not a square matrix\n\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n\n    # Check the sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sums of all columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    main_diag_sum = sum(matrix[i][i] for i in range(n))\n    if main_diag_sum != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    sec_diag_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if sec_diag_sum != magic_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(square):\n    n = len(square)\n    if n == 0 or any(len(row) != n for row in square):\n        return False  # Not a square matrix\n\n    # Calculate the sum of the first row to use as the target sum\n    target_sum = sum(square[0])\n\n    # Check row sums\n    for row in square:\n        if sum(row) != target_sum:\n            return False\n\n    # Check column sums\n    for col in range(n):\n        if sum(square[row][col] for row in range(n)) != target_sum:\n            return False\n\n    # Check diagonal sums\n    if sum(square[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(square[i][n - 1 - i] for i in range(n)) != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if n == 0 or any(len(row) != n for row in matrix):\n        return False  # Not a square matrix\n    \n    # Calculate the sum of the first row to use as the magic constant\n    magic_constant = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if it's a square matrix\n    n = len(matrix)\n    if not all(len(row) == n for row in matrix):\n        return False\n\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n\n    # Check the sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sums of all columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(grid):\n    # Calculate the magic sum using the first row\n    magic_sum = sum(grid[0])\n    \n    # Check sum of each row\n    for row in grid:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sum of each column\n    for col in range(len(grid[0])):\n        if sum(grid[row][col] for row in range(len(grid))) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(grid[i][i] for i in range(len(grid))) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(grid[i][len(grid)-1-i] for i in range(len(grid))) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Calculate the sum of the first row to use as a reference\n    ref_sum = sum(mat[0])\n    \n    # Check row sums\n    for row in mat:\n        if sum(row) != ref_sum:\n            return False\n    \n    # Check column sums\n    for col in range(len(mat[0])):\n        col_sum = sum(row[col] for row in mat)\n        if col_sum != ref_sum:\n            return False\n    \n    # Check diagonal sums\n    diag1_sum = sum(mat[i][i] for i in range(len(mat)))\n    diag2_sum = sum(mat[i][len(mat)-1-i] for i in range(len(mat)))\n    if diag1_sum != ref_sum or diag2_sum != ref_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(sess):\n    \"\"\"\n    Determines if a given square matrix is a magic square.\n    \n    Parameters:\n    sess (list of list of int): The square matrix to be checked.\n    \n    Returns:\n    bool: True if the input matrix is a magic square, otherwise False.\n    \"\"\"\n    n = len(sess)\n    if n == 0 or any(len(row) != n for row in sess):\n        return False  # Not a square matrix\n    \n    # Calculate the sum of the first row to use as the magic constant\n    magic_constant = sum(sess[0])\n    \n    # Check the sum of each row\n    for row in sess:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(sess[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(sess[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(sess[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    size = len(matrix)\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(size):\n        col_sum = sum(matrix[row][col] for row in range(size))\n        if col_sum != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(size))\n    if main_diagonal_sum != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][size - 1 - i] for i in range(size))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if n == 0 or any(len(row) != n for row in matrix):\n        return False  # Not a square matrix\n    \n    # Calculate the sum of the first row to use as a reference\n    target_sum = sum(matrix[0])\n    \n    # Check the sums of all rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sums of all columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != target_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != target_sum:\n        return False\n    \n    return True\nmatrix = [\n    [7, 12, 1, 14],\n    [2, 13, 8, 11],\n    [16, 3, 10, 5],\n    [9, 6, 15, 4]\n]", "matching_cluster_idx": 13}]}, "Mbpp/130": {"dps": 79.73094170403587, "dps_norm": 73.33333333333334, "pass@1": 95.0, "profiled": [{"solution": "def max_occurrences(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    max_freq = max(freq_dict.values())\n    for key, value in freq_dict.items():\n        if value == max_freq:\n            return key", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import defaultdict\n    frequency = defaultdict(int)\n    for item in lst:\n        frequency[item] += 1\n    max_freq = -1\n    max_item = None\n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    count = Counter(lst)\n    max_freq = max(count.values())\n    for num in count:\n        if count[num] == max_freq:\n            return num", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n\n    max_freq = 0\n    max_item = None\n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    max_frequency = 0\n    max_item = None\n    for key, value in frequency_dict.items():\n        if value > max_frequency:\n            max_frequency = value\n            max_item = key\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import defaultdict\n    freq_map = defaultdict(int)\n    for num in lst:\n        freq_map[num] += 1\n    max_freq = -1\n    max_item = None\n    for item, freq in freq_map.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    count = Counter(lst)\n    max_count = max(count.values())\n    for num in count:\n        if count[num] == max_count:\n            return num", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(arr):\n    frequency = {}\n    for num in arr:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    max_freq = 0\n    max_item = None\n    for num, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = num\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import defaultdict\n    frequency_dict = defaultdict(int)\n    for item in lst:\n        frequency_dict[item] += 1\n    max_frequency = max(frequency_dict.values())\n    for key, value in frequency_dict.items():\n        if value == max_frequency:\n            return key\n    return None", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    count = Counter(lst)\n    max_freq = max(count.values())\n    for num in count:\n        if count[num] == max_freq:\n            return num", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n\n    max_freq = 0\n    max_item = None\n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    max_num = None\n    max_count = 0\n    for num, count in counts.items():\n        if count > max_count:\n            max_num = num\n            max_count = count\n    return max_num", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_freq = 0\n    max_item = None\n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import defaultdict\n    freq = defaultdict(int)\n    for item in lst:\n        freq[item] += 1\n    max_freq = -1\n    max_item = None\n    for item, freq in freq.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_freq = 0\n    max_item = None\n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import defaultdict\n    freq_map = defaultdict(int)\n    for num in lst:\n        freq_map[num] += 1\n    max_freq = -1\n    max_elem = None\n    for num, freq in freq_map.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_elem = num\n    return max_elem", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for num in lst:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    max_freq_num = lst[0]\n    max_freq_count = frequency[max_freq_num]\n    for num in frequency:\n        if frequency[num] > max_freq_count:\n            max_freq_num = num\n            max_freq_count = frequency[num]\n    return max_freq_num", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(arr):\n    from collections import Counter\n    freq = Counter(arr)\n    max_freq = max(freq.values())\n    for num, count in freq.items():\n        if count == max_freq:\n            return num\n    return None", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    max_freq = 0\n    max_item = None\n    for key, value in frequency_dict.items():\n        if value > max_freq:\n            max_freq = value\n            max_item = key\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for num in lst:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n\n    max_freq = 0\n    max_item = None\n    for num, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = num\n    return max_item", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": 53.2258064516129, "dps_norm": 65.0, "pass@1": 51.0, "profiled": [{"solution": "def zero_count(arr):\n    if not arr:  # Edge case: empty array\n        return 0  # or any other appropriate value or exception\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')  # or any other appropriate value to indicate division by zero\n    ratio = zero_count / non_zero_count\n    return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    zero_count = 0\n    non_zero_count = 0\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    if non_zero_count == 0:\n        return float('inf')  # or handle as per requirement\n    return zero_count / non_zero_count", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    zeros = 0\n    non_zeros = 0\n    for num in arr:\n        if num == 0:\n            zeros += 1\n        else:\n            non_zeros += 1\n    if non_zeros == 0:\n        return float('inf')  # or handle as needed\n    return zeros / non_zeros", "matching_cluster_idx": 3}, {"solution": "def zero_count(arr):\n    zeros = 0\n    non_zeros = 0\n    for num in arr:\n        if num == 0:\n            zeros += 1\n        else:\n            non_zeros += 1\n    if non_zeros == 0:\n        return float('inf')  # or handle as per requirements\n    return zeros / non_zeros", "matching_cluster_idx": 3}, {"solution": "def zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # or handle as per requirement\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zero_count = 0\n    non_zero_count = 0\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    if non_zero_count == 0:\n        return float('inf')  # or handle as per requirement\n    return zero_count / non_zero_count", "matching_cluster_idx": 3}, {"solution": "def zero_count(arr):\n    zero_count = 0\n    non_zero_count = 0\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    if non_zero_count == 0:\n        return float('inf')  # or handle as per requirement\n    return zero_count / non_zero_count", "matching_cluster_idx": 3}, {"solution": "def zero_count(arr):\n    zeroes = 0\n    non_zeroes = 0\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n    ratio = zeroes / non_zeroes if non_zeroes != 0 else float('inf')\n    return ratio\narr = [0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # or some other value indicating division by zero\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "def zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n    arr (list): List of integers.\n\n    Returns:\n    float: Ratio of zeroes to non-zeroes.\n\n    \"\"\"\n    if not arr:\n        return 0.0  # If the array is empty, there are no elements to compare.\n\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n\n    if non_zero_count == 0:\n        return float('inf')  # If there are no non-zero elements, the ratio is infinite.\n\n    ratio = zero_count / non_zero_count\n    return ratio", "matching_cluster_idx": 6}, {"solution": "def zero_count(arr):\n    num_zeros = sum(1 for x in arr if x == 0)\n    num_non_zeros = len(arr) - num_zeros\n    if num_non_zeros == 0:\n        return float('inf')  # or handle as per requirement\n    ratio = num_zeros / num_non_zeros\n    return round(ratio, 6)", "matching_cluster_idx": 4}, {"solution": "def zero_count(arr):\n    zero_count = 0\n    non_zero_count = 0\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    if non_zero_count == 0:\n        return float('inf')  # or handle as per requirement\n    return zero_count / non_zero_count", "matching_cluster_idx": 3}, {"solution": "def zero_count(arr):\n    zeros = sum(1 for num in arr if num == 0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # or handle as needed\n    ratio = zeros / non_zeros\n    return ratio", "matching_cluster_idx": 4}, {"solution": "def zero_count(arr):\n    if not arr:  # If the array is empty, return 0\n        return 0.0\n\n    zero_count = 0\n    non_zero_count = 0\n\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n\n    if non_zero_count == 0:\n        return float('inf')  # or handle as needed\n\n    ratio = zero_count / non_zero_count\n    return ratio", "matching_cluster_idx": 3}, {"solution": "def zero_count(arr):\n    zeros = sum(1 for x in arr if x == 0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # or handle as needed\n    return zeros / non_zeros", "matching_cluster_idx": 4}, {"solution": "def zero_count(numbers):\n    zero_count = 0\n    non_zero_count = 0\n    for num in numbers:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    if non_zero_count == 0:\n        return float('inf')  # or handle as per requirement\n    return zero_count / non_zero_count", "matching_cluster_idx": 3}, {"solution": "def zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # or handle as per requirements\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "def zero_count(arr):\n    num_zeros = 0\n    num_non_zeros = 0\n    for num in arr:\n        if num == 0:\n            num_zeros += 1\n        else:\n            num_non_zeros += 1\n    if num_non_zeros == 0:\n        return float('inf')\n    ratio = num_zeros / num_non_zeros\n    return ratio", "matching_cluster_idx": 3}, {"solution": "def zero_count(arr):\n    if not arr:\n        return 0.0  # or any appropriate value or exception for division by zero\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    ratio = zero_count / non_zero_count if non_zero_count != 0 else float('inf')\n    return ratio", "matching_cluster_idx": 6}, {"solution": "def zero_count(numbers):\n    total_zeros = 0\n    total_non_zeros = 0\n    for num in numbers:\n        if num == 0:\n            total_zeros += 1\n        else:\n            total_non_zeros += 1\n    if total_non_zeros == 0:\n        return float('inf')  # or handle as needed\n    return total_zeros / total_non_zeros", "matching_cluster_idx": 3}]}, "Mbpp/140": {"dps": 64.5807453416149, "dps_norm": 80.0, "pass@1": 99.0, "profiled": [{"solution": "def extract_singly(tuples_list):\n    \"\"\"\n    Flattens a list of tuples into a single set of unique numbers.\n\n    Args:\n    tuples_list: A list of tuples containing numbers.\n\n    Returns:\n    A set containing all unique numbers from the tuples.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    result_set = set()\n    for tup in tuples_list:\n        result_set.update(tup)\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Flatten a list of tuples into a single set of numbers.\n\n    Args:\n    list_of_tuples (list of tuples): A list containing tuples of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the tuples.\n    \"\"\"\n    result_set = set()\n    for tup in list_of_tuples:\n        result_set.update(tup)\n    return result_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Flattens a list of tuples into a single set of unique numbers.\n    \n    Args:\n    list_of_tuples (list of tuples): A list containing tuples of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the tuples.\n    \"\"\"\n    result_set = set()\n    for tup in list_of_tuples:\n        result_set.update(tup)\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Flattens a list of tuples into a single set of unique numbers.\n    \n    Args:\n    list_of_tuples (list of tuples): A list containing tuples of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the tuples.\n    \"\"\"\n    # Initialize an empty set to store unique elements\n    unique_numbers = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Update the set with elements from the current tuple\n        unique_numbers.update(tup)\n    \n    return unique_numbers", "matching_cluster_idx": 7}, {"solution": "def extract_singly(lists):\n    \"\"\"\n    Flatten a list of tuples into a single set containing all unique elements.\n\n    Args:\n    lists (list of tuples): A list where each element is a tuple containing integers.\n\n    Returns:\n    set: A set containing all unique integers from the tuples in the list.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    # Initialize an empty set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each tuple in the list\n    for tup in lists:\n        # Update the set with elements from the current tuple\n        unique_elements.update(tup)\n    \n    return unique_elements", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    result_set = set()\n    for lst in list_of_lists:\n        for item in lst:\n            result_set.add(item)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(tuples_list):\n    \"\"\"\n    Function to flatten a list of tuples into a single set of unique numbers.\n    \n    Args:\n    tuples_list: A list of tuples containing integers.\n    \n    Returns:\n    A set containing all unique integers from the tuples.\n    \"\"\"\n    # Flatten the list of tuples into a single list\n    flattened_list = [num for tup in tuples_list for num in tup]\n    \n    # Convert the flattened list to a set to remove duplicates\n    unique_set = set(flattened_list)\n    \n    return unique_set", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lists):\n    \"\"\"\n    Flatten a list of tuples into a set containing all unique elements.\n\n    Args:\n    lists: A list of tuples, where each tuple contains integers.\n\n    Returns:\n    A set containing all unique integers from the tuples.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    # Initialize an empty set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each tuple in the list\n    for tup in lists:\n        # Update the set with elements from the current tuple\n        unique_elements.update(tup)\n    \n    return unique_elements", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Flatten a list of tuples into a single set containing all unique elements.\n\n    Args:\n    list_of_tuples (list of tuples): A list containing tuples of elements.\n\n    Returns:\n    set: A set containing all unique elements from the tuples.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    result_set = set()\n    for t in list_of_tuples:\n        result_set.update(t)\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(lists):\n    result = set()\n    for lst in lists:\n        for item in lst:\n            result.add(item)\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_singly(lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n    lists: A list of lists containing integers.\n\n    Returns:\n    A set containing all unique integers from the lists.\n    \"\"\"\n    result_set = set()\n    for sublist in lists:\n        for item in sublist:\n            result_set.add(item)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    result_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            result_set.add(item)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a set containing all unique elements.\n    \n    Args:\n    list_of_lists (list of lists): A list containing sublists of elements.\n    \n    Returns:\n    set: A set containing all unique elements from the sublists.\n    \"\"\"\n    # Initialize an empty set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Update the set with elements from the current sublist\n        unique_elements.update(sublist)\n    \n    return unique_elements", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Flattens a list of tuples into a single set of unique numbers.\n\n    Parameters:\n    - list_of_tuples: A list containing tuples of integers.\n\n    Returns:\n    - A set containing all unique integers from the tuples.\n    \"\"\"\n    result_set = set()\n    for tup in list_of_tuples:\n        result_set.update(tup)\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(tuples_list):\n    \"\"\"\n    Flatten a list of tuples into a set containing all unique elements.\n\n    Args:\n    tuples_list: A list of tuples containing elements.\n\n    Returns:\n    A set containing all unique elements from the tuples.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    unique_elements = set()\n    for tup in tuples_list:\n        unique_elements.update(tup)\n    return unique_elements", "matching_cluster_idx": 7}, {"solution": "def extract_singly(tuples_list):\n    result_set = set()\n    for tup in tuples_list:\n        for item in tup:\n            result_set.add(item)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Flatten a list of tuples into a single set of unique numbers.\n\n    Args:\n    list_of_tuples (list of tuples): A list containing tuples of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the tuples.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    result_set = set()\n    for tup in list_of_tuples:\n        result_set.update(tup)\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n\n    Args:\n    list_of_lists (list of list of int): A list containing sublists of integers.\n\n    Returns:\n    set: A set containing all unique integers from the sublists.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    result_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            result_set.add(item)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list of list of int): A list containing sublists of integers.\n    \n    Returns:\n    set: A set containing all unique integers from the sublists.\n    \"\"\"\n    result_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            result_set.add(item)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Parameters:\n    lists (list of lists): The input list containing sublists of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    result_set = set()\n    for sublist in lists:\n        result_set.update(sublist)\n    return result_set", "matching_cluster_idx": 6}]}, "Mbpp/141": {"dps": 82.38095238095238, "dps_norm": 45.625, "pass@1": 75.0, "profiled": [{"solution": "def pancake_sort(arr):\n    def flip(sublist, k):\n        sublist[:k] = sublist[:k][::-1]\n    \n    def find_max_index(sublist, n):\n        max_index = 0\n        for i in range(1, n):\n            if sublist[i] > sublist[max_index]:\n                max_index = i\n        return max_index\n    \n    cur_size = len(arr)\n    while cur_size > 1:\n        max_index = find_max_index(arr, cur_size)\n        if max_index != cur_size - 1:\n            flip(arr, max_index + 1)\n            flip(arr, cur_size)\n        cur_size -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    curr = n\n    while curr > 1:\n        # Find the index of the maximum element in arr[0 to curr-1]\n        mi = arr.index(max(arr[0:curr]))\n        if mi != curr - 1:\n            # Reverse the array up to index mi\n            arr = arr[mi::-1] + arr[mi+1:]\n            # Reverse the entire array to move the maximum to its correct position\n            arr = arr[curr-1::-1] + arr[curr:]\n        curr -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    current_size = n\n    while current_size > 1:\n        # Find the index of the maximum element in arr[0 to current_size-1]\n        mi = arr.index(max(arr[0:current_size]))\n        \n        if mi != current_size - 1:\n            # Reverse the array from 0 to mi\n            arr = arr[mi::-1] + arr[mi+1:]\n            # Reverse the entire array to move the maximum element to its correct position\n            arr = arr[current_size-1::-1] + arr[current_size:]\n        current_size -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the pancake sorting algorithm.\n    \n    Pancake sorting is the colloquial term for the mathematical problem of sorting a disordered stack of pancakes in order of size when a spatula can be inserted at any point in the stack and used to flip all pancakes above it. A pancake number is the minimum number of flips required for a given number of pancakes. In this case, the function sorts an array of integers in ascending order.\n    \n    Parameters:\n    arr (list): A list of integers to be sorted.\n    \n    Returns:\n    list: The sorted list of integers.\n    \"\"\"\n    n = len(arr)\n    \n    while n > 1:\n        # Find the index of the maximum element in arr[0:n]\n        max_idx = arr.index(max(arr[0:n]))\n        \n        if max_idx != n - 1:\n            # Flip the array from 0 to max_idx\n            arr[:max_idx+1] = reversed(arr[:max_idx+1])\n            # Flip the entire array from 0 to n-1\n            arr[:n] = reversed(arr[:n])\n        \n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort a list of elements using the Pancake Sort algorithm.\n\n    Pancake sorting is the colloquial term for the mathematical problem of sorting a disordered stack of pancakes in order of size when a spatula can be inserted at any point in the stack and used to flip all pancakes above it. A pancake number is the minimum number of flips required for a given number of pancakes. The problem was first discussed by American geometer Jacob E. Goodman.\n\n    Arguments:\n    arr -- list of elements to be sorted\n\n    Returns:\n    arr -- sorted list of elements\n    \"\"\"\n\n    n = len(arr)\n\n    while n > 1:\n        # Find the index of the maximum element in arr[0 to n-1]\n        max_idx = arr.index(max(arr[0:n]))\n\n        # Move the maximum element to end of current array if it's not already at the end\n        if max_idx != n - 1:\n            # Flip the array from 0 to max_idx\n            arr[:max_idx+1] = reversed(arr[:max_idx+1])\n            # Flip the entire array from 0 to n-1\n            arr[:n] = reversed(arr[:n])\n\n        # Reduce the current array size by one\n        n -= 1\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort a list using the pancake sorting algorithm.\n    \n    Pancake sorting is the colloquial term for the mathematical problem of sorting a disordered stack of pancakes in order of size when a spatula can be inserted at any point in the stack and used to flip all pancakes above it. A pancake number is the minimum number of flips required for a given number of pancakes. In this function, we sort an array of integers in ascending order using the pancake sorting algorithm.\n    \n    Parameters:\n    arr (list): The list of integers to be sorted.\n    \n    Returns:\n    list: The sorted list of integers.\n    \"\"\"\n    n = len(arr)\n    \n    while n > 1:\n        # Find the index of the maximum element in arr[0:n]\n        max_idx = arr.index(max(arr[0:n]))\n        \n        if max_idx != n - 1:\n            # Flip the array from 0 to max_idx\n            arr = arr[:max_idx+1][::-1] + arr[max_idx+1:]\n            # Flip the entire array from 0 to n-1\n            arr = arr[:n][::-1] + arr[n:]\n        \n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    cur = n\n    while cur > 1:\n        # Find the index of the maximum element in arr[0:cur]\n        idx = arr.index(max(arr[0:cur]))\n        # Reverse the elements from 0 to idx\n        arr = arr[idx::-1] + arr[idx+1:n]\n        # Reverse the entire array to move the maximum element to its correct position\n        arr = arr[cur-1::-1] + arr[cur:n]\n        cur -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Perform pancake sort on a list of integers.\n\n    Pancake sorting is the colloquial term for the mathematical problem of sorting a disordered stack of pancakes in order of size when a spatula can be inserted at any point in the stack and used to flip all pancakes above it. A pancake number is the minimum number of flips required for a given number of pancakes. In this code, we sort the array in ascending order using the pancake sort algorithm.\n\n    :param arr: List of integers to be sorted.\n    :return: Sorted list of integers.\n    \"\"\"\n\n    def flip(sublist, k):\n        \"\"\"\n        Reverse the order of the first k elements in the sublist.\n\n        :param sublist: The list to be modified.\n        :param k: The number of elements from the start to flip.\n        \"\"\"\n        sublist[:k] = sublist[:k][::-1]\n\n    def find_max_index(sublist, n):\n        \"\"\"\n        Find the index of the maximum element in sublist up to index n.\n\n        :param sublist: The list to search.\n        :param n: The number of elements to consider from the start of the list.\n        :return: Index of the maximum element.\n        \"\"\"\n        return max(range(n), key=sublist.__getitem__)\n\n    cur_size = len(arr)\n    while cur_size > 1:\n        # Find index of the maximum element in arr[0..cur_size-1]\n        max_index = find_max_index(arr, cur_size)\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if max_index != cur_size - 1:\n            # Flip the array up to the max element\n            flip(arr, max_index + 1)\n            # Flip the entire array to move the max element to the end\n            flip(arr, cur_size)\n        \n        # Reduce the current size of the array\n        cur_size -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort a list of elements using the pancake sorting algorithm.\n\n    Parameters:\n    arr (List[int]): A list of integers to be sorted.\n\n    Returns:\n    List[int]: The sorted list of integers.\n    \"\"\"\n\n    def flip(sub_arr, i):\n        \"\"\"\n        Reverses the first i elements of the sub_arr.\n\n        Parameters:\n        sub_arr (List[int]): The list to flip.\n        i (int): The index up to which to flip the list.\n\n        Returns:\n        List[int]: The list with the first i elements flipped.\n        \"\"\"\n        start = 0\n        while start < i:\n            sub_arr[start], sub_arr[i - 1] = sub_arr[i - 1], sub_arr[start]\n            start += 1\n            i -= 1\n        return sub_arr\n\n    n = len(arr)\n\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_index = 0\n        for i in range(1, curr_size):\n            if arr[i] > arr[max_index]:\n                max_index = i\n\n        # Move the maximum element to the end of the current array if it's not already there\n        if max_index != curr_size - 1:\n            # Flip the array up to the max_index\n            arr = flip(arr, max_index + 1)\n            # Flip the entire array to move the max element to the end\n            arr = flip(arr, curr_size)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(sublist, k):\n        i = 0\n        while i < k / 2:\n            sublist[i], sublist[k - i - 1] = sublist[k - i - 1], sublist[i]\n            i += 1\n    cursor = len(arr)\n    while cursor > 0:\n        # Find the index of the maximum element in arr[0:cursor]\n        idx_max = arr.index(max(arr[0:cursor]))\n        if idx_max != cursor - 1:\n            # Flip the array from 0 to idx_max\n            flip(arr, idx_max + 1)\n            # Flip the entire array to move the maximum element to the end\n            flip(arr, cursor)\n        cursor -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(sublist, k):\n        i = 0\n        while i < k / 2:\n            sublist[i], sublist[k - i - 1] = sublist[k - i - 1], sublist[i]\n            i += 1\n    n = len(arr)\n    while n > 1:\n        max_index = arr.index(max(arr[0:n]))\n        flip(arr, max_index + 1)\n        flip(arr, n)\n        n -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    current = n\n    while current > 1:\n        # Find the index of the maximum element in arr[0 to current-1]\n        mi = arr.index(max(arr[0:current]))\n        \n        if mi != current - 1:\n            # Reverse the array from 0 to mi\n            arr = arr[mi::-1] + arr[mi+1:]\n            # Reverse the entire array to move the maximum element to its correct position\n            arr = arr[current-1::-1] + arr[current:]\n        \n        current -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    curr = n\n    while curr > 1:\n        # Find the index of the maximum element in arr[0 to curr-1]\n        mi = arr.index(max(arr[0:curr]))\n        if mi != curr - 1:\n            # Reverse the array up to index mi\n            arr[0:mi+1] = reversed(arr[0:mi+1])\n            # Reverse the entire array up to index curr\n            arr[0:curr] = reversed(arr[0:curr])\n        curr -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Perform pancake sort on a list of integers.\n\n    Pancake sorting is the colloquial term for the mathematical problem of sorting a disordered stack of pancakes in order of size when a spatula can be inserted at any point in the stack and used to flip all pancakes above it. A pancake number is the minimum number of flips required for a given number of pancakes. In this code, we sort the array in ascending order using the pancake sort algorithm.\n\n    Parameters:\n    arr (list): The list of integers to be sorted.\n\n    Returns:\n    list: The sorted list of integers.\n    \"\"\"\n    def flip(sublist, k):\n        \"\"\"\n        Flip the sublist from index 0 to k-1.\n\n        Parameters:\n        sublist (list): The list to flip.\n        k (int): The number of elements from the start to flip.\n        \"\"\"\n        sublist[:k] = sublist[:k][::-1]\n\n    def find_max_index(sublist, n):\n        \"\"\"\n        Find the index of the maximum element in sublist up to index n.\n\n        Parameters:\n        sublist (list): The list to search.\n        n (int): The number of elements to consider from the start of the list.\n\n        Returns:\n        int: The index of the maximum element.\n        \"\"\"\n        return max(range(n), key=sublist.__getitem__)\n\n    cur_size = len(arr)\n    while cur_size > 1:\n        # Find index of the maximum element in arr[0..cur_size-1]\n        max_index = find_max_index(arr, cur_size)\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if max_index != cur_size - 1:\n            # Flip the array from 0 to max_index\n            flip(arr, max_index + 1)\n            # Flip the entire array to move the max element to the end\n            flip(arr, cur_size)\n        \n        # Reduce the current size of the array\n        cur_size -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    current = n\n    while current > 1:\n        # Find the index of the maximum element in arr[0 to current-1]\n        max_index = arr.index(max(arr[0:current]))\n        \n        # Flip the array from 0 to max_index, so that the maximum element goes to the first position\n        arr = arr[max_index::-1] + arr[max_index+1:n]\n        \n        # Flip the array from 0 to current-1, so that the maximum element goes to its correct position\n        arr = arr[current-1::-1] + arr[current:n]\n        \n        # Decrease current by 1, since the largest element is now at its correct position\n        current -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the pancake sorting algorithm.\n\n    Pancake sorting is the colloquial term for the mathematical problem of sorting a disordered stack of pancakes in order of size when a spatula can be inserted at any point in the stack and used to flip all pancakes above it. A pancake number is the minimum number of flips required for a given number of pancakes. In this case, the function sorts an array of integers in ascending order using flips.\n\n    Parameters:\n    arr (list): The list of integers to be sorted.\n\n    Returns:\n    list: The sorted list of integers.\n\n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    n = len(arr)\n\n    # Helper function to flip the array up to a given index\n    def flip(k):\n        arr[:k+1] = arr[:k+1][::-1]\n\n    # Perform pancake sort\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:size]\n        max_index = arr.index(max(arr[0:size]))\n        if max_index != size - 1:\n            # Flip the array from 0 to max_index\n            flip(max_index)\n            # Flip the entire array up to size - 1\n            flip(size - 1)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the pancake sorting algorithm.\n\n    Pancake sorting is the colloquial term for the mathematical problem of sorting a disordered stack of pancakes in order of size when a spatula can be inserted at any point in the stack and used to flip all pancakes above it. A pancake number is the minimum number of flips required for a given number of pancakes. In this case, the function sorts an array of integers in ascending order.\n\n    Parameters:\n    arr (list): The list of integers to be sorted.\n\n    Returns:\n    list: The sorted list of integers.\n    \"\"\"\n    n = len(arr)\n\n    # Helper function to flip the array up to a given index\n    def flip(sublist, end):\n        start = 0\n        while start < end:\n            sublist[start], sublist[end] = sublist[end], sublist[start]\n            start += 1\n            end -= 1\n\n    # Start with the entire array\n    curr_size = n\n    while curr_size > 1:\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        mi = arr.index(max(arr[0:curr_size]))\n\n        # Move the maximum element to the end of the current array if it's not already at the end\n        if mi != curr_size - 1:\n            # Flip the array from 0 to mi\n            flip(arr, mi)\n            # Flip the entire array to move the maximum element to the end\n            flip(arr, curr_size - 1)\n        # Reduce the current size of the array\n        curr_size -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the pancake sorting algorithm.\n    \n    Pancake sorting is the colloquial term for the mathematical problem of sorting a disordered stack of pancakes in order of size when a spatula can be inserted at any point in the stack and used to flip all pancakes above it. A pancake number is the minimum number of flips required for a given number of pancakes. In this case, the function sorts an array of integers in ascending order using flips.\n    \n    Parameters:\n    arr (list): The list of integers to be sorted.\n    \n    Returns:\n    list: The sorted list of integers.\n    \"\"\"\n    def flip(sublist, k):\n        \"\"\"\n        Reverses the order of the first k elements in the sublist.\n        \n        Parameters:\n        sublist (list): The list to be modified.\n        k (int): The number of elements from the start to flip.\n        \"\"\"\n        sublist[:k] = sublist[:k][::-1]\n    \n    n = len(arr)\n    \n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_index = arr.index(max(arr[0:curr_size]))\n        \n        # Move the maximum element to the end of the current sublist if it's not already there\n        if max_index != curr_size - 1:\n            # Flip the list from 0 to max_index, so that the max element is at the beginning\n            flip(arr, max_index + 1)\n            # Flip the entire sublist, so the max element is at the end\n            flip(arr, curr_size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(sublist, k):\n        i = 0\n        while i < k / 2:\n            sublist[i], sublist[k - i - 1] = sublist[k - i - 1], sublist[i]\n            i += 1\n    cursor = len(arr)\n    while cursor > 1:\n        # Find the index of the maximum element in arr[0:cursor]\n        max_index = 0\n        for i in range(1, cursor):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        # Move the maximum element to the top of the sublist arr[0:cursor]\n        if max_index != 0:\n            flip(arr, max_index + 1)\n        # Move the maximum element to its correct position at the bottom of the sublist\n        flip(arr, cursor)\n        # Reduce the size of the current sublist\n        cursor -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(sublist, k):\n        i = 0\n        while i < k / 2:\n            sublist[i], sublist[k - i - 1] = sublist[k - i - 1], sublist[i]\n            i += 1\n    n = len(arr)\n    for size in range(n, 1, -1):\n        max_index = arr.index(max(arr[:size]))\n        if max_index + 1 < size:\n            if max_index != 0:\n                flip(arr, max_index + 1)\n            flip(arr, size)\n    return arr", "matching_cluster_idx": 2}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_result = nums[i] ^ nums[j]\n            if xor_result % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Count the number of pairs of integers in the list that XOR to an even number.\n\n    Parameters:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The number of pairs that XOR to an even number.\n    \"\"\"\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Count the number of pairs of integers in the list that XOR to an even number.\n\n    Parameters:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The number of pairs that XOR to an even number.\n    \"\"\"\n    even_pairs = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_pairs += 1\n    return even_pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_pairs = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_pairs += 1\n    return even_pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    This function counts the number of pairs of integers in a list that xor to an even number.\n    \n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    \n    :param nums: List of integers\n    :return: Number of pairs that XOR to an even number\n    \"\"\"\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Count the number of pairs of integers in the list that XOR to an even number.\n\n    :param nums: List of integers.\n    :return: Integer representing the count of pairs that XOR to an even number.\n    \"\"\"\n    even_pairs = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_pairs += 1\n    return even_pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_result = nums[i] ^ nums[j]\n            if xor_result % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    even_pairs = 0\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_result = numbers[i] ^ numbers[j]\n            if xor_result % 2 == 0:\n                even_pairs += 1\n    return even_pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_pairs = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_pairs += 1\n    return even_pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_result = nums[i] ^ nums[j]\n            if xor_result % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 95.18115942028986, "dps_norm": 96.875, "pass@1": 47.0, "profiled": [{"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list within the range specified by start and end indices.\n\n    :param lst: List of integers.\n    :param start: Starting index of the range.\n    :param end: Ending index of the range.\n    :return: Sum of the numbers within the specified range.\n    \"\"\"\n    if not lst or start < 0 or end >= len(lst) or start > end:\n        return 0\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list within the range specified by start and end indices.\n\n    Args:\n    lst (list of int): The list of numbers.\n    start (int): The starting index of the range.\n    end (int): The ending index of the range.\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n\n    \"\"\"\n    # Ensure that the start and end indices are within the bounds of the list\n    if start < 0:\n        start = 0\n    if end >= len(lst):\n        end = len(lst) - 1\n\n    # Calculate the sum of the sublist from start to end (inclusive)\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    if not 0 <= start <= end < len(lst):\n        return 0\n    return sum(lst[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list within the range specified by start and end indices.\n    \n    Parameters:\n    - lst: List of numbers.\n    - start: Starting index of the range.\n    - end: Ending index of the range.\n    \n    Returns:\n    - The sum of the numbers within the specified range.\n    \"\"\"\n    if not lst or start < 0 or end >= len(lst) or start > end:\n        return 0\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Ensure the list is not empty and indices are within range\n    if not lst or start < 0 or end >= len(lst) or start > end:\n        return 0\n    # Calculate the sum of the specified range\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list within a range specified by two indices.\n    \n    :param lst: List of numbers.\n    :param start: Starting index of the range.\n    :param end: Ending index of the range.\n    :return: Sum of the numbers within the specified range.\n    \"\"\"\n    if not lst or start < 0 or end >= len(lst) or start > end:\n        return 0\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    if not numbers or start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n        return 0\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list from index start to end, inclusive.\n    \n    :param numbers: List of numbers.\n    :param start: Starting index for the sum range.\n    :param end: Ending index for the sum range.\n    :return: Sum of numbers within the specified range.\n    \"\"\"\n    if not numbers:\n        return 0\n    if start < 0 or end >= len(numbers):\n        raise IndexError(\"Start or end index out of bounds.\")\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n\n    Args:\n    numbers (list): A list of numbers.\n    start_index (int): The starting index of the range.\n    end_index (int): The ending index of the range.\n\n    Returns:\n    int: The sum of numbers within the specified range.\n\n    Raises:\n    IndexError: If start_index or end_index are out of bounds of the list.\n    ValueError: If numbers is not a list or contains non-numeric values.\n    TypeError: If start_index or end_index are not integers.\n    \"\"\"\n\n    # Validate input types\n    if not isinstance(numbers, list):\n        raise ValueError(\"numbers must be a list\")\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise ValueError(\"all elements in numbers must be numeric\")\n    if not isinstance(start_index, int) or not isinstance(end_index, int):\n        raise TypeError(\"start_index and end_index must be integers\")\n\n    # Validate index ranges\n    if start_index < 0 or end_index >= len(numbers):\n        raise IndexError(\"start_index or end_index out of bounds\")\n\n    # Calculate sum within range\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 2}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within the range specified by start_index and end_index (inclusive).\n    \n    :param numbers: List of numbers.\n    :param start_index: The starting index of the range.\n    :param end_index: The ending index of the range.\n    :return: The sum of numbers within the specified range.\n    \"\"\"\n    if not numbers or start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n        return 0\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list from start_index to end_index inclusive.\n\n    Args:\n    numbers (list of int): The list of numbers.\n    start_index (int): The starting index of the range.\n    end_index (int): The ending index of the range.\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    if not numbers or start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n        return 0\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n    \n    Args:\n    numbers: List of numbers.\n    start: Starting index of the range.\n    end: Ending index of the range.\n    \n    Returns:\n    The sum of numbers within the specified range.\n    \"\"\"\n    if not numbers or start < 0 or end >= len(numbers) or start > end:\n        return 0\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list from index start to end, inclusive.\n\n    Args:\n    numbers (list of int): The list of numbers.\n    start (int): The starting index of the range.\n    end (int): The ending index of the range.\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    # Ensure that start and end are within the bounds of the list\n    if start < 0 or end >= len(numbers):\n        raise IndexError(\"Start or end index out of range\")\n\n    # Calculate the sum of the specified range\n    total = sum(numbers[start:end+1])\n    return total", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list within the range specified by start and end indices.\n    \n    :param lst: List of integers.\n    :param start: Starting index of the range.\n    :param end: Ending index of the range.\n    :return: Sum of the numbers within the specified range.\n    \"\"\"\n    if not lst or start < 0 or end >= len(lst) or start > end:\n        return 0\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list from index 'start' to 'end' inclusive.\n    \n    Parameters:\n    numbers (list): A list of numbers.\n    start (int): The starting index of the range.\n    end (int): The ending index of the range.\n    \n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    if not numbers or start < 0 or end >= len(numbers) or start > end:\n        return 0\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list from start_index to end_index inclusive.\n\n    :param numbers: List of numbers.\n    :param start_index: Starting index for the sum range.\n    :param end_index: Ending index for the sum range.\n    :return: Sum of the numbers within the specified range.\n    \"\"\"\n    if not numbers or start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n        return 0\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list within the range specified by start and end indices.\n    \n    Args:\n    nums (list): The list of numbers.\n    start (int): The starting index of the range.\n    end (int): The ending index of the range.\n    \n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    if not nums or start < 0 or end >= len(nums) or start > end:\n        return 0\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list within the range specified by start and end indices.\n\n    Args:\n    lst (list of int): The list of integers.\n    start (int): The starting index of the range.\n    end (int): The ending index of the range.\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n\n    Example:\n    >>> sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 8, 10)\n    29\n    \"\"\"\n    if not lst or start < 0 or end >= len(lst) or start > end:\n        return 0\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    if not lst or start < 0 or end >= len(lst) or start > end:\n        return 0\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    if not numbers or start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n        return 0\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 87.82945736434108, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters at odd indices from a given string.\n\n    Parameters:\n    input_string (str): The string from which to remove characters.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate over the string, considering only even indices\n    for index in range(len(input_string)):\n        if index % 2 == 0:\n            result += input_string[index]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters which have odd index values from a given string.\n    \n    Parameters:\n    s (str): The input string from which odd-indexed characters will be removed.\n    \n    Returns:\n    str: A string with characters at odd indices removed.\n    \"\"\"\n    # Using string slicing to remove characters at odd indices\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to store characters at even indices\n    result = ''\n    # Iterate over the string using index\n    for index in range(len(input_string)):\n        # Check if the index is even\n        if index % 2 == 0:\n            # Append the character at the even index to the result\n            result += input_string[index]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result = result + str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters at odd indices from a given string.\n\n    Parameters:\n    s (str): The input string from which characters at odd indices will be removed.\n\n    Returns:\n    str: A string with characters at odd indices removed.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate over the string using enumerate to keep track of indices\n    for index, char in enumerate(s):\n        # Check if the index is even\n        if index % 2 == 0:\n            # Append the character to the result string\n            result += char\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Select characters at even indices (0-based indexing)\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(str):\n    result = \"\"  \n    for i in range(len(str)):\n        if i % 2 == 0:\n            result = result + str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str_input):\n    return str_input[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters which have odd index values in a given string.\n\n    Parameters:\n    input_string (str): The string from which to remove odd-indexed characters.\n\n    Returns:\n    str: A new string with odd-indexed characters removed.\n    \"\"\"\n    # Initialize an empty result string\n    result = ''\n\n    # Iterate over the string, considering only even indices\n    for index in range(len(input_string)):\n        if index % 2 == 0:\n            result += input_string[index]\n\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def replace_blank(input_string, replacement_char):\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces blank spaces in the string with the specified character.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, char):\n    return text.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, char):\n    # Replace blank spaces with the given character\n    result = text.replace(\" \", char)\n    return result", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string: str, character: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the string with the specified character.\n\n    Parameters:\n    string (str): The input string containing blank spaces.\n    character (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replace_char):\n    return input_string.replace(\" \", replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    Parameters:\n    text (str): The input string to process.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the specified character.\n\n    Example:\n    >>> replace_blank(\"hello people\", \"@\")\n    'hello@people'\n    \"\"\"\n    return text.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, char):\n    return text.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(sentence, char):\n    return sentence.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 57.068965517241374, "dps_norm": 64.5, "pass@1": 31.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    count = 0\n    sequences = []\n    def backtrack(current):\n        nonlocal sequences\n        if len(current) == n:\n            sequences.append(current[:])\n            return\n        if len(current) == 0:\n            start = 1\n        else:\n            start = 2 * current[-1]\n        for i in range(start, m + 1):\n            if len(current) < n:\n                current.append(i)\n                backtrack(current)\n                current.pop()\n    backtrack([])\n    return len(sequences)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of sequences of length n where each element is a positive integer,\n    >= twice the previous element, and <= m.\n    \n    Args:\n    m (int): Maximum value for any element in the sequence.\n    n (int): Length of the sequence.\n    \n    Returns:\n    int: Number of sequences satisfying the conditions.\n    \"\"\"\n    # Initialize a dictionary to store the number of sequences starting with a particular number\n    memo = {}\n    \n    def helper(current, length):\n        # If the sequence has reached the desired length, return 1\n        if length == n:\n            return 1\n        # If the current number doubled is greater than m, no further sequences can be formed\n        if 2 * current > m:\n            return 0\n        # If this subproblem has been solved before, return the stored result\n        if (current, length) in memo:\n            return memo[(current, length)]\n        # Initialize the count for this subproblem\n        count = 0\n        # Try the next number starting from twice the current number up to m\n        for next_num in range(2 * current, m + 1):\n            count += helper(next_num, length + 1)\n        # Store the result in memo\n        memo[(current, length)] = count\n        return count\n    \n    # Start the sequence with numbers from 1 to m\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += helper(start, 1)\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Function to find the number of sequences of length n where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n    \n    Args:\n    m (int): The maximum value that any element in the sequence can take.\n    n (int): The length of the sequence.\n    \n    Returns:\n    int: The number of possible sequences.\n    \"\"\"\n    \n    # Helper function to recursively count sequences\n    def count_sequences(prev, remaining_length):\n        if remaining_length == 0:\n            return 1\n        total = 0\n        # Start from twice the previous value or 1 if prev is 0\n        start = max(1, 2 * prev)\n        # End at m\n        for i in range(start, m + 1):\n            if i > m:\n                break\n            total += count_sequences(i, remaining_length - 1)\n        return total\n    \n    # Start the sequence with previous value as 0 (first element can be from 1 to m)\n    return count_sequences(0, n)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n,\n    where each element is a positive integer >= twice the previous element\n    and <= m.\n\n    :param m: Maximum value for any element in the sequence\n    :param n: Length of the sequence\n    :return: Number of sequences satisfying the conditions\n    \"\"\"\n    from collections import defaultdict\n\n    # Memoization dictionary to store already computed results\n    memo = defaultdict(int)\n\n    def sequences(start, remaining_length):\n        # Base case: if remaining_length is 0, we've formed a valid sequence\n        if remaining_length == 0:\n            return 1\n        # Create a unique key for memoization\n        key = (start, remaining_length)\n        # If result is already computed, return it\n        if key in memo:\n            return memo[key]\n        total = 0\n        # Iterate through possible next elements in the sequence\n        for next_elem in range(start * 2, m + 1):\n            if next_elem > m:\n                break\n            # Recurse with the next element and decrease remaining length\n            total += sequences(next_elem, remaining_length - 1)\n        # Store the computed result in memo\n        memo[key] = total\n        return total\n\n    # Start sequences with the first element ranging from 1 to m\n    result = 0\n    for start in range(1, m + 1):\n        result += sequences(start, n - 1)\n    return result", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    def helper(current, prev):\n        if current == n:\n            return 1\n        count = 0\n        for i in range(2 * prev, m + 1):\n            count += helper(current + 1, i)\n        return count\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += helper(1, i)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def dfs(current, prev):\n        if current == n:\n            return 1\n        count = 0\n        for i in range(2 * prev, m + 1):\n            count += dfs(current + 1, i)\n        return count\n\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += dfs(1, start)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Define a function to calculate the number of sequences recursively\n    def sequences(current_m, length):\n        # Base case: if length is 0, there's one sequence (empty sequence)\n        if length == 0:\n            return 1\n        # Base case: if current_m is 0, no sequences can be formed\n        if current_m == 0:\n            return 0\n        # Calculate the number of sequences by choosing current_m or skipping to smaller values\n        # If we choose current_m, the next element can be from 1 to current_m // 2\n        # If we skip current_m, the next element is from 1 to current_m - 1\n        return sequences(current_m // 2, length - 1) + sequences(current_m - 1, length)\n    \n    # Start from m with sequence length n\n    return sequences(m, n)", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of sequences of length n where each element is a positive integer >= 2*previous and <= m.\n    \"\"\"\n    def helper(current_max, remaining_length):\n        if remaining_length == 0:\n            return 1\n        total = 0\n        for i in range(2 * current_max, m + 1):\n            if i > m:\n                break\n            total += helper(i, remaining_length - 1)\n        return total\n    \n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += helper(start, n - 1)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of sequences of length n where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n    \n    Args:\n    m (int): The maximum value any element in the sequence can take.\n    n (int): The length of the sequence.\n    \n    Returns:\n    int: The number of possible sequences.\n    \"\"\"\n    # Initialize a dictionary to store the number of sequences starting with a particular number\n    start_with = {}\n    \n    # Helper function to calculate the number of sequences starting with a specific number\n    def count_sequences(current, remaining_length):\n        if remaining_length == 0:\n            return 1\n        if (current, remaining_length) in start_with:\n            return start_with[(current, remaining_length)]\n        total = 0\n        # The next number must be at least twice the current number and at most m\n        next_start = 2 * current\n        while next_start <= m:\n            total += count_sequences(next_start, remaining_length - 1)\n            next_start += 1\n        start_with[(current, remaining_length)] = total\n        return total\n    \n    # Start sequences with the first number ranging from 1 to m\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    memo = {}\n\n    def count_sequences(prev, remaining):\n        if remaining == 0:\n            return 1\n        key = (prev, remaining)\n        if key in memo:\n            return memo[key]\n        total = 0\n        start = 2 * prev\n        for next_val in range(start, m + 1):\n            if next_val > m:\n                break\n            total += count_sequences(next_val, remaining - 1)\n        memo[key] = total\n        return total\n\n    result = 0\n    for start in range(1, m + 1):\n        result += count_sequences(start, n - 1)\n    return result", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    def helper(current, prev):\n        if current == n:\n            return 1\n        total = 0\n        for i in range(2 * prev, m + 1):\n            total += helper(current + 1, i)\n        return total\n\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += helper(1, i)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Base cases\n    if m < 1 or n < 1:\n        return 0\n    if n == 1:\n        return m\n\n    # Initialize a list to store the number of sequences ending with each possible value\n    dp = [1] * m  # Initially, there's one sequence of length 1 for each number\n\n    for seq_len in range(2, n + 1):\n        new_dp = [0] * m\n        for last_val in range(m):\n            prev_val_max = (last_val - 1) // 2\n            if prev_val_max >= 0:\n                new_dp[last_val] = sum(dp[:prev_val_max + 1])\n        dp = new_dp\n\n    return sum(dp)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    def dfs(current, prev):\n        if current == n:\n            return 1\n        count = 0\n        for i in range(2 * prev, m + 1):\n            count += dfs(current + 1, i)\n        return count\n\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += dfs(1, start)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Find the number of possible sequences of length n, such that each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n\n    :param m: The maximum value that any element in the sequence can take\n    :param n: The length of the sequence\n    :return: The number of possible sequences satisfying the given conditions\n\n    Approach:\n    1. Use a helper function with memoization to avoid redundant calculations.\n    2. Start building the sequence from the first element and ensure each subsequent element is at least twice the previous one and <= m.\n    3. Use recursion to explore all possible sequences and memoize the results based on the current position and the previous element chosen.\n    \"\"\"\n\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def helper(position, prev):\n        # If we've filled the sequence of length n, return 1 (valid sequence found)\n        if position == n:\n            return 1\n        # Calculate the minimum possible value for the current position\n        min_val = 2 * prev\n        # Initialize a counter for the number of sequences from this point\n        count = 0\n        # Iterate through all possible values that can be placed at the current position\n        for val in range(min_val, m + 1):\n            # Recurse to the next position with the current value as the previous one\n            count += helper(position + 1, val)\n        return count\n\n    # Start the sequence with position 0 and previous value 0\n    # The first element can be any value from 1 to m\n    total_sequences = 0\n    for start_val in range(1, m + 1):\n        total_sequences += helper(1, start_val)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    memo = {}\n    \n    def helper(current, remaining):\n        if remaining == 0:\n            return 1\n        if (current, remaining) in memo:\n            return memo[(current, remaining)]\n        total = 0\n        next_start = 2 * current\n        if next_start > m:\n            return 0\n        for i in range(next_start, m + 1):\n            total += helper(i, remaining - 1)\n        memo[(current, remaining)] = total\n        return total\n    \n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += helper(start, n - 1)\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of sequences of length n where each element is a positive integer >= 2*(previous element)\n    and <= m.\n\n    :param m: The maximum value any element in the sequence can take.\n    :param n: The length of the sequence.\n    :return: The number of such sequences.\n\n    Approach:\n    - Use dynamic programming to build up the number of sequences.\n    - Create a table dp where dp[i][j] represents the number of sequences of length i with j as the last element.\n    - Initialize dp[1][j] = 1 for all j from 1 to m, as sequences of length 1 are just single numbers.\n    - For sequences of length >1, dp[i][j] can be formed by adding j to sequences of length (i-1) where the last element is <= j//2.\n    - Sum up dp[n][j] for all j from 1 to m to get the total number of sequences of length n.\n    \"\"\"\n\n    # Initialize a DP table with zeros, considering 1-based indexing for simplicity\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # For sequences of length 1, every number from 1 to m is a valid sequence\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n\n    # Fill the DP table for sequences of length 2 to n\n    for i in range(2, n + 1):\n        # Prefix sums to speed up the calculation\n        prefix = [0] * (m + 1)\n        prefix[1] = dp[i - 1][1]\n        for j in range(2, m + 1):\n            prefix[j] = prefix[j - 1] + dp[i - 1][j]\n\n        # For each possible last element j in the sequence\n        for j in range(1, m + 1):\n            # The previous element can be at most j // 2\n            prev_max = j // 2\n            if prev_max >= 1:\n                dp[i][j] = prefix[prev_max]\n            else:\n                dp[i][j] = 0\n\n    # Sum up all sequences of length n\n    total_sequences = sum(dp[n])\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    def helper(m, n, prev):\n        if n == 0:\n            return 1\n        total = 0\n        for i in range(2 * prev, m + 1):\n            total += helper(m, n - 1, i)\n        return total\n\n    if m < 1 or n < 1:\n        return 0\n    total = 0\n    for start in range(1, m + 1):\n        total += helper(m, n - 1, start)\n    return total", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n    \n    Args:\n    m (int): The maximum value that any element in the sequence can take.\n    n (int): The length of the sequence.\n    \n    Returns:\n    int: The number of possible sequences.\n    \"\"\"\n    def count_sequences(current, length):\n        if length == n:\n            return 1\n        total = 0\n        next_min = 2 * current\n        if next_min > m:\n            return 0\n        for next_val in range(next_min, m + 1):\n            total += count_sequences(next_val, length + 1)\n        return total\n    \n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, 1)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    total_sequences = 0\n    sequence = [0] * n  # Initialize a list to hold the sequence\n    def generate_sequences(index, prev):\n        nonlocal total_sequences\n        if index == n:\n            total_sequences += 1\n            return\n        start = 1 if index == 0 else 2 * prev\n        for i in range(start, m + 1):\n            if i > m:\n                break\n            sequence[index] = i\n            generate_sequences(index + 1, i)\n    generate_sequences(0, 0)\n    return total_sequences", "matching_cluster_idx": 4}, {"solution": "def get_total_number_of_sequences(m, n):\n    sequences = [[]]\n    for _ in range(n):\n        new_sequences = []\n        for seq in sequences:\n            if not seq:\n                for i in range(1, m+1):\n                    new_sequences.append([i])\n            else:\n                last = seq[-1]\n                for i in range(2*last, m+1):\n                    new_sequences.append(seq + [i])\n        sequences = new_sequences\n    return len(sequences)", "matching_cluster_idx": 2}]}, "Mbpp/240": {"dps": 89.08536585365854, "dps_norm": 93.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def replace_list(lst1, lst2):\n    # Remove the last element from the first list\n    lst1.pop()\n    # Extend the first list with all elements from the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(first_list, second_list):\n    # Remove the last element from the first list\n    first_list.pop()\n    # Extend the first list with all elements from the second list\n    first_list.extend(second_list)\n    return first_list", "matching_cluster_idx": 8}, {"solution": "def replace_list(first_list, second_list):\n    # Remove the last element of the first list\n    first_list.pop()\n    # Extend the first list with all elements of the second list\n    first_list.extend(second_list)\n    return first_list", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    # Remove the last element from list1\n    list1.pop()\n    # Extend list1 with all elements from list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n\n    Args:\n    lst1: List[int] - The first list.\n    lst2: List[int] - The second list.\n\n    Returns:\n    List[int] - The modified list.\n    \"\"\"\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with all elements from lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(first_list, second_list):\n    # Remove the last element of the first list\n    first_list.pop()\n    # Extend the first list with all elements of the second list\n    first_list.extend(second_list)\n    return first_list", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    # Remove the last element of list1\n    list1.pop()\n    # Extend list1 with list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(first_list, second_list):\n    # Remove the last element from the first list\n    first_list.pop()\n    # Extend the first list with all elements from the second list\n    first_list.extend(second_list)\n    return first_list", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of the first list\n    lst1.pop()\n    # Extend the first list with all elements of the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(first_list, second_list):\n    # Remove the last element of the first list\n    first_list.pop()\n    # Extend the first list with all elements of the second list\n    first_list.extend(second_list)\n    return first_list", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Parameters:\n    lst1 (list): The first list.\n    lst2 (list): The second list.\n\n    Returns:\n    list: The modified first list with its last element replaced by the elements of the second list.\n    \"\"\"\n    if not lst1:  # If the first list is empty, return the second list\n        return lst2\n    else:\n        # Remove the last element from the first list and extend it with the second list\n        return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(first_list, second_list):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Parameters:\n    first_list (list): The first list.\n    second_list (list): The second list.\n\n    Returns:\n    list: The modified first list with its last element replaced by the elements of the second list.\n    \"\"\"\n    # Remove the last element from the first list\n    first_list.pop()\n    \n    # Extend the first list with the elements of the second list\n    first_list.extend(second_list)\n    \n    return first_list", "matching_cluster_idx": 8}, {"solution": "def replace_list(first_list, second_list):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Parameters:\n    first_list (list): The first list.\n    second_list (list): The second list.\n\n    Returns:\n    list: The modified first list with its last element replaced by the elements of the second list.\n    \"\"\"\n    if not first_list:\n        return second_list\n    first_list[-1:] = second_list\n    return first_list", "matching_cluster_idx": 7}, {"solution": "def replace_list(first_list, second_list):\n    # Remove the last element from the first list\n    first_list.pop()\n    # Extend the first list with all elements from the second list\n    first_list.extend(second_list)\n    return first_list", "matching_cluster_idx": 8}, {"solution": "def replace_list(first_list, second_list):\n    # Remove the last element from the first list\n    first_list.pop()\n    # Extend the first list with all elements from the second list\n    first_list.extend(second_list)\n    return first_list", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements of list2.\n\n    Parameters:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list with the last element of list1 replaced by all elements of list2.\n    \"\"\"\n    if not list1:  # If list1 is empty, return list2 as is.\n        return list2\n    # Remove the last element from list1 and extend it with list2.\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2  # Replace the last element of list1 with list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(first_list, second_list):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n    first_list (list): The first list.\n    second_list (list): The second list.\n\n    Returns:\n    list: A new list with the last element of the first list replaced by the elements of the second list.\n    \"\"\"\n    # Make a copy of the first list to avoid modifying the original list\n    new_list = first_list[:-1].copy()\n    # Extend the new list with the elements of the second list\n    new_list.extend(second_list)\n    return new_list", "matching_cluster_idx": 4}]}, "Mbpp/251": {"dps": 91.95402298850576, "dps_norm": 77.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Parameters:\n    lst (list): The list to be modified.\n    elem: The element to insert before each element in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Args:\n    lst (list): The original list.\n    element: The element to insert before each element in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    result = []\n    for item in input_list:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(arr, elem):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Parameters:\n    arr (list): The input list.\n    elem: The element to be inserted before each element in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in arr:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Args:\n        lst (list): The original list.\n        elem: The element to insert before each element in the list.\n\n    Returns:\n        list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 60.06849315068493, "dps_norm": 58.529411764705884, "pass@1": 86.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    if n<=2:\n        return 0\n    elif n==3:\n        return 1\n    else:\n        count=1\n        for num in range(3,n,2):\n            for i in range(3,int(num**0.5)+1,2):\n                if (num%i==0):\n                    break\n            else: count+=1\n        return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        prime = True\n        for i in range(2, int(num**0.5)+1):\n            if (num % i == 0):\n                prime = False\n                break\n        if prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        prime = True\n        for i in range(2, int(num ** 0.5) + 1):\n            if (num % i == 0):\n                prime = False\n                break\n        if prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if (num % i == 0):\n                prime = False\n                break\n        if prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        prime = True\n        for i in range(2, int(num ** 0.5) + 1):\n            if (num % i == 0):\n                prime = False\n                break\n        if prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    sieve = [1] * n\n    sieve[0] = sieve[1] = 0\n    for x in range(2, int(n**0.5) + 1):\n        if sieve[x] == 1:\n            for i in range(x*x, n, x):\n                sieve[i] = 0\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if all(i % j != 0 for j in range(2, int(i**0.5)+1)):\n            count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if all(i % j != 0 for j in range(2, int(i**0.5) + 1)):\n            count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def count_Primes_nums(n):\n    \"\"\"Return the count of prime numbers less than the given non-negative integer n.\n\n    A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers.\n    This function uses the Sieve of Eratosthenes algorithm for efficient computation of primes.\n\n    Args:\n        n (int): A non-negative integer.\n\n    Returns:\n        int: The count of prime numbers less than n.\n\n    Examples:\n        >>> count_Primes_nums(5)\n        2\n        >>> count_Primes_nums(10)\n        4\n        >>> count_Primes_nums(0)\n        0\n        >>> count_Primes_nums(1)\n        0\n    \"\"\"\n    if n <= 2:\n        return 0\n    sieve = [1] * n\n    sieve[0] = sieve[1] = 0\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            sieve[i*i:n:i] = [0] * len(sieve[i*i:n:i])\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        prime = True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                prime = False\n                break\n        if prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        prime = True\n        for i in range(2, int(num**0.5)+1):\n            if (num % i == 0):\n                prime = False\n                break\n        if prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    sieve = [1] * n\n    sieve[0] = sieve[1] = 0\n    for i in range(2, int(n**0.5)+1):\n        if sieve[i]:\n            sieve[i*i: n: i] = [0] * len(sieve[i*i: n: i])\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    if n<=2:\n        return 0\n    elif n==3:\n        return 1\n    else:\n        count=1\n        for num in range(3,n):\n            for i in range(2,num):\n                if (num%i)==0:\n                    break\n            else:\n                count+=1\n        return count", "matching_cluster_idx": 1}, {"solution": "def count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if all(i % j != 0 for j in range(2, int(i**0.5)+1)):\n            count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        prime = True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                prime = False\n                break\n        if prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n        \n    primes = [True] * n\n    primes[0] = primes[1] = False\n    i = 2\n    while i*i < n:\n        if primes[i]:\n            j = i*i\n            while j < n:\n                primes[j] = False\n                j += i\n        i += 1\n    return sum(primes)", "matching_cluster_idx": 13}]}, "Mbpp/265": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/281": {"dps": 96.3, "dps_norm": 90.0, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(lst):\n    seen = set()\n    for element in lst:\n        if element in seen:\n            return False\n        seen.add(element)\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(lst):\n    seen = set()\n    for element in lst:\n        if element in seen:\n            return False\n        seen.add(element)\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(lst):\n    seen = set()\n    for elem in lst:\n        if elem in seen:\n            return False\n        seen.add(elem)\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Use a set to track unique elements\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    # Use a set to store seen elements\n    seen = set()\n    for element in lst:\n        if element in seen:\n            return False\n        seen.add(element)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    seen = set()\n    for element in lst:\n        if element in seen:\n            return False\n        seen.add(element)\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n    lst: list of elements\n\n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    seen = set()\n    for element in lst:\n        if element in seen:\n            return False\n        seen.add(element)\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Using a set to track unique elements\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 46.41025641025641, "dps_norm": 72.5, "pass@1": 100.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr, temp, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += merge_sort(arr, temp, left, mid)\n            inv_count += merge_sort(arr, temp, mid + 1, right)\n            inv_count += merge(arr, temp, left, mid + 1, right)\n        return inv_count\n\n    def merge(arr, temp, left, mid, right):\n        i = left\n        j = mid\n        k = left\n        inv_count = 0\n        while i <= mid - 1 and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                k += 1\n                i += 1\n            else:\n                temp[k] = arr[j]\n                inv_count += (mid - i)\n                k += 1\n                j += 1\n        while i <= mid - 1:\n            temp[k] = arr[i]\n            k += 1\n            i += 1\n        while j <= right:\n            temp[k] = arr[j]\n            k += 1\n            j += 1\n        for i in range(left, right + 1):\n            arr[i] = temp[i]\n        return inv_count\n\n    n = len(arr)\n    temp = [0] * n\n    return merge_sort(arr, temp, 0, n - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inversion_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    def merge_count_split_inv(left, right):\n        i, j, inv_count = 0, 0, 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_count += len(left) - i  # All remaining elements in left are inversions\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n\n    def sort_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, left_inv = sort_count(arr[:mid])\n        right, right_inv = sort_count(arr[mid:])\n        merged, split_inv = merge_count_split_inv(left, right)\n        total_inv = left_inv + right_inv + split_inv\n        return merged, total_inv\n\n    _, total_inversions = sort_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    def merge_count_split_inv(left, right):\n        i, j, inv_count = 0, 0, 0\n        result = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i  # All remaining elements in left are inversions with right[j]\n        result += left[i:]\n        result += right[j:]\n        return result, inv_count\n\n    def sort_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, left_inv = sort_count(arr[:mid])\n        right, right_inv = sort_count(arr[mid:])\n        merged, split_inv = merge_count_split_inv(left, right)\n        total_inv = left_inv + right_inv + split_inv\n        return merged, total_inv\n\n    _, total_inv = sort_count(arr)\n    return total_inv", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_and_count_split_inv(left, right):\n        i, j, inv_count = 0, 0, 0\n        result = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i  # All remaining elements in left are inversions with right[j]\n        result += left[i:]\n        result += right[j:]\n        return result, inv_count\n\n    def sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, left_inv = sort_and_count(arr[:mid])\n        right, right_inv = sort_and_count(arr[mid:])\n        merged, split_inv = merge_and_count_split_inv(left, right)\n        total_inv = left_inv + right_inv + split_inv\n        return merged, total_inv\n\n    _, total_inversions = sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr, temp, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += merge_sort(arr, temp, left, mid)\n            inv_count += merge_sort(arr, temp, mid + 1, right)\n            inv_count += merge(arr, temp, left, mid + 1, right)\n        return inv_count\n\n    def merge(arr, temp, left, mid, right):\n        i = left\n        j = mid\n        k = left\n        inv_count = 0\n\n        while i <= mid - 1 and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                k += 1\n                i += 1\n            else:\n                temp[k] = arr[j]\n                inv_count += (mid - i)\n                k += 1\n                j += 1\n\n        while i <= mid - 1:\n            temp[k] = arr[i]\n            k += 1\n            i += 1\n\n        while j <= right:\n            temp[k] = arr[j]\n            k += 1\n            j += 1\n\n        for i in range(left, right + 1):\n            arr[i] = temp[i]\n\n        return inv_count\n\n    n = len(arr)\n    temp = [0] * n\n    return merge_sort(arr, temp, 0, n - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    def merge_and_count_split_inv(left, right):\n        i, j, inv_count = 0, 0, 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_count += len(left) - i  # All remaining elements in left are inversions with right[j]\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n\n    def sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, left_inv = sort_and_count(arr[:mid])\n        right, right_inv = sort_and_count(arr[mid:])\n        merged, split_inv = merge_and_count_split_inv(left, right)\n        total_inv = left_inv + right_inv + split_inv\n        return merged, total_inv\n\n    _, total_inversions = sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    def merge_count_split_inv(left, right):\n        i, j, inv_count = 0, 0, 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_count += len(left) - i  # All remaining elements in left are inversions with right[j]\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n\n    def sort_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, left_inv = sort_count(arr[:mid])\n        right, right_inv = sort_count(arr[mid:])\n        merged, split_inv = merge_count_split_inv(left, right)\n        total_inv = left_inv + right_inv + split_inv\n        return merged, total_inv\n\n    _, total_inversions = sort_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_and_count_split_inv(left, right):\n        i, j, inv_count = 0, 0, 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_count += len(left) - i  # All remaining elements in left are inversions with right[j]\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n\n    def sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, left_inv = sort_and_count(arr[:mid])\n        right, right_inv = sort_and_count(arr[mid:])\n        merged, split_inv = merge_and_count_split_inv(left, right)\n        total_inv = left_inv + right_inv + split_inv\n        return merged, total_inv\n\n    _, inv_count = sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr, temp, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += merge_sort(arr, temp, left, mid)\n            inv_count += merge_sort(arr, temp, mid + 1, right)\n            inv_count += merge(arr, temp, left, mid + 1, right)\n        return inv_count\n\n    def merge(arr, temp, left, mid, right):\n        i = left\n        j = mid\n        k = left\n        inv_count = 0\n        while i <= mid - 1 and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                k += 1\n                i += 1\n            else:\n                temp[k] = arr[j]\n                inv_count += (mid - i)\n                k += 1\n                j += 1\n        while i <= mid - 1:\n            temp[k] = arr[i]\n            k += 1\n            i += 1\n        while j <= right:\n            temp[k] = arr[j]\n            k += 1\n            j += 1\n        for i in range(left, right + 1):\n            arr[i] = temp[i]\n        return inv_count\n    n = len(arr)\n    temp = [0] * n\n    return merge_sort(arr, temp, 0, n - 1)", "matching_cluster_idx": 5}]}, "Mbpp/308": {"dps": 93.00492610837439, "dps_norm": 66.66666666666667, "pass@1": 14.0, "profiled": [{"solution": "def large_product(list1, list2, n):\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "import heapq\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the specified number of largest products from two given lists, selecting one factor from each list.\n    \n    Args:\n    list1 (List[int]): The first list of integers.\n    list2 (List[int]): The second list of integers.\n    n (int): The number of largest products to find.\n    \n    Returns:\n    List[int]: A list containing the 'n' largest products.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n    \n    # Use a min-heap to keep track of the top 'n' products\n    min_heap = []\n    \n    for num1 in list1:\n        for num2 in list2:\n            product = num1 * num2\n            if len(min_heap) < n:\n                heapq.heappush(min_heap, product)\n            else:\n                # If the current product is larger than the smallest in the heap, replace it\n                if product > min_heap[0]:\n                    heapq.heappushpop(min_heap, product)\n    \n    # The heap contains the top 'n' products in ascending order\n    # We need to return them in descending order\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 3}, {"solution": "import heapq\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the n largest products from two given lists by multiplying one element from each list.\n    \n    Args:\n    list1: First list of integers.\n    list2: Second list of integers.\n    n: Number of largest products to find.\n    \n    Returns:\n    A list containing the n largest products in descending order.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n    \n    # Use a min heap to keep track of the top n products\n    min_heap = []\n    \n    for num1 in list1:\n        for num2 in list2:\n            product = num1 * num2\n            if len(min_heap) < n:\n                heapq.heappush(min_heap, product)\n            else:\n                # If the current product is larger than the smallest in the heap, replace it\n                if product > min_heap[0]:\n                    heapq.heappushpop(min_heap, product)\n    \n    # The heap contains the top n products in ascending order, so reverse it to descending\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(nums1, nums2, k):\n    if not nums1 or not nums2 or k <= 0:\n        return []\n\n    # Use negative values to turn min-heap into max-heap\n    min_heap = []\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            if len(min_heap) < k:\n                heapq.heappush(min_heap, product)\n            else:\n                # If the current product is larger than the smallest in the heap\n                if product > min_heap[0]:\n                    heapq.heappushpop(min_heap, product)\n    \n    # Since we used a min-heap with negative values, convert back to positive\n    # and sort descending\n    result = sorted([heapq.heappop(min_heap) for _ in range(len(min_heap))], reverse=True)\n    return result", "matching_cluster_idx": 3}, {"solution": "import heapq\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the n largest products from two lists by multiplying one element from each list.\n    \n    Args:\n    list1: First list of integers.\n    list2: Second list of integers.\n    n: Number of largest products to find.\n    \n    Returns:\n    A list containing the n largest products in descending order.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n    \n    # Use a min-heap to keep track of the top n products\n    min_heap = []\n    \n    for num1 in list1:\n        for num2 in list2:\n            product = num1 * num2\n            if len(min_heap) < n:\n                heapq.heappush(min_heap, product)\n            else:\n                # If the current product is larger than the smallest in the heap, replace it\n                if product > min_heap[0]:\n                    heapq.heappushpop(min_heap, product)\n    \n    # The heap contains the top n products, but in ascending order\n    # We need to return them in descending order\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    products = []\n    \n    for num1 in list1:\n        for num2 in list2:\n            product = num1 * num2\n            products.append(product)\n    \n    products.sort(reverse=True)\n    \n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the n largest products from two given lists by selecting one factor from each list.\n\n    Parameters:\n    list1 (list of int): The first list of integers.\n    list2 (list of int): The second list of integers.\n    n (int): The number of largest products to find.\n\n    Returns:\n    list of int: A list containing the n largest products in descending order.\n    \"\"\"\n    from itertools import product\n    # Generate all possible products of one element from each list\n    all_products = [a * b for a, b in product(list1, list2)]\n    # Sort the products in descending order\n    all_products.sort(reverse=True)\n    # Return the first n products\n    return all_products[:n]", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Find the n largest products from two lists by selecting one element from each list.\n\n    Parameters:\n    list1 (List[int]): First list of integers.\n    list2 (List[int]): Second list of integers.\n    n (int): Number of largest products to find.\n\n    Returns:\n    List[int]: A list containing the n largest products in descending order.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    # Use negative values to create a max heap since heapq is a min heap by default\n    max_heap = [(-x*y, x, y) for x in list1 for y in list2]\n    heapq.heapify(max_heap)\n\n    result = []\n    for _ in range(min(n, len(max_heap))):\n        product, _, _ = heapq.heappop(max_heap)\n        result.append(-product)  # Convert back to positive\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from heapq import heapify, heappush, heappop\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the 'n' largest products from two given lists by selecting one element from each list.\n    \n    Parameters:\n    list1 (List[int]): The first list of integers.\n    list2 (List[int]): The second list of integers.\n    n (int): The number of largest products to find.\n    \n    Returns:\n    List[int]: A list containing the 'n' largest products in descending order.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n    \n    # Initialize a min-heap to keep track of the top 'n' products\n    min_heap = []\n    heapify(min_heap)\n    \n    for num1 in list1:\n        for num2 in list2:\n            product = num1 * num2\n            if len(min_heap) < n:\n                heappush(min_heap, product)\n            else:\n                # If the current product is larger than the smallest in the heap, replace it\n                if product > min_heap[0]:\n                    heappop(min_heap)\n                    heappush(min_heap, product)\n    \n    # The heap contains the top 'n' products in ascending order, so reverse it to descending\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    heap = []\n    for num1 in list1:\n        for num2 in list2:\n            product = num1 * num2\n            if len(heap) < n:\n                heapq.heappush(heap, product)\n            else:\n                heapq.heappushpop(heap, product)\n    return sorted(heap, reverse=True)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the 'n' largest products from two given lists by selecting one element from each list.\n\n    Parameters:\n    - list1 (List[int]): The first list of integers.\n    - list2 (List[int]): The second list of integers.\n    - n (int): The number of largest products to return.\n\n    Returns:\n    - List[int]: A list containing the 'n' largest products in descending order.\n    \"\"\"\n    from itertools import product\n    from heapq import nlargest\n\n    # Generate all possible products of one element from each list\n    all_products = (a * b for a, b in product(list1, list2))\n\n    # Find the 'n' largest products using heapq.nlargest\n    largest_products = nlargest(n, all_products)\n\n    return largest_products", "matching_cluster_idx": 4}, {"solution": "def large_product(list1, list2, n):\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "from heapq import heappush, heappop, nlargest\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the n largest products from two lists by multiplying one element from each list.\n    \n    Args:\n    list1: First list of integers.\n    list2: Second list of integers.\n    n: Number of largest products to find.\n    \n    Returns:\n    A list containing the n largest products in descending order.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n    \n    # Initialize a min-heap to keep track of the top n products\n    min_heap = []\n    for num1 in list1:\n        for num2 in list2:\n            product = num1 * num2\n            if len(min_heap) < n:\n                heappush(min_heap, product)\n            else:\n                # If the current product is larger than the smallest in the heap, replace it\n                if product > min_heap[0]:\n                    heappop(min_heap)\n                    heappush(min_heap, product)\n    \n    # The heap contains the top n products, but not necessarily in sorted order\n    # Use nlargest to get them in descending order\n    return nlargest(n, min_heap)", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 36.0, "profiled": [{"solution": "def get_max_sum(n: int) -> int:\n    memo = {}\n    \n    def f(x):\n        if x in memo:\n            return memo[x]\n        option1 = x\n        if x >= 2:\n            option1 = max(option1, f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5))\n        memo[x] = option1\n        return option1\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    \n    def f(x):\n        if x == 0:\n            return 0\n        if x in memo:\n            return memo[x]\n        result = max(x, f(x//2) + f(x//3) + f(x//4) + f(x//5))\n        memo[x] = result\n        return result\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n: int) -> int:\n    \"\"\"\n    Function to compute the maximum sum for a given number n\n    using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    The function uses memoization to store previously computed results\n    to optimize performance.\n    \"\"\"\n\n    # Dictionary to store computed results for memoization\n    memo = {}\n\n    def helper(x):\n        # Check if the result is already computed\n        if x in memo:\n            return memo[x]\n        # Base case: if x is less than or equal to 1\n        if x <= 1:\n            return x\n        # Recursive case: compute the sum of f(x/2), f(x/3), f(x/4), f(x/5)\n        sum_values = helper(x // 2) + helper(x // 3) + helper(x // 4) + helper(x // 5)\n        # Choose the maximum between the sum and x itself\n        result = max(sum_values, x)\n        # Store the result in memo dictionary\n        memo[x] = result\n        return result\n\n    # Call the helper function with the initial value n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n: int) -> int:\n    memo = {0: 0}\n\n    def f(k):\n        if k not in memo:\n            memo[k] = max(k, f(k // 2) + f(k // 3) + f(k // 4) + f(k // 5))\n        return memo[k]\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    \n    def f(x):\n        if x < 2:\n            return x\n        if x in memo:\n            return memo[x]\n        result = max(x, f(x//2) + f(x//3) + f(x//4) + f(x//5))\n        memo[x] = result\n        return result\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def f(n):\n        if n in memo:\n            return memo[n]\n        option1 = n\n        if n >= 2:\n            option1 = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        memo[n] = max(option1, n)\n        return memo[n]\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def f(n):\n        if n in memo:\n            return memo[n]\n        option1 = n\n        if n < 2:\n            return option1\n        option2 = f(n//2) + f(n//3) + f(n//4) + f(n//5)\n        memo[n] = max(option1, option2)\n        return memo[n]\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    \n    def f(x):\n        if x < 2:\n            return x\n        if x in memo:\n            return memo[x]\n        result = max(x, f(x//2) + f(x//3) + f(x//4) + f(x//5))\n        memo[x] = result\n        return result\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n: int) -> int:\n    memo = {}\n    \n    def f(k):\n        if k == 0:\n            return 0\n        if k in memo:\n            return memo[k]\n        candidate1 = k\n        candidate2 = f(k // 2) + f(k // 3) + f(k // 4) + f(k // 5)\n        memo[k] = max(candidate1, candidate2)\n        return memo[k]\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def f(n):\n        if n in memo:\n            return memo[n]\n        option1 = n\n        if n < 2:\n            return option1\n        option2 = f(n//2) + f(n//3) + f(n//4) + f(n//5)\n        memo[n] = max(option1, option2)\n        return memo[n]\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def f(x):\n        if x == 0:\n            return 0\n        if x in memo:\n            return memo[x]\n        result = max(x, f(x//2) + f(x//3) + f(x//4) + f(x//5))\n        memo[x] = result\n        return result\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    \n    def f(x):\n        if x == 0:\n            return 0\n        if x in memo:\n            return memo[x]\n        result = max(x, f(x//2) + f(x//3) + f(x//4) + f(x//5))\n        memo[x] = result\n        return result\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    \n    def f(x):\n        if x == 0:\n            return 0\n        if x in memo:\n            return memo[x]\n        # Calculate the value of the equation\n        result = max(x, f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5))\n        memo[x] = result\n        return result\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {0: 0}\n    def f(x):\n        if x not in memo:\n            memo[x] = max(x, f(x//2) + f(x//3) + f(x//4) + f(x//5))\n        return memo[x]\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n: int) -> int:\n    memo = {}\n    \n    def f(x):\n        if x in memo:\n            return memo[x]\n        option1 = x\n        if x >= 2:\n            option1 = f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5)\n        memo[x] = max(x, option1)\n        return memo[x]\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    \n    def f(x):\n        if x == 0:\n            return 0\n        if x in memo:\n            return memo[x]\n        result = max(x, f(x//2) + f(x//3) + f(x//4) + f(x//5))\n        memo[x] = result\n        return result\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def recurse(x):\n        if x in memo:\n            return memo[x]\n        val1 = x\n        if x >= 2:\n            val1 = recurse(x // 2) + recurse(x // 3) + recurse(x // 4) + recurse(x // 5)\n        memo[x] = max(x, val1)\n        return memo[x]\n    return recurse(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {0: 0}\n    \n    def f(x):\n        if x not in memo:\n            memo[x] = max(x, f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5))\n        return memo[x]\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def f(n):\n        if n in memo:\n            return memo[n]\n        option1 = n\n        if n >= 2:\n            option1 = f(n//2) + f(n//3) + f(n//4) + f(n//5)\n        memo[n] = max(option1, n)\n        return memo[n]\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def f(x):\n        if x == 0:\n            return 0\n        if x not in memo:\n            memo[x] = max(x, f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5))\n        return memo[x]\n    return f(n)", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_counts = {}\n    for char in s:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_counts = {}\n    for char in s:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string: str):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    count = {}\n    for char in string:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    for char in string:\n        if count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    # Initialize a dictionary to store character frequencies\n    freq = {}\n    \n    # Iterate over the string to populate frequency dictionary\n    for char in string:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    \n    # Iterate over the string again to find the first non-repeating character\n    for char in string:\n        if freq[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_str):\n    # Initialize a dictionary to count character frequencies\n    char_count = {}\n    \n    # Populate the dictionary with character counts\n    for char in input_str:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in input_str:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # This dictionary will store the frequency of each character\n    frequency = {}\n    \n    # Iterate through the string and update the frequency dictionary\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    \n    # Iterate through the string again to find the first non-repeated character\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store character frequencies\n    freq = {}\n    \n    # Count the frequency of each character\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if freq[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tup, element):\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    elem: The element to search for.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    # Use the 'in' operator to check for existence\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Check if the specified element exists in the given tuple.\n\n    Args:\n    input_tuple (tuple): The tuple to search in.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    elem: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    :param tup: The tuple to search in.\n    :param element: The element to search for.\n    :return: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search in.\n    elem: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if the given element exists in the tuple.\n\n    Args:\n        tup (tuple): The tuple to search in.\n        element: The element to search for.\n\n    Returns:\n        bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Args:\n    input_tuple (tuple): The tuple to search in.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Args:\n    tup: tuple in which to search for the element.\n    element: the element to search for within the tuple.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 63.72670807453416, "dps_norm": 82.22222222222221, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value from seq1 exists in seq2.\n\n    Parameters:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check against.\n\n    Returns:\n    bool: True if any element from seq1 is found in seq2, False otherwise.\n    \"\"\"\n    set1 = set(seq1)\n    set2 = set(seq2)\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Determines whether there is any overlapping value between two sequences.\n\n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check.\n\n    Returns:\n    bool: True if there is at least one common value, False otherwise.\n    \"\"\"\n    set1 = set(seq1)\n    set2 = set(seq2)\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value from seq1 exists in seq2.\n\n    Args:\n    seq1: A sequence (e.g., list, tuple) of elements.\n    seq2: Another sequence of elements.\n\n    Returns:\n    bool: True if any element from seq1 is found in seq2, False otherwise.\n    \"\"\"\n    return any(elem in seq2 for elem in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set1 = set(seq1)\n    set2 = set(seq2)\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1: The first sequence to check.\n    seq2: The second sequence to check.\n\n    Returns:\n    True if there is at least one common element, False otherwise.\n    \"\"\"\n    set1 = set(seq1)\n    set2 = set(seq2)\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    This function takes in two sequences and checks if there is any common value between them.\n    \n    Parameters:\n    seq1: The first sequence to be checked.\n    seq2: The second sequence to be checked.\n    \n    Returns:\n    True if there is at least one common value, False otherwise.\n    \"\"\"\n    set1 = set(seq1)\n    set2 = set(seq2)\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    return not set(seq1).isdisjoint(seq2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(sequence1, sequence2):\n    \"\"\"\n    Check whether any value in sequence1 exists in sequence2.\n\n    Args:\n    sequence1 (iterable): The first sequence to check.\n    sequence2 (iterable): The second sequence to check.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set1 = set(sequence1)\n    set2 = set(sequence2)\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    return any(element in seq2 for element in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1: A sequence (e.g., list, tuple) of elements.\n    seq2: Another sequence of elements.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set1 = set(seq1)\n    set2 = set(seq2)\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value from seq1 exists in seq2.\n\n    Args:\n    seq1: The first sequence to check.\n    seq2: The second sequence where we look for values from seq1.\n\n    Returns:\n    True if any value from seq1 is found in seq2, False otherwise.\n    \"\"\"\n    return any(elem in seq2 for elem in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1: The first sequence to check.\n    seq2: The second sequence to check.\n\n    Returns:\n    True if there is at least one common element, False otherwise.\n    \"\"\"\n    set1 = set(seq1)\n    set2 = set(seq2)\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any overlapping value between two sequences.\n\n    Args:\n    seq1: First sequence to check.\n    seq2: Second sequence to check.\n\n    Returns:\n    True if there is at least one common value, False otherwise.\n    \"\"\"\n    set1 = set(seq1)\n    set2 = set(seq2)\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    return any(element in seq2 for element in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(elem in seq2 for elem in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value from seq1 exists in seq2.\n\n    Args:\n    seq1: A sequence (e.g., list, tuple) of elements.\n    seq2: Another sequence (e.g., list, tuple) of elements.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set1 = set(seq1)\n    set2 = set(seq2)\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1: The first sequence to check.\n    seq2: The second sequence to check.\n\n    Returns:\n    True if there is at least one common element, False otherwise.\n    \"\"\"\n    set1 = set(seq1)\n    set2 = set(seq2)\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value from seq1 exists in seq2.\n\n    Args:\n    seq1: The first sequence to check.\n    seq2: The second sequence where we look for values from seq1.\n\n    Returns:\n    True if any value from seq1 is found in seq2, otherwise False.\n    \"\"\"\n    return any(element in seq2 for element in seq1)", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 76.17283950617283, "dps_norm": 86.42857142857142, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(t, delimiter='-'):\n    \"\"\"\n    Concatenates elements of a tuple into a string with a specified delimiter.\n\n    Parameters:\n    t (tuple): The input tuple to concatenate.\n    delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n    str: A string with concatenated tuple elements separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join with the delimiter\n    return delimiter.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(str(element) for element in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple into a string, separated by the given delimiter.\n\n    Parameters:\n    tup (tuple): The input tuple containing elements to concatenate.\n    delimiter (str): The delimiter to use for concatenation. Default is '-'.\n\n    Returns:\n    str: A string with tuple elements concatenated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings\n    str_elements = [str(element) for element in tup]\n    # Join the string elements with the delimiter\n    concatenated_string = delimiter.join(str_elements)\n    return concatenated_string", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    \"\"\"\n    Concatenates the elements of a tuple into a single string, using a specified delimiter.\n\n    Parameters:\n    t (tuple): The tuple containing elements to concatenate.\n    delimiter (str, optional): The string to use for separating elements in the resulting string. Defaults to '-'.\n\n    Returns:\n    str: A string with all tuple elements concatenated, separated by the delimiter.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert all elements to strings\n    str_elements = [str(element) for element in t]\n    # Join the string elements with the delimiter\n    result = delimiter.join(str_elements)\n    return result", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple into a string, separated by the given delimiter.\n    \n    Parameters:\n    - tup: The input tuple whose elements are to be concatenated.\n    - delimiter: The string to place between elements of the tuple.\n    \n    Returns:\n    - A string that is the concatenation of the tuple's elements, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings in case they are not strings\n    str_elements = [str(element) for element in tup]\n    # Join the string elements with the delimiter\n    result = delimiter.join(str_elements)\n    return result", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates the elements of a tuple into a single string, separated by a specified delimiter.\n    \n    Parameters:\n    - tup: The tuple whose elements are to be concatenated.\n    - delimiter: The string to use for separating elements in the resulting string (default is '-').\n    \n    Returns:\n    - A string that is the concatenation of the tuple's elements, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings in case they are not strings\n    str_elements = [str(element) for element in tup]\n    # Join the string elements with the delimiter\n    concatenated_string = delimiter.join(str_elements)\n    return concatenated_string", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    # Convert each element in the tuple to string and join with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a single string, separated by a specified delimiter.\n\n    :param tup: The input tuple containing elements to concatenate.\n    :param delimiter: The string to use for separating elements in the resulting string. Default is '-'.\n    :return: A string that is the concatenation of the tuple's elements, separated by the delimiter.\n    \"\"\"\n    # Convert each element in the tuple to string and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple into a string, separated by the given delimiter.\n\n    Args:\n    tup (tuple): The input tuple containing elements to concatenate.\n    delimiter (str): The string to use for separating elements in the resulting string.\n\n    Returns:\n    str: A string with all tuple elements concatenated, separated by the delimiter.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert all elements to strings in case they are not already\n    str_elements = map(str, tup)\n    # Join them with the specified delimiter\n    result = delimiter.join(str_elements)\n    return result", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    # Convert each element in the tuple to string and join with delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    # Convert each element in the tuple to string and join with delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates the elements of a tuple into a single string, separated by the specified delimiter.\n    \n    Parameters:\n    - tup: The tuple whose elements are to be concatenated.\n    - delimiter: The string to use for separating elements in the resulting string. Default is '-'.\n    \n    Returns:\n    A string that is the concatenation of the tuple's elements, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings in case they are not strings\n    str_elements = [str(element) for element in tup]\n    # Join the string elements with the delimiter\n    result = delimiter.join(str_elements)\n    return result", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates the elements of a tuple into a single string, separated by a specified delimiter.\n\n    Args:\n    tup (tuple): The input tuple containing elements to concatenate.\n    delimiter (str, optional): The delimiter to use for concatenation. Defaults to '-'.\n\n    Returns:\n    str: A string that is the concatenation of the tuple's elements, separated by the delimiter.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert all elements to strings\n    str_elements = [str(element) for element in tup]\n    # Join the string elements with the delimiter\n    concatenated_string = delimiter.join(str_elements)\n    return concatenated_string", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    \"\"\"\n    Concatenates the elements of a tuple into a single string, separated by the given delimiter.\n    \n    Parameters:\n    - t: A tuple containing elements to be concatenated.\n    - delimiter: A string to separate the elements in the final string. Default is '-'.\n    \n    Returns:\n    - A string with tuple elements concatenated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings\n    str_elements = [str(element) for element in t]\n    # Join the string elements with the delimiter\n    result = delimiter.join(str_elements)\n    return result", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    \"\"\"\n    Concatenate elements of a tuple into a string, separated by the given delimiter.\n    \n    Parameters:\n    t (tuple): The tuple containing elements to concatenate.\n    delimiter (str): The string to use for separating elements in the resulting string.\n    \n    Returns:\n    str: A string with tuple elements concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings\n    str_elements = [str(element) for element in t]\n    # Join the string elements with the delimiter\n    result = delimiter.join(str_elements)\n    return result", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple into a string, separated by the given delimiter.\n    \n    Parameters:\n    - tup: The input tuple whose elements are to be concatenated.\n    - delimiter: The string to use for separating elements in the resulting string. Default is '-'.\n    \n    Returns:\n    - A string that is the concatenation of all elements in the tuple, separated by the delimiter.\n    \"\"\"\n    # Convert each element in the tuple to a string\n    str_elements = [str(element) for element in tup]\n    # Join the string elements with the delimiter\n    result = delimiter.join(str_elements)\n    return result", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    \"\"\"\n    Concatenates the elements of a tuple into a single string, separated by a specified delimiter.\n    \n    Parameters:\n    - t (tuple): The tuple containing elements to concatenate.\n    - delimiter (str): The string to use for separating elements in the resulting string.\n    \n    Returns:\n    - str: A string that is the concatenation of the tuple's elements, separated by the delimiter.\n    \n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert all elements in the tuple to strings\n    str_elements = map(str, t)\n    # Join the string elements with the delimiter\n    result = delimiter.join(str_elements)\n    return result", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates elements of a tuple into a single string, separated by the given delimiter.\n\n    Parameters:\n    - tup: A tuple containing elements to be concatenated.\n    - delimiter: A string to separate the elements in the final string. Default is '-'.\n\n    Returns:\n    - A string with tuple elements concatenated by the delimiter.\n\n    Example:\n    - concatenate_tuple((\"ID\", \"is\", 4, \"UTS\")) returns 'ID-is-4-UTS'\n    \"\"\"\n    # Convert all elements to strings\n    str_elements = [str(element) for element in tup]\n    # Join the string elements with the delimiter\n    concatenated_string = delimiter.join(str_elements)\n    return concatenated_string", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple into a string, separated by the specified delimiter.\n    \n    Parameters:\n    t (tuple): The input tuple containing elements to concatenate.\n    delimiter (str): The delimiter to use for concatenation. Default is '-'.\n    \n    Returns:\n    str: A string with tuple elements concatenated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings\n    str_elements = [str(element) for element in t]\n    # Join the string elements with the delimiter\n    result = delimiter.join(str_elements)\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/424": {"dps": 76.96750902527076, "dps_norm": 89.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        input_tuple (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    input_tuple (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n\n    Examples:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n    strings_tuple (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    result = [s[-1] for s in input_tuple]\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extract the last character from each string in the given tuple.\n\n    Args:\n    input_tuple (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n\n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(items):\n    \"\"\"\n    Extracts the last character from each string in a tuple.\n\n    Parameters:\n    items (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [item[-1] for item in items]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    if not all(isinstance(item, str) for item in t):\n        raise ValueError(\"All elements in the tuple must be strings.\")\n    return [item[-1] for item in t]", "matching_cluster_idx": 2}, {"solution": "def extract_rear(input_tuple):\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str):\n            if len(item) > 0:\n                result.append(item[-1])\n            else:\n                result.append(None)  # or decide on another way to handle empty strings\n        else:\n            raise ValueError(\"All elements in the tuple must be strings\")\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(t):\n    if not all(isinstance(item, str) for item in t):\n        raise ValueError(\"All elements in the tuple must be strings.\")\n    return [item[-1] for item in t]", "matching_cluster_idx": 2}, {"solution": "def extract_rear(input_tuple):\n    # Extract the last character of each string in the tuple\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    input_tuple (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n\n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    input_tuple (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n    \"\"\"\n    # Check if input is a tuple\n    if not isinstance(input_tuple, tuple):\n        raise ValueError(\"Input must be a tuple.\")\n\n    # Extract last character from each string in the tuple\n    result = [s[-1] for s in input_tuple if isinstance(s, str)]\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def extract_rear(t):\n    \"\"\"\n    Extracts the last character from each string in a tuple.\n\n    Parameters:\n    t (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the last character of each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in t]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    - input_tuple: A tuple of strings.\n\n    Returns:\n    - A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    result = []\n    for string in input_tuple:\n        if string:  # Check if the string is not empty\n            result.append(string[-1])\n        else:\n            result.append('')\n    return result", "matching_cluster_idx": 2}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Args:\n    list_of_lists: A list of lists, where each sublist may contain elements.\n    element: The element to search for in the sublists.\n\n    Returns:\n    An integer representing the number of sublists that contain the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n    \n    Parameters:\n        list_of_lists (list of lists): The list containing sublists.\n        element: The element to search for in the sublists.\n    \n    Returns:\n        int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Args:\n    list_of_lists: A list of lists, where each sublist contains elements.\n    element: The element to search for in the sublists.\n\n    Returns:\n    An integer representing the number of sublists that contain the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    count = 0\n    for sublist in lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    count = 0\n    for sublist in lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Args:\n    list_of_lists: A list of lists, where each sublist can contain any number of elements.\n    element: The element to search for within the sublists.\n\n    Returns:\n    An integer representing the number of sublists that contain the specified element.\n    \"\"\"\n\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    return sum(element in sublist for sublist in list_of_lists)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    count = 0\n    for sublist in lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Args:\n    nested_list: a list of lists containing elements\n    element: the element to count in the sublists\n\n    Returns:\n    count: the number of sublists containing the element\n    \"\"\"\n\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    list_of_lists (list of lists): The list containing sublists.\n    element: The element to search for in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Args:\n    list_of_lists: A list of lists, where each sublist may contain elements.\n    element: The element to search for in the sublists.\n\n    Returns:\n    The count of sublists that contain the specified element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n    list_of_lists: A list of lists, where each sublist may contain elements.\n    element: The element to search for within the sublists.\n\n    Returns:\n    The count of sublists that contain the specified element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    count = 0\n    for sublist in lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 25.619834710743802, "dps_norm": 44.44444444444444, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements (integers) to be sorted.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Start with a big gap, then reduce the gap until it becomes 0\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap.\n    \n    # Start with a big gap, then reduce the gap until it is 1\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements a[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            # add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap.\n    \n    # Start with a big gap, then reduce the gap until it is 0.\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            # Add arr[i] to the elements that have been gap sorted.\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location.\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element.\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n    \n    # Start with a big gap, then reduce the gap until it is 0.\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements are already in gapped order\n        # keep adding one more element until the entire array is gap sorted.\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element.\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size to half of the array length\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements a[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            # add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/433": {"dps": 96.43617021276596, "dps_norm": 97.0, "pass@1": 99.0, "profiled": [{"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Function to check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    for elem in arr:\n        if num <= elem:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for elem in arr:\n        if num <= elem:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/437": {"dps": 90.58823529411765, "dps_norm": 85.0, "pass@1": 94.0, "profiled": [{"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(input_string):\n    result = ''\n    for index, character in enumerate(input_string):\n        if (index + 1) % 2 == 0:\n            result += character\n    return result", "matching_cluster_idx": -1}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(text):\n    return text[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(input_string):\n    result = ''\n    for index, char in enumerate(input_string):\n        if index % 2 != 0:\n            result += char\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(input_string):\n    return input_string[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"Remove characters from a string that are at odd indices.\"\"\"\n    return ''.join(char for idx, char in enumerate(s, start=1) if idx % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 72.0, "profiled": [{"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        if item in tup:\n            count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        if item in tup:\n            count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_, list_):\n    count = 0\n    for item in list_:\n        count += tuple_.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(target_tuple, elements_list):\n    count = 0\n    for element in elements_list:\n        count += target_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    # Iterate over each element in the list\n    for item in lst:\n        # Add the count of the current item in the tuple to the total count\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    \"\"\"\n    Counts the occurrences of all elements from the list in the tuple.\n\n    Parameters:\n    test_tup (tuple): The tuple in which to count occurrences.\n    test_list (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of the elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for elem in test_list:\n        count += test_tup.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_, list_):\n    count = 0\n    for item in list_:\n        count += tuple_.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, elements_list):\n    count = 0\n    for element in elements_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    count = 0\n    for item in list_data:\n        count += tuple_data.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 96.0, "profiled": [{"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Parameters:\n        s (str): The input string from which whitespaces are to be removed.\n\n    Returns:\n        str: The string with all whitespaces removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Parameters:\n    s (str): The input string from which whitespaces are to be removed.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Parameters:\n    - input_str (str): The string from which whitespaces are to be removed.\n\n    Returns:\n    - str: The string with all whitespaces removed.\n    \"\"\"\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Parameters:\n    input_string (str): The string from which whitespaces are to be removed.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    # Using the replace method to remove all whitespace characters\n    no_whitespace_string = input_string.replace(\" \", \"\")\n    return no_whitespace_string", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Parameters:\n    - input_string (str): The string from which whitespaces are to be removed.\n\n    Returns:\n    - str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    Args:\n        input_string (str): The string from which to remove whitespace.\n\n    Returns:\n        str: The input string with all whitespace removed.\n\n    Examples:\n        >>> remove_whitespaces(' Google    Flutter ')\n        'GoogleFlutter'\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Args:\n    input_string (str): The string from which whitespaces are to be removed.\n\n    Returns:\n    str: The string with all whitespaces removed.\n\n    Examples:\n    >>> remove_whitespaces(' Google    Flutter ')\n    'GoogleFlutter'\n    >>> remove_whitespaces(' Hello World ')\n    'HelloWorld'\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n    input_list (list of str): The list of strings to be reversed.\n\n    Returns:\n    list of str: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n\n    Parameters:\n    input_list (list of str): The list of strings to be reversed.\n\n    Returns:\n    list of str: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n        input_list (list): A list of strings to be reversed.\n\n    Returns:\n        list: A new list containing the reversed strings.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(input_list, list):\n        raise ValueError(\"Input must be a list of strings.\")\n    \n    # Initialize an empty list to store reversed strings\n    reversed_list = []\n    \n    # Iterate over each string in the input list\n    for string in input_list:\n        # Check if the current item is a string\n        if not isinstance(string, str):\n            raise ValueError(\"All items in the list must be strings.\")\n        \n        # Reverse the string and append to the reversed_list\n        reversed_list.append(string[::-1])\n    \n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n    input_list (list): A list of strings to be reversed.\n\n    Returns:\n    list: A new list containing the reversed strings.\n    \"\"\"\n    # Using list comprehension to reverse each string in the input list\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n    input_list (list of str): The list of strings to be reversed.\n\n    Returns:\n    list of str: A new list containing the reversed strings.\n    \"\"\"\n    # Use list comprehension to reverse each string in the input list\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Parameters:\n    - input_list: List of strings to be reversed.\n\n    Returns:\n    - A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverse each string in a given list of strings.\n\n    Args:\n    input_list (list): A list of strings to be reversed individually.\n\n    Returns:\n    list: A new list containing the reversed strings.\n    \"\"\"\n    # Use list comprehension to reverse each string in the input list\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n    input_list (list of str): The list of strings to be reversed.\n\n    Returns:\n    list of str: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n\n    Args:\n        input_list (list of str): The list of strings to be reversed.\n\n    Returns:\n        list of str: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Parameters:\n    input_list (list of str): A list containing string elements to be reversed.\n\n    Returns:\n    list of str: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Parameters:\n    input_list (list): A list of strings to be reversed.\n\n    Returns:\n    list: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n    input_list (list of str): The list containing strings to be reversed.\n\n    Returns:\n    list of str: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n    input_list (list): A list of strings.\n\n    Returns:\n    list: A new list containing the reversed strings.\n    \"\"\"\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Parameters:\n    input_list (list): A list of strings to be reversed.\n\n    Returns:\n    list: A new list containing the reversed strings.\n    \"\"\"\n    # Using list comprehension to reverse each string in the input list\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    # Use list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 48.55769230769231, "dps_norm": 80.0, "pass@1": 87.0, "profiled": [{"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    This function takes a list of lists (sublists) and returns a list containing the first element of each sublist.\n\n    :param lst: List of lists from which the first elements are to be extracted.\n    :return: A list containing the first elements of each sublist in the input list.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(l):\n    return [sublist[0] for sublist in l]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist in a given list of lists.\n\n    Parameters:\n    list_of_lists (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element from each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns a list containing\n    the first element of each sublist.\n\n    Parameters:\n    list_of_lists (list of lists): A list where each element is a list itself.\n\n    Returns:\n    list: A list containing the first elements of each sublist in the input list.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns a list containing\n    the first element of each sublist.\n\n    Args:\n    list_of_lists (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Initialize an empty list to store the first elements\n    first_elements = []\n\n    # Iterate through each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Check if the sublist is not empty\n        if sublist:\n            # Append the first element of the sublist to the result list\n            first_elements.append(sublist[0])\n\n    return first_elements", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns a list containing\n    the first element of each sublist.\n\n    Parameters:\n    - list_of_lists: A list where each element is also a list.\n\n    Returns:\n    - A list containing the first element of each sublist in the input list.\n    \"\"\"\n    result = []\n    for sublist in list_of_lists:\n        if sublist:  # Check if the sublist is not empty\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 2}, {"solution": "def Extract(lists):\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    result = [sublist[0] for sublist in list_of_lists]\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    # Initialize an empty list to store the first elements\n    first_elements = []\n    \n    # Iterate through each sublist in the list_of_lists\n    for sublist in list_of_lists:\n        # Check if the sublist is not empty\n        if sublist:\n            # Append the first element of the sublist to the first_elements list\n            first_elements.append(sublist[0])\n    \n    return first_elements", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist in a given list of lists.\n\n    Args:\n    list_of_lists: A list containing sublists from which the first elements are to be extracted.\n\n    Returns:\n    A list containing the first elements of each sublist.\n\n    Raises:\n    IndexError: If any sublist is empty.\n\n    Examples:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist in a given list of lists.\n\n    Parameters:\n    list_of_lists (list of lists): A list containing sublists from which the first elements are to be extracted.\n\n    Returns:\n    list: A list containing the first elements of each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(nested_list):\n    return [sublist[0] for sublist in nested_list]", "matching_cluster_idx": 3}]}, "Mbpp/474": {"dps": 93.46341463414635, "dps_norm": 94.28571428571429, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' with 'new' in the string 's'.\n    \n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n        \n    Returns:\n        str: The modified string.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string: str, target: str, replacement: str) -> str:\n    return string.replace(target, replacement)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, target_char, replacement_char):\n    \"\"\"\n    Replace all occurrences of target_char in input_string with replacement_char.\n\n    Args:\n    - input_string (str): The string to be modified.\n    - target_char (str): The character to be replaced.\n    - replacement_char (str): The character to replace with.\n\n    Returns:\n    - str: The modified string with target_char replaced by replacement_char.\n    \"\"\"\n    return input_string.replace(target_char, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, original_char, new_char):\n    return string.replace(original_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate through each character in the input string\n    for char in s:\n        # If the character matches the one to be replaced, append the new character\n        if char == old:\n            result += new\n        else:\n            # Otherwise, append the original character\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character in string 's' with 'new' character.\n\n    Parameters:\n    s (str): The original string.\n    old (str): The character to replace.\n    new (str): The character to replace with.\n\n    Returns:\n    str: A new string with all occurrences of 'old' replaced by 'new'.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character in string 's' with 'new' character.\n    \n    :param s: Input string\n    :param old: Character to be replaced\n    :param new: Character to replace with\n    :return: Modified string with replacements\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character in string 's' with 'new' character.\n\n    Args:\n    s (str): The original string.\n    old (str): The character to replace.\n    new (str): The character to replace with.\n\n    Returns:\n    str: The modified string.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' with 'new' in the string 's'.\n    \n    Args:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n    \n    Returns:\n    str: The modified string.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, target, replacement):\n    return string.replace(target, replacement)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    result = ''\n    for char in s:\n        if char == old:\n            result += new\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}]}, "Mbpp/476": {"dps": 65.30201342281879, "dps_norm": 81.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    # Find the largest value in the array\n    max_val = max(arr)\n    \n    # Find the smallest value in the array\n    min_val = min(arr)\n    \n    # Calculate the sum of the largest and smallest values\n    sum_val = max_val + min_val\n    \n    return sum_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # Return 0 for empty array\n    max_val = arr[0]\n    min_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n        elif num < min_val:\n            min_val = num\n    return max_val + min_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    # find the smallest value in the array\n    smallest = min(arr)\n    # find the largest value in the array\n    largest = max(arr)\n    # calculate the sum of the smallest and largest values\n    total = smallest + largest\n    # return the sum\n    return total", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # or any other value or exception as per requirement\n    max_val = arr[0]\n    min_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n        if num < min_val:\n            min_val = num\n    return max_val + min_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(numbers):\n    if not numbers:\n        return 0  # or raise an error, depending on the desired behavior for empty lists\n    max_value = max(numbers)\n    min_value = min(numbers)\n    return max_value + min_value", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0\n    min_val = min(arr)\n    max_val = max(arr)\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return 0  # Return 0 for an empty array\n    max_val = arr[0]  # Initialize max_val with the first element\n    min_val = arr[0]  # Initialize min_val with the first element\n    for num in arr:\n        if num > max_val:\n            max_val = num  # Update max_val if a larger number is found\n        elif num < min_val:\n            min_val = num  # Update min_val if a smaller number is found\n    return max_val + min_val  # Return the sum of the largest and smallest values", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # or handle as per requirement\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # or handle as per requirement\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # or handle as per requirement\n    max_val = arr[0]\n    min_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n        elif num < min_val:\n            min_val = num\n    return max_val + min_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # or raise an error, depending on desired behavior\n    max_val = arr[0]\n    min_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n        if num < min_val:\n            min_val = num\n    return max_val + min_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(numbers):\n    if not numbers:\n        return 0  # or handle as per requirement, assuming sum as 0 for empty list\n    max_val = max(numbers)\n    min_val = min(numbers)\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # or handle as per requirements, e.g., raise an exception\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # or handle as per requirement\n    min_val = arr[0]\n    max_val = arr[0]\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # or perhaps raise an exception, depending on requirements\n    max_val = arr[0]\n    min_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n        if num < min_val:\n            min_val = num\n    return max_val + min_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # or handle as per requirements, e.g., raise an exception\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # or any other value, since there are no elements\n    max_val = arr[0]\n    min_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n        elif num < min_val:\n            min_val = num\n    return max_val + min_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    # Check if the array is empty\n    if not arr:\n        return 0  # or handle as per requirement\n    \n    # Initialize min and max with the first element\n    min_val = arr[0]\n    max_val = arr[0]\n    \n    # Iterate through the array to find min and max\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    \n    # Return the sum of min and max\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # or raise an error, depending on requirements\n    max_val = arr[0]\n    min_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n        if num < min_val:\n            min_val = num\n    return max_val + min_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # or handle as per requirement\n    max_val = arr[0]\n    min_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n        elif num < min_val:\n            min_val = num\n    return max_val + min_val", "matching_cluster_idx": 3}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    s (str): The string to be converted.\n\n    Returns:\n    str: The converted string in lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_str: str) -> str:\n    \"\"\"Convert the given string to lower case.\n\n    Args:\n        input_str (str): The string to be converted.\n\n    Returns:\n        str: The converted string in lower case.\n    \"\"\"\n    return input_str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    s (str): The string to be converted.\n\n    Returns:\n    str: The converted string in lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    :param input_string: The string to be converted.\n    :return: The converted string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string: str) -> str:\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"\n    Converts the given string to lower case.\n    \n    Parameters:\n    - input_string (str): The string to be converted.\n    \n    Returns:\n    - str: The converted string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n    return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"Convert the given string to lower case.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"Convert the given string to lower case.\"\"\"\n    return s.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 85.24590163934427, "dps_norm": 81.81818181818181, "pass@1": 96.0, "profiled": [{"solution": "import re\ndef extract_values(s):\n    pattern = '\"(.*?)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    pattern = r'\\\"(.*?)\\\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(text):\n    import re\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_str):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a given string.\n\n    Args:\n    input_str (str): A string containing values enclosed in double quotation marks.\n\n    Returns:\n    list: A list of strings extracted from within the double quotation marks.\n\n    Example:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n\n    # Importing the regular expression module\n    import re\n\n    # Regular expression pattern to find double quoted strings\n    pattern = r'\"([^\"]*)\"'\n\n    # Find all non-overlapping matches of the pattern in the string\n    matches = re.findall(pattern, input_str)\n\n    # Return the list of matches\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    pattern = r'\\\"(.*?)\\\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    pattern = r'\".*?\"'\n    matches = re.findall(pattern, string)\n    return [match[1:-1] for match in matches]", "matching_cluster_idx": 8}, {"solution": "def extract_values(text):\n    import re\n    return re.findall('\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    pattern = r'\".*?\"'\n    matches = re.findall(pattern, input_string)\n    return [match.strip('\"') for match in matches]", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from the given string.\n\n    Parameters:\n    input_string (str): The string from which to extract values.\n\n    Returns:\n    list: A list of extracted values.\n\n    Example:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    import re\n    # Use regular expression to find all substrings that are enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "def extract_values(s: str) -> list:\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a given string.\n    \n    This function searches for all occurrences of text enclosed in double quotes\n    and returns them as a list of strings. It assumes that the quotation marks\n    are properly paired and nested quotations are not handled.\n    \n    Args:\n        s (str): The input string containing quoted text.\n        \n    Returns:\n        list: A list of strings extracted from within the double quotes.\n        \n    Examples:\n        >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n        ['Python', 'PHP', 'Java']\n        >>> extract_values('No quotes here')\n        []\n        >>> extract_values('\"Single quoted string\"')\n        ['Single quoted string']\n        >>> extract_values('\"Quotes \"inside\" quotes\"')\n        ['Quotes \"inside\" quotes']\n    \"\"\"\n    import re\n    # Pattern to find text within double quotes\n    pattern = r'\"(.*?)\"'\n    # Find all non-overlapping matches of the pattern in the string\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all substrings that are within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s: str) -> list:\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n        s (str): The input string containing quoted values.\n        \n    Returns:\n        list: A list of extracted values.\n    \"\"\"\n    import re\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a given string.\n\n    Parameters:\n    text (str): The input string containing quoted values.\n\n    Returns:\n    list: A list of strings extracted between double quotation marks.\n    \"\"\"\n    import re\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 95.06172839506173, "dps_norm": 85.71428571428571, "pass@1": 97.0, "profiled": [{"solution": "def two_unique_nums(arr):\n    # Count the frequency of each element in the array\n    frequency = {}\n    for num in arr:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    # Collect elements that appear only once\n    unique = [num for num, count in frequency.items() if count == 1]\n    return unique", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(arr):\n    num_counts = {}\n    for num in arr:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    result = []\n    for num, count in num_counts.items():\n        if count == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(arr):\n    num_freq = {}\n    for num in arr:\n        num_freq[num] = num_freq.get(num, 0) + 1\n    result = [num for num, freq in num_freq.items() if freq == 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    return [num for num, count in counts.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    result = []\n    for num, freq in frequency.items():\n        if freq == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(arr):\n    num_count = {}\n    for num in arr:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    result = []\n    for num, count in num_count.items():\n        if count == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    counts = {}\n    for num in lst:\n        counts[num] = counts.get(num, 0) + 1\n    result = []\n    for num, count in counts.items():\n        if count == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    count_dict = {}\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    counts = {}\n    for num in lst:\n        counts[num] = counts.get(num, 0) + 1\n    result = []\n    for num, count in counts.items():\n        if count == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    counts = {}\n    for num in lst:\n        counts[num] = counts.get(num, 0) + 1\n    result = [num for num, count in counts.items() if count == 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    count_dict = {}\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    result = [num for num, count in count_dict.items() if count == 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(arr):\n    num_counts = {}\n    for num in arr:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    result = []\n    for num, count in num_counts.items():\n        if count == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(arr):\n    num_count = {}\n    for num in arr:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    result = []\n    for num, count in num_count.items():\n        if count == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    unique = []\n    for num, count in counts.items():\n        if count == 1:\n            unique.append(num)\n    return unique", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    num_freq = {}\n    for num in nums:\n        if num in num_freq:\n            num_freq[num] += 1\n        else:\n            num_freq[num] = 1\n    result = []\n    for num, freq in num_freq.items():\n        if freq == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    unique = []\n    for num, freq in frequency.items():\n        if freq == 1:\n            unique.append(num)\n    return unique", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    num_counts = {}\n    for num in lst:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    unique_nums = [num for num, count in num_counts.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    counts = {}\n    for num in lst:\n        counts[num] = counts.get(num, 0) + 1\n    result = [num for num, count in counts.items() if count == 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    num_count = {}\n    for num in nums:\n        num_count[num] = num_count.get(num, 0) + 1\n    result = [num for num, count in num_count.items() if count == 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    result = [num for num, count in counts.items() if count == 1]\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 76.26984126984127, "dps_norm": 70.45454545454545, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length\")\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    if not all(len(lst) == len(list1) for lst in [list2, list3]):\n        raise ValueError(\"All lists must be of the same length.\")\n    result = []\n    for items in zip(list1, list2, list3):\n        result.extend(items)\n    return result", "matching_cluster_idx": 8}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if all lists have the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length\")\n    \n    # Interleave the lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Parameters:\n    - list1, list2, list3: Lists to interleave.\n\n    Returns:\n    - A single list containing elements from list1, list2, and list3 in order.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must be of the same length.\")\n    \n    interleaved = []\n    for items in zip(list1, list2, list3):\n        interleaved.extend(items)\n    return interleaved", "matching_cluster_idx": 8}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Parameters:\n    - list1: The first list to interleave.\n    - list2: The second list to interleave.\n    - list3: The third list to interleave.\n    \n    Returns:\n    - A single list containing elements from list1, list2, and list3 interleaved.\n    \n    Raises:\n    - ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    interleaved_list = []\n    for items in zip(list1, list2, list3):\n        interleaved_list.extend(items)\n    return interleaved_list", "matching_cluster_idx": 8}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Parameters:\n    - list1 (list): The first list to interleave.\n    - list2 (list): The second list to interleave.\n    - list3 (list): The third list to interleave.\n\n    Returns:\n    - list: A single flat list with elements from list1, list2, and list3 interleaved.\n\n    Example:\n    >>> interleave_lists([1,2,3,4,5,6,7], [10,20,30,40,50,60,70], [100,200,300,400,500,600,700])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    result = []\n    for items in zip(list1, list2, list3):\n        result.extend(items)\n    return result", "matching_cluster_idx": 8}, {"solution": "def interleave_lists(list1, list2, list3):\n    if not all(len(lst) == len(list1) for lst in [list2, list3]):\n        raise ValueError(\"All lists must be of the same length.\")\n    \n    result = []\n    for items in zip(list1, list2, list3):\n        result.extend(items)\n    return result", "matching_cluster_idx": 8}, {"solution": "def interleave_lists(list1, list2, list3):\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3: Lists to be interleaved.\n    \n    Returns:\n    A single list containing elements from list1, list2, and list3 in order.\n    \n    Example:\n    >>> interleave_lists([1,2,3,4,5,6,7], [10,20,30,40,50,60,70], [100,200,300,400,500,600,700])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    # Interleave the lists\n    result = []\n    for items in zip(list1, list2, list3):\n        result.extend(items)\n    return result", "matching_cluster_idx": 8}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Parameters:\n    - list1: First list to interleave.\n    - list2: Second list to interleave.\n    - list3: Third list to interleave.\n    \n    Returns:\n    - A list containing elements from list1, list2, and list3 interleaved.\n    \n    Example:\n    >>> interleave_lists([1,2,3,4,5,6,7], [10,20,30,40,50,60,70], [100,200,300,400,500,600,700])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    \"\"\"\n    # Ensure all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    # Interleave the lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.extend([list1[i], list2[i], list3[i]])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if all lists have the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length\")\n    \n    # Interleave the lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if all lists have the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length\")\n    \n    # Interleave the lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if all lists have the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length\")\n    \n    # Interleave the lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if all lists have the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length\")\n    \n    # Interleave the lists\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Parameters:\n    - list1 (list): The first list to interleave.\n    - list2 (list): The second list to interleave.\n    - list3 (list): The third list to interleave.\n\n    Returns:\n    - list: A single list containing elements from list1, list2, and list3 interleaved.\n\n    Example:\n    >>> list1 = [1,2,3,4,5,6,7]\n    >>> list2 = [10,20,30,40,50,60,70]\n    >>> list3 = [100,200,300,400,500,600,700]\n    >>> interleave_lists(list1, list2, list3)\n    [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    # Interleave the lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length\")\n    \n    # Interleave the lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n    list1: The first list to interleave.\n    list2: The second list to interleave.\n    list3: The third list to interleave.\n\n    Returns:\n    A list containing elements from list1, list2, and list3 interleaved.\n\n    Example:\n    >>> interleave_lists([1,2,3,4,5,6,7],[10,20,30,40,50,60,70],[100,200,300,400,500,600,700])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Parameters:\n    list1 (list): The first list to interleave.\n    list2 (list): The second list to interleave.\n    list3 (list): The third list to interleave.\n    \n    Returns:\n    list: A single list containing elements from list1, list2, and list3 interleaved.\n    \n    Example:\n    >>> interleave_lists([1,2,3,4,5,6,7], [10,20,30,40,50,60,70], [100,200,300,400,500,600,700])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    \"\"\"\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    return interleaved", "matching_cluster_idx": 6}]}, "Mbpp/586": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/587": {"dps": null, "dps_norm": null, "pass@1": 8.0, "profiled": []}, "Mbpp/588": {"dps": 79.93119266055047, "dps_norm": 94.16666666666667, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(nums):\n    if not nums:\n        return 0  # or perhaps raise an error, depending on desired behavior\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a list.\n\n    Parameters:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The difference between the largest and smallest integer in the list.\n    \"\"\"\n    if not nums:  # Check if the list is empty\n        return 0  # or raise an exception based on requirements\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        return 0  # Assuming difference is 0 for empty list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n\n    :param nums: List of integers\n    :return: Difference between the largest and smallest integer in the list\n\n    >>> big_diff([10, 3, 5, 6])\n    7\n    >>> big_diff([7, 7, 7])\n    0\n    >>> big_diff([1, 2, 3, 4])\n    3\n    \"\"\"\n    if not nums:\n        return 0  # or raise an exception if preferred\n\n    max_val = nums[0]\n    min_val = nums[0]\n\n    for num in nums:\n        if num > max_val:\n            max_val = num\n        elif num < min_val:\n            min_val = num\n\n    return max_val - min_val", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    if not nums:\n        return 0  # or perhaps raise an error, but 0 is a common choice for empty lists\n    max_val = nums[0]\n    min_val = nums[0]\n    for num in nums:\n        if num > max_val:\n            max_val = num\n        elif num < min_val:\n            min_val = num\n    return max_val - min_val", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    # Assuming that the list has at least one number\n    # Find the minimum and maximum values in the list\n    min_val = min(nums)\n    max_val = max(nums)\n    \n    # Calculate the difference\n    difference = max_val - min_val\n    \n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        return 0\n    min_val = float('inf')\n    max_val = -float('inf')\n    for num in nums:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n    return max_val - min_val", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    if not nums:\n        return 0  # or perhaps raise an error, depending on requirements\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # First, we need to find the largest and smallest values in the list.\n    # We can use the built-in max and min functions for this purpose.\n    max_value = max(nums)\n    min_value = min(nums)\n    \n    # Then, calculate the difference between the largest and smallest values.\n    difference = max_value - min_value\n    \n    # Finally, return the difference.\n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n\n    Parameters:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The difference between the largest and smallest integer in the list.\n\n    Example:\n    assert big_diff([1,2,3,4]) == 3\n    \"\"\"\n    if not nums:  # Check if the list is empty\n        return 0  # or raise an exception, depending on requirements\n    max_val = max(nums)\n    min_val = min(nums)\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Ensure the list has at least one element\n    if not nums:\n        raise ValueError(\"List must contain at least one element.\")\n    \n    # Initialize variables to store the smallest and largest values\n    min_val = nums[0]\n    max_val = nums[0]\n    \n    # Iterate through the list to find the min and max values\n    for num in nums:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    \n    # Calculate the difference\n    difference = max_val - min_val\n    return difference", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    \"\"\"\n    This function finds the difference between the largest and smallest values in a given list.\n    \n    Parameters:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The difference between the largest and smallest integers in the list.\n    \"\"\"\n    if not nums:\n        return 0  # Return 0 for an empty list\n    \n    max_val = nums[0]\n    min_val = nums[0]\n    \n    for num in nums:\n        if num > max_val:\n            max_val = num\n        elif num < min_val:\n            min_val = num\n    \n    return max_val - min_val", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    if not nums:\n        return 0  # or perhaps raise an error, depending on requirements\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    This function finds the difference between the largest and smallest value in a given list of numbers.\n    \"\"\"\n    # Check if the list is empty\n    if not nums:\n        return 0  # or raise an error, depending on requirements\n\n    # Initialize variables to store the smallest and largest values\n    smallest = largest = nums[0]\n\n    # Iterate through the list starting from the second element\n    for num in nums[1:]:\n        if num < smallest:\n            smallest = num\n        elif num > largest:\n            largest = num\n\n    # Calculate the difference\n    difference = largest - smallest\n    return difference", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Find the difference between largest and smallest value in a given list.\n\n    :param nums: List of integers.\n    :return: Difference between the largest and smallest integer in the list.\n    \"\"\"\n    if not nums:\n        return 0  # or raise an exception, depending on the desired behavior for empty lists\n    max_val = max(nums)\n    min_val = min(nums)\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        return 0  # or perhaps raise an error, depending on desired behavior\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Computes the difference between the largest and smallest value in a given list.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The difference between the largest and smallest integer in the list.\n\n    Examples:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    >>> big_diff([4, 3, 2, 1])\n    3\n    >>> big_diff([100])\n    0\n    \"\"\"\n    if not nums:\n        raise ValueError(\"List must contain at least one number.\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The difference between the largest and smallest integer in the list.\n\n    Examples:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    >>> big_diff([10, 3, 5, 6])\n    7\n    >>> big_diff([1])\n    0\n    \"\"\"\n    if not nums:  # Check if the list is empty\n        return 0  # or raise an exception, depending on requirements\n\n    max_val = nums[0]\n    min_val = nums[0]\n\n    for num in nums:\n        if num > max_val:\n            max_val = num\n        elif num < min_val:\n            min_val = num\n\n    return max_val - min_val", "matching_cluster_idx": 4}]}, "Mbpp/592": {"dps": 65.33333333333334, "dps_norm": 54.0, "pass@1": 45.0, "profiled": [{"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given integer n.\n    \n    The binomial coefficient, denoted as C(n, k), is the number of ways to choose k elements from a set of n elements.\n    This function computes the sum of the product of consecutive binomial coefficients for k ranging from 0 to n-1.\n    \n    The formula being implemented is:\n    sum_{k=0}^{n-1} [C(n, k) * C(n, k+1)]\n    \n    Args:\n        n (int): The number of elements in the set.\n    \n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    \n    total_sum = 0\n    for k in range(n):\n        term = math.comb(n, k) * math.comb(n, k + 1)\n        total_sum += term\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n):\n    if n < 1:\n        return 0\n    total = 0\n    for k in range(n + 1):\n        total += math.comb(n, k) * math.comb(n, k + 1) if k + 1 <= n else math.comb(n, k) * 0\n    return total", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    sum = 0\n    for k in range(n + 1):\n        sum += math.comb(n, k) * math.comb(n, k + 1) if k + 1 <= n else math.comb(n, k) * 0\n    return sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n    \n    total_sum = 0\n    for k in range(n + 1):\n        term = math.comb(n, k) * math.comb(n, k + 1) if k + 1 <= n else 0\n        total_sum += term\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    import math\n    sum = 0\n    for k in range(0, n+1):\n        sum += math.comb(n, k) * math.comb(n, k+1)\n    return sum", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    import math\n    sum_product = 0\n    for k in range(n+1):\n        sum_product += math.comb(n, k) * math.comb(n, k+1)\n    return sum_product", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    The binomial coefficient for a given n and k is denoted as C(n, k).\n    This function computes the sum of products C(n, k) * C(n, k+1) for k from 0 to n-1.\n    \n    Parameters:\n    - n: integer, the number of elements in the binomial coefficient.\n    \n    Returns:\n    - sum_product: integer, the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n    sum_product = 0\n    for k in range(n):\n        sum_product += comb(n, k) * comb(n, k+1)\n    return sum_product", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    import math\n    sum = 0\n    for k in range(n+1):\n        sum += math.comb(n, k) * math.comb(n, k+1)\n    return sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Function to calculate the sum of the product of consecutive binomial coefficients.\n    The binomial coefficient for a given n and k is C(n, k), and the product of consecutive\n    coefficients is C(n, k) * C(n, k+1). This function sums these products for k from 0 to n-1.\n\n    :param n: int - the number of terms and the upper limit for binomial coefficients\n    :return: int - the sum of the product of consecutive binomial coefficients\n\n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    from math import comb\n    total = 0\n    for k in range(n):\n        total += comb(n, k) * comb(n, k + 1)\n    return total", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given integer n.\n    \n    The binomial coefficient, denoted as C(n, k), is the number of ways to choose k elements from a set of n elements.\n    This function computes the sum of the product of C(n, k) and C(n, k+1) for k from 0 to n-1.\n    \n    Parameters:\n    n (int): A non-negative integer representing the number of elements in the set.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        C_n_k = math.comb(n, k)\n        C_n_k1 = math.comb(n, k+1)\n        total_sum += C_n_k * C_n_k1\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    from math import comb\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) * comb(n, k + 1)\n    return total", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    from math import comb\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) * comb(n, k + 1)\n    return total", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Function to calculate the sum of the product of consecutive binomial coefficients.\n    The binomial coefficient for a given n and k is C(n, k), and this function calculates\n    the sum of products C(n, k) * C(n, k+1) for k from 0 to n-1.\n    \n    Parameters:\n    n (int): The number of terms to consider for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    # Importing math to use factorial function\n    import math\n    \n    # Function to calculate binomial coefficient\n    def binom(n, k):\n        return math.comb(n, k)\n    \n    # Initialize sum\n    total_sum = 0\n    \n    # Calculate sum of product of consecutive binomial coefficients\n    for k in range(n):\n        total_sum += binom(n, k) * binom(n, k + 1)\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    from math import comb\n    sum_product = 0\n    for k in range(n+1):\n        sum_product += comb(n, k) * comb(n, k+1)\n    return sum_product", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given integer n.\n    \n    The binomial coefficient, denoted as C(n, k), is the number of ways to choose k elements from a set of n elements.\n    This function computes the sum of the product of consecutive binomial coefficients for k ranging from 0 to n-1.\n    \n    The formula for the sum is:\n    sum_{k=0}^{n-1} C(n, k) * C(n, k+1)\n    \n    Parameters:\n    - n: An integer representing the number of elements in the set.\n    \n    Returns:\n    - An integer representing the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    \n    # Import the math module to use the comb function for binomial coefficients\n    import math\n    \n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate from k = 0 to k = n-1\n    for k in range(n):\n        # Calculate C(n, k) and C(n, k+1)\n        coeff1 = math.comb(n, k)\n        coeff2 = math.comb(n, k+1)\n        \n        # Add the product of the coefficients to the total sum\n        total_sum += coeff1 * coeff2\n    \n    # Return the total sum\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Args:\n        n (int): The upper limit for the binomial coefficients.\n        \n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    # Initialize the sum\n    total_sum = 0\n    # Calculate the sum of product of consecutive binomial coefficients\n    for k in range(n+1):\n        # Calculate binomial coefficient for k and k+1\n        if k < n:\n            term = factorial(n, k) * factorial(n, k+1)\n        else:\n            term = factorial(n, k) * 0  # When k+1 exceeds n, consider it as 0\n        total_sum += term\n    return total_sum\ndef factorial(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k).\n    \n    Args:\n        n (int): The total number of items.\n        k (int): The number of items to choose.\n        \n    Returns:\n        int: The binomial coefficient C(n, k).\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    num = den = 1\n    for i in range(1, k+1):\n        num *= n - (k - i)\n        den *= i\n    return num // den", "matching_cluster_idx": 1}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Args:\n    n (int): The upper limit for binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) * comb(n, k + 1) if k + 1 <= n else comb(n, k) * 0\n    return total", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Function to calculate the sum of the product of consecutive binomial coefficients.\n    \n    The binomial coefficient for a given n and k is C(n, k), and this function\n    computes the sum of products C(n, k) * C(n, k+1) for k from 0 to n-1.\n    \n    Parameters:\n    n (int): The number of terms to consider in the sum.\n    \n    Returns:\n    int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    from math import comb\n    sum_product = sum(comb(n, k) * comb(n, k+1) for k in range(n))\n    return sum_product", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    The binomial coefficient, denoted as C(n, k), is the number of ways to choose k elements from a set of n elements.\n    This function computes the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Parameters:\n    n (int): The number of elements in the set.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    sum_product = 0\n    for k in range(n + 1):\n        C_n_k = math.comb(n, k)\n        if k < n:\n            C_n_k1 = math.comb(n, k + 1)\n            product = C_n_k * C_n_k1\n            sum_product += product\n    return sum_product", "matching_cluster_idx": 4}]}, "Mbpp/597": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 17.0, "profiled": [{"solution": "def find_kth(arr1, arr2, k):\n    # Combine the two sorted arrays into one sorted array\n    merged = sorted(arr1 + arr2)\n    # Find the kth element (1-based index)\n    if k <= len(merged):\n        return merged[k - 1]\n    else:\n        raise IndexError(\"k is out of bounds for the merged array\")", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the k-th smallest element from the combination of two sorted arrays.\n\n    Parameters:\n    arr1 (List[int]): First sorted array.\n    arr2 (List[int]): Second sorted array.\n    k (int): The k-th position to find (1-based index).\n\n    Returns:\n    int: The k-th smallest element.\n\n    Raises:\n    IndexError: If k is out of bounds for the combined arrays.\n\n    Examples:\n    >>> find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5)\n    6\n    >>> find_kth([1, 2], [3, 4], 2)\n    2\n    >>> find_kth([1, 5], [2, 3, 4], 4)\n    5\n    \"\"\"\n    # Merge the two arrays\n    merged = sorted(arr1 + arr2)\n    \n    # Check if k is within bounds\n    if k < 1 or k > len(merged):\n        raise IndexError(\"k is out of bounds for the combined arrays.\")\n    \n    # Return the k-th element (1-based index)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Combine the two sorted arrays into one sorted array\n    combined = sorted(arr1 + arr2)\n    # Find the kth element (1-based indexing)\n    if k <= len(combined):\n        return combined[k - 1]\n    else:\n        raise IndexError(\"k is larger than the combined array length\")", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Combine the two sorted arrays into one sorted array\n    merged = sorted(arr1 + arr2)\n    # Return the kth element (1-based index)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Combine the two sorted arrays into one sorted array\n    combined = sorted(arr1 + arr2)\n    # Find the kth element (1-based index)\n    if k <= len(combined):\n        return combined[k - 1]\n    else:\n        raise IndexError(\"k is out of bounds for the combined array\")", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Concatenate the two sorted arrays\n    merged = sorted(arr1 + arr2)\n    # Return the kth element (1-based index)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from the combination of two sorted arrays.\n\n    Args:\n    arr1: First sorted array.\n    arr2: Second sorted array.\n    k: The kth position to find (1-based index).\n\n    Returns:\n    The kth element from the combined array.\n\n    Approach:\n    - Merge the two sorted arrays into one sorted array.\n    - Return the element at the kth position.\n\n    Complexity:\n    - Time: O(n + m), where n and m are the lengths of arr1 and arr2.\n    - Space: O(n + m), for the merged array.\n    \"\"\"\n    merged = sorted(arr1 + arr2)\n    if k <= len(merged):\n        return merged[k - 1]\n    else:\n        raise IndexError(\"k is out of bounds for the combined array.\")", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Finds the k-th smallest element from the combined elements of two sorted arrays.\n\n    Parameters:\n    arr1 (list of int): First sorted array.\n    arr2 (list of int): Second sorted array.\n    k (int): The k-th position to find the element (1-based index).\n\n    Returns:\n    int: The k-th smallest element from the two arrays.\n\n    Raises:\n    IndexError: If k is out of bounds for the combined arrays.\n\n    Example:\n    >>> find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5)\n    6\n    \"\"\"\n    # Merge the two arrays into one sorted array\n    merged = sorted(arr1 + arr2)\n    \n    # Check if k is within the bounds of the merged array\n    if k <= 0 or k > len(merged):\n        raise IndexError(\"k is out of bounds for the combined arrays.\")\n    \n    # Return the k-th smallest element (1-based index)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Combine the two sorted arrays into one sorted array\n    merged = sorted(arr1 + arr2)\n    # Check if k is within the bounds of the merged array\n    if k <= len(merged):\n        # Return the kth element (1-based indexing)\n        return merged[k - 1]\n    else:\n        # If k is larger than the combined length, return None or an appropriate value\n        return None", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Finds the k-th smallest element from the combined elements of two sorted arrays.\n\n    Args:\n    arr1 (List[int]): First sorted array.\n    arr2 (List[int]): Second sorted array.\n    k (int): The k-th position to find the element (1-based index).\n\n    Returns:\n    int: The k-th smallest element.\n\n    \"\"\"\n    # Merge the two arrays\n    merged = sorted(arr1 + arr2)\n    \n    # Adjust for 0-based indexing\n    k -= 1\n    \n    # Check if k is within the bounds of the merged array\n    if k < len(merged):\n        return merged[k]\n    else:\n        raise IndexError(\"k is out of bounds of the merged array.\")", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two sorted arrays\n    merged = sorted(arr1 + arr2)\n    # Find the kth element (1-based index)\n    if k <= len(merged):\n        return merged[k - 1]\n    else:\n        raise IndexError(\"k is out of bounds for the merged array\")", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two sorted arrays\n    merged = sorted(arr1 + arr2)\n    # Find the kth element\n    if k > len(merged):\n        return None  # k is larger than the combined array length\n    else:\n        # Arrays are 0-indexed in Python, so k-1\n        return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Concatenate the two sorted arrays\n    merged = sorted(arr1 + arr2)\n    # Check if k is within the bounds of the merged array\n    if k <= len(merged):\n        # Return the kth element (1-based indexing)\n        return merged[k - 1]\n    else:\n        # If k is larger than the combined length, return None or an appropriate value\n        return None", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # combine the two sorted arrays into one sorted array\n    combined = sorted(arr1 + arr2)\n    # return the kth element (considering 1-based indexing)\n    return combined[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two arrays into one sorted array\n    merged = sorted(arr1 + arr2)\n    # Get the kth element (1-based indexing)\n    if k <= len(merged):\n        return merged[k - 1]\n    else:\n        raise IndexError(\"k is out of bounds for the merged array\")", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Combine the two sorted arrays into one sorted array\n    merged = sorted(arr1 + arr2)\n    # Get the kth element (considering k starts from 1)\n    if 1 <= k <= len(merged):\n        return merged[k-1]\n    else:\n        raise IndexError(\"k is out of bounds for the merged array\")", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two arrays\n    merged = sorted(arr1 + arr2)\n    # Get the kth element\n    if k > len(merged):\n        return None  # k is larger than the combined array length\n    else:\n        return merged[k - 1]  # Arrays are zero-indexed", "matching_cluster_idx": 3}]}, "Mbpp/604": {"dps": 52.27272727272727, "dps_norm": 90.0, "pass@1": 96.0, "profiled": [{"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 3}, {"solution": "def reverse_words(sentence):\n    # Split the sentence into words based on spaces\n    words = sentence.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list back into a string with spaces\n    reversed_sentence = ' '.join(reversed_words)\n    \n    return reversed_sentence", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 3}, {"solution": "def reverse_words(string: str) -> str:\n    words = string.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence: str) -> str:\n    words = sentence.split()  # split the sentence into words\n    reversed_words = words[::-1]  # reverse the list of words\n    reversed_sentence = ' '.join(reversed_words)  # join them back into a string\n    return reversed_sentence", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    words = sentence.split()\n    reversed_words = words[::-1]\n    reversed_sentence = \" \".join(reversed_words)\n    return reversed_sentence", "matching_cluster_idx": 3}, {"solution": "def reverse_words(string):\n    words = string.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    words = s.split()\n    words.reverse()\n    reversed_string = ' '.join(words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    # Split the input string by spaces\n    words = input_string.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string with spaces\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 3}]}, "Mbpp/610": {"dps": 62.86231884057972, "dps_norm": 62.142857142857146, "pass@1": 77.0, "profiled": [{"solution": "def remove_kth_element(lst, k=2):\n    \"\"\"\n    Removes the k'th element from a list.\n\n    Parameters:\n    - lst: List from which the element is to be removed.\n    - k: The 1-based index of the element to remove.\n\n    Returns:\n    - A new list with the k'th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=2):\n    if k < 1:\n        raise ValueError(\"k must be greater than or equal to 1\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=1):\n    \"\"\"\n    Function to remove the k'th element from a list.\n\n    Parameters:\n    lst (list): The input list from which the k'th element is to be removed.\n    k (int): The position of the element to remove. Defaults to 1.\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Examples:\n    >>> remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        raise IndexError(\"k is out of bounds for the list.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=2):\n    # Create a copy of the list to avoid modifying the original list\n    result = lst.copy()\n    # Remove the k'th element\n    if 1 <= k <= len(result):\n        del result[k-1]\n    return result", "matching_cluster_idx": 4}, {"solution": "def remove_kth_element(lst, k=1):\n    if k < 1 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=1):\n    \"\"\"\n    Takes a list and returns a list with the same elements, but the k'th element removed.\n    \n    :param lst: List of elements.\n    :param k: The 1-based index of the element to remove.\n    :return: A new list with the k'th element removed.\n    \n    Example:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1],3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=1):\n    if k <= 0 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=2):\n    if k <= 0:\n        raise ValueError(\"k must be a positive integer\")\n    if k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=2):\n    \"\"\"\n    This function takes a list and an integer k, and returns a new list with the k'th element removed.\n    \n    Parameters:\n    lst (list): The input list from which an element will be removed.\n    k (int): The index of the element to remove (1-based index).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \n    Example:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1],3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds for the list.\")\n    # Adjust for 0-based indexing\n    k -= 1\n    return lst[:k] + lst[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=2):\n    \"\"\"\n    Remove the k'th element from a list.\n\n    Parameters:\n    lst (list): The input list from which an element will be removed.\n    k (int): The index of the element to remove (1-based index).\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Examples:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1],3)\n    [1, 1, 3, 4, 4, 5, 1]\n    >>> remove_kth_element([1,2,3,4],1)\n    [2, 3, 4]\n    >>> remove_kth_element([1],1)\n    []\n    >>> remove_kth_element([1,2,3],4)\n    'Index out of range'\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return 'Index out of range'\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=2):\n    if k < 1:\n        return lst\n    try:\n        del lst[k-1]\n    except IndexError:\n        pass\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k=2):\n    \"\"\"\n    Remove the k'th element from a list.\n\n    Parameters:\n    lst (list): The input list.\n    k (int): The position of the element to remove (1-based index).\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Examples:\n    >>> remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    >>> remove_kth_element([1, 2, 3, 4], 1)\n    [2, 3, 4]\n    >>> remove_kth_element([1, 2, 3, 4], 5)\n    [1, 2, 3, 4]\n    >>> remove_kth_element([], 1)\n    []\n    \"\"\"\n    if not lst or k <= 0 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=2):\n    if k < 1:\n        raise ValueError(\"k must be greater than or equal to 1\")\n    if k > len(lst):\n        raise IndexError(\"list index out of range\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=2):\n    \"\"\"\n    Remove the k'th element from a list.\n\n    Parameters:\n    lst (list): The input list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=2):\n    if k < 1:\n        raise ValueError(\"k must be greater than or equal to 1\")\n    if k > len(lst):\n        return lst  # k is larger than the list length, so no removal occurs\n\n    # Create a new list without the k'th element\n    result = lst[:k-1] + lst[k:]\n    return result", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=2):\n    if k < 1:\n        raise ValueError(\"k must be greater than or equal to 1\")\n    if k > len(lst):\n        return lst  # k is larger than the list length, so no removal occurs\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=2):\n    if k < 1 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=2):\n    \"\"\"\n    Remove the k'th element from a list.\n\n    Parameters:\n    lst (list): The input list.\n    k (int): The position of the element to remove (1-based index).\n\n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n\n    # Check if k is within the range of the list's length\n    if k > 0 and k <= len(lst):\n        # Remove the k'th element (adjusting for 0-based index)\n        del lst[k - 1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k=1):\n    \"\"\"\n    Remove the k'th element from a list.\n\n    Args:\n    lst: List from which to remove element.\n    k: Position of the element to remove, 1-based index.\n\n    Returns:\n    A new list with the k'th element removed.\n\n    Raises:\n    IndexError: If k is out of bounds.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k=2):\n    \"\"\"\n    This function takes a list and an integer k as input and returns a new list with the k'th element removed.\n    \n    Parameters:\n    lst (list): The input list from which the k'th element will be removed.\n    k (int): The position of the element to remove. Default is 2.\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    else:\n        # Remove the k'th element by slicing the list\n        return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": 81.28834355828221, "dps_norm": 95.0, "pass@1": 49.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function takes a matrix represented as a list of lists and an integer n,\n    and returns the maximum value of the nth column in the matrix.\n    \n    :param matrix: List of lists, where each inner list represents a row in the matrix.\n    :param n: Integer representing the column index (0-based).\n    :return: The maximum value in the nth column.\n    \n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    # Extract the nth element from each row\n    nth_column = [row[n] for row in matrix]\n    # Return the maximum value from the nth column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n'th column in a matrix.\n    \n    Args:\n    matrix (list of lists): The matrix to search.\n    n (int): The column index to find the maximum value in.\n    \n    Returns:\n    int: The maximum value in the n'th column.\n    \n    Raises:\n    IndexError: If the column index is out of range.\n    ValueError: If the matrix is empty or rows have varying lengths.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"Matrix is empty.\")\n    \n    for row in matrix:\n        if not isinstance(row, list):\n            raise ValueError(\"Matrix must be a list of lists.\")\n        if len(row) <= n:\n            raise IndexError(f\"Column index {n} is out of range.\")\n    \n    max_value = matrix[0][n]\n    for row in matrix:\n        if row[n] > max_value:\n            max_value = row[n]\n    return max_value", "matching_cluster_idx": 4}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Find the maximum value in the nth column of a matrix.\n\n    Args:\n    matrix: A list of lists, where each inner list represents a row in the matrix.\n    n: The index of the column (0-based) for which to find the maximum value.\n\n    Returns:\n    The maximum value found in the nth column.\n\n    Raises:\n    IndexError: If the matrix does not have any rows or if any row is too short to have an nth element.\n\n    Examples:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    >>> max_of_nth([[1, 2], [3, 4], [5, 6]], 1)\n    6\n    >>> max_of_nth([[10]], 0)\n    10\n    \"\"\"\n    if not matrix:\n        raise IndexError(\"Matrix has no rows.\")\n\n    max_value = matrix[0][n]\n    for row in matrix:\n        if len(row) <= n:\n            raise IndexError(f\"Row {row} is too short to have an nth element.\")\n        if row[n] > max_value:\n            max_value = row[n]\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function takes a matrix (list of lists) and an integer n, and returns the maximum value in the nth column of the matrix.\n    \"\"\"\n    try:\n        # Extract the nth element from each row and find the maximum\n        return max(row[n] for row in matrix)\n    except IndexError:\n        # If n is larger than the number of columns in any row\n        raise ValueError(\"Column index is out of range\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Check if the matrix is empty\n    if not matrix:\n        return None  # or raise an exception\n    # Check if n is within the bounds of the matrix\n    if n >= len(matrix[0]):\n        return None  # or raise an exception\n    # Extract the nth column\n    column = [row[n] for row in matrix]\n    # Return the maximum value in the column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the maximum value of the n'th column.\n    \n    Parameters:\n    matrix (list of lists): The matrix from which to find the maximum value.\n    n (int): The index of the column from which to find the maximum value.\n    \n    Returns:\n    int or float: The maximum value in the n'th column of the matrix.\n    \n    Raises:\n    IndexError: If the matrix does not have enough columns.\n    ValueError: If the matrix is empty or the columns are not of equal length.\n    \"\"\"\n    \n    # Check if the matrix is empty\n    if not matrix:\n        raise ValueError(\"Matrix is empty.\")\n    \n    # Check if all rows have the same number of columns\n    row_length = len(matrix[0])\n    if any(len(row) != row_length for row in matrix):\n        raise ValueError(\"Matrix columns are not of equal length.\")\n    \n    # Check if the requested column index is within range\n    if n >= row_length:\n        raise IndexError(\"Matrix does not have an n'th column.\")\n    \n    # Extract the n'th column and find the maximum value\n    column = [row[n] for row in matrix]\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function receives a matrix represented as a list of lists and an integer n.\n    It returns the maximum value of the n'th column in the matrix.\n    \n    :param matrix: List of lists, where each inner list represents a row in the matrix.\n    :param n: Integer, the index of the column (0-based) for which the maximum value is to be found.\n    :return: The maximum value in the n'th column.\n    \n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    # Extract the n'th element from each row\n    nth_column = [row[n] for row in matrix]\n    # Find and return the maximum value in the n'th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value from the n-th column of a matrix.\n    \n    :param matrix: List of lists, where each inner list represents a row in the matrix.\n    :param n: Integer, the index of the column from which to find the maximum value.\n    :return: The maximum value found in the n-th column.\n    \n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    # Extract the n-th element from each row\n    column = [row[n] for row in matrix]\n    # Find and return the maximum value in the column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the maximum value of the nth column.\n    \n    Parameters:\n    matrix (list of lists): The matrix from which to find the maximum value.\n    n (int): The index of the column to consider (0-based index).\n    \n    Returns:\n    int or float: The maximum value in the nth column of the matrix.\n    \n    Raises:\n    IndexError: If the matrix does not have enough columns.\n    ValueError: If the matrix is empty or rows have varying lengths.\n    \"\"\"\n    \n    # Check if the matrix is empty\n    if not matrix:\n        raise ValueError(\"Matrix is empty.\")\n    \n    # Check if all rows have the same length\n    row_length = len(matrix[0])\n    if not all(len(row) == row_length for row in matrix):\n        raise ValueError(\"Rows have varying lengths.\")\n    \n    # Check if the requested column index is valid\n    if n >= row_length:\n        raise IndexError(\"Matrix does not have an nth column.\")\n    \n    # Extract the nth column and find the maximum value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Return the maximum value of the n-th column in a matrix.\n    \n    Args:\n    matrix (list of lists): The matrix to search.\n    n (int): The column index to find the maximum value in.\n    \n    Returns:\n    int: The maximum value in the n-th column.\n    \n    Raises:\n    IndexError: If the column index is out of range.\n    ValueError: If the matrix is empty or rows have inconsistent lengths.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"Matrix is empty.\")\n    \n    for row in matrix:\n        if not isinstance(row, list):\n            raise ValueError(\"Matrix contains non-list row.\")\n        if len(row) <= n:\n            raise IndexError(f\"Column index {n} is out of range.\")\n    \n    return max(row[n] for row in matrix)", "matching_cluster_idx": 4}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n'th column in a given matrix.\n    \n    Parameters:\n    matrix (list of lists): The matrix from which to find the maximum value.\n    n (int): The index of the column to consider (0-based index).\n    \n    Returns:\n    int: The maximum value in the n'th column.\n    \n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    # Extract the n'th element from each row\n    nth_column = [row[n] for row in matrix]\n    # Find the maximum value in the n'th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the maximum value of the n'th column.\n    \n    Args:\n    matrix: List of lists, where each inner list represents a row in the matrix.\n    n: Integer, the index of the column for which to find the maximum value.\n    \n    Returns:\n    The maximum value in the n'th column of the matrix.\n    \n    Assumes that:\n    - The matrix is non-empty.\n    - All rows in the matrix have at least n+1 elements.\n    - The elements in the n'th column are comparable (can be compared using max()).\n    \n    Examples:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    # Extract the n'th element from each row\n    column = [row[n] for row in matrix]\n    # Find and return the maximum value in the column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Check if the matrix is not empty and n is within the range of columns\n    if not matrix or n >= len(matrix[0]):\n        return None  # or raise an error, depending on how you want to handle invalid inputs\n    # Use a list comprehension to extract the nth element from each row\n    nth_column = [row[n] for row in matrix]\n    # Return the maximum value from the list\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the nth column in a matrix.\n    \n    Args:\n        matrix (list of lists): The matrix to search.\n        n (int): The column index to find the maximum value in.\n        \n    Returns:\n        int or float: The maximum value in the nth column.\n        \n    Raises:\n        IndexError: If the matrix does not have enough columns.\n        TypeError: If the input matrix is not a list of lists.\n    \"\"\"\n    if not all(isinstance(row, list) for row in matrix):\n        raise TypeError(\"Input matrix must be a list of lists.\")\n    if not all(len(row) > n for row in matrix):\n        raise IndexError(f\"Matrix does not have an nth column at index {n}.\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 3}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, return the maximum value of the nth column.\n\n    Args:\n    matrix (list of lists): The matrix from which to find the max value.\n    n (int): The column index for which to find the max value.\n\n    Returns:\n    int or float: The maximum value in the nth column of the matrix.\n\n    Raises:\n    IndexError: If n is out of bounds for the matrix columns.\n    ValueError: If the matrix is empty or not properly formatted.\n    \"\"\"\n\n    # Check if the matrix is empty\n    if not matrix:\n        raise ValueError(\"Matrix is empty\")\n\n    # Check if n is within the bounds of the matrix columns\n    if not all(len(row) > n for row in matrix):\n        raise IndexError(\"Column index is out of bounds\")\n\n    # Extract the nth element from each row and find the max\n    max_value = max(row[n] for row in matrix)\n\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, return the maximum value in the nth column.\n\n    Args:\n    matrix: List of lists, where each inner list represents a row in the matrix.\n    n: Integer, the index of the column to find the maximum value in (0-based index).\n\n    Returns:\n    The maximum value in the nth column of the matrix.\n\n    Raises:\n    IndexError: If n is out of bounds for the columns in the matrix.\n    ValueError: If the matrix is empty or not properly formed.\n\n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    if not matrix or not all(isinstance(row, list) for row in matrix):\n        raise ValueError(\"Matrix must be a non-empty list of lists.\")\n\n    if not all(len(row) > n for row in matrix):\n        raise IndexError(\"Column index is out of bounds for the matrix.\")\n\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 3}, {"solution": "def max_of_nth(matrix, n):\n    # Check if the matrix is empty or n is out of range\n    if not matrix or n >= len(matrix[0]):\n        return None  # or raise an exception, depending on requirements\n    # Extract the nth column and find the maximum value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the maximum value of the nth column.\n    \n    Parameters:\n    - matrix: List of lists, where each inner list represents a row in the matrix.\n    - n: Integer, the index of the column for which to find the maximum value.\n    \n    Returns:\n    - The maximum value found in the nth column of the matrix.\n    \n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    # Extract the nth element from each row\n    column = [row[n] for row in matrix]\n    # Find and return the maximum value in the column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value from the n-th column of a matrix.\n    \n    Parameters:\n    matrix (list of lists): A 2D list representing the matrix.\n    n (int): The index of the column to find the maximum value in.\n    \n    Returns:\n    int: The maximum value in the n-th column.\n    \n    Raises:\n    IndexError: If the matrix doesn't have enough columns.\n    \"\"\"\n    if not all(len(row) > n for row in matrix):\n        raise IndexError(\"Matrix does not have enough columns.\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 53.40277777777777, "dps_norm": 58.125, "pass@1": 21.0, "profiled": [{"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n\n    :param text: The input string to process.\n    :type text: str\n    :return: The modified string with whitespaces and underscores swapped.\n    :rtype: str\n\n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Hello World')\n    'Hello_World'\n    >>> replace_spaces('Python_Programming')\n    'Python Programming'\n    >>> replace_spaces('Replace   spaces and  _underscores')\n    'Replace___spaces_and__underscores'\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = text.replace(' ', '\u00a7')\n    # Replace underscores with spaces\n    temp = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    return temp.replace('\u00a7', '_')", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n    \n    :param s: str - the input string to process.\n    :return: str - the string with spaces and underscores swapped.\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = s.replace(' ', '\u00a7')\n    # Replace underscores with spaces\n    temp = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    return temp.replace('\u00a7', '_')", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n\n    :param s: Input string containing spaces and/or underscores.\n    :return: Modified string with spaces and underscores swapped.\n\n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = s.replace(' ', 'TEMP')\n    # Replace underscores with spaces\n    temp = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    result = temp.replace('TEMP', '_')\n    return result", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n    s (str): The input string to process.\n\n    Returns:\n    str: The string with whitespaces and underscores swapped.\n\n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Jumanji_The_Jungle')\n    'Jumanji The Jungle'\n    >>> replace_spaces('Replace   spaces and  _underscores')\n    'Replace___spaces_and__underscores'\n    >>> replace_spaces('NoSpacesOrUnderscores')\n    'NoSpacesOrUnderscores'\n    >>> replace_spaces('Mixed spaces_and   underscores')\n    'Mixed_spaces and   underscores'\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = s.replace(' ', '\u00a7')\n    # Replace underscores with spaces\n    temp = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    return temp.replace('\u00a7', '_')", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n\n    :param s: The input string to be modified.\n    :type s: str\n    :return: The modified string with whitespaces and underscores swapped.\n    :rtype: str\n    \"\"\"\n    # Replace underscores with a placeholder that's unlikely to appear in the string\n    placeholder = 'uniqueplaceholder'\n    s = s.replace('_', placeholder)\n    \n    # Replace spaces with underscores\n    s = s.replace(' ', '_')\n    \n    # Replace the placeholder with spaces\n    s = s.replace(placeholder, ' ')\n    \n    return s", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n    :param s: str - input string containing spaces and/or underscores\n    :return: str - modified string with spaces and underscores swapped\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = s.replace(' ', '$temp$')\n    # Replace underscores with spaces\n    result = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    final_result = result.replace('$temp$', '_')\n    return final_result", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n    s (str): The input string to be modified.\n\n    Returns:\n    str: The modified string with whitespaces replaced by underscores and underscores replaced by whitespaces.\n    \"\"\"\n    # Replace spaces with temporary placeholder to avoid overwriting issues\n    temp = s.replace(' ', '\u00a7')\n    # Replace underscores with spaces\n    temp = temp.replace('_', ' ')\n    # Replace temporary placeholder with underscores\n    result = temp.replace('\u00a7', '_')\n    return result", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n\n    Args:\n    text (str): The string in which replacements need to be made.\n\n    Returns:\n    str: The modified string with replacements.\n\n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = text.replace(' ', '\u00a7')\n    # Replace underscores with spaces\n    temp = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    result = temp.replace('\u00a7', '_')\n    return result", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n\n    Parameters:\n    text (str): The input string to process.\n\n    Returns:\n    str: The modified string with whitespaces and underscores swapped.\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = text.replace(' ', '$temp$')\n    # Replace underscores with spaces\n    modified = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    final = modified.replace('$temp$', '_')\n    return final", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string: str) -> str:\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Parameters:\n    input_string (str): The string to be modified.\n\n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = input_string.replace(' ', '\u00a7')\n    # Replace underscores with spaces\n    temp = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    return temp.replace('\u00a7', '_')", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n\n    Args:\n    s (str): The input string to be modified.\n\n    Returns:\n    str: The modified string with whitespaces and underscores swapped.\n\n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = s.replace(' ', '\u00a7')\n    # Replace underscores with spaces\n    temp = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    result = temp.replace('\u00a7', '_')\n    return result", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n\n    Args:\n    text (str): The input string to process.\n\n    Returns:\n    str: The string with whitespaces and underscores swapped.\n\n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Jumanji_The_Jungle')\n    'Jumanji The Jungle'\n    >>> replace_spaces('Replace   spaces and  underscores')\n    'Replace_spaces_and_underscores'\n    >>> replace_spaces('Replace_spaces_and_underscores')\n    'Replace spaces and underscores'\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = text.replace(' ', '\u00a7')\n    # Replace underscores with spaces\n    temp = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    return temp.replace('\u00a7', '_')", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(input_string: str) -> str:\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n    \n    :param input_string: The string to be modified.\n    :return: The modified string with spaces and underscores swapped.\n    \n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Hello World_Example')\n    'Hello World Example'\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = input_string.replace(' ', '\u00a7')\n    # Replace underscores with spaces\n    temp = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    return temp.replace('\u00a7', '_')", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n\n    Args:\n    text (str): The input string to process.\n\n    Returns:\n    str: The string with whitespaces and underscores swapped.\n\n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Jumanji_The_Jungle')\n    'Jumanji The Jungle'\n    >>> replace_spaces('Hello World')\n    'Hello_World'\n    >>> replace_spaces('Hello_World')\n    'Hello World'\n    >>> replace_spaces('Some Text')\n    'Some_Text'\n    >>> replace_spaces('Some_Text')\n    'Some Text'\n    >>> replace_spaces('With   Multiple Spaces')\n    'With___Multiple_Spaces'\n    >>> replace_spaces('With___Multiple_Spaces')\n    'With   Multiple Spaces'\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = text.replace(' ', '\u00a7')\n    # Replace underscores with spaces\n    temp = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    return temp.replace('\u00a7', '_')", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(input_string):\n    # Replace spaces with underscores and underscores with spaces\n    result = []\n    for char in input_string:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(text: str) -> str:\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n\n    :param text: The input string to process.\n    :return: A new string with whitespaces replaced by underscores and underscores replaced by whitespaces.\n    \n    Example:\n        replace_spaces('Jumanji The Jungle') returns 'Jumanji_The_Jungle'\n        replace_spaces('Hello World') returns 'Hello_World'\n        replace_spaces('Python_Programming') returns 'Python Programming'\n        replace_spaces('Replace   spaces') returns 'Replace___spaces'\n    \"\"\"\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string: str) -> str:\n    result = ''\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n\n    Args:\n    s (str): The input string to be modified.\n\n    Returns:\n    str: The modified string with whitespaces and underscores swapped.\n\n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Hello World')\n    'Hello_World'\n    >>> replace_spaces('Python_Programming')\n    'Python Programming'\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = s.replace(' ', '\u00a7')\n    # Replace underscores with spaces\n    temp = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    result = temp.replace('\u00a7', '_')\n    return result", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n        input_string (str): The string to be modified.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n\n    Examples:\n        >>> replace_spaces('Jumanji The Jungle')\n        'Jumanji_The_Jungle'\n        >>> replace_spaces('Hello World')\n        'Hello_World'\n        >>> replace_spaces('Python_is_awesome')\n        'Python is awesome'\n        >>> replace_s webspace('This is a test')\n        'This_is_a_test'\n        >>> replace_spaces('Already_Underscored')\n        'Already Underscored'\n    \"\"\"\n    # Replace spaces with a temporary placeholder\n    temp = input_string.replace(' ', '\u00a7')\n    # Replace underscores with spaces\n    temp = temp.replace('_', ' ')\n    # Replace the temporary placeholder with underscores\n    return temp.replace('\u00a7', '_')", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n    \n    Parameters:\n    - text (str): The input string to process.\n    \n    Returns:\n    - str: The modified string with spaces and underscores swapped.\n    \n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Jumanji_The_Jungle')\n    'Jumanji The Jungle'\n    >>> replace_spaces('Replace   spaces and  underscores')\n    'Replace___spaces_and__underscores'\n    >>> replace_spaces('Replace___spaces_and__underscores')\n    'Replace   spaces and  underscores'\n    \"\"\"\n    # Initialize an empty list to build the new string\n    new_text = []\n    \n    # Iterate through each character in the input string\n    for char in text:\n        if char == ' ':\n            # Replace space with underscore\n            new_text.append('_')\n        elif char == '_':\n            # Replace underscore with space\n            new_text.append(' ')\n        else:\n            # Keep the character as is\n            new_text.append(char)\n    \n    # Join the list into a string and return\n    return ''.join(new_text)", "matching_cluster_idx": 3}]}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def move_zero(lst):\n    result = []\n    zero_count = 0\n    for num in lst:\n        if num == 0:\n            zero_count += 1\n        else:\n            result.append(num)\n    result.extend([0] * zero_count)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # Initialize a list to hold non-zero elements\n    non_zero = []\n    # Initialize a counter for zeroes\n    zero_count = 0\n    # Iterate through the array\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero.append(num)\n    # Extend the non-zero list with zeroes\n    non_zero.extend([0] * zero_count)\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Function to move all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    arr (list): The input list containing integers.\n    \n    Returns:\n    list: The list with all zeroes moved to the end.\n    \"\"\"\n    # Initialize an empty list to store non-zero elements\n    non_zero = []\n    # Initialize a counter for zeroes\n    zero_count = 0\n    \n    # Iterate through each element in the list\n    for num in arr:\n        # If the element is not zero, append it to the non_zero list\n        if num != 0:\n            non_zero.append(num)\n        else:\n            # If the element is zero, increment the zero counter\n            zero_count += 1\n    \n    # Extend the non_zero list with zeroes based on zero_count\n    non_zero.extend([0] * zero_count)\n    \n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    result = []\n    zero_count = 0\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            result.append(num)\n    result.extend([0] * zero_count)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    Approach:\n    1. Separate non-zero and zero elements.\n    2. Concatenate the non-zero list with the zero list.\n    \n    :param lst: List of integers.\n    :return: List with zeros moved to the end.\n    \"\"\"\n    non_zeros = [item for item in lst if item != 0]\n    zeros = [item for item in lst if item == 0]\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Move all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    arr (list): The input list containing integers.\n    \n    Returns:\n    list: The list with all zeroes moved to the end.\n    \"\"\"\n    zero_count = arr.count(0)\n    result = [num for num in arr if num != 0]\n    result.extend([0]*zero_count)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # Initialize a list to hold non-zero elements\n    non_zero = []\n    # Initialize a counter for zero elements\n    zero_count = 0\n    \n    # Iterate through the array\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero.append(num)\n    \n    # Extend the non-zero list with zeros\n    non_zero.extend([0] * zero_count)\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    res = [num for num in arr if num != 0]\n    zero_count = arr.count(0)\n    res.extend([0]*zero_count)\n    return res", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    non_zero = [num for num in lst if num != 0]\n    zeros = [0] * lst.count(0)\n    return non_zero + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (list): The input list containing integers.\n    \n    Returns:\n    list: The list with all zeroes moved to the end.\n    \"\"\"\n    zeroes = lst.count(0)\n    lst = [i for i in lst if i != 0]\n    lst.extend([0]*zeroes)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    result = []\n    zero_count = 0\n    for num in lst:\n        if num == 0:\n            zero_count += 1\n        else:\n            result.append(num)\n    result.extend([0] * zero_count)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Move all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    Args:\n    arr (list): The input list containing integers.\n    \n    Returns:\n    list: The list with all zeroes moved to the end.\n    \"\"\"\n    count_zeros = arr.count(0)\n    result = [num for num in arr if num != 0]\n    result.extend([0]*count_zeros)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    result = []\n    zero_count = 0\n    for num in lst:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n    result.extend([0] * zero_count)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    result = []\n    zero_count = 0\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            result.append(num)\n    result.extend([0] * zero_count)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # Initialize a list to hold non-zero elements\n    non_zero = []\n    # Initialize a counter for zeros\n    zero_count = 0\n    # Iterate through the array\n    for num in arr:\n        # If the element is not zero, append it to the non_zero list\n        if num != 0:\n            non_zero.append(num)\n        else:\n            # If it's zero, increment the zero_count\n            zero_count += 1\n    # Extend the non_zero list with zeros according to zero_count\n    non_zero.extend([0] * zero_count)\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    result = []\n    zero_count = 0\n    for num in lst:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n    result.extend([0] * zero_count)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        arr (list): A list of integers which may contain zero and non-zero values.\n\n    Returns:\n        list: A new list with all zeroes moved to the end.\n\n    Example:\n        >>> move_zero([1,0,2,0,3,4])\n        [1,2,3,4,0,0]\n    \"\"\"\n    count = arr.count(0)\n    arr = [i for i in arr if i != 0]\n    arr.extend([0]*count)\n    return arr", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    res = []\n    zero_count = 0\n    for num in lst:\n        if num == 0:\n            zero_count += 1\n        else:\n            res.append(num)\n    res.extend([0] * zero_count)\n    return res", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    result = []\n    zero_count = 0\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            result.append(num)\n    result.extend([0] * zero_count)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Function to move all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    arr (list): The input list containing integers.\n    \n    Returns:\n    list: The list with all zeroes moved to the end.\n    \"\"\"\n    # Initialize an empty list to store non-zero elements\n    non_zero = []\n    # Initialize a counter for zeroes\n    zero_count = 0\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is not zero, append it to the non_zero list\n        if num != 0:\n            non_zero.append(num)\n        else:\n            # If the element is zero, increment the zero_count\n            zero_count += 1\n    \n    # Extend the non_zero list with zeros based on zero_count\n    non_zero.extend([0] * zero_count)\n    \n    return non_zero", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 94.3089430894309, "dps_norm": 50.0, "pass@1": 95.0, "profiled": [{"solution": "def pair_xor_Sum(arr, n):\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += arr[i] ^ arr[j]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_xor += arr[i] ^ arr[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += arr[i] ^ arr[j]\n    return sum\narr = [5, 9, 7, 6]\nn = 4", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += numbers[i] ^ numbers[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Function to compute the sum of XOR of all pairs in the list.\n\n    Parameters:\n    arr (list): List of integers.\n    n (int): Number of elements in arr.\n\n    Returns:\n    int: Sum of XOR of all pairs.\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_xor += arr[i] ^ arr[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += arr[i] ^ arr[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += arr[i] ^ arr[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += arr[i] ^ arr[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    sum = 0\n    for i in range(0, n):\n        for j in range(i+1, n):\n            sum += arr[i] ^ arr[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += arr[i] ^ arr[j]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += lst[i] ^ lst[j]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    sum = 0\n    for i in range(0, n):\n        for j in range(i+1, n):\n            sum += arr[i] ^ arr[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum_xor += arr[i] ^ arr[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += lst[i] ^ lst[j]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += lst[i] ^ lst[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    sum = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            sum += arr[i] ^ arr[j]\n    return sum", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 87.71276595744679, "dps_norm": 86.33333333333333, "pass@1": 85.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return \"Error: Position exceeds array length\"\n    elif k <= 0:\n        return \"Error: Invalid position\"\n    else:\n        # Reverse the sub-array up to position k\n        arr[:k] = arr[:k][::-1]\n        return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return arr\n    # Reverse the subarray up to position k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return \"Position exceeds array length\"\n    else:\n        # Reverse the subarray up to position k\n        arr[:k] = arr[:k][::-1]\n        return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the subarray up to position k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k <= 0 or k > len(arr):\n        return arr\n    reversed_part = arr[:k][::-1]\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n    \n    Parameters:\n    arr (list): The input list of elements.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The modified list with the first k elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array\")\n    \n    # Reverse the sub-array up to position k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the subarray up to position k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return arr\n    reversed_part = arr[:k][::-1]\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return \"Position out of bounds\"\n    else:\n        return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return arr  # No change if k is beyond array length\n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return arr\n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return arr\n    else:\n        reversed_part = arr[:k][::-1]\n        remaining_part = arr[k:]\n        return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return -1\n    arr = arr[:k][::-1] + arr[k:]\n    return arr", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return arr  # Return the original array if k is beyond its length\n    # Reverse the sub-array up to position k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the subarray up to index k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return -1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return \"Error: k is larger than the array size.\"\n    else:\n        # Reverse the subarray up to position k\n        arr[:k] = arr[:k][::-1]\n        return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return \"Position exceeds array length\"\n    else:\n        reversed_part = arr[:k][::-1]\n        remaining_part = arr[k:]\n        new_arr = reversed_part + remaining_part\n    return new_arr", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k <= 0 or k > len(arr):\n        return arr  # No changes needed if k is invalid\n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return arr\n    part = arr[:k]\n    part.reverse()\n    return part + arr[k:]", "matching_cluster_idx": 10}]}, "Mbpp/720": {"dps": 44.61538461538461, "dps_norm": 82.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to a tuple and returns a new tuple.\n    \n    Parameters:\n    - input_tuple (tuple): The original tuple.\n    - input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    - tuple: A new tuple with the dictionary added.\n    \"\"\"\n    # Convert the tuple to a list to append the dictionary\n    temp_list = list(input_tuple)\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n    \n    Parameters:\n    - input_tuple (tuple): The original tuple.\n    - input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    - tuple: A new tuple with the dictionary added to the end.\n    \"\"\"\n    # Convert the tuple to a list to append the dictionary\n    temp_list = list(input_tuple)\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    new_tuple = tuple(temp_list)\n    return new_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"\n    Add a dictionary to the tuple and return a new tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dic (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple containing all elements of the original tuple followed by the dictionary.\n    \"\"\"\n    # Convert the tuple to a list to append the dictionary\n    temp_list = list(tup)\n    temp_list.append(dic)\n    \n    # Convert the list back to a tuple\n    new_tuple = tuple(temp_list)\n    return new_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns a new tuple.\n    \n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple with the dictionary added to the end.\n    \"\"\"\n    # Convert the tuple to a list to append the dictionary\n    temp_list = list(input_tuple)\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    updated_tuple = tuple(temp_list)\n    \n    return updated_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    This function takes a tuple and a dictionary as inputs and returns a new tuple with the dictionary added to the end.\n    \n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple with the original elements followed by the dictionary.\n    \"\"\"\n    # Convert the tuple to a list to append the dictionary\n    temp_list = list(input_tuple)\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple and return\n    return tuple(temp_list)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list to allow modifications\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    \n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list to allow modifications\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    updated_tuple = tuple(temp_list)\n    \n    return updated_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list to allow modifications\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    updated_tuple = tuple(temp_list)\n    \n    return updated_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list to append the dictionary\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    \n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list to allow modifications\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    \n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list to allow modifications\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    updated_tuple = tuple(temp_list)\n    \n    return updated_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list to allow modifications\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    \n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list to allow modifications\n    temp_list = list(input_tuple)\n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    # Convert the list back to a tuple\n    updated_tuple = tuple(temp_list)\n    return updated_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list to allow modifications\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    updated_tuple = tuple(temp_list)\n    \n    return updated_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list to allow modifications\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    \n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list for easy modification\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    updated_tuple = tuple(temp_list)\n    \n    return updated_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list to allow modifications\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    updated_tuple = tuple(temp_list)\n    \n    return updated_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Function to add a dictionary to the end of a tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary added to the end.\n\n    Example:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    # Convert the tuple to a list to append the dictionary\n    temp_list = list(input_tuple)\n    temp_list.append(input_dict)\n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 69.2896174863388, "dps_norm": 73.125, "pass@1": 89.0, "profiled": [{"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks from the given string.\n\n    Args:\n    text (str): The input string containing quoted text.\n\n    Returns:\n    list: A list of strings extracted from within the quotation marks.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n\n    # Using regular expressions to find all patterns that start and end with \"\n    # The pattern looks for any sequence of characters that are not \" inside \"\n    matches = re.findall(r'\"([^\"]*)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all matches within double quotes\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Find all occurrences of text enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the given text.\n\n    Parameters:\n        text (str): The input string from which to extract quoted substrings.\n\n    Returns:\n        list: A list of substrings that were enclosed in double quotation marks.\n\n    Example:\n        >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n        ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Regular expression to find all substrings enclosed in double quotes\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts values between quotation marks in a given string.\n\n    Args:\n    s (str): The input string containing quoted substrings.\n\n    Returns:\n    list: A list of strings extracted between the quotation marks.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts values between quotation marks in a given string.\n    \n    Parameters:\n    s (str): The input string containing quoted text.\n    \n    Returns:\n    list: A list of strings extracted from within the quotation marks.\n    \n    Examples:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Use regular expression to find all matches within double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\\\"(.*?)\\\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    pattern = r'\\\"(.*?)\\\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    pattern = re.compile(r'\"(.*?)\"')\n    return pattern.findall(s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(text):\n    \"\"\"\n    Extracts values between double quotation marks from a given string.\n\n    Args:\n        text (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found between double quotation marks.\n\n    Examples:\n        >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n        ['A53', 'multi', 'Processor']\n    \"\"\"\n    import re\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks from the given string.\n\n    Args:\n    text (str): The input string containing quoted text.\n\n    Returns:\n    list: A list of strings extracted between quotation marks.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Regular expression to find all text between double quotation marks\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    pattern = re.compile(r'\"(.*?)\"')\n    matches = pattern.findall(s)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a given string.\n\n    Args:\n    text (str): The input string from which to extract quoted values.\n\n    Returns:\n    list: A list of strings extracted from within double quotation marks.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Regular expression to find double quoted strings\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts values between quotation marks from the given string.\n\n    Parameters:\n    s (str): The input string containing quoted text.\n\n    Returns:\n    list: A list of strings extracted between quotation marks.\n    \"\"\"\n    # Using regular expression to find all matches within double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 5}]}, "Mbpp/732": {"dps": 44.14728682170543, "dps_norm": 63.0, "pass@1": 97.0, "profiled": [{"solution": "def replace_specialchar(text):\n    # Define the special characters to be replaced\n    special_chars = [' ', ',', '.']\n    # Replace each special character with a colon\n    for char in special_chars:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    # Replace each special character with a colon\n    for char in special_chars:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    import re\n    # Define the pattern to match spaces, commas, or dots\n    pattern = r'[ ,.]'\n    # Use re.sub to replace the matched characters with colon\n    replaced_text = re.sub(pattern, ':', text)\n    return replaced_text", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon in the given text.\n\n    Parameters:\n    - text (str): The input string to process.\n\n    Returns:\n    - str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Replace each special character with a colon\n    for char in special_chars:\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    import re\n    # Define a regular expression pattern to match spaces, commas, or dots\n    pattern = r'[ ,.]'\n    # Use re.sub to replace matched characters with colons\n    replaced_text = re.sub(pattern, ':', text)\n    return replaced_text", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon in the given text.\n\n    :param text: The input string containing spaces, commas, or dots.\n    :return: A new string with all spaces, commas, and dots replaced by colons.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Define the special characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Replace each special character with a colon\n    for char in special_chars:\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \n    Parameters:\n    text (str): The input string containing spaces, commas, or dots to be replaced.\n    \n    Returns:\n    str: The modified string with all spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Replace spaces with colons\n    text = text.replace(' ', ':')\n    # Replace commas with colons\n    text = text.replace(',', ':')\n    # Replace dots with colons\n    text = text.replace('.', ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    import re\n    # Use regular expression to replace spaces, commas, or dots with colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 2}, {"solution": "def replace_specialchar(text):\n    import re\n    # Define the pattern to match spaces, commas, or dots\n    pattern = r'[ ,.]'\n    # Use re.sub to replace the matched characters with colon\n    replaced_text = re.sub(pattern, ':', text)\n    return replaced_text", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(text):\n    import re\n    # Use regular expression to replace spaces, commas, or dots with colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 2}, {"solution": "import re\ndef replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in the given text with a colon.\n    \n    Args:\n    text (str): The input string containing spaces, commas, or dots to be replaced.\n    \n    Returns:\n    str: The modified string with all spaces, commas, and dots replaced by colons.\n    \n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Define the pattern to match spaces, commas, or dots\n    pattern = r'[ ,.]'\n    \n    # Use re.sub() to replace the matched characters with a colon\n    replaced_text = re.sub(pattern, ':', text)\n    \n    return replaced_text", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(text):\n    import re\n    # Use regular expression to replace spaces, commas, or dots with colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 2}, {"solution": "import re\ndef replace_specialchar(text):\n    # Define the pattern to match spaces, commas, and dots\n    pattern = r'[ ,.]'\n    # Use re.sub to replace matched characters with colon\n    replaced_text = re.sub(pattern, ':', text)\n    return replaced_text", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon in the given text.\n\n    Parameters:\n    text (str): The input string to process.\n\n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Replace each special character with a colon\n    for char in special_chars:\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n    text (str): The input string containing spaces, commas, or dots.\n\n    Returns:\n    str: The modified string with all spaces, commas, and dots replaced by colons.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    import re\n    # Define the pattern to match spaces, commas, or dots\n    pattern = r'[ ,.]'\n    # Replace the matched characters with colons\n    replaced_text = re.sub(pattern, ':', text)\n    return replaced_text", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(text):\n    # Define a function to replace spaces, commas, or dots with a colon\n    # Iterate through each character in the string\n    # If the character is a space, comma, or dot, replace it with a colon\n    # Otherwise, keep the character as is\n    # Return the modified string\n\n    # Initialize an empty string to store the result\n    result = ''\n    # Loop through each character in the input text\n    for char in text:\n        # Check if the character is a space, comma, or dot\n        if char in [' ', ',', '.']:\n            # If it is, append a colon to the result string\n            result += ':'\n        else:\n            # If not, append the character as is\n            result += char\n    # Return the final result string\n    return result", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(text):\n    special_chars = [' ', ',', '.']\n    for char in special_chars:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    import re\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \n    Args:\n    text (str): The input string containing spaces, commas, or dots.\n    \n    Returns:\n    str: The modified string with all spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Define the special characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Replace each special character with a colon\n    for char in special_chars:\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define a string of characters to be replaced\n    special_chars = ' ,.'\n    # Initialize an empty string to build the result\n    result = ''\n    # Iterate through each character in the input text\n    for char in text:\n        # Check if the character is in the special_chars string\n        if char in special_chars:\n            # Replace with a colon\n            result += ':'\n        else:\n            # Keep the original character\n            result += char\n    # Return the modified string\n    return result", "matching_cluster_idx": 3}]}, "Mbpp/740": {"dps": 82.85454545454546, "dps_norm": 71.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements\")\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even.\")\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary by using every two adjacent elements as a key-value pair.\n    \n    Args:\n    t (tuple): A tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary with keys and values taken from the tuple.\n    \n    Examples:\n    >>> tuple_to_dict((1, 2, 3, 4))\n    {1: 2, 3: 4}\n    \n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements\")\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple length must be even.\")\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a dictionary by using adjacent elements as key-value pairs.\n    \n    This function takes a tuple with an even number of elements and converts it into a dictionary\n    where each pair of elements in the tuple represents a key and its corresponding value.\n    \n    Parameters:\n    tup (tuple): The tuple to be converted. It should contain an even number of elements.\n    \n    Returns:\n    dict: A dictionary with keys and values taken from the tuple.\n    \n    Examples:\n    >>> tuple_to_dict((1, 2, 3, 4))\n    {1: 2, 3: 4}\n    \n    >>> tuple_to_dict(('a', 'b', 'c', 'd', 'e', 'f'))\n    {'a': 'b', 'c': 'd', 'e': 'f'}\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements\")\n    \n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements\")\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple length must be even.\")\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple length must be even to pair keys and values.\")\n    res_dict = {}\n    for i in range(0, len(tup), 2):\n        key = tup[i]\n        value = tup[i + 1]\n        res_dict[key] = value\n    return res_dict", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple length must be even\")\n    res = {}\n    for i in range(0, len(tup), 2):\n        res[tup[i]] = tup[i + 1]\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a dictionary by pairing adjacent elements as key-value pairs.\n\n    :param tup: A tuple with an even number of elements.\n    :return: A dictionary with keys and values taken from adjacent elements of the tuple.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements\")\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a key-value dictionary using adjacent elements.\n    \n    The input tuple should have an even number of elements for perfect pairing.\n    If the tuple has an odd number of elements, the last element will be ignored.\n    \n    Parameters:\n    tup (tuple): The tuple to be converted.\n    \n    Returns:\n    dict: A dictionary with keys and values taken from adjacent elements of the tuple.\n    \"\"\"\n    # Ensure the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        tup = tup[:-1]  # Ignore the last element if the tuple has odd length\n    \n    # Create a dictionary by pairing adjacent elements\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements\")\n    res = {}\n    for i in range(0, len(tup), 2):\n        res[tup[i]] = tup[i+1]\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements\")\n    it = iter(tup)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements\")\n    res = {}\n    for i in range(0, len(tup), 2):\n        res[tup[i]] = tup[i+1]\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple length must be even.\")\n    it = iter(tup)\n    return {key: next(it) for key in it}", "matching_cluster_idx": 6}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple length must be even\")\n    res = {}\n    for i in range(0, len(tup), 2):\n        res[tup[i]] = tup[i+1]\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements\")\n    res = {}\n    for i in range(0, len(tup), 2):\n        res[tup[i]] = tup[i+1]\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements\")\n    res = {}\n    for i in range(0, len(tup), 2):\n        res[tup[i]] = tup[i+1]\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a dictionary by using every two adjacent elements as a key-value pair.\n    \n    :param tup: A tuple with an even number of elements.\n    :return: A dictionary with keys and values taken from the tuple.\n    \n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements\")\n    it = iter(tup)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}]}, "Mbpp/744": {"dps": 81.67808219178082, "dps_norm": 86.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    - tup: tuple to check\n\n    Returns:\n    - True if None is found in the tuple, False otherwise\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return any(element is None for element in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    - input_tuple (tuple): The tuple to check for None values.\n\n    Returns:\n    - bool: True if any None value is found, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 4}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n        t (tuple): The tuple to check.\n\n    Returns:\n        bool: True if there is at least one None in the tuple, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if None is found in the tuple, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if there is at least one None in the tuple, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tpl):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    tpl (tuple): The tuple to check.\n\n    Returns:\n    bool: True if None is found in the tuple, False otherwise.\n    \"\"\"\n    return None in tpl", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    t (tuple): The tuple to check.\n\n    Returns:\n    bool: True if there is at least one None in the tuple, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if there is at least one None in the tuple, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    - tup: A tuple to be checked.\n\n    Returns:\n    - True if any element in the tuple is None, otherwise False.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    t (tuple): The tuple to check.\n\n    Returns:\n    bool: True if there is at least one None in the tuple, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tpl):\n    return any(elem is None for elem in tpl)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if there is at least one None in the tuple, False otherwise.\n    \"\"\"\n    return any(elem is None for elem in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple contains any None value.\n    \n    Parameters:\n    t (tuple): The tuple to check.\n    \n    Returns:\n    bool: True if None is found in the tuple, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Function to check if the given tuple has any None value or not.\n\n    Parameters:\n    tup (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if None is found in the tuple, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return any(ele is None for ele in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(t):\n    return any(ele is None for ele in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if None is found in the tuple, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if there is at least one None in the tuple, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any None value or not.\n\n    Parameters:\n    t (tuple): The tuple to check.\n\n    Returns:\n    bool: True if there is at least one None in the tuple, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}]}, "Mbpp/750": {"dps": 74.62585034013605, "dps_norm": 75.83333333333333, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the elements of the given tuple to the end of the given list.\n\n    Args:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the elements of the tuple added.\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Extend the list with the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list_data, tuple_data):\n    \"\"\"\n    Add elements from a tuple to the end of a list.\n\n    :param list_data: List to which elements will be added.\n    :param tuple_data: Tuple containing elements to add to the list.\n    :return: List with elements from the tuple added at the end.\n\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Extend the list with elements from the tuple\n    list_data.extend(tuple_data)\n    return list_data", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list_param, tuple_param):\n    list_param.extend(tuple_param)\n    return list_param", "matching_cluster_idx": 5}, {"solution": "def add_tuple(original_list, input_tuple):\n    \"\"\"\n    Add the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    original_list (list): The list to which the tuple elements will be added.\n    input_tuple (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The original list with the elements of the tuple added at the end.\n\n    Examples:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Extend the list with the elements of the tuple\n    original_list.extend(input_tuple)\n    return original_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Add the elements of the given tuple to the end of the given list.\n\n    :param input_list: List to which the tuple elements will be added\n    :param input_tuple: Tuple whose elements will be added to the list\n    :return: A new list containing the elements of the original list followed by the elements of the tuple\n    \"\"\"\n    # Create a new list by combining the input list with the elements of the tuple\n    # This is done by converting the tuple to a list and extending the input list with it\n    new_list = input_list + list(input_tuple)\n    return new_list", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n    # Extend the list with the elements of the tuple\n    list1.extend(tuple1)\n    return list1", "matching_cluster_idx": 5}, {"solution": "def add_tuple(input_list, input_tuple):\n    # Convert the tuple to a list\n    tuple_list = list(input_tuple)\n    \n    # Extend the input list with the converted list from the tuple\n    input_list.extend(tuple_list)\n    \n    # Return the modified list\n    return input_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Args:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The list with the tuple elements added at the end.\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Convert the tuple to a list and extend the original list with it\n    lst.extend(list(tup))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def add_tuple(list_param, tuple_param):\n    \"\"\"\n    Add the elements of a tuple to the end of a list.\n\n    :param list_param: List to which elements will be added.\n    :param tuple_param: Tuple containing elements to add to the list.\n    :return: A new list with elements from both the original list and the tuple.\n    \"\"\"\n    # Convert the tuple to a list and extend the original list\n    list_param.extend(list(tuple_param))\n    return list_param", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Add the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The list with the tuple elements added.\n    \"\"\"\n    # Extend the list with the elements of the tuple\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the elements of a tuple to the end of a list.\n\n    Args:\n    lst: list to which the tuple elements will be added\n    tup: tuple whose elements will be added to the list\n\n    Returns:\n    list: the original list with the tuple elements appended\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The list with the tuple elements added to the end.\n\n    Examples:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Extend the list with the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a given tuple to the end of a given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    # Extend the list with the elements of the tuple\n    lst.extend(list(tpl))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    This function takes a list and a tuple as input and returns a new list\n    that is the original list with the elements of the tuple appended to it.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: A new list containing all elements of the original list followed by the elements of the tuple.\n    \"\"\"\n    # Extend the list with the elements of the tuple\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Add elements from a tuple to the end of a list.\n\n    Args:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The list with the tuple elements added to the end.\n\n    Examples:\n    >>> add_tuple([1, 2, 3], (4, 5))\n    [1, 2, 3, 4, 5]\n    >>> add_tuple(['a', 'b'], ('c', 'd', 'e'))\n    ['a', 'b', 'c', 'd', 'e']\n    \"\"\"\n    # Extend the list with the elements of the tuple\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Args:\n        input_list (list): The list to which the tuple elements will be added.\n        input_tuple (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n        list: The updated list with the tuple elements added.\n    \"\"\"\n    # Extend the list with the elements of the tuple\n    input_list.extend(input_tuple)\n    return input_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Add the given tuple to the given list and return the new list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: A new list containing all elements of the original list followed by all elements of the tuple.\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Create a new list by concatenating the original list with the tuple converted to a list\n    new_list = lst + list(tpl)\n    return new_list", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    :param lst: list to which the tuple elements will be added\n    :param tup: tuple whose elements will be added to the list\n    :return: the list with the tuple elements appended\n    \"\"\"\n    # Extend the list with the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}]}, "Mbpp/753": {"dps": 97.31543624161074, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def min_k(tuples, k):\n    \"\"\"\n    Find the minimum k records from a list of tuple pairs.\n\n    Parameters:\n    tuples (list of tuple): The list containing tuple pairs.\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list of tuple: A list containing the k smallest tuples based on the second element.\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Args:\n    records (list of tuples): The list containing tuples of the form (name, value).\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list of tuples: A list containing the k tuples with the smallest values.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list based on the second element of the tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n    \n    Parameters:\n    - tuples_list: A list of tuples, where each tuple contains a string and an integer.\n    - k: An integer representing the number of minimum records to find.\n    \n    Returns:\n    - A list of tuples containing the k tuples with the smallest second elements.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort the tuple list based on the second element in each tuple\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Finds the first k tuples with the smallest second elements from the given list of tuples.\n\n    Args:\n    tuples_list: List of tuples, where each tuple contains a name and a numeric value.\n    k: Integer representing the number of minimum records to find.\n\n    Returns:\n    List of tuples containing the k smallest records based on the second element of the tuples.\n\n    Example:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    # sort the tuple list by the second item in each tuple\n    sorted_tuple_list = sorted(tuple_list, key=lambda x: x[1])\n    # return the first k elements\n    return sorted_tuple_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    # Sort the tuple list based on the second element in each tuple\n    sorted_tuple_list = sorted(tuple_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuple_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort the list of tuples based on the second element in each tuple\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Args:\n    tuple_list: List of tuples, where each tuple contains a string and an integer.\n    k: Integer representing the number of minimum records to find.\n\n    Returns:\n    List of tuples containing the k tuples with the smallest second elements.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    # Return the first k elements of the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Finds the k tuples with the smallest second elements from a list of tuples.\n\n    Parameters:\n    tuples_list (list of tuple): The list of tuples, where each tuple contains a string and an integer.\n    k (int): The number of minimum elements to find.\n\n    Returns:\n    list of tuple: A list containing the k tuples with the smallest second elements.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Args:\n    lst: List of tuples, where each tuple contains a string and an integer.\n    k: Integer representing the number of minimum records to find.\n\n    Returns:\n    A list of tuples containing the k tuples with the smallest second elements.\n\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(lst, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Parameters:\n    tuple_list (list of tuples): The list from which to find the minimum k records.\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list of tuples: A list containing the k tuples with the smallest second elements.\n\n    Example:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    # Return the first k elements of the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples, sorted by the second element in each tuple.\n\n    Args:\n    tuples (list of tuples): The list containing tuples, where each tuple consists of a string and an integer.\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list of tuples: A list containing the k tuples with the smallest second elements.\n\n    Example:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # First, we need to sort the list of tuples based on the second element in each tuple.\n    # We can use the sorted function with a key argument to specify that we want to sort by the second element of each tuple.\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    \n    # Now, we need to select the first k elements from this sorted list.\n    # We can do this using list slicing.\n    min_k_tuples = sorted_tuples[:k]\n    \n    # Finally, we return the selected tuples.\n    return min_k_tuples", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the tuple list based on the second element in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # Sort the tuple list based on the second item in each tuple in ascending order\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    # Sort the list of tuples based on the second element in each tuple\n    sorted_tuples = sorted(tuple_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples, sorted by the second element in each tuple.\n    \n    Args:\n    tuple_list: A list of tuples, where each tuple contains a name (string) and a numeric value (int or float).\n    k: The number of minimum records to find.\n    \n    Returns:\n    A list of tuples containing the k tuples with the smallest numeric values.\n    \n    Example:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list of tuples based on the second element in each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Parameters:\n    records (list of tuples): The list containing tuples of the form (name, value).\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list of tuples: A list containing the k tuples with the smallest values.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list based on the second element of the tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    return sorted_list[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 89.65517241379311, "dps_norm": 87.5, "pass@1": 66.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    min_len = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    result = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find elements that are common to all three lists at the same index.\n\n    Parameters:\n    l1, l2, l3 (list): Input lists to compare.\n\n    Returns:\n    list: A list of elements that are common at the same index in all three lists.\n    \"\"\"\n    # Determine the smallest length among the three lists to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to iterate up to the smallest list's length\n    # and collect elements where l1[i] == l2[i] == l3[i]\n    common_elements = [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    result = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists based on their indices.\n    \n    Parameters:\n    - l1, l2, l3: Lists to compare.\n    \n    Returns:\n    - A list of elements that are common at the same indices across all three lists.\n    \"\"\"\n    # Ensure all lists are of the same length\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    \n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists at the same index.\n\n    Args:\n    l1, l2, l3: Lists to compare.\n\n    Returns:\n    A list of elements that are common at the same index in all three lists.\n    \"\"\"\n    result = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists based on their indices.\n    \n    Parameters:\n    - l1, l2, l3: Lists to compare.\n    \n    Returns:\n    - A list containing elements that are the same across all three lists at the same index.\n    \"\"\"\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    result = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    result = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate over each index up to the length of the shortest list\n    for i in range(min_length):\n        # Check if elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, append the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    # Return the list of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the smallest length among the three lists to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    # Initialize an empty list to store common elements\n    common_elements = []\n    # Iterate over each index up to the smallest list's length\n    for i in range(min_length):\n        # Check if elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, append to the common_elements list\n            common_elements.append(l1[i])\n    # Return the list of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    min_length = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists at the same index.\n\n    Args:\n    l1, l2, l3: Lists to compare.\n\n    Returns:\n    A list of elements that are common at the same index in all three lists.\n    \"\"\"\n\n    # Initialize an empty list to store common elements\n    common_elements = []\n\n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n\n    # Iterate through each index up to the length of the shortest list\n    for i in range(min_length):\n        # Check if elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, append the element to the common_elements list\n            common_elements.append(l1[i])\n\n    # Return the list of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    result = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through each index up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, append the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    # Return the list of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    result = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 49.469026548672566, "dps_norm": 78.33333333333333, "pass@1": 58.0, "profiled": [{"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # Not enough elements to find the second smallest\n    # Initialize two variables to store the smallest and second smallest values\n    smallest = float('inf')\n    second_smallest = float('inf')\n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    if second_smallest == float('inf'):\n        return None  # No second smallest found\n    return second_smallest", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # or raise an error, depending on requirements\n    first, second = float('inf'), float('inf')\n    for num in numbers:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Handle edge cases where list is too small\n    if len(numbers) < 2:\n        return None  # or raise an error based on requirements\n\n    # Initialize two variables to store the smallest and second smallest values\n    min1 = min2 = float('inf')\n\n    for num in numbers:\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2 and num != min1:\n            min2 = num\n\n    # If no second smallest is found, return None or an appropriate value\n    if min2 == float('inf'):\n        return None\n    else:\n        return min2", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # or raise an error, depending on requirements\n    # Initialize two variables to store the smallest and second smallest values\n    min1 = min2 = float('inf')\n    for num in numbers:\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2 and num != min1:\n            min2 = num\n    return min2 if min2 != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # Not enough elements to find the second smallest\n    first_min = second_min = float('inf')\n    for num in numbers:\n        if num < first_min:\n            second_min = first_min\n            first_min = num\n        elif num < second_min and num != first_min:\n            second_min = num\n    return second_min if second_min != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # or raise an exception, depending on requirements\n    first, second = float('inf'), float('inf')\n    for num in numbers:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in a list.\n\n    :param numbers: List of numbers.\n    :return: The second smallest number.\n    \"\"\"\n    if len(numbers) < 2:\n        return None  # or raise an error, depending on requirements\n    first, second = float('inf'), float('inf')\n    for num in numbers:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates and handle edge cases\n    unique_nums = list(set(numbers))\n    if len(unique_nums) < 2:\n        return None  # or raise an error, depending on requirements\n    unique_nums.sort()\n    return unique_nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # or raise an error, depending on requirements\n    first_min = float('inf')\n    second_min = float('inf')\n    for num in numbers:\n        if num < first_min:\n            second_min = first_min\n            first_min = num\n        elif first_min < num < second_min:\n            second_min = num\n    if second_min == float('inf'):\n        return None  # No second smallest found\n    return second_min", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # Not enough elements\n    \n    # Initialize two variables to store the smallest and second smallest\n    min1 = min2 = float('inf')\n    \n    for num in numbers:\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2 and num != min1:\n            min2 = num\n    \n    return min2 if min2 != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # Not enough elements to find the second smallest\n    first_min = second_min = float('inf')\n    for num in numbers:\n        if num < first_min:\n            second_min = first_min\n            first_min = num\n        elif num < second_min and num != first_min:\n            second_min = num\n    return second_min if second_min != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # or raise an error, depending on requirements\n    first, second = float('inf'), float('inf')\n    for num in numbers:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # Not enough elements to find the second smallest\n\n    # Initialize two variables to store the smallest and second smallest values\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    # If second_smallest was never updated, there is no second smallest\n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # Not enough elements\n\n    # Initialize two variables to store the smallest and second smallest\n    first, second = float('inf'), float('inf')\n\n    for num in numbers:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # Not enough elements to find the second smallest\n    first_min = second_min = float('inf')\n    for num in numbers:\n        if num < first_min:\n            second_min = first_min\n            first_min = num\n        elif num < second_min and num != first_min:\n            second_min = num\n    return second_min if second_min != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # Not enough elements to find the second smallest\n    first_min = float('inf')\n    second_min = float('inf')\n    for num in numbers:\n        if num < first_min:\n            second_min = first_min\n            first_min = num\n        elif num < second_min and num != first_min:\n            second_min = num\n    if second_min == float('inf'):\n        return None  # No second smallest found\n    return second_min", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # or raise an error, depending on requirements\n    unique_numbers = list(set(numbers))\n    if len(unique_numbers) < 2:\n        return None  # or raise an error, if second smallest doesn't exist\n    unique_numbers.sort()\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # or raise an error, depending on requirements\n    first, second = float('inf'), float('inf')\n    for num in numbers:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in a list.\n\n    :param numbers: List of numbers.\n    :return: The second smallest number.\n    \"\"\"\n    if len(numbers) < 2:\n        return None  # or raise an error, depending on requirements\n    first, second = float('inf'), float('inf')\n    for num in numbers:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Handle edge cases where list is too short\n    if len(numbers) < 2:\n        return None  # or raise an exception, depending on requirements\n\n    # Initialize two variables to store the smallest and second smallest values\n    smallest = float('inf')\n    second = float('inf')\n\n    for num in numbers:\n        if num < smallest:\n            second = smallest\n            smallest = num\n        elif num < second and num != smallest:\n            second = num\n\n    # If second smallest wasn't found, return None\n    if second == float('inf'):\n        return None\n    else:\n        return second", "matching_cluster_idx": 4}]}, "Mbpp/757": {"dps": null, "dps_norm": null, "pass@1": 7.0, "profiled": []}, "Mbpp/758": {"dps": 16.467181467181465, "dps_norm": 63.75, "pass@1": 100.0, "profiled": [{"solution": "def unique_sublists(input_list):\n    \"\"\"\n    Counts the occurrences of sublists within a given list and returns a dictionary\n    with tuples of the sublists as keys and their counts as values.\n\n    Args:\n    input_list (list of lists): The list containing sublists to be counted.\n\n    Returns:\n    dict: A dictionary with tuples of sublists as keys and their occurrence counts as values.\n    \"\"\"\n    count_dict = {}\n    for sublist in input_list:\n        # Convert the sublist to a tuple to make it hashable\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "from typing import List, Tuple, Dict\ndef unique_sublists(big_list: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Counts the occurrences of sublists within a given list of lists.\n    \n    Parameters:\n        big_list (List[List[int]]): A list containing sublists of integers.\n        \n    Returns:\n        Dict[Tuple[int, ...], int]: A dictionary with tuples of sublists as keys\n                                     and their occurrence counts as values.\n    \"\"\"\n    count_dict = {}\n    for sublist in big_list:\n        # Convert sublist to tuple so it can be used as a dictionary key\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(input_list):\n    # Convert each sublist to a tuple so they can be hashed\n    tuple_list = [tuple(sublist) for sublist in input_list]\n    # Use a dictionary to count occurrences of each tuple\n    count_dict = {}\n    for tpl in tuple_list:\n        if tpl in count_dict:\n            count_dict[tpl] += 1\n        else:\n            count_dict[tpl] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(input_list):\n    count_dict = {}\n    for sublist in input_list:\n        # Convert the sublist to a tuple so it can be used as a key in the dictionary\n        tuple_key = tuple(sublist)\n        if tuple_key in count_dict:\n            count_dict[tuple_key] += 1\n        else:\n            count_dict[tuple_key] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(input_list):\n    # Convert each sublist to a tuple to make it hashable\n    tuple_list = [tuple(sublist) for sublist in input_list]\n    # Use a dictionary to count occurrences of each tuple\n    count_dict = {}\n    for t in tuple_list:\n        if t in count_dict:\n            count_dict[t] += 1\n        else:\n            count_dict[t] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(lst):\n    count = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count:\n            count[tuple_sublist] += 1\n        else:\n            count[tuple_sublist] = 1\n    return count", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple, Dict\ndef unique_sublists(lst: List[List]) -> Dict[Tuple, int]:\n    count_dict = {}\n    for sub in lst:\n        # Convert the sublist to a tuple so it can be used as a key in the dictionary\n        tup = tuple(sub)\n        if tup in count_dict:\n            count_dict[tup] += 1\n        else:\n            count_dict[tup] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of sublists within a list and returns a dictionary\n    with tuples of the sublists as keys and their counts as values.\n    \n    Args:\n    lst (list of list): The list containing sublists to count.\n    \n    Returns:\n    dict: A dictionary with tuples of sublists as keys and their occurrence counts as values.\n    \"\"\"\n    count_dict = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple to make it hashable\n        tup = tuple(sublist)\n        if tup in count_dict:\n            count_dict[tup] += 1\n        else:\n            count_dict[tup] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(main_list):\n    # Convert each sublist to a tuple to make them hashable\n    tuple_list = [tuple(sublist) for sublist in main_list]\n    \n    # Create a dictionary to store the count of each tuple\n    count_dict = {}\n    for tpl in tuple_list:\n        if tpl in count_dict:\n            count_dict[tpl] += 1\n        else:\n            count_dict[tpl] = 1\n    \n    return count_dict", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple, Dict\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    count_dict = {}\n    for sublst in lst:\n        tup = tuple(sublst)\n        if tup in count_dict:\n            count_dict[tup] += 1\n        else:\n            count_dict[tup] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple, Dict\ndef unique_sublists(input_list: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Counts the occurrences of sublists within a list and returns a dictionary with tuples of sublists as keys and their occurrence counts as values.\n\n    Parameters:\n    input_list (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where each key is a tuple representing a sublist from the input list, and each value is the count of how many times that sublist appears in the input list.\n    \"\"\"\n    count_dict = {}\n    for sublist in input_list:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple, Dict\ndef unique_sublists(list_of_lists: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Counts the occurrences of sublists within a given list of lists.\n    \n    Args:\n    list_of_lists: A list containing sublists of integers.\n    \n    Returns:\n    A dictionary where keys are tuples representing the sublists and values are the counts of their occurrences.\n    \n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    count_dict = {}\n    for sublist in list_of_lists:\n        # Convert the sublist to a tuple so it can be used as a key in the dictionary\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(list_of_lists):\n    count_dict = {}\n    for sublist in list_of_lists:\n        # Convert the sublist to a tuple so it can be used as a key in the dictionary\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(input_list):\n    count_dict = {}\n    for sublist in input_list:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        tuple_key = tuple(sublist)\n        if tuple_key in count_dict:\n            count_dict[tuple_key] += 1\n        else:\n            count_dict[tuple_key] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublst in lst:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        tpl = tuple(sublst)\n        if tpl in count_dict:\n            count_dict[tpl] += 1\n        else:\n            count_dict[tpl] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(input_list):\n    count_dict = {}\n    for sublist in input_list:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        tuple_key = tuple(sublist)\n        if tuple_key in count_dict:\n            count_dict[tuple_key] += 1\n        else:\n            count_dict[tuple_key] = 1\n    return count_dict", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(input_list):\n    count_dict = {}\n    for sublist in input_list:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        tuple_key = tuple(sublist)\n        if tuple_key in count_dict:\n            count_dict[tuple_key] += 1\n        else:\n            count_dict[tuple_key] = 1\n    return count_dict", "matching_cluster_idx": 4}]}, "Mbpp/760": {"dps": 80.69343065693431, "dps_norm": 81.875, "pass@1": 89.0, "profiled": [{"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(list):\n    if len(set(list)) ==1:\n        return True\n    else:\n        return False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(lst)\n    \n    # Check if there is only one unique element\n    if len(unique_elements) == 1:\n        return True\n    else:\n        return False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Args:\n    nums (list): A list of numbers.\n\n    Returns:\n    bool: True if there is only one distinct element in the list, False otherwise.\n\n    Examples:\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1,2,1])\n    False\n    >>> unique_Element([5])\n    True\n    >>> unique_Element([])\n    True\n    \"\"\"\n    return len(set(nums)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Check if all elements in the list are the same\n    return all(element == lst[0] for element in lst)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(arr):\n    return len(set(arr)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if a list contains only one distinct element.\n    \n    Args:\n    lst: List of numbers to be checked.\n    \n    Returns:\n    True if all elements in the list are the same, False otherwise.\n    \"\"\"\n    if not lst:\n        return True  # An empty list can be considered to have only one distinct element.\n    first_element = lst[0]\n    for item in lst:\n        if item != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates\n    unique_set = set(lst)\n    # If the set has only one element, it means all elements in the list were the same\n    return len(unique_set) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    This function checks whether a list of numbers contains only one distinct element.\n\n    Approach:\n    1. Convert the list to a set to remove duplicates.\n    2. Check the length of the set. If it's 1, it means all elements in the list are the same.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n\n    # Convert list to set to remove duplicates\n    unique_elements = set(lst)\n    \n    # Check if the set has only one unique element\n    if len(unique_elements) == 1:\n        return True\n    else:\n        return False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    if not lst:\n        return True  # An empty list is considered to have only one distinct element\n    first_element = lst[0]\n    for item in lst:\n        if item != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    if not lst:\n        return True\n    first_element = lst[0]\n    for item in lst:\n        if item != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    # The function checks whether all elements in the list are the same.\n    # It returns True if there's only one distinct element, else False.\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(arr):\n    # Check if all elements in the list are the same\n    return all(element == arr[0] for element in arr)", "matching_cluster_idx": 3}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n    s (str): The string to be analyzed.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Parameters:\n    s (str): The input string to be analyzed.\n\n    Returns:\n    int: The count of digits in the string.\n\n    Example:\n    >>> number_ctr('program2bedone')\n    1\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    :param s: The input string to be analyzed.\n    :return: The count of digits present in the string.\n\n    Example:\n    >>> number_ctr('program2bedone')\n    1\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    s (str): The input string to search for digits.\n\n    Returns:\n    int: The count of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 61.44859813084112, "dps_norm": 54.16666666666667, "pass@1": 98.0, "profiled": [{"solution": "def pair_wise(input_list):\n    # Check if the list has fewer than 2 elements\n    if len(input_list) < 2:\n        return []\n    # Use list comprehension to create pairs of consecutive items\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    if len(input_list) < 2:\n        return []\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    result = []\n    for i in range(len(lst) - 1):\n        pair = (lst[i], lst[i+1])\n        result.append(pair)\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    result = []\n    for i in range(len(input_list) - 1):\n        pair = (input_list[i], input_list[i+1])\n        result.append(pair)\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    This function takes a list as input and returns a list of tuples, where each tuple contains\n    a pair of consecutive items from the input list.\n\n    Args:\n    input_list (list): The list from which to generate pairs of consecutive items.\n\n    Returns:\n    list: A list of tuples, each containing a pair of consecutive items from the input list.\n\n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    result = []\n    for i in range(len(input_list) - 1):\n        pair = (input_list[i], input_list[i+1])\n        result.append(pair)\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    This function takes a list as input and returns a list of tuples, where each tuple contains\n    a pair of consecutive items from the input list.\n    \n    Args:\n        input_list (list): The list from which to generate pairs of consecutive items.\n        \n    Returns:\n        list of tuples: A list where each tuple contains a pair of consecutive items from the input list.\n        \n    Example:\n        >>> pair_wise([1,1,2,3,3,4,4,5])\n        [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    result = []\n    for i in range(len(input_list) - 1):\n        result.append((input_list[i], input_list[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n    \n    Args:\n    lst (list): A list of elements.\n    \n    Returns:\n    list of tuples: A list where each tuple contains a pair of consecutive elements from the input list.\n    \n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    result = []\n    for i in range(len(input_list)-1):\n        result.append((input_list[i], input_list[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    This function takes in a list and returns a list of tuples, where each tuple contains\n    a pair of consecutive items from the input list.\n\n    :param input_list: List of elements\n    :return: List of tuples, each containing a pair of consecutive items\n    \"\"\"\n    result = []\n    for i in range(len(input_list) - 1):\n        result.append((input_list[i], input_list[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    # Check if the list has fewer than 2 elements\n    if len(input_list) < 2:\n        return []\n    # Use list comprehension to create pairs of consecutive items\n    result = [(input_list[i], input_list[i+1]) for i in range(len(input_list)-1)]\n    return result", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Generate a list of all pairs of consecutive items in the given list.\n\n    Args:\n    lst (list): The input list of items.\n\n    Returns:\n    list of tuples: A list where each tuple contains a pair of consecutive items from the input list.\n\n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Function to return a list of all pairs of consecutive items in a given list.\n\n    Parameters:\n        input_list (list): A list of elements.\n\n    Returns:\n        list: A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n\n    Example:\n        >>> pair_wise([1,1,2,3,3,4,4,5])\n        [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    result = []\n    for i in range(len(input_list) - 1):\n        pair = (input_list[i], input_list[i+1])\n        result.append(pair)\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    if not input_list or len(input_list) < 2:\n        return []\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    This function takes a list as input and returns a list of tuples, where each tuple contains\n    a pair of consecutive items from the input list.\n\n    Args:\n    input_list (list): The list from which to generate pairs of consecutive items.\n\n    Returns:\n    list: A list of tuples, each containing a pair of consecutive items from the input list.\n\n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    result = []\n    for i in range(len(input_list) - 1):\n        result.append((input_list[i], input_list[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n\n    :param input_list: List of elements to be paired.\n    :return: List of tuples, each containing a pair of consecutive elements.\n    \"\"\"\n    result = []\n    for i in range(len(input_list) - 1):\n        pair = (input_list[i], input_list[i+1])\n        result.append(pair)\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    result = []\n    for i in range(len(input_list) - 1):\n        pair = (input_list[i], input_list[i+1])\n        result.append(pair)\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}]}, "Mbpp/775": {"dps": 91.52, "dps_norm": 68.57142857142857, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(numbers_list):\n    # check if all numbers at odd indices are odd\n    for i in range(1, len(numbers_list), 2):\n        if numbers_list[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains an odd number in a given list.\n\n    :param nums: List of integers to check.\n    :return: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    # Iterate over the list, considering only odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n    \n    Args:\n    numbers (list): A list of integers.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(numbers), 2):\n        if numbers[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(arr):\n    for i in range(1, len(arr), 2):\n        if arr[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(arr):\n    for i in range(1, len(arr), 2):\n        if arr[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(arr):\n    for i in range(1, len(arr), 2):\n        if arr[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    for index in range(len(numbers)):\n        if index % 2 != 0 and numbers[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for index in range(1, len(numbers), 2):\n        if numbers[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(arr):\n    for i in range(1, len(arr), 2):\n        if arr[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    for index in range(len(numbers)):\n        if index % 2 != 0 and numbers[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}]}, "Mbpp/777": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/781": {"dps": 87.4015748031496, "dps_norm": 40.0, "pass@1": 99.0, "profiled": [{"solution": "def count_divisors(n):\n    \"\"\"\n    Determine if the count of divisors of a given positive integer n is even.\n    \n    Args:\n    n (int): A positive integer whose number of divisors is to be checked.\n    \n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \n    Examples:\n    >>> count_divisors(10)\n    True\n    >>> count_divisors(9)\n    False\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of a given number is even.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of a given number is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of a given number is even.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of a given number is even.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of a given number is even.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Determine if the count of divisors of a given integer is even.\n\n    Args:\n    n (int): The integer to analyze.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n\n    Examples:\n    >>> count_divisors(10)\n    True\n    >>> count_divisors(9)\n    False\n    \"\"\"\n\n    # Initialize count\n    count = 0\n\n    # Loop from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n\n    # Check if the count is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(num):\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of a given number is even.\n    \n    :param n: integer, the number to check\n    :return: boolean, True if the count of divisors is even, False otherwise\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of a given number is even.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n\n    Examples:\n    >>> count_divisors(10)\n    True\n    >>> count_divisors(9)\n    False\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(num):\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Determine if the number of divisors of a given integer is even.\n\n    Args:\n        n (int): The integer to analyze.\n\n    Returns:\n        bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}]}, "Mbpp/800": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def remove_all_spaces(s: str) -> str:\n    \"\"\"Remove all whitespaces from a string.\"\"\"\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    Remove all whitespaces from a string.\n\n    Parameters:\n    s (str): The input string from which whitespaces are to be removed.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str):\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    Parameters:\n    input_str (str): The string from which to remove spaces.\n\n    Returns:\n    str: The string with all spaces removed.\n\n    Examples:\n    >>> remove_all_spaces('python  program')\n    'pythonprogram'\n    \"\"\"\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from the input string.\n    \n    Parameters:\n    input_string (str): The string from which to remove spaces.\n    \n    Returns:\n    str: The input string with all spaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from a string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: A string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Removing all white spaces\n    result = input_string.replace(\" \", \"\")\n    return result", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    This function removes all whitespaces from a given string.\n\n    Args:\n        input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n        str: The string with all whitespaces removed.\n\n    Example:\n        >>> remove_all_spaces('python  program')\n        'pythonprogram'\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str):\n    return input_str.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str):\n    \"\"\"\n    Remove all whitespaces from a given string.\n\n    Parameters:\n    input_str (str): The string from which to remove whitespaces.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str):\n    \"\"\"\n    Remove all whitespace characters from a given string.\n\n    Parameters:\n    input_str (str): The string from which to remove whitespace.\n\n    Returns:\n    str: The string with all whitespace removed.\n    \"\"\"\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the input string.\n\n    Args:\n        input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n        str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(list_of_lists):\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists with the highest sum of elements.\n    \n    Parameters:\n    list_of_lists (list of lists): A list containing sublists of integers.\n    \n    Returns:\n    list: The sublist with the highest sum of elements.\n    \n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to store the maximum sum and the list with that sum\n    max_sum = None\n    max_list = None\n\n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # If max_sum is None or current_sum is greater than max_sum, update max_sum and max_list\n        if max_sum is None or current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Parameters:\n    list_of_lists (list of lists): A list containing sublists of integers.\n    \n    Returns:\n    list: The sublist with the highest sum of elements.\n    \n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    This function receives a list of lists and returns the list with the highest sum of elements.\n\n    Args:\n    list_of_lists: A list where each element is a list of numbers.\n\n    Returns:\n    The list with the highest sum of elements.\n\n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Parameters:\n    list_of_lists (list of lists): A list containing sublists of integers.\n    \n    Returns:\n    list: The sublist with the highest sum of elements.\n    \n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    if not list_of_lists:\n        return []\n    \n    max_sum = float('-inf')\n    max_list = []\n    \n    for sublist in list_of_lists:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the highest sum of elements in a list of lists.\n\n    Args:\n    list_of_lists: A list where each element is a list of numbers.\n\n    Returns:\n    The list with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return None  # Return None if the input list is empty\n\n    # Initialize the maximum sum and the list with the maximum sum\n    max_sum = float('-inf')\n    max_list = None\n\n    # Iterate through each list in the list of lists\n    for sublist in list_of_lists:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n        list_of_lists (list of lists): A list containing sublists of integers.\n\n    Returns:\n        list: The sublist with the highest sum of elements.\n\n    Example:\n        >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n        [10, 11, 12]\n    \"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements from a list of lists.\n\n    Parameters:\n    list_of_lists (list of lists): A list containing sublists of numbers.\n\n    Returns:\n    list: The sublist with the highest sum of elements.\n\n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Parameters:\n    list_of_lists (list of lists): A list containing sublists of integers.\n    \n    Returns:\n    list: The sublist with the highest sum of elements.\n    \n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize the maximum sum and the list with the maximum sum\n    max_sum = float('-inf')\n    max_list = None\n\n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # If the current sum is greater than the maximum sum found so far\n        if current_sum > max_sum:\n            # Update the maximum sum and the list with the maximum sum\n            max_sum = current_sum\n            max_list = lst\n\n    # Return the list with the maximum sum\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Function to find the list with the highest sum of elements in a list of lists.\n\n    Args:\n    list_of_lists: A list containing sublists of integers.\n\n    Returns:\n    The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return None  # Return None if the list is empty\n\n    # Initialize the maximum sum and the list with the maximum sum\n    max_sum = float('-inf')\n    max_sum_list = None\n\n    # Iterate through each sublist\n    for sublist in list_of_lists:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_list = sublist\n\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Parameters:\n    list_of_lists (list of lists): A list containing sublists of integers.\n\n    Returns:\n    list: The sublist with the highest sum of elements.\n\n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements in a list of lists.\n\n    Parameters:\n    list_of_lists (list of lists): A list containing sublists of integers.\n\n    Returns:\n    list: The sublist with the highest sum of elements.\n    \"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 93.0, "profiled": [{"solution": "def check_K(tpl, k):\n    \"\"\"\n    Function to check if the given tuple contains the specified value k.\n\n    :param tpl: Tuple to be checked\n    :param k: Value to search for in the tuple\n    :return: True if k is found in tpl, False otherwise\n    \"\"\"\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Function to check if the given tuple contains the specified value k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is found in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple1, k):\n    return k in tuple1", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple1, k):\n    return k in tuple1", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple1, k):\n    return k in tuple1", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the specified value k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is found in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple1, k):\n    return k in tuple1", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the specified value k.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    k (Any): The value to look for in the tuple.\n\n    Returns:\n    bool: True if k is found in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    \"\"\"\n    Check if the given tuple contains the specified value k.\n\n    Args:\n    tpl (tuple): The tuple to check.\n    k (any): The value to look for in the tuple.\n\n    Returns:\n    bool: True if k is found in tpl, False otherwise.\n    \"\"\"\n    return k in tpl", "matching_cluster_idx": 5}]}}}