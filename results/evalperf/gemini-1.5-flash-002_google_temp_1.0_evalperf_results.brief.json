{"date": "2024-10-19 16:30", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 79.85512300275154, "dps_norm": 76.4398130083651, "pass@1": 77.63559322033899}, "eval": {"HumanEval/9": {"dps": 73.02839116719242, "dps_norm": 80.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    max_so_far = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] > max_so_far:\n            max_so_far = numbers[i]\n        rolling_max_list.append(max_so_far)\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = []\n    current_max = numbers[0]\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    max_so_far = numbers[0]\n    for i in range(1, len(numbers)):\n        max_so_far = max(max_so_far, numbers[i])\n        rolling_max_list.append(max_so_far)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = []\n    current_max = numbers[0]\n    rolling_max_list.append(current_max)\n\n    for i in range(1, len(numbers)):\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = []\n    current_max = numbers[0]\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    for i in range(1, len(numbers)):\n        current_max = max(current_max, numbers[i])\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = []\n    current_max = numbers[0]\n    rolling_max_list.append(current_max)\n\n    for i in range(1, len(numbers)):\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = []\n    current_max = numbers[0]\n    rolling_max_list.append(current_max)\n\n    for i in range(1, len(numbers)):\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = []\n    current_max = numbers[0]\n    rolling_max_list.append(current_max)\n\n    for i in range(1, len(numbers)):\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    for i in range(1, len(numbers)):\n        current_max = max(current_max, numbers[i])\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = []\n    max_so_far = numbers[0]\n    rolling_max_list.append(max_so_far)\n\n    for i in range(1, len(numbers)):\n        if numbers[i] > max_so_far:\n            max_so_far = numbers[i]\n        rolling_max_list.append(max_so_far)\n\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = []\n    current_max = numbers[0]\n    rolling_max_list.append(current_max)\n\n    for i in range(1, len(numbers)):\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = []\n    max_so_far = numbers[0]\n    rolling_max_list.append(max_so_far)\n\n    for i in range(1, len(numbers)):\n        if numbers[i] > max_so_far:\n            max_so_far = numbers[i]\n        rolling_max_list.append(max_so_far)\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 7}]}, "HumanEval/0": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}]}, "HumanEval/4": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}]}, "HumanEval/16": {"dps": 16.27906976744186, "dps_norm": 33.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}]}, "HumanEval/20": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 97.27891156462586, "dps_norm": 62.5, "pass@1": 100.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #Handles edge case where n is 1.  Largest divisor is itself.\n    >>> largest_divisor(100)\n    50\n    >>> largest_divisor(2)\n    1 #Handles edge case where n is prime\n    \"\"\"\n    if n <= 1:\n        return n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #Handles edge case of 1\n    >>> largest_divisor(2)\n    1 #Handles edge case of 2\n\n    \"\"\"\n    if n <= 1:\n        return n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(100)\n    50\n\n    \"\"\"\n    if n <=1:\n        return 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #Handles the edge case where n is 1.  Largest divisor is itself.\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(100)\n    50\n\n    \"\"\"\n    if n <=1:\n        return 1 #Handle edge cases where n is 0 or 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #Handles edge case where n is 1.  Largest divisor is itself.\n    >>> largest_divisor(2)\n    1 #Handles edge case where n is prime.\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <=1:\n        return n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 # handles edge case of 1\n    >>> largest_divisor(2)\n    1 # handles edge case of 2\n\n    \"\"\"\n    if n <= 1:\n        return 1 # Handle edge cases of 1 and 2\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #Edge Case: 1 is the largest divisor of 1, even though it's equal to 1.\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(12)\n    6\n\n    \"\"\"\n    if n <=1:\n        return 1 #Handle edge cases for 1 and numbers less than 1.\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #Handles the edge case of 1\n    >>> largest_divisor(100)\n    50\n    >>> largest_divisor(7)\n    1 #Handles prime numbers\n\n    \"\"\"\n    if n <= 1:\n        return 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 # handles edge case of 1\n    >>> largest_divisor(2)\n    1 # handles edge case of prime numbers\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <= 1:\n        return 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #Handles edge case where n=1.  Largest divisor is itself.\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <=1:\n        return n #Handles edge cases where n is 0 or 1\n\n    for i in range(n // 2, 0, -1):  # Iterate downwards from n//2\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #Handles edge case of 1\n    >>> largest_divisor(2)\n    1 #Handles edge case of prime numbers\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <= 1:\n        return 1 #Handle edge cases for numbers less than or equal to 1\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #Handles the edge case of 1\n    >>> largest_divisor(12)\n    6\n    >>> largest_divisor(7)\n    1 #Handles prime numbers\n    \"\"\"\n    if n <= 1:\n        return n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #Handles edge case of 1\n    >>> largest_divisor(2)\n    1 #Handles edge case of prime numbers\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <= 1:\n        return n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #Edge case: 1 is handled as itself\n    >>> largest_divisor(12)\n    6\n    >>> largest_divisor(7)\n    1 #Prime numbers\n    \"\"\"\n    if n <=1:\n        return n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #This is a edge case.  Largest divisor of 1 is 1.  Could also raise an exception.\n    >>> largest_divisor(2)\n    1\n    \"\"\"\n    if n <=1:\n        return 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return 1  # Handle cases where n is 0 or 1\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(12)\n    6\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    1\n\n    \"\"\"\n    if n <= 1:\n        return 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #Edge case: 1 is the largest divisor of itself, even though it's not smaller.\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(100)\n    50\n\n    \"\"\"\n    if n <= 1:\n        return 1  # Handle edge cases where n is 1 or less\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1 #Handles edge case of 1\n    >>> largest_divisor(2)\n    1 #Handles edge case of prime numbers\n    \"\"\"\n    if n <=1:\n        return 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(12)\n    6\n    >>> largest_divisor(7)\n    1\n    \"\"\"\n    if n <= 1:\n        return 1  # Handle cases where n is 0 or 1\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}]}, "HumanEval/26": {"dps": 31.6, "dps_norm": 76.25, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 2}]}, "HumanEval/31": {"dps": 88.10126582278481, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/34": {"dps": 58.5377358490566, "dps_norm": 82.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = set(l)  #Sets automatically handle uniqueness\n    sorted_unique_elements = sorted(list(unique_elements)) #Convert back to list and sort\n    return sorted_unique_elements", "matching_cluster_idx": 3}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = set(l)  #Sets automatically remove duplicates\n    sorted_unique_elements = sorted(list(unique_elements)) #Convert back to list and sort\n    return sorted_unique_elements", "matching_cluster_idx": 3}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = set(l)  # Use a set to automatically remove duplicates\n    sorted_unique_elements = sorted(list(unique_elements)) #Convert back to list and sort\n    return sorted_unique_elements", "matching_cluster_idx": 3}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = sorted(list(set(l)))\n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = set(l) #Use a set to automatically remove duplicates\n    sorted_unique_elements = sorted(list(unique_elements)) #Convert back to list and sort\n    return sorted_unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = []\n    for element in l:\n        if element not in unique_elements:\n            unique_elements.append(element)\n    unique_elements.sort()\n    return unique_elements", "matching_cluster_idx": 0}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_list = []\n    for item in l:\n        if item not in unique_list:\n            unique_list.append(item)\n    unique_list.sort()\n    return unique_list", "matching_cluster_idx": 0}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = sorted(list(set(l)))\n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = set(l)  #Sets automatically handle uniqueness\n    sorted_unique_elements = sorted(list(unique_elements)) #Convert back to list and sort\n    return sorted_unique_elements", "matching_cluster_idx": 3}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = set(l)  #Sets only store unique elements\n    sorted_unique = sorted(list(unique_elements)) # Convert back to list and sort\n    return sorted_unique", "matching_cluster_idx": 3}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = sorted(list(set(l)))\n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = set(l)  #Sets automatically handle uniqueness\n    sorted_unique_elements = sorted(list(unique_elements)) #Convert back to list and sort\n    return sorted_unique_elements", "matching_cluster_idx": 3}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = set(l)  #Use a set to automatically remove duplicates\n    sorted_unique = sorted(list(unique_elements)) #Convert back to list and sort\n    return sorted_unique", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_list = []\n    for item in l:\n        if item not in unique_list:\n            unique_list.append(item)\n    unique_list.sort()\n    return unique_list", "matching_cluster_idx": 0}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 94.92635024549918, "dps_norm": 90.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    l_prime = []\n    i = 0\n    j = 0\n    while i < len(even_indices) or j < len(odd_indices):\n        if i < len(even_indices):\n            l_prime.append(even_indices[i])\n            i += 1\n        if j < len(odd_indices):\n            l_prime.append(odd_indices[j])\n            j += 1\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    \n    result = []\n    i = 0\n    j = 0\n    while i < len(even_indices) or j < len(odd_indices):\n        if i < len(even_indices):\n            result.append(even_indices[i])\n            i += 1\n        if j < len(odd_indices):\n            result.append(odd_indices[j])\n            j += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    l_prime = []\n    i = 0\n    j = 0\n    while i < len(even_indices) or j < len(odd_indices):\n        if i < len(even_indices):\n            l_prime.append(even_indices[i])\n            i += 1\n        if j < len(odd_indices):\n            l_prime.append(odd_indices[j])\n            j += 1\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    l_prime = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indices[i//2])\n        else:\n            l_prime.append(odd_indices[i//2])\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    result = []\n    i = 0\n    j = 0\n    while i < len(even_indices) or j < len(odd_indices):\n        if i < len(even_indices):\n            result.append(even_indices[i])\n            i += 1\n        if j < len(odd_indices):\n            result.append(odd_indices[j])\n            j += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    result = []\n    i = 0\n    j = 0\n    while i < len(even_indices) or j < len(odd_indices):\n        if i < len(even_indices):\n            result.append(even_indices[i])\n            i += 1\n        if j < len(odd_indices):\n            result.append(odd_indices[j])\n            j += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    l_prime = []\n    i = 0\n    j = 0\n    while i < len(even_indices) or j < len(odd_indices):\n        if i < len(even_indices):\n            l_prime.append(even_indices[i])\n            i += 1\n        if j < len(odd_indices):\n            l_prime.append(odd_indices[j])\n            j += 1\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    \n    result = []\n    even_index = 0\n    odd_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices[even_index])\n            even_index +=1\n        else:\n            result.append(odd_indices[odd_index])\n            odd_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    l_prime = []\n    i = 0\n    j = 0\n    while i < len(even_indices) or j < len(odd_indices):\n        if i < len(even_indices):\n            l_prime.append(even_indices[i])\n            i += 1\n        if j < len(odd_indices):\n            l_prime.append(odd_indices[j])\n            j += 1\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    l_prime = []\n    i = 0\n    j = 0\n    while i < len(even_indices) or j < len(odd_indices):\n        if i < len(even_indices):\n            l_prime.append(even_indices[i])\n            i += 1\n        if j < len(odd_indices):\n            l_prime.append(odd_indices[j])\n            j += 1\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    \n    result = []\n    even_index = 0\n    odd_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices[even_index])\n            even_index += 1\n        else:\n            result.append(odd_indices[odd_index])\n            odd_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    l_prime = []\n    i = 0\n    j = 0\n    while i < len(even_indices) or j < len(odd_indices):\n        if i < len(even_indices):\n            l_prime.append(even_indices[i])\n            i += 1\n        if j < len(odd_indices):\n            l_prime.append(odd_indices[j])\n            j += 1\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    \n    result = []\n    even_index = 0\n    odd_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices[even_index])\n            even_index += 1\n        else:\n            result.append(odd_indices[odd_index])\n            odd_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    result = []\n    i = 0\n    j = 0\n    while i < len(even_indices) or j < len(odd_indices):\n        if i < len(even_indices):\n            result.append(even_indices[i])\n            i += 1\n        if j < len(odd_indices):\n            result.append(odd_indices[j])\n            j += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    \n    result = []\n    even_index = 0\n    odd_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices[even_index])\n            even_index += 1\n        else:\n            result.append(odd_indices[odd_index])\n            odd_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    l_prime = []\n    i = 0\n    j = 0\n    while i < len(even_indices) or j < len(odd_indices):\n        if i < len(even_indices):\n            l_prime.append(even_indices[i])\n            i += 1\n        if j < len(odd_indices):\n            l_prime.append(odd_indices[j])\n            j += 1\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    \n    result = []\n    even_index = 0\n    odd_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices[even_index])\n            even_index +=1\n        else:\n            result.append(odd_indices[odd_index])\n            odd_index += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    \n    result = []\n    even_index = 0\n    odd_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices[even_index])\n            even_index +=1\n        else:\n            result.append(odd_indices[odd_index])\n            odd_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    \n    result = []\n    even_index = 0\n    odd_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices[even_index])\n            even_index += 1\n        else:\n            result.append(odd_indices[odd_index])\n            odd_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    odd_indices = l[1::2]\n    even_indices.sort()\n    \n    result = []\n    even_index = 0\n    odd_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices[even_index])\n            even_index += 1\n        else:\n            result.append(odd_indices[odd_index])\n            odd_index +=1\n            \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/58": {"dps": 42.362204724409445, "dps_norm": 40.0, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)  #Efficiently find common elements using sets\n    return sorted(list(common_elements)) #Convert back to list and sort", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)  #Efficiently find common elements using sets\n    return sorted(list(common_elements)) #Convert back to list and sort", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)  #Efficiently find common elements using sets\n    return sorted(list(common_elements)) # Convert back to list and sort", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)  #Efficiently find common elements using sets\n    return sorted(list(common_elements)) #Convert back to list and sort", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)  #Efficiently find common elements using sets\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)  # Efficiently find common elements using sets\n    return sorted(list(common_elements)) # Convert back to list and sort", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 36.94805194805194, "dps_norm": 43.125, "pass@1": 100.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' or char == 'Y':\n            if i == len(s) - 1:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' or char == 'Y':\n            if i == len(s) - 1:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' or char == 'Y':\n            if i == len(s) - 1:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' or char == 'Y':\n            if i == len(s) - 1:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' or char == 'Y':\n            if i == len(s) - 1:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "import unittest\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    count = 0\n    s = s.lower()\n    vowels = \"aeiou\"\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    \"\"\"\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    \"\"\"\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    \"\"\"\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 97.02970297029702, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_even_odd_indices = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_even_odd_indices += lst[i]\n    return sum_even_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_even_odd_indices = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_even_odd_indices += lst[i]\n    return sum_even_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_even_odd_indices = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_even_odd_indices += lst[i]\n    return sum_even_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_evens += lst[i]\n    return sum_of_evens", "matching_cluster_idx": 3}]}, "HumanEval/86": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/87": {"dps": null, "dps_norm": null, "pass@1": 6.0, "profiled": []}, "HumanEval/89": {"dps": 96.64948453608248, "dps_norm": 28.571428571428573, "pass@1": 100.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., shifted by 4 places).\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., 4 places).\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., shift down by 4 places).\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., four places).\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., shifted by 4 places).\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., shifted down by 4 places).\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., shifted by 4 places).\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., four places).\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., shifted by 4 places).\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += encrypted_char\n    return encrypted_string", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 57.12062256809339, "dps_norm": 51.25, "pass@1": 100.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst))) #remove duplicates and sort\n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst))) #Remove duplicates and sort\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst))) #remove duplicates and sort\n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(list(set(lst)))\n    \n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}]}, "HumanEval/113": {"dps": 98.98580121703854, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count_in_string = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_count_in_string += 1\n        output_string = \"the number of odd elements \" + str(odd_count_in_string) + \"n the str\" + str(odd_count_in_string) + \"ng \" + str(odd_count_in_string) + \" of the \" + str(odd_count_in_string) + \"nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_digits = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        output.append(output_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_digits = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        output.append(output_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output_list = []\n    for s in lst:\n        odd_digits = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        output_list.append(output_string)\n    return output_list", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_digits = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        output.append(output_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output_list = []\n    for s in lst:\n        odd_digits = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        output_list.append(output_string)\n    return output_list", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        count = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                count += 1\n        output_string = \"the number of odd elements \" + str(count) + \"n the str\" + str(count) + \"ng \" + str(count) + \" of the \" + str(count) + \"nput.\"\n        output.append(output_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_digits = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        output.append(output_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_digits = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        output.append(output_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_digits = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        output.append(output_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_digits = sum(1 for digit in s if int(digit) % 2 != 0)\n        result = f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n        output.append(result)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_digits = sum(int(digit) % 2 != 0 for digit in s)\n        output_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        output.append(output_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_digits = sum(1 for digit in s if int(digit) % 2 != 0)\n        new_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        output.append(new_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output_list = []\n    for s in lst:\n        odd_digit_count = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digit_count += 1\n        output_string = \"the number of odd elements \" + str(odd_digit_count) + \"n the str\" + str(odd_digit_count) + \"ng \" + str(odd_digit_count) + \" of the \" + str(odd_digit_count) + \"nput.\"\n        output_list.append(output_string)\n    return output_list", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output_list = []\n    for string in lst:\n        odd_digits = 0\n        for digit in string:\n            if int(digit) % 2 != 0:\n                odd_digits += 1\n        output_string = \"the number of odd elements \" + str(odd_digits) + \"n the str\" + str(odd_digits) + \"ng \" + str(odd_digits) + \" of the \" + str(odd_digits) + \"nput.\"\n        output_list.append(output_string)\n    return output_list", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 6.976744186046512, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1 = lst[0]\n    s2 = lst[1]\n\n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1 = lst[0]\n    s2 = lst[1]\n\n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1 = lst[0]\n    s2 = lst[1]\n\n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        cnt = 0\n        for char in s:\n            if char == '(':\n                cnt += 1\n            elif cnt > 0:\n                cnt -= 1\n            else:\n                return False\n        return cnt == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        cnt = 0\n        for char in s:\n            if char == '(':\n                cnt += 1\n            elif cnt > 0:\n                cnt -= 1\n            else:\n                return False\n        return cnt == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_good(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif count > 0:\n                count -= 1\n            else:\n                return False\n        return count == 0\n\n    if is_good(s1 + s2):\n        return 'Yes'\n    elif is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}]}, "HumanEval/120": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/121": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  #Sort by length, then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  #Sort by length, then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  #Sort by length then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  #Sort by length then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  #Sort by length then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  #Sort by length then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  #Sort by length then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  # Sort by length, then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  #Sort by length then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  #Sort by length then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  #Sort by length then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  #Sort by length then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  #Sort by length then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  # Sort by length, then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 97.79661016949153, "dps_norm": 98.75, "pass@1": 36.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n\n    # Optimized primality test: only check divisibility up to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, so it's not prime\n\n    return False  # No divisors found, so it's prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      n: An integer.\n\n    Returns:\n      True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      n: An integer.\n\n    Returns:\n      True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      n: An integer.\n\n    Returns:\n      True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      num: An integer.\n\n    Returns:\n      True if the number is not a prime number, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False  # 2 and 3 are prime\n    if num % 2 == 0 or num % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False  # Prime if no divisors found", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      n: An integer.\n\n    Returns:\n      True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      n: An integer.\n\n    Returns:\n      True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False # 2 and 3 are prime\n\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      num: An integer.\n\n    Returns:\n      True if the number is not a prime number, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False  # 2 and 3 are prime\n    if num % 2 == 0 or num % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False  # If no divisors found, it's prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      n: An integer.\n\n    Returns:\n      True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False  # If no divisors found, it's prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False  # Not divisible by any number up to sqrt(n), it's prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      n: An integer.\n\n    Returns:\n      True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False  # Prime if no divisors found", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      n: An integer.\n\n    Returns:\n      True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      n: An integer.\n\n    Returns: \n      True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      n: An integer.\n\n    Returns:\n      True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False  # If no divisors found, it's prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      n: An integer.\n\n    Returns:\n      True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      num: An integer.\n\n    Returns:\n      True if the number is not a prime number, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False  # 2 and 3 are prime\n    if num % 2 == 0 or num % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      n: An integer.\n\n    Returns:\n      True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      n: An integer.\n\n    Returns:\n      True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3, not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False  #If no divisors found, it's prime", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 95.46075085324232, "dps_norm": 84.16666666666666, "pass@1": 100.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      numbers: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or larger than the input list length.  \n      Raises TypeError if input is not a list or n is not an integer.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer.\")\n    if n <=0 or n > len(numbers):\n        return []\n\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        numbers: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of numbers.  Raises TypeError if input is not a list or n is not an integer.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"numbers must be a list\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0 or n > len(numbers):\n        return []\n\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      numbers: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of numbers.\n      Raises TypeError if input is not a list or n is not an integer.\n      Raises ValueError if n is negative.\n\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer.\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative.\")\n    if n == 0 or n > len(numbers):\n        return []\n\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        numbers: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.  Returns an empty list if the input list is empty or n is 0 or less.  Returns a list containing all numbers in descending order if n is greater than or equal to the length of the input list.\n\n    \"\"\"\n    if not numbers or n <= 0:\n        return []\n\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        numbers: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of numbers.  Raises TypeError if input is not a list or n is not an integer.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input 'numbers' must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"Input 'n' must be an integer.\")\n    if n <= 0 or n > len(numbers):\n        return []\n\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      nums: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of nums.  Returns a list containing all elements in descending order if n is greater than or equal to the length of nums\n    \"\"\"\n    if n == 0 or n > len(nums):\n        return []\n\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      nums: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of nums.  Returns the entire list sorted in descending order if n is greater than or equal to the length of nums.\n    \"\"\"\n    if n == 0 or n > len(nums):\n        return []\n    \n    return sorted(nums, reverse=True)[:n]", "matching_cluster_idx": 11}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      numbers: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of the input list.  Returns the input list if n is equal to the length of the input list.\n    \"\"\"\n    if n == 0 or n > len(numbers):\n        return []\n    if n == len(numbers):\n        return sorted(numbers, reverse=True)\n\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      numbers: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of numbers.  Raises TypeError if input is not a list or n is not an integer.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"numbers must be a list\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <=0 or n > len(numbers):\n        return []\n\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        numbers: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of numbers.  Raises TypeError if input is not a list or n is not an integer.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"numbers must be a list\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0 or n > len(numbers):\n        return []\n\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      nums: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of nums.  Raises TypeError if input is not a list or n is not an integer.\n    \"\"\"\n    if not isinstance(nums, list):\n        raise TypeError(\"nums must be a list\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0 or n > len(nums):\n        return []\n\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      nums: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of nums.  Raises TypeError if input is not a list or n is not an integer.\n    \"\"\"\n    if not isinstance(nums, list):\n        raise TypeError(\"nums must be a list\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0 or n > len(nums):\n        return []\n\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      nums: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of nums.  Returns a list containing all numbers in descending order if n is greater than or equal to the length of nums.\n    \"\"\"\n    if n == 0 or n > len(nums):\n        return []\n\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        numbers: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of numbers.  Raises TypeError if input is not a list or n is not an integer.\n\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"numbers must be a list\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0 or n > len(numbers):\n        return []\n\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      numbers: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of numbers.  Raises TypeError if input is not a list or n is not an integer.\n\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"numbers must be a list\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0 or n > len(numbers):\n        return []\n\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of nums.  Raises TypeError if input is not a list or n is not an integer.\n    \"\"\"\n    if not isinstance(nums, list):\n        raise TypeError(\"nums must be a list\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0 or n > len(nums):\n        return []\n\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      numbers: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or larger than the input list length.  Raises TypeError if input is not a list.  Raises ValueError if n is negative.\n\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative.\")\n    if n == 0 or n > len(numbers):\n        return []\n\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      nums: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of nums.  Returns a list of length less than n if nums has fewer than n elements.\n\n    \"\"\"\n    if n == 0 or n > len(nums):\n        return []\n    \n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      nums: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list containing the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of nums.  Raises TypeError if input is not a list or n is not an integer.\n    \"\"\"\n    if not isinstance(nums, list):\n        raise TypeError(\"nums must be a list\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <=0 or n > len(nums):\n        return []\n\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      nums: A list of numbers.\n      n: The number of largest integers to find.\n\n    Returns:\n      A list of the n largest integers in descending order.  Returns an empty list if n is 0 or greater than the length of nums.  Raises TypeError if input is not a list or n is not an integer.\n\n    \"\"\"\n    if not isinstance(nums, list):\n        raise TypeError(\"nums must be a list\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0 or n > len(nums):\n        return []\n\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 47.993197278911566, "dps_norm": 49.5, "pass@1": 70.0, "profiled": [{"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The minimum number of rotations (greater than 0) required to get the same string, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return -1  # No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The minimum number of rotations required, or -1 if no such rotation exists.  Returns 1 if the string is all the same character.\n    \"\"\"\n    if not s:\n        return -1  # Handle empty string case\n\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    #check if string is all the same character.\n    is_same = all(c == s[0] for c in s)\n    if is_same:\n        return 1\n\n    return -1 #No rotation found", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The minimum number of rotations, or -1 if no such rotation exists.  Returns 1 if the string is all the same character.\n    \"\"\"\n    if not s:\n        return -1  # Handle empty string case\n\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    #Check if string is all the same character, return 1 if it is\n    all_same = all(c == s[0] for c in s)\n    if all_same:\n        return 1\n\n    return -1  # No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The minimum number of rotations (greater than 0), or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated_s = s[i:] + s[:i]\n        if rotated_s == s:\n            return i\n    return -1  # No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations (greater than 0), or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return -1  # No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations (greater than 0), or -1 if no such rotation exists.  \n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated_s = s[i:] + s[:i]\n        if rotated_s == s:\n            return i\n    return -1  #No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or -1 if no such rotation exists.  Returns 1 if the string is all the same character.\n    \"\"\"\n    if not s:\n        return -1  # Handle empty string case\n\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    #check for all same character case. This is a special case since the above loop will not find a match.\n    if all(c == s[0] for c in s):\n        return 1\n    \n    return -1  # No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations (greater than 0), or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return -1  # No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The minimum number of rotations, or -1 if no such rotation exists.  Returns 1 if the string is all the same character.\n\n    \"\"\"\n    if not s:\n        return -1  # Handle empty string case\n\n    n = len(s)\n    for i in range(1, n + 1):  # Iterate through possible rotation amounts\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    #Check if all characters are the same\n    if all(c == s[0] for c in s):\n        return 1\n\n\n    return -1 #No rotation found", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The minimum number of rotations, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for rotations in range(1, n + 1):\n        rotated_s = s[rotations:] + s[:rotations]\n        if rotated_s == s:\n            return rotations\n    return -1  # No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The minimum number of rotations, or -1 if no such rotation exists.  Returns 1 if the string is all the same character.\n    \"\"\"\n    if not s:\n        return -1  # Handle empty string case\n\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    #Check for all same character case\n    if all(c == s[0] for c in s):\n        return 1\n\n    return -1  # No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return -1  # No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for rotations in range(1, n + 1):\n        rotated_s = s[rotations:] + s[:rotations]\n        if rotated_s == s:\n            return rotations\n    return -1  # No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The minimum number of rotations, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return -1  # No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or -1 if no such rotation exists.  Returns 1 if the string is all the same character.\n    \"\"\"\n    if not s:\n        return -1  # Handle empty string case\n\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    #Handle case where all characters are the same.\n    if all(c == s[0] for c in s):\n        return 1\n\n    return -1  # No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or -1 if no such rotation exists.  Returns 1 if the string is all the same character.\n    \"\"\"\n    if not s:\n        return -1  # Handle empty string case\n\n    n = len(s)\n    for i in range(1, n + 1):  # Iterate through possible rotations\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n        #Optimization for all same characters\n        if all(c == s[0] for c in s):\n            return 1\n\n\n    return -1  # No rotation produces the same string", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The minimum number of rotations, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated_s = s[i:] + s[:i]\n        if rotated_s == s:\n            return i\n    return -1  # No rotation found", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The minimum number of rotations required, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for rotations in range(1, n + 1):\n        rotated_s = s[rotations:] + s[:rotations]\n        if rotated_s == s:\n            return rotations\n    return -1  # No rotation found", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations required, or -1 if no such rotation exists.  Returns 1 if the string is all the same character.\n    \"\"\"\n    if not s:\n        return -1  # Handle empty string case\n\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    #Check for all same character case.  This handles strings like \"aaaa\" which would otherwise return -1.\n    if all(c == s[0] for c in s):\n        return 1\n\n    return -1  # No rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or -1 if no such rotation exists.  Returns 1 for strings that are all the same character.\n    \"\"\"\n    if not s:\n        return -1  # Handle empty string case\n\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    #Check for all same character case\n    if all(c == s[0] for c in s):\n        return 1\n    return -1 #No rotation found", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 48.0, "profiled": [{"solution": "def remove_Occ(input_string, char_to_remove):\n    \"\"\"Removes the first and last occurrences of a given character from a string.\n\n    Args:\n      input_string: The input string.\n      char_to_remove: The character to remove.\n\n    Returns:\n      The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n    \"\"\"\n    first_index = input_string.find(char_to_remove)\n    last_index = input_string.rfind(char_to_remove)\n\n    if first_index == -1:  # Character not found\n        return input_string\n    elif first_index == last_index: # Only one occurrence\n        return input_string[:first_index] + input_string[first_index+1:]\n    else:\n        return input_string[:first_index] + input_string[first_index+1:last_index] + input_string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str, ch):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n      str: The input string.\n      ch: The character to remove.\n\n    Returns:\n      The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n    \"\"\"\n\n    first = str.find(ch)\n    last = str.rfind(ch)\n\n    if first == -1:  # Character not found\n        return str\n\n    if first == last: # Only one occurrence\n        return str[:first] + str[first+1:]\n\n    return str[:first] + str[first+1:last] + str[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str, char):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n      str: The input string.\n      char: The character to remove.\n\n    Returns:\n      The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n    \"\"\"\n    first_index = str.find(char)\n    last_index = str.rfind(char)\n\n    if first_index == -1:  # Character not found\n        return str\n\n    if first_index == last_index: #only one occurrence\n        return str[:first_index] + str[first_index+1:]\n\n    return str[:first_index] + str[first_index+1:last_index] + str[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char_to_remove):\n    \"\"\"Removes the first and last occurrences of a given character from a string.\n\n    Args:\n      input_string: The input string.\n      char_to_remove: The character to remove.\n\n    Returns:\n      The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n    \"\"\"\n\n    first_index = input_string.find(char_to_remove)\n    last_index = input_string.rfind(char_to_remove)\n\n    if first_index == -1:  # Character not found\n        return input_string\n\n    if first_index == last_index: #only one occurrence\n        return input_string[:first_index] + input_string[first_index+1:]\n\n    return input_string[:first_index] + input_string[first_index + 1:last_index] + input_string[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str, char):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n      str: The input string.\n      char: The character to remove.\n\n    Returns:\n      The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n    \"\"\"\n    first_index = str.find(char)\n    last_index = str.rfind(char)\n\n    if first_index == -1:  #Character not found\n        return str\n\n    if first_index == last_index: #Only one occurrence\n        return str[:first_index] + str[first_index+1:]\n    else:\n        return str[:first_index] + str[first_index+1:last_index] + str[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str, ch):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n        str: The input string.\n        ch: The character to remove.\n\n    Returns:\n        The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n    \"\"\"\n    first = str.find(ch)\n    last = str.rfind(ch)\n\n    if first == -1:  # Character not found\n        return str\n\n    if first == last: # Only one occurrence\n        return str[:first] + str[first+1:]\n\n    return str[:first] + str[first+1:last] + str[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char_to_remove):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n        input_string: The input string.\n        char_to_remove: The character to remove.\n\n    Returns:\n        The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n\n    \"\"\"\n    first_index = input_string.find(char_to_remove)\n    last_index = input_string.rfind(char_to_remove)\n\n    if first_index == -1:  # Character not found\n        return input_string\n    elif first_index == last_index: #only one occurrence\n        return input_string[:first_index] + input_string[first_index+1:]\n    else:\n        return input_string[:first_index] + input_string[first_index+1:last_index] + input_string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str, char):\n    \"\"\"Removes the first and last occurrences of a given character from a string.\n\n    Args:\n      str: The input string.\n      char: The character to remove.\n\n    Returns:\n      The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n    \"\"\"\n\n    first = str.find(char)\n    last = str.rfind(char)\n\n    if first == -1:  # Character not found\n        return str\n\n    if first == last: # Only one occurrence\n        return str[:first] + str[first+1:]\n\n    return str[:first] + str[first+1:last] + str[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char_to_remove):\n    \"\"\"Removes the first and last occurrences of a character from a string.\n\n    Args:\n        input_string: The input string.\n        char_to_remove: The character to remove.\n\n    Returns:\n        The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n    \"\"\"\n\n    first_index = input_string.find(char_to_remove)\n    last_index = input_string.rfind(char_to_remove)\n\n    if first_index == -1:  # Character not found\n        return input_string\n\n    if first_index == last_index: #only one occurrence\n        return input_string[:first_index] + input_string[first_index+1:]\n\n    return input_string[:first_index] + input_string[first_index+1:last_index] + input_string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n        string: The input string.\n        char: The character to remove.\n\n    Returns:\n        The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n\n    \"\"\"\n    first_index = string.find(char)\n    last_index = string.rfind(char)\n\n    if first_index == -1:  # Character not found\n        return string\n    elif first_index == last_index: # Only one occurrence\n        return string[:first_index] + string[first_index+1:]\n    else:\n        return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char_to_remove):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n        input_string: The input string.\n        char_to_remove: The character to remove.\n\n    Returns:\n        The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n    \"\"\"\n    \n    first_index = input_string.find(char_to_remove)\n    last_index = input_string.rfind(char_to_remove)\n\n    if first_index == -1:  # Character not found\n        return input_string\n    \n    if first_index == last_index: #only one occurrence\n        return input_string[:first_index] + input_string[first_index+1:]\n    else:\n        return input_string[:first_index] + input_string[first_index+1:last_index] + input_string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str, char):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n      str: The input string.\n      char: The character to remove.\n\n    Returns:\n      The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n\n    \"\"\"\n    first = str.find(char)\n    last = str.rfind(char)\n\n    if first == -1:  # Character not found\n        return str\n\n    if first == last: #Only one occurrence\n        return str[:first] + str[first+1:]\n\n    return str[:first] + str[first+1:last] + str[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str, char):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n      str: The input string.\n      char: The character to remove.\n\n    Returns:\n      The string with the first and last occurrences of the character removed.\n      Returns the original string if the character is not found.\n\n    \"\"\"\n    first_index = str.find(char)\n    last_index = str.rfind(char)\n\n    if first_index == -1:  # Character not found\n        return str\n\n    if first_index == last_index: #only one occurence\n        return str[:first_index] + str[first_index+1:]\n\n    return str[:first_index] + str[first_index+1:last_index] + str[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_str, char_to_remove):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n      input_str: The input string.\n      char_to_remove: The character to remove.\n\n    Returns:\n      The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n\n    \"\"\"\n    first_index = input_str.find(char_to_remove)\n    last_index = input_str.rfind(char_to_remove)\n\n    if first_index == -1:  #Character not found\n        return input_str\n\n    if first_index == last_index: # only one occurrence\n        return input_str[:first_index] + input_str[first_index+1:]\n    else:\n        return input_str[:first_index] + input_str[first_index+1:last_index] + input_str[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char_to_remove):\n    \"\"\"Removes the first and last occurrences of a given character from a string.\n\n    Args:\n        input_string: The input string.\n        char_to_remove: The character to remove.\n\n    Returns:\n        The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n    \"\"\"\n\n    first_index = input_string.find(char_to_remove)\n    last_index = input_string.rfind(char_to_remove)\n\n    if first_index == -1:  # Character not found\n        return input_string\n\n    if first_index == last_index: #only one occurrence\n        return input_string[:first_index] + input_string[first_index+1:]\n\n    return input_string[:first_index] + input_string[first_index+1:last_index] + input_string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str, ch):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n      str: The input string.\n      ch: The character to remove.\n\n    Returns:\n      The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n    \"\"\"\n    first = str.find(ch)\n    last = str.rfind(ch)\n\n    if first == -1:  # Character not found\n        return str\n\n    if first == last: #Only one occurrence\n        return str.replace(ch,\"\",1)\n\n    return str[:first] + str[first+1:last] + str[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char_to_remove):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n      input_string: The input string.\n      char_to_remove: The character to remove.\n\n    Returns:\n      The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n    \"\"\"\n\n    first_index = input_string.find(char_to_remove)\n    last_index = input_string.rfind(char_to_remove)\n\n    if first_index == -1:  # Character not found\n        return input_string\n    elif first_index == last_index: #Only one occurrence\n        return input_string[:first_index] + input_string[first_index+1:]\n    else:\n        return input_string[:first_index] + input_string[first_index+1:last_index] + input_string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str, ch):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n        str: The input string.\n        ch: The character to remove.\n\n    Returns:\n        The string with the first and last occurrences of the character removed.  Returns the original string if the character is not found.\n    \"\"\"\n    first = str.find(ch)\n    last = str.rfind(ch)\n\n    if first == -1:  # Character not found\n        return str\n\n    if first == last: #Only one occurrence\n        return str[:first] + str[first+1:]\n\n    return str[:first] + str[first+1:last] + str[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_str, char_to_remove):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n        input_str: The input string.\n        char_to_remove: The character to remove.\n\n    Returns:\n        The string with the first and last occurrences of the character removed.\n        Returns the original string if the character is not found.\n    \"\"\"\n\n    first_index = input_str.find(char_to_remove)\n    last_index = input_str.rfind(char_to_remove)\n\n    if first_index == -1:  # Character not found\n        return input_str\n\n    if first_index == last_index: # Only one occurrence\n        return input_str[:first_index] + input_str[first_index+1:]\n    else:\n        return input_str[:first_index] + input_str[first_index+1:last_index] + input_str[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str, char):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n      str: The input string.\n      char: The character to remove.\n\n    Returns:\n      The string with the first and last occurrences of the character removed.\n      Returns the original string if the character is not found.\n\n    \"\"\"\n    first_index = str.find(char)\n    last_index = str.rfind(char)\n\n    if first_index == -1:  # Character not found\n        return str\n\n    if first_index == last_index: # Only one occurrence\n        return str[:first_index] + str[first_index+1:]\n\n    return str[:first_index] + str[first_index+1:last_index] + str[last_index+1:]", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 95.13477088948787, "dps_norm": 96.875, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new list of lists representing the sorted matrix.  Returns an empty list if input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return []  #Handle invalid input\n\n    #Calculate row sums and create tuples for sorting\n    row_sums = [(sum(row), row) for row in matrix]\n\n    #Sort by row sum\n    row_sums.sort()\n\n    #Extract sorted rows\n    sorted_matrix = [row for sum_row, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new list of lists representing the sorted matrix.  Returns the original \n      matrix if it's empty or contains non-numerical data.\n    \"\"\"\n    if not matrix:\n        return matrix\n\n    # Check if all elements are numbers\n    if not all(isinstance(x, (int, float)) for row in matrix for x in row):\n        return matrix\n\n\n    # Create a list of tuples, where each tuple contains the row sum and the row itself.\n    row_sums = [(sum(row), row) for row in matrix]\n\n    # Sort the list of tuples based on the row sums.\n    row_sums.sort()\n\n    # Extract the sorted rows to create the sorted matrix.\n    sorted_matrix = [row for sum_row, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 5}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new list of lists representing the sorted matrix.  Returns an empty list if input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return []  #Handle invalid input\n\n    #Calculate row sums and create tuples for sorting\n    row_sums = [(sum(row), row) for row in matrix]\n\n    #Sort by row sum (ascending)\n    row_sums.sort()\n\n    #Extract sorted rows\n    sorted_matrix = [row for sum_row, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new matrix sorted in ascending order based on row sums.  Returns an empty list if input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return []  # Handle invalid input\n\n    #Calculate row sums and create tuples for sorting\n    row_sums = [(sum(row), row) for row in matrix]\n\n    #Sort based on row sums\n    row_sums.sort()\n\n    #Extract sorted rows\n    sorted_matrix = [row for sum_row, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix in ascending order based on the sum of its rows.\"\"\"\n\n    # Calculate row sums and create a list of (sum, row) tuples.\n    row_sums = [(sum(row), row) for row in matrix]\n\n    # Sort the list of tuples based on the row sums (the first element of each tuple).\n    row_sums.sort()\n\n    # Extract the sorted rows to create the sorted matrix.\n    sorted_matrix = [row for sum_row, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix in ascending order based on the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new matrix sorted in ascending order based on row sums.  Returns an empty list if input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return []  # Handle invalid input\n\n    #Calculate row sums and create tuples for sorting\n    row_sums = [(sum(row), row) for row in matrix]\n\n    #Sort based on row sums\n    row_sums.sort()\n\n    #Extract sorted rows\n    sorted_matrix = [row for _, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new matrix sorted in ascending order based on row sums.  Returns an empty list if the input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return []  # Handle invalid input\n\n    # Calculate row sums and create a list of (sum, row) tuples\n    rows_with_sums = [(sum(row), row) for row in matrix]\n\n    # Sort the tuples based on the sums (first element of the tuple)\n    rows_with_sums.sort()\n\n    # Extract the sorted rows to create the sorted matrix\n    sorted_matrix = [row for sum_row, row in rows_with_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.  Returns an empty list if the input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return []  # Handle invalid input\n\n    # Calculate row sums and create a list of (sum, row) tuples\n    row_sums = [(sum(row), row) for row in matrix]\n\n    # Sort the tuples based on row sums\n    row_sums.sort()\n\n    # Extract the sorted rows\n    sorted_matrix = [row for sum_row, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new list of lists representing the sorted matrix.  Returns an empty list if the input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return []  #Handle invalid input\n\n    # Calculate row sums and create tuples for sorting\n    row_sums = [(sum(row), row) for row in matrix]\n\n    # Sort based on row sums\n    row_sums.sort()\n\n    # Extract sorted rows\n    sorted_matrix = [row for sum_row, row in row_sums]\n\n    return sorted_matrix\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]\nsorted_matrix = sort_matrix(matrix)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new matrix sorted in ascending order based on row sums.\n    \"\"\"\n\n    #Calculate row sums\n    row_sums = [sum(row) for row in matrix]\n\n    #Zip row sums and matrix rows for sorting\n    zipped_data = list(zip(row_sums, matrix))\n\n    #Sort by row sums (first element of the tuple)\n    zipped_data.sort()\n\n    #Unzip to get the sorted matrix\n    sorted_matrix = [row for _, row in zipped_data]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.  Returns an empty list if input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return [] #Handle invalid input\n\n    #Calculate row sums and create a list of (sum, row) tuples\n    row_sums = [(sum(row), row) for row in matrix]\n\n    #Sort the list of tuples based on the row sums\n    row_sums.sort()\n\n    #Extract the sorted rows\n    sorted_matrix = [row for sum_row, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.  Returns an empty list if input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return []  # Handle invalid input\n\n    # Calculate row sums and create tuples for sorting\n    row_sums = [(sum(row), row) for row in matrix]\n\n    # Sort based on row sums\n    row_sums.sort()\n\n    # Extract sorted rows\n    sorted_matrix = [row for _, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new list of lists representing the sorted matrix.  Returns an empty list if input is invalid.\n\n    Raises:\n      TypeError: if input is not a list of lists.\n      ValueError: if rows in the matrix are of unequal length.\n\n    \"\"\"\n    if not isinstance(matrix, list):\n        raise TypeError(\"Input must be a list of lists.\")\n    if not all(isinstance(row, list) for row in matrix):\n        raise TypeError(\"Input must be a list of lists.\")\n    if len(matrix) > 0 and not all(len(row) == len(matrix[0]) for row in matrix):\n        raise ValueError(\"All rows in the matrix must have the same length.\")\n    if len(matrix) == 0:\n      return []\n\n    # Create a list of tuples where each tuple contains the row sum and the row itself.\n    rows_with_sums = [(sum(row), row) for row in matrix]\n\n    # Sort the list of tuples based on the row sums (the first element of each tuple).\n    rows_with_sums.sort()\n\n    # Extract the sorted rows from the list of tuples.\n    sorted_matrix = [row for sum_val, row in rows_with_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix in ascending order based on the sum of its rows.\"\"\"\n\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n\n    # Create a list of tuples, where each tuple contains the row sum and the original row\n    row_sum_pairs = list(zip(row_sums, matrix))\n\n    # Sort the list of tuples based on the row sums (the first element of each tuple)\n    row_sum_pairs.sort()\n\n    # Extract the sorted rows from the tuples\n    sorted_matrix = [row for sum_val, row in row_sum_pairs]\n\n    return sorted_matrix\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]\nsorted_matrix = sort_matrix(matrix)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.  Returns an empty list if input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return []  #Handle invalid input\n\n    # Calculate row sums and create a list of (sum, row) tuples\n    row_sums = [(sum(row), row) for row in matrix]\n\n    # Sort the tuples based on the row sums (first element of the tuple)\n    row_sums.sort()\n\n    # Extract the sorted rows\n    sorted_matrix = [row for sum_val, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new list of lists representing the sorted matrix.  Returns an empty list if the input is invalid.\n    \"\"\"\n    if not matrix or not all(isinstance(row, list) for row in matrix):\n        return []\n\n    # Calculate row sums and create a list of (sum, row) tuples\n    row_sums = [(sum(row), row) for row in matrix]\n\n    # Sort the tuples based on the row sums (first element of the tuple)\n    row_sums.sort()\n\n    # Extract the sorted rows\n    sorted_matrix = [row for sum_row, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix in ascending order based on row sums.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new list of lists representing the sorted matrix.  Returns an empty list if the input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return []  #Handle invalid input\n\n    # Calculate row sums and create a list of (sum, row) tuples\n    row_sums = [(sum(row), row) for row in matrix]\n\n    # Sort the tuples based on row sums (first element of the tuple)\n    row_sums.sort()\n\n    # Extract the sorted rows\n    sorted_matrix = [row for sum_val, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new list of lists representing the sorted matrix.  Returns an empty list if the input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return []  #Handle invalid input\n\n    #Calculate row sums and create a list of (sum, row) tuples\n    row_sums = [(sum(row), row) for row in matrix]\n\n    #Sort the tuples based on the sum (first element of the tuple)\n    row_sums.sort()\n\n    #Extract the sorted rows\n    sorted_matrix = [row for sum_val, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix in ascending order based on row sums.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new matrix sorted in ascending order based on row sums.  Returns an empty list if input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return []  #Handle invalid input\n\n    #Calculate row sums and create tuples for sorting\n    rows_with_sums = [(sum(row), row) for row in matrix]\n\n    #Sort based on row sums\n    rows_with_sums.sort()\n\n    #Extract sorted rows\n    sorted_matrix = [row for sum_val, row in rows_with_sums]\n    return sorted_matrix\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]\nsorted_matrix = sort_matrix(matrix)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new list of lists representing the sorted matrix.  Returns an empty list if input is invalid.\n    \"\"\"\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        return []  # Handle invalid input\n\n    # Calculate row sums and create a list of (sum, row) tuples\n    row_sums = [(sum(row), row) for row in matrix]\n\n    # Sort the tuples based on the sum (first element of the tuple)\n    row_sums.sort()\n\n    # Extract the sorted rows\n    sorted_matrix = [row for sum_val, row in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      True if the string contains sequences of lowercase letters joined with underscores, \n      False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.  ^ and $ ensure the entire string matches.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'  # Matches one or more lowercase letters, followed by zero or more occurrences of an underscore and one or more lowercase letters.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.  ^ and $ ensure the whole string matches.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      True if the string contains sequences of lowercase letters joined with underscores, \n      False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'  # Matches one or more lowercase letters, optionally followed by one or more underscores and lowercase letters.\n    match = re.fullmatch(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'  # Matches one or more lowercase letters, followed by zero or more occurrences of \"_\" and one or more lowercase letters.  ^ and $ ensure the entire string matches.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      True if the string contains sequences of lowercase letters joined with underscores, \n      False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.  ^ and $ ensure the whole string matches.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.  ^ and $ ensure the whole string matches.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.  The ^ and $ ensure the entire string matches.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'  # Matches one or more lowercase letters, optionally followed by one or more underscores and lowercase letters.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      True if the string contains only lowercase letters and underscores, \n      and the underscores are used to separate sequences of lowercase letters; \n      False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.  The ^ and $ anchor to the beginning and end of the string.\n\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.  ^ and $ ensure the entire string matches.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches one or more lowercase letters, optionally followed by underscores and more lowercase letters.  The ^ and $ anchor to the beginning and end of the string.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}]}, "Mbpp/19": {"dps": 98.53535353535354, "dps_norm": 99.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array of integers contains any duplicate elements.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      True if the array contains any duplicate elements, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def contains_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate element.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      True if the array contains any duplicate element, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\ndef test_duplicate(arr):\n    return contains_duplicate(arr)", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    assert test_duplicate(([1,2,3,4,5]))==False\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def contains_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate element.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      True if the array contains any duplicate element, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\ndef test_duplicate(arr):\n    return contains_duplicate(arr)", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    assert test_duplicate(([1,2,3,4,5]))==False\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array of integers contains any duplicate elements.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      True if the array contains duplicate elements, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array of integers contains any duplicate elements.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      True if the array contains duplicate elements, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def contains_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicate elements, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\ndef test_duplicate(arr):\n    return contains_duplicate(arr)", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    assert test_duplicate(([1,2,3,4,5]))==False\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array of integers contains any duplicate elements.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array of integers contains any duplicate elements.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      True if the array contains any duplicate elements, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array contains any duplicate elements.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      True if the array contains duplicate elements, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate element.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      True if the array contains duplicate elements, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def contains_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate element.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      True if the array contains duplicate elements, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\ndef test_duplicate(arr):\n    return contains_duplicate(arr)", "matching_cluster_idx": 14}, {"solution": "def contains_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate element.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains any duplicate element, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\ndef test_duplicate(arr):\n    \"\"\"\n    Test function for contains_duplicate.\n    \"\"\"\n    return contains_duplicate(arr)", "matching_cluster_idx": 13}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array contains any duplicate elements.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def contains_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      True if the array contains at least one duplicate element, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\ndef test_duplicate(arr):\n    \"\"\"Test function for contains_duplicate.\"\"\"\n    return contains_duplicate(arr)", "matching_cluster_idx": 14}]}, "Mbpp/62": {"dps": 50.15384615384615, "dps_norm": 58.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n\n    Raises:\n      TypeError: if input is not a list.\n      ValueError: if input list contains non-numeric values.\n\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    if not all(isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"List must contain only numbers.\")\n    if not numbers:\n        return None  #Handle empty list case\n    return min(numbers)", "matching_cluster_idx": 0}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The smallest number in the list.  Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    min_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    \n    min_num = numbers[0]  # Initialize with the first element\n    for number in numbers:\n        if number < min_num:\n            min_num = number\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n\n    Raises:\n      TypeError: if input is not a list.\n      ValueError: if the list contains non-numeric values.\n\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    if not numbers:\n        return None  # Handle empty list case\n    if not all(isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"List must contain only numbers.\")\n\n    smallest = numbers[0]  # Initialize with the first element\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    min_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n\n    Raises:\n      TypeError: if input is not a list.\n      ValueError: if the list contains non-numeric values.\n\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    if not numbers:\n        return None  #Handle empty list case\n    if not all(isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"List must contain only numbers.\")\n\n    min_num = numbers[0]  # Initialize with the first element\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": -1}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    min_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    min_num = numbers[0]\n    for number in numbers:\n        if number < min_num:\n            min_num = number\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The smallest number in the list.  Returns None if the list is empty.\n\n    Raises:\n        TypeError: if input is not a list.\n        ValueError: if the list contains non-numeric values.\n\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    if not numbers:\n        return None  #Handle empty list case\n    if not all(isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"List must contain only numbers.\")\n\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    min_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    min_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for number in numbers:\n        if number < smallest:\n            smallest = number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    min_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for number in numbers:\n        if number < smallest:\n            smallest = number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n\n    Raises:\n      TypeError: if input is not a list.\n      ValueError: if the list contains non-numeric values.\n\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    if not numbers:\n        return None\n    if not all(isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"List must contain only numbers.\")\n    return min(numbers)", "matching_cluster_idx": 0}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n\n    \"\"\"\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for number in numbers:\n        if number < smallest:\n            smallest = number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The smallest number in the list.  Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for number in numbers:\n        if number < smallest:\n            smallest = number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The smallest number in the list.  Returns None if the list is empty.\n\n    Raises:\n        TypeError: if input is not a list.\n        ValueError: if the list contains non-numeric values.\n\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    if not numbers:\n        return None  #Handle empty list case\n    if not all(isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"List must contain only numbers.\")\n\n    min_num = numbers[0]  # Initialize with the first element\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": -1}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    min_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    min_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}]}, "Mbpp/75": {"dps": 94.28571428571429, "dps_norm": 73.33333333333334, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples in a list where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for num in tup:\n            if num % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 8}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n      list_of_tuples: A list of tuples.\n      k: The divisor.\n\n    Returns:\n      A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples are found.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Finds tuples in a list where all elements are divisible by k.\n\n    Args:\n        tuple_list: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in tuple_list:\n        all_divisible = True\n        for num in tup:\n            if num % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result\ntuple_list = [(6, 24, 12), (7, 9, 6), (12, 18, 21)]\nk = 6\nresult = find_tuples(tuple_list, k)", "matching_cluster_idx": 8}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples of integers.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for num in tup:\n            if num % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 8}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Finds tuples in a list where all elements are divisible by k.\n\n    Args:\n        tuple_list: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in tuple_list:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: An integer.\n\n    Returns:\n        A list of tuples where all elements in each tuple are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples in a list where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list containing tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples in a list where all elements are divisible by k.\n\n    Args:\n      list_of_tuples: A list of tuples.\n      k: The divisor.\n\n    Returns:\n      A list containing only the tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n      list_of_tuples: A list of tuples.\n      k: The divisor.\n\n    Returns:\n      A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result\nlist_of_tuples = [(6, 24, 12), (7, 9, 6), (12, 18, 21)]\nk = 6\nresult = find_tuples(list_of_tuples, k)", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result\nlist_of_tuples = [(6, 24, 12), (7, 9, 6), (12, 18, 21)]\nk = 6\nresult = find_tuples(list_of_tuples,k)", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n      list_of_tuples: A list of tuples of integers.\n      k: An integer divisor.\n\n    Returns:\n      A list containing only the tuples from list_of_tuples where all elements \n      are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples in a list where all elements are divisible by k.\n\n    Args:\n      list_of_tuples: A list of tuples.\n      k: The divisor.\n\n    Returns:\n      A list containing only the tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for num in tup:\n            if num % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result\nlist_of_tuples = [(6, 24, 12), (7, 9, 6), (12, 18, 21)]\nk = 6\nresult = find_tuples(list_of_tuples, k)", "matching_cluster_idx": 8}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples in a list where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: An integer.\n\n    Returns:\n        A list of tuples that satisfy the condition.  Returns an empty list if no tuples satisfy the condition.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n      list_of_tuples: A list of tuples.\n      k: The divisor.\n\n    Returns:\n      A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result\nlist_of_tuples = [(6, 24, 12), (7, 9, 6), (12, 18, 21)]\nk = 6\nresult = find_tuples(list_of_tuples, k)", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.  Returns an empty list if no such tuples exist.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = all(x % k == 0 for x in tup)\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 91.7156862745098, "dps_norm": 92.85714285714286, "pass@1": 100.0, "profiled": [{"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of elements in a list.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    return dict(Counter(input_list))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of elements in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are elements from the input list and values are their frequencies.\n        Returns an empty dictionary if the input list is empty.\n\n    \"\"\"\n    if not input_list:\n        return {}\n    \n    return dict(Counter(input_list))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the unique elements from the input list and \n        values are their corresponding frequencies.  Returns an empty dictionary if the input is empty.\n    \"\"\"\n    if not input_list:\n        return {}\n    return dict(Counter(input_list))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef freq_count(list_):\n    \"\"\"\n    Counts the frequency of elements in a list.\n\n    Args:\n      list_: The input list.\n\n    Returns:\n      A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    return dict(Counter(list_))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Write a function to get the frequency of all the elements in a list, returned as a dictionary.\n    assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1})\n    \"\"\"\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      A dictionary where keys are elements from the input list and values are their frequencies.\n    \"\"\"\n\n    frequency = {}\n    for item in input_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      A dictionary where keys are the unique elements from the input list and \n      values are their corresponding frequencies.  Returns an empty dictionary if the input is None or empty.\n    \"\"\"\n    if not input_list:\n        return {}\n    return dict(Counter(input_list))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef freq_count(list_):\n    \"\"\"\n    This function takes a list as input and returns a dictionary containing the frequency of each element in the list.\n    \"\"\"\n    return dict(Counter(list_))\nlist_ = [10,10,10,10,20,20,20,20,40,40,50,50,30]", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of elements in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are elements from the input list and values are their frequencies.  Returns an empty dictionary if the input is not a list or the list is empty.\n    \"\"\"\n    if not isinstance(input_list, list):\n        return {}\n    if not input_list:\n        return {}\n    return dict(Counter(input_list))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the unique elements from the list and \n        values are their corresponding frequencies.  Returns an empty \n        dictionary if the input list is empty.\n    \"\"\"\n    if not input_list:\n        return {}\n    return dict(Counter(input_list))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements from the input list and values are their frequencies.\n    \"\"\"\n    return dict(Counter(input_list))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the unique elements from the input list and \n        values are their corresponding frequencies.  Returns an empty dictionary if the input is empty or None.\n    \"\"\"\n    if not input_list:\n        return {}\n    return dict(Counter(input_list))", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the unique elements from the input list and values are their frequencies.\n    \"\"\"\n    freq_dict = defaultdict(int)  #Use defaultdict to avoid KeyError if a new element is encountered\n    for item in input_list:\n        freq_dict[item] += 1\n    return dict(freq_dict) #Convert back to a regular dict for assertion purposes.", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      A dictionary where keys are the elements from the input list and values are their frequencies.  Returns an empty dictionary if the input list is empty.\n    \"\"\"\n    if not input_list:\n        return {}\n    return dict(Counter(input_list))", "matching_cluster_idx": 6}, {"solution": "def freq_count(data):\n    \"\"\"\n    Counts the frequency of elements in a list.\n\n    Args:\n      data: A list of elements.\n\n    Returns:\n      A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    freq = {}\n    for item in data:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(data):\n    \"\"\"\n    Counts the frequency of elements in a list.\n\n    Args:\n        data: A list of elements.\n\n    Returns:\n        A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    freq = {}\n    for item in data:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of elements in a list.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    return dict(Counter(input_list))", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      A dictionary where keys are elements from the input list and values are their frequencies.\n    \"\"\"\n    freq_dict = defaultdict(int)  # Use defaultdict for easier counting\n    for item in input_list:\n        freq_dict[item] += 1\n    return dict(freq_dict)  # Convert back to a regular dictionary if needed", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Counts the frequency of elements in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    return dict(Counter(input_list))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      A dictionary where keys are the elements from the input list and values are their frequencies.  Returns an empty dictionary if the input list is empty.\n    \"\"\"\n    if not input_list:\n        return {}\n    return dict(Counter(input_list))\ninput_list = [10,10,10,10,20,20,20,20,40,40,50,50,30]", "matching_cluster_idx": 6}]}, "Mbpp/90": {"dps": 75.63414634146342, "dps_norm": 83.57142857142857, "pass@1": 100.0, "profiled": [{"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n      words: A list of strings.\n\n    Returns:\n      The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n      words: A list of strings.\n\n    Returns:\n      The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)\nwords = [\"python\",\"PHP\",\"bigdata\"]", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n      words: A list of strings.\n\n    Returns:\n      The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n      words: A list of strings.\n\n    Returns:\n      The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n      words: A list of strings.\n\n    Returns:\n      The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n      words: A list of strings.\n\n    Returns:\n      The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Write a python function to find the length of the longest word.\n    assert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7\n    \"\"\"\n    if not words:  # Handle empty list case\n        return 0\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Write a python function to find the length of the longest word.\n    assert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7\n    \"\"\"\n    if not words:  # Handle empty list case\n        return 0\n    \n    max_length = 0\n    for word in words:\n        max_length = max(max_length, len(word))\n    return max_length", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n      words: A list of strings.\n\n    Returns:\n      The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 62.545731707317074, "dps_norm": 55.0, "pass@1": 84.0, "profiled": [{"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        list_of_tuples: A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second element.  Returns None if the list is empty.\n\n    Raises:\n        TypeError: if input is not a list.\n        ValueError: if any tuple in the list does not have at least two elements, or if the second element is not comparable.\n\n    \"\"\"\n    if not isinstance(list_of_tuples, list):\n        raise TypeError(\"Input must be a list of tuples.\")\n    if not list_of_tuples:\n        return None\n\n    for tup in list_of_tuples:\n        if not isinstance(tup, tuple) or len(tup) < 2:\n            raise ValueError(\"All elements in the list must be tuples with at least two elements.\")\n        try:\n            float(tup[1]) #check if comparable, this handles int and floats.\n        except ValueError:\n            raise ValueError(\"The second element of each tuple must be comparable.\")\n\n\n    min_tuple = min(list_of_tuples, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 1}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuple_list: A list of tuples, where each tuple contains two elements.\n\n    Returns:\n        The first value of the tuple with the smallest second value.  Returns None if the list is empty.\n    \"\"\"\n    if not tuple_list:\n        return None\n\n    min_tuple = min(tuple_list, key=lambda item: item[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n      tuple_list: A list of tuples, where each tuple contains at least two elements.\n\n    Returns:\n      The first element of the tuple with the smallest second element.  Returns None if the input list is empty.\n\n    Raises:\n      TypeError: if input is not a list.\n      ValueError: if any tuple in the list does not have at least two elements, or if the second element is not comparable.\n\n    \"\"\"\n    if not isinstance(tuple_list, list):\n        raise TypeError(\"Input must be a list of tuples.\")\n\n    if not tuple_list:\n        return None\n\n    for tup in tuple_list:\n        if not isinstance(tup, tuple) or len(tup) < 2:\n            raise ValueError(\"Tuples must contain at least two elements.\")\n        try:\n            float(tup[1]) #check if second element can be compared\n        except ValueError:\n            raise ValueError(\"Second element of each tuple must be comparable\")\n\n\n\n    min_second_value = min(tuple_list, key=lambda x: x[1])[1]\n    for tup in tuple_list:\n        if tup[1] == min_second_value:\n            return tup[0]", "matching_cluster_idx": 0}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value in a list of tuples.\n\n    Args:\n      tuple_list: A list of tuples, where each tuple contains two elements (string, integer).\n\n    Returns:\n      The first element (string) of the tuple with the smallest second element (integer).\n      Returns None if the input list is empty or contains tuples with non-integer second elements.\n\n    \"\"\"\n    if not tuple_list:\n        return None\n\n    #Error handling for non-integer second elements\n    if not all(isinstance(x[1], int) for x in tuple_list):\n        return None\n\n\n    min_tuple = min(tuple_list, key=lambda item: item[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuple_list: A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second element.  Returns None if the list is empty.\n    \"\"\"\n    if not tuple_list:\n        return None\n\n    min_tuple = min(tuple_list, key=lambda x: x[1])  #Finds the tuple with the minimum second element\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        list_of_tuples: A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second element.  Returns None if the list is empty.\n\n    Raises:\n        TypeError: if input is not a list.\n        ValueError: if any tuple in the list does not have at least two elements, or if the second element is not comparable.\n\n    \"\"\"\n    if not isinstance(list_of_tuples, list):\n        raise TypeError(\"Input must be a list.\")\n    if not list_of_tuples:\n        return None\n\n    for tup in list_of_tuples:\n        if not isinstance(tup, tuple) or len(tup) < 2:\n            raise ValueError(\"All elements in the list must be tuples with at least two elements.\")\n        try:\n            float(tup[1]) #check if second element is comparable, can be extended for other types\n        except (ValueError, TypeError):\n            raise ValueError(\"Second element of each tuple must be comparable.\")\n\n    min_tuple = min(list_of_tuples, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 1}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        list_of_tuples: A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second element.  Returns None if the list is empty.\n\n    Raises:\n        TypeError: if input is not a list.\n        ValueError: if tuples in list don't have at least two elements.\n    \"\"\"\n    if not isinstance(list_of_tuples, list):\n        raise TypeError(\"Input must be a list of tuples.\")\n    if not list_of_tuples:  # Handle empty list case\n        return None\n\n    for tup in list_of_tuples:\n        if len(tup) < 2:\n            raise ValueError(\"Tuples must have at least two elements.\")\n\n    #Find the minimum second value efficiently using min function and a key to specify the comparison element.\n    min_tuple = min(list_of_tuples, key=lambda item: item[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value in a list of tuples.\n\n    Args:\n      list_of_tuples: A list of tuples, where each tuple contains two elements: a string and an integer.\n\n    Returns:\n      The string (first element) of the tuple with the smallest integer (second element).  \n      Returns None if the input list is empty.\n    \"\"\"\n    if not list_of_tuples:\n        return None\n\n    min_tuple = min(list_of_tuples, key=lambda x: x[1])  #Finds the tuple with the minimum second element.\n    return min_tuple[0] # Returns the first element (string) of that tuple.", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuple_list: A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n        The first value of the tuple with the smallest second value.  Returns None if the list is empty.\n\n    Raises:\n        TypeError: if input is not a list.\n        ValueError: if any tuple in the list does not have at least two elements, or if the second element is not comparable.\n\n    \"\"\"\n    if not isinstance(tuple_list, list):\n        raise TypeError(\"Input must be a list of tuples.\")\n    \n    if not tuple_list:\n        return None\n\n    for tup in tuple_list:\n        if len(tup) < 2:\n            raise ValueError(\"All tuples must have at least two elements.\")\n        if not isinstance(tup[1], (int, float)): #check for comparable second element. Could be extended.\n          raise ValueError(\"Second element of tuples must be comparable (int or float).\")\n\n\n    min_tuple = min(tuple_list, key=lambda item: item[1])\n    return min_tuple[0]", "matching_cluster_idx": 1}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuple_list: A list of tuples, where each tuple contains two elements (a string and an integer).\n\n    Returns:\n        The first element (string) of the tuple with the smallest second element (integer).  \n        Returns None if the input list is empty.\n\n    \"\"\"\n    if not tuple_list:\n        return None\n\n    min_tuple = min(tuple_list, key=lambda x: x[1])  #Finds tuple with minimum second element\n    return min_tuple[0] # returns the first element of that tuple", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples_list: A list of tuples, where each tuple contains two elements (a string and an integer).\n\n    Returns:\n        The first element (string) of the tuple with the smallest second element (integer).  Returns None if the list is empty.\n\n    \"\"\"\n    if not tuples_list:\n        return None\n\n    min_tuple = min(tuples_list, key=lambda item: item[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value in a list of tuples.\n\n    Args:\n        list_of_tuples: A list of tuples, where each tuple contains two elements: a string and an integer.\n\n    Returns:\n        The string (first element) of the tuple with the smallest integer (second element).  Returns None if the list is empty.\n    \"\"\"\n    if not list_of_tuples:\n        return None\n\n    min_tuple = min(list_of_tuples, key=lambda item: item[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Args:\n      list_of_tuples: A list of tuples, where each tuple contains two elements: a string and an integer.\n\n    Returns:\n      The string from the tuple with the smallest integer value.  Returns None if the list is empty.\n    \"\"\"\n    if not list_of_tuples:\n        return None\n\n    min_tuple = min(list_of_tuples, key=lambda item: item[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value in a list of tuples.\n\n    Args:\n        list_of_tuples: A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second element.  Returns None if the list is empty.\n\n    Raises:\n        TypeError: if input is not a list.\n        ValueError: if any tuple in the list does not have at least two elements, or if the second element is not comparable.\n\n    \"\"\"\n    if not isinstance(list_of_tuples, list):\n        raise TypeError(\"Input must be a list.\")\n    if not list_of_tuples:\n        return None\n\n    for tup in list_of_tuples:\n        if not isinstance(tup, tuple) or len(tup) < 2:\n            raise ValueError(\"All elements in the list must be tuples with at least two elements.\")\n        try:\n            # Check if the second element is comparable. This will raise an error if it's not a number or comparable type.\n            min(list_of_tuples, key=lambda x: x[1])[1]\n            break\n        except TypeError:\n            raise ValueError(\"The second element of each tuple must be comparable.\")\n\n    min_tuple = min(list_of_tuples, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Finds the first element of the tuple with the smallest second value.\n\n    Args:\n      list_of_tuples: A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n      The first element of the tuple with the smallest second value.  Returns None if the list is empty.\n    \"\"\"\n    if not list_of_tuples:\n        return None\n\n    min_tuple = min(list_of_tuples, key=lambda item: item[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Finds the first element of the tuple with the smallest second value in a list of tuples.\n\n    Args:\n      list_of_tuples: A list of tuples, where each tuple contains at least two elements.\n\n    Returns:\n      The first element of the tuple with the smallest second value.  Returns None if the list is empty.\n    \"\"\"\n    if not list_of_tuples:\n        return None\n\n    min_tuple = min(list_of_tuples, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuple_list: A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second element.  Returns None if the list is empty.\n    \"\"\"\n    if not tuple_list:\n        return None\n\n    min_tuple = min(tuple_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n      list_of_tuples: A list of tuples, where each tuple contains two elements.\n\n    Returns:\n      The first value of the tuple with the smallest second value.  Returns None if the list is empty.\n    \"\"\"\n    if not list_of_tuples:\n        return None\n\n    min_tuple = min(list_of_tuples, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n      list_of_tuples: A list of tuples, where each tuple contains two elements (a string and an integer).\n\n    Returns:\n      The first element (string) of the tuple with the smallest second element (integer).  Returns None if the list is empty.\n    \"\"\"\n    if not list_of_tuples:\n        return None\n\n    min_tuple = min(list_of_tuples, key=lambda x: x[1])  #Finds the tuple with the minimum second element.\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        list_of_tuples: A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second element.  Returns None if the input list is empty or contains invalid tuples.\n    \"\"\"\n    if not list_of_tuples:\n        return None\n\n    min_tuple = min(list_of_tuples, key=lambda x: x[1] if len(x) > 1 else float('inf')) #Handles tuples with less than 2 elements\n\n    if len(min_tuple) < 1:\n        return None\n\n    return min_tuple[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 66.24999999999999, "dps_norm": 67.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "def divisor(n):\n    \"\"\"\n    Write a python function to find the number of divisors of a given integer.\n    assert divisor(15) == 4\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n      n: The integer.\n\n    Returns:\n      The number of divisors of n.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Write a python function to find the number of divisors of a given integer.\n    assert divisor(15) == 4\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer.\n\n    Returns:\n        The number of divisors of n.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer.\n\n    Returns:\n        The number of divisors of n.  Returns 0 if n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer.\n\n    Returns:\n        The number of divisors of n.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n      n: The input integer.\n\n    Returns:\n      The number of divisors of n.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n      n: The integer.\n\n    Returns:\n      The number of divisors of n.  Returns 0 if n is less than 1.\n\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer.\n\n    Returns:\n        The number of divisors of n.  Returns 0 if n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        return 0\n\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer.\n\n    Returns:\n        The number of divisors of n.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The number of divisors of n.  Returns 0 if n is less than 1.\n\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer.\n\n    Returns:\n        The number of divisors of n.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n      n: The integer.\n\n    Returns:\n      The number of divisors of n.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer.\n\n    Returns:\n        The number of divisors of n.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n      n: The integer.\n\n    Returns:\n      The number of divisors of n.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    This function counts the number of divisors of a given integer n.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        The number of divisors of n.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n      n: The integer.\n\n    Returns:\n      The number of divisors of n.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Write a python function to find the number of divisors of a given integer.\n    assert divisor(15) == 4\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/97": {"dps": 95.33333333333333, "dps_norm": 86.875, "pass@1": 100.0, "profiled": [{"solution": "from collections import defaultdict\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing numerical elements.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.  Returns an empty dictionary if the input is invalid.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        return {}\n    \n    flattened_list = []\n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            return {}\n        for item in sublist:\n            if not isinstance(item,(int,float)):\n                return {}\n            flattened_list.append(item)\n\n    frequency = defaultdict(int)\n    for item in flattened_list:\n        frequency[item] += 1\n    return dict(frequency)", "matching_cluster_idx": 5}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n      list_of_lists: A list of lists containing numbers.\n\n    Returns:\n      A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = {}\n    for item in flattened_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency_dict = {}\n    for item in flattened_list:\n        frequency_dict[item] = frequency_dict.get(item, 0) + 1\n\n    return frequency_dict\nlist_of_lists = [[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n      list_of_lists: A list of lists containing numbers.\n\n    Returns:\n      A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = {}\n    for item in flattened_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    frequency_dict = dict(Counter(flattened_list))\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n      list_of_lists: A list of lists containing numbers.\n\n    Returns:\n      A dictionary where keys are the unique elements and values are their frequencies.  Returns an empty dictionary if the input is empty or None.\n    \"\"\"\n    if not list_of_lists:\n        return {}\n\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    frequency = defaultdict(int)\n    for item in flattened_list:\n        frequency[item] += 1\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = {}\n    for item in flattened_list:\n        frequency[item] = frequency.get(item, 0) + 1\n\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A dictionary where keys are the unique elements from the flattened list and values are their frequencies.  Returns an empty dictionary if the input is empty or None.\n    \"\"\"\n    if not list_of_lists:\n        return {}\n\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    frequency = {}\n    for item in flattened_list:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n    assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = {}\n    for item in flattened_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency\nlist_of_lists = [[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = defaultdict(int)\n    for item in flattened_list:\n        frequency[item] += 1\n\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n      list_of_lists: A list of lists containing numbers.\n\n    Returns:\n      A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequencies = {}\n    for item in flattened_list:\n        frequencies[item] = frequencies.get(item, 0) + 1\n\n    return frequencies", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing numerical elements.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.  Returns an empty dictionary if the input is empty or None.\n    \"\"\"\n    if not list_of_lists:\n        return {}\n\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    return dict(Counter(flattened_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n    assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = {}\n    for item in flattened_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency\nlist_of_lists = [[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n\n    frequency = {}\n    for item in flattened_list:\n        frequency[item] = frequency.get(item, 0) + 1\n\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = {}\n    for item in flattened_list:\n        frequency[item] = frequency.get(item, 0) + 1\n\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = {}\n    for item in flattened_list:\n        frequency[item] = frequency.get(item, 0) + 1\n\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = {}\n    for item in flattened_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency\nlist_of_lists = [[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A dictionary where keys are the unique elements from the flattened list \n        and values are their corresponding frequencies.  Returns an empty \n        dictionary if the input is empty or None.\n    \"\"\"\n    if not list_of_lists:\n        return {}\n\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    frequency = defaultdict(int)\n    for item in flattened_list:\n        frequency[item] += 1\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n      list_of_lists: A list of lists containing numbers.\n\n    Returns:\n      A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = {}\n    for item in flattened_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n      list_of_lists: A list of lists containing numbers.\n\n    Returns:\n      A dictionary where keys are the unique elements from the flattened list and values are their frequencies.  Returns an empty dictionary if the input is empty or None.\n    \"\"\"\n    if not list_of_lists:\n        return {}\n\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n\n    frequency = {}\n    for item in flattened_list:\n        frequency[item] = frequency.get(item, 0) + 1\n\n    return frequency", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 54.70779220779221, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(list_to_add, tuple_to_add_to):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        list_to_add: The list to be appended.\n        tuple_to_add_to: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.  Returns None if input is invalid.\n    \"\"\"\n    if not isinstance(list_to_add, list) or not isinstance(tuple_to_add_to, tuple):\n        return None\n\n    return tuple_to_add_to + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n      input_list: The list to append.\n      input_tuple: The tuple to append to.\n\n    Returns:\n      A new tuple with the list appended to the original tuple.  Returns None if \n      input_tuple is not a tuple or input_list is not a list.\n    \"\"\"\n    if not isinstance(input_list, list) or not isinstance(input_tuple, tuple):\n        return None\n    return input_tuple + tuple(input_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_add, tuple_to_add_to):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        list_to_add: The list to append.\n        tuple_to_add_to: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.  Returns None if input is invalid.\n    \"\"\"\n    if not isinstance(list_to_add, list) or not isinstance(tuple_to_add_to, tuple):\n        return None\n\n    return tuple_to_add_to + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_add, tuple_to_append):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        list_to_add: The list to append.\n        tuple_to_append: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.  Returns None if input is invalid.\n    \"\"\"\n    if not isinstance(list_to_add, list) or not isinstance(tuple_to_append, tuple):\n        return None\n\n    return tuple_to_append + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_add, tuple_to_add_to):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        list_to_add: The list to append.\n        tuple_to_add_to: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.  Returns None if input is invalid.\n    \"\"\"\n    if not isinstance(list_to_add, list) or not isinstance(tuple_to_add_to, tuple):\n        return None\n    return tuple_to_add_to + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        lst: The list to append.\n        tup: The tuple to append to.\n\n    Returns:\n        A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends a list to a tuple.\n\n    Args:\n        input_list: The list to append.\n        input_tuple: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.  Returns None if input is invalid.\n    \"\"\"\n    if not isinstance(input_list, list) or not isinstance(input_tuple, tuple):\n        return None\n\n    return input_tuple + tuple(input_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        input_list: The list to append.\n        input_tuple: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.  Returns None if input is invalid.\n    \"\"\"\n    if not isinstance(input_list, list) or not isinstance(input_tuple, tuple):\n        return None\n    \n    return input_tuple + tuple(input_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_add, tuple_to_add_to):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        list_to_add: The list to append.\n        tuple_to_add_to: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.  Returns None if input is invalid.\n\n    Raises:\n      TypeError: if input types are not as expected.\n\n    \"\"\"\n    if not isinstance(list_to_add, list):\n        raise TypeError(\"list_to_add must be a list\")\n    if not isinstance(tuple_to_add_to, tuple):\n        raise TypeError(\"tuple_to_add_to must be a tuple\")\n\n    return tuple_to_add_to + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        input_list: The list to be appended.\n        input_tuple: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.  Returns None if input is invalid.\n\n    \"\"\"\n    if not isinstance(input_list, list) or not isinstance(input_tuple, tuple):\n        return None\n\n    return input_tuple + tuple(input_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        lst: The list to append.\n        tup: The tuple to append to.\n\n    Returns:\n        A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends a list to a tuple.\n\n    Args:\n        input_list: The list to append.\n        input_tuple: The tuple to append to.\n\n    Returns:\n        A new tuple containing the elements of the input tuple followed by the elements of the input list.  Returns None if input is not a list and tuple.\n\n    \"\"\"\n    if not isinstance(input_list, list) or not isinstance(input_tuple, tuple):\n        return None\n    return input_tuple + tuple(input_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(my_list, my_tuple):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n      my_list: The list to append.\n      my_tuple: The tuple to append to.\n\n    Returns:\n      A new tuple containing the elements of my_tuple followed by the elements of my_list.  \n    \"\"\"\n    return my_tuple + tuple(my_list)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_add, tuple_to_add_to):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        list_to_add: The list to append.\n        tuple_to_add_to: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.  Returns None if input is invalid.\n    \"\"\"\n    if not isinstance(list_to_add, list) or not isinstance(tuple_to_add_to, tuple):\n        return None\n\n    return tuple_to_add_to + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(my_list, my_tuple):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        my_list: The list to append.\n        my_tuple: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.  Returns None if input is invalid.\n    \"\"\"\n    if not isinstance(my_list, list) or not isinstance(my_tuple, tuple):\n        return None\n    return my_tuple + tuple(my_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_add, tuple_to_add_to):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        list_to_add: The list to append.\n        tuple_to_add_to: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.  Returns None if input is invalid.\n    \"\"\"\n    if not isinstance(list_to_add, list) or not isinstance(tuple_to_add_to, tuple):\n        return None\n    return tuple_to_add_to + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_add, tuple_to_add_to):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        list_to_add: The list to append.\n        tuple_to_add_to: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tuple_to_add_to + tuple(list_to_add)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_add, tuple_to_add_to):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        list_to_add: The list to append.\n        tuple_to_add_to: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.  Returns None if input is invalid.\n\n    \"\"\"\n    if not isinstance(list_to_add, list) or not isinstance(tuple_to_add_to, tuple):\n        return None\n\n    return tuple_to_add_to + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_add, tuple_to_add_to):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        list_to_add: The list to append.\n        tuple_to_add_to: The tuple to append to.\n\n    Returns:\n        A new tuple containing the elements of the original tuple followed by the elements of the list.  Returns None if input is invalid.\n    \"\"\"\n    if not isinstance(list_to_add, list) or not isinstance(tuple_to_add_to, tuple):\n        return None\n    return tuple_to_add_to + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_add, tuple_to_add_to):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        list_to_add: The list to append.\n        tuple_to_add_to: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.  Returns the original tuple if the input is invalid.\n\n    \"\"\"\n    try:\n        return tuple_to_add_to + tuple(list_to_add)\n    except TypeError:\n        return tuple_to_add_to", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n    Returns:\n      A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3  # Concatenate the three lists\n    merged_list.sort()  # Sort the merged list in place\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n\n    merged_list = list1 + list2 + list3  #Concatenate the lists\n    merged_list.sort() #Sort the concatenated list\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three sorted lists into a single sorted list.\n\n    Args:\n        list1: The first sorted list.\n        list2: The second sorted list.\n        list3: The third sorted list.\n\n    Returns:\n        A new list containing all elements from the three input lists, \n        sorted in ascending order.  Returns an empty list if all input lists are empty.\n    \"\"\"\n\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n    Returns:\n      A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3  # Combine all lists\n    merged_list.sort()  # Sort the combined list\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the three input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3  # Concatenate the lists\n    merged_list.sort()  # Sort the merged list\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three sorted lists into a single sorted list.\n\n    Args:\n        list1: The first sorted list.\n        list2: The second sorted list.\n        list3: The third sorted list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n    merged_list = list1 + list2 + list3  # Combine all three lists\n    merged_list.sort()  # Sort the combined list\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n    Returns:\n      A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n\n    merged_list = list1 + list2 + list3  # Concatenate the three lists\n    merged_list.sort()  # Sort the merged list in ascending order\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n    Returns:\n      A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n    Returns:\n      A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n\n    merged_list = list1 + list2 + list3  # Concatenate the three lists\n    merged_list.sort()  # Sort the merged list in ascending order\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n    Returns:\n      A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n    Returns:\n      A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3  # Concatenate the three lists\n    merged_list.sort()  # Sort the merged list in ascending order\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 91.53846153846155, "dps_norm": 86.25, "pass@1": 89.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n        nested_lists: A list of lists containing numbers.\n\n    Returns:\n        A set containing the common elements.  Returns an empty set if the input list is empty or contains empty lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    if any(not sublist for sublist in nested_lists): #Handle cases with empty inner lists.\n        return set()\n\n\n    common = set(nested_lists[0])\n    for sublist in nested_lists[1:]:\n        common.intersection_update(sublist)\n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n        nested_lists: A list of lists containing numbers.\n\n    Returns:\n        A set containing the common elements.  Returns an empty set if the input list is empty or contains empty lists.\n    \"\"\"\n    if not nested_lists or not all(nested_lists): #Handle empty input or empty sublists\n        return set()\n\n    #Efficient approach using set intersection\n    result = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        result = result.intersection(lst)\n    return result", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        A set containing the elements that are common to all inner lists.  Returns an empty set if input is invalid or no common elements exist.\n\n    \"\"\"\n    if not nested_lists or not all(isinstance(inner_list, list) for inner_list in nested_lists):\n        return set()\n\n    if len(nested_lists) == 0:\n        return set()\n\n    #Efficient approach using set intersection\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists containing numbers.\n\n    Returns:\n        A set containing the common elements.  Returns an empty set if the input list is empty or contains empty lists.\n    \"\"\"\n    if not nested_lists or not all(nested_lists): #handles empty input list or lists containing empty lists\n        return set()\n    \n    common = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common.intersection_update(lst)\n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n      nested_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n      A set containing the elements that are common to all inner lists.  Returns an empty set if the input list is empty or if no common elements exist.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    # Efficiently find common elements using set intersection\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n        nested_lists: A list of lists containing numbers.\n\n    Returns:\n        A set containing the elements common to all lists.  Returns an empty set if the input list is empty or no common elements exist.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    # Efficiently find common elements using set intersection\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n        nested_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        A set containing the elements that are common to all inner lists.  Returns an empty set if the input list is empty or if no common elements exist.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    #Efficiently find common elements using sets.\n    result = set(nested_lists[0])  #Start with the first list's elements\n    for lst in nested_lists[1:]:\n        result.intersection_update(lst) #Efficiently find intersection\n\n    return result", "matching_cluster_idx": 6}, {"solution": "from functools import reduce\ndef common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n      nested_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n      A set containing the elements that are common to all inner lists.  Returns an empty set if the input list is empty or no common elements are found.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    return reduce(lambda x, y: x.intersection(y), (set(lst) for lst in nested_lists))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n      nested_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n      A set containing the elements that are common to all inner lists.  Returns an empty set if the input list is empty or no common elements exist.\n\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    # Efficiently find common elements using sets\n    common = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common.intersection_update(lst)\n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n        nested_lists: A list of lists containing numbers.\n\n    Returns:\n        A set containing the elements common to all inner lists.  Returns an empty set if input is invalid or no common elements exist.\n    \"\"\"\n    if not nested_lists or not all(isinstance(inner_list, list) for inner_list in nested_lists):\n        return set()  # Handle invalid input\n\n    if len(nested_lists) == 0:\n        return set()\n\n    #Efficiently find common elements using sets\n    common_elements = set(nested_lists[0])\n    for inner_list in nested_lists[1:]:\n        common_elements.intersection_update(inner_list)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n      nested_lists: A list of lists containing numerical data.\n\n    Returns:\n      A set containing the elements common to all lists in nested_lists.  Returns an empty set if the input list is empty or no common elements exist.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    # Efficiently find common elements using set intersection\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n      nested_lists: A list of lists of numbers.\n\n    Returns:\n      A set containing the common elements.  Returns an empty set if the input list is empty or contains empty lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    if any(not lst for lst in nested_lists):\n        return set()\n\n    #Efficient approach using set intersection\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "from functools import reduce\ndef common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n        nested_lists: A list of lists of numbers.\n\n    Returns:\n        A set containing the common elements.  Returns an empty set if the input list is empty or contains empty lists.\n    \"\"\"\n    if not nested_lists or any(not lst for lst in nested_lists):\n        return set()\n    return reduce(lambda x, y: set(x) & set(y), nested_lists)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists containing numbers.\n\n    Returns:\n        A set containing the common elements.  Returns an empty set if the input list is empty or contains empty lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    if any(not sublist for sublist in nested_lists):\n        return set()\n\n\n    common = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common.intersection_update(lst)\n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists containing numbers.\n\n    Returns:\n        A set containing the common elements.  Returns an empty set if input is invalid or no common elements are found.\n    \"\"\"\n    if not nested_lists or not all(isinstance(inner_list, list) for inner_list in nested_lists):\n        return set() #Handle invalid input\n\n    if len(nested_lists) == 0:\n        return set()\n\n    # Efficiently find common elements using set intersection\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n        nested_lists: A list of lists containing numbers.\n\n    Returns:\n        A set containing the common elements.  Returns an empty set if the input list is empty or contains empty lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    if any(not lst for lst in nested_lists):\n        return set()\n\n    common = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common.intersection_update(lst)\n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n      nested_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n      A set containing the elements that are common to all inner lists.  Returns an empty set if the input list is empty or if no common elements exist.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    #Use sets for efficient intersection operations.\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        A set containing the elements that are common to all inner lists.  Returns an empty set if the input list is empty or contains empty inner lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    #Handle empty inner lists\n    if any(len(lst) == 0 for lst in nested_lists):\n        return set()\n\n    #Efficiently find common elements using sets\n    common = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common.intersection_update(lst)\n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n      nested_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n      A set containing the elements that are common to all inner lists.  Returns an empty set if the input list is empty or contains empty lists.\n\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    if any(not lst for lst in nested_lists):\n        return set()\n\n    #Efficient approach using sets intersection\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists containing numbers.\n\n    Returns:\n        A set containing the common elements.  Returns an empty set if input is invalid or no common elements exist.\n    \"\"\"\n    if not isinstance(nested_lists, list):\n        return set()  # Handle invalid input\n    if not all(isinstance(inner_list, list) for inner_list in nested_lists):\n        return set() # Handle invalid input\n    if not nested_lists:\n        return set() #Handle empty input\n\n    #Efficient approach using sets for intersection\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 90.0, "profiled": [{"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n        n: The minimum length of words to be included.\n        words: A string containing space-separated words.\n\n    Returns:\n        A list of words longer than n characters.  Returns an empty list if no words meet the criteria or if the input is invalid.\n    \"\"\"\n    try:\n        word_list = words.split()  #split the string into a list of words\n        result = [word for word in word_list if len(word) > n]\n        return result\n    except (AttributeError, TypeError): #handle cases where input is not a string\n        return []", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n        n: The minimum length of words to be returned.\n        words: A string containing words separated by spaces.\n\n    Returns:\n        A list of strings, where each string is a word from the input \n        string that has more than n characters.  Returns an empty list if \n        no words meet the criteria or if the input string is empty.\n    \"\"\"\n    word_list = words.split()\n    result = [word for word in word_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Finds words longer than n characters from a given text.\n\n    Args:\n      n: The minimum length of words to be returned.\n      text: The input string containing words separated by spaces.\n\n    Returns:\n      A list of words from the input string that are longer than n characters.  Returns an empty list if the input string is empty or None.\n    \"\"\"\n    if not text:\n        return []\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n        n: The minimum length of words to be included.\n        words: A string containing words separated by spaces.\n\n    Returns:\n        A list of words that are longer than n characters.  Returns an empty list if no words meet the criteria or the input is invalid.\n    \"\"\"\n    try:\n        word_list = words.split()\n        result = [word for word in word_list if len(word) > n]\n        return result\n    except AttributeError:\n      return []", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n        n: The minimum length of words to be included in the result.\n        words: A string containing space-separated words.\n\n    Returns:\n        A list of words that are longer than n characters.  Returns an empty list if no words meet the criteria or if the input is invalid.\n\n    \"\"\"\n    try:\n      word_list = words.split()\n      result = [word for word in word_list if len(word) > n]\n      return result\n    except AttributeError:\n      return []", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n        n: The minimum length of words to be included.\n        words: A string containing words separated by spaces.\n\n    Returns:\n        A list of words longer than n characters.  Returns an empty list if no words \n        meet the criteria or if the input string is empty or None.\n    \"\"\"\n    if not words:\n        return []\n    word_list = words.split()\n    long_word_list = [word for word in word_list if len(word) > n]\n    return long_word_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n      n: The minimum length of words to be included.\n      words: A string containing words separated by spaces.\n\n    Returns:\n      A list of words longer than n characters.  Returns an empty list if the input string is empty or contains only words shorter than n.\n    \"\"\"\n    word_list = words.split()\n    long_word_list = [word for word in word_list if len(word) > n]\n    return long_word_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words longer than n characters in a sentence.\n\n    Args:\n        n: The minimum length of words to be included.\n        sentence: The input sentence as a string.\n\n    Returns:\n        A list of words from the sentence that are longer than n characters.  Returns an empty list if the input sentence is empty or None.\n    \"\"\"\n    if not sentence:\n        return []\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Finds words longer than n characters from a given text.\n\n    Args:\n        n: The minimum length of words to be returned.\n        text: The input string containing words separated by spaces.\n\n    Returns:\n        A list of words from the input string that are longer than n characters.  Returns an empty list if no words meet the criteria or the input is invalid.\n    \"\"\"\n    try:\n        words = text.split()\n        long_word_list = [word for word in words if len(word) > n]\n        return long_word_list\n    except (AttributeError, TypeError):\n        return []", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words longer than n characters from a given sentence.\n\n    Args:\n      n: The minimum length of words to be returned.\n      sentence: The input sentence as a string.\n\n    Returns:\n      A list of words from the sentence that are longer than n characters.  Returns an empty list if the input sentence is empty or None.\n    \"\"\"\n    if not sentence:\n        return []\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words longer than n characters in a sentence.\n\n    Args:\n      n: The minimum length of words to be returned.\n      sentence: The input sentence as a string.\n\n    Returns:\n      A list of words from the sentence that are longer than n characters.  Returns an empty list if the input sentence is empty or None.\n    \"\"\"\n    if not sentence:\n        return []\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n        n: The minimum length of words to be included.\n        words: A string containing words separated by spaces.\n\n    Returns:\n        A list of words from the input string that are longer than n characters.  Returns an empty list if the input string is empty or contains no words longer than n.\n    \"\"\"\n    word_list = words.split()\n    result = [word for word in word_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    \"\"\"\n    Finds words longer than n characters from a given string.\n\n    Args:\n      n: The minimum length of words to be returned.\n      string: The input string containing words separated by spaces.\n\n    Returns:\n      A list of words from the input string that are longer than n characters.  Returns an empty list if the input string is empty or None.\n    \"\"\"\n    if not string:\n        return []\n    words = string.split()\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n      n: The minimum length of words to be included in the result.\n      words: A string containing words separated by spaces.\n\n    Returns:\n      A list of strings containing words longer than n characters.  Returns an empty list if no words meet the criteria or if input is invalid.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        return []  # Handle invalid input for n\n\n    try:\n        word_list = words.split()\n    except AttributeError:\n        return [] #Handle case where words is not a string\n\n\n    long_word_list = [word for word in word_list if len(word) > n]\n    return long_word_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n        n: The minimum length of words to be returned.\n        words: A string containing words separated by spaces.\n\n    Returns:\n        A list of words that are longer than n characters.  Returns an empty list if no words meet the criteria or the input is invalid.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        return []  # Handle invalid input for n\n\n    try:\n        word_list = words.split()  #Split the input string into a list of words\n    except AttributeError:\n        return [] #Handle cases where words is not a string\n\n    long_words_list = [word for word in word_list if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n      n: The minimum length of words to be included.\n      words: A string containing words separated by spaces.\n\n    Returns:\n      A list of words longer than n characters.  Returns an empty list if no words meet the criteria or if the input string is empty or None.\n    \"\"\"\n    if not words:\n        return []\n    word_list = words.split()\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n        n: The minimum length of words to be included.\n        words: A string containing words separated by spaces.\n\n    Returns:\n        A list of words longer than n characters.  Returns an empty list if the input string is empty or None.\n    \"\"\"\n    if not words:\n        return []\n    word_list = words.split()\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n        n: The minimum length of words to be included.\n        words: A string containing words separated by spaces.\n\n    Returns:\n        A list of words longer than n characters.  Returns an empty list if no words \n        meet the criteria or if the input string is empty or None.\n    \"\"\"\n    if not words:\n        return []\n\n    word_list = words.split()\n    result = [word for word in word_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n      n: The minimum length of words to be included.\n      words: A string containing words separated by spaces.\n\n    Returns:\n      A list of words longer than n characters.  Returns an empty list if the input string is empty or None.\n    \"\"\"\n    if not words:\n        return []\n    word_list = words.split()\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n        n: The minimum length of words to be included.\n        words: A string containing words separated by spaces.\n\n    Returns:\n        A list of words longer than n characters.  Returns an empty list if the input string is empty or None.\n\n    \"\"\"\n    if not words:\n        return []\n    word_list = words.split()\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 64.46428571428572, "dps_norm": 95.33333333333333, "pass@1": 91.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    if n == 0:  #Handle empty matrix case\n        return False\n\n    # Check if the matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic constant (sum of any row, column, or diagonal)\n    magic_constant = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = 0\n        for row in range(n):\n            column_sum += matrix[row][col]\n        if column_sum != magic_constant:\n            return False\n\n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n\n    if diag1_sum != magic_constant or diag2_sum != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    if n == 0:\n        return False  # Handle empty matrix case\n\n    # Check if the matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic constant (sum of any row/column/diagonal)\n    magic_constant = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for col_index in range(n):\n        column_sum = 0\n        for row_index in range(n):\n            column_sum += matrix[row_index][col_index]\n        if column_sum != magic_constant:\n            return False\n\n    # Check diagonals\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag1_sum != magic_constant or diag2_sum != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    if n == 0:\n        return False  # Handle empty matrix case\n\n    # Check if the matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic constant (sum of any row/column/diagonal)\n    magic_constant = sum(matrix[0])  # Sum of the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_constant:\n            return False\n\n    # Check diagonals\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag1_sum != magic_constant or diag2_sum != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    if n == 0:\n        return False  # Handle empty matrix case\n\n    # Check if the matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic sum (sum of the first row)\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n    \"\"\"\n    n = len(matrix)\n    magic_sum = sum(matrix[0])  # Calculate the magic sum from the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    if n == 0:\n        return False  # Handle empty matrix case\n\n    # Check if matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    magic_sum = sum(matrix[0])  # Calculate the magic sum from the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n    \"\"\"\n    n = len(matrix)\n    magic_sum = sum(matrix[0])  # Calculate the magic sum from the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n    \"\"\"\n    n = len(matrix)\n    magic_sum = sum(matrix[0])  # Calculate the magic sum from the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    if n == 0:  #Handle empty matrix case\n        return False\n\n    #Check if it's a square matrix\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    magic_sum = sum(matrix[0]) # Calculate the magic sum using the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n    \"\"\"\n    n = len(matrix)\n    magic_sum = sum(matrix[0])  # Calculate the magic sum from the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n    \"\"\"\n    n = len(matrix)\n    magic_sum = sum(matrix[0])  # Calculate the magic sum from the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = 0\n        for row in range(n):\n            column_sum += matrix[row][col]\n        if column_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n    \"\"\"\n    n = len(matrix)\n    magic_sum = sum(matrix[0])  # Calculate the magic sum from the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    if n == 0:\n        return False  # Handle empty matrix case\n\n    # Check if it's a square matrix\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic constant (sum of the first row)\n    magic_constant = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_constant:\n            return False\n\n    # Check diagonals\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag1_sum != magic_constant or diag2_sum != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    if n == 0:  #Handle empty matrix case\n        return False\n\n    # Check if the matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic sum (sum of the first row)\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    if n == 0:\n        return False  # Handle empty matrix case\n\n    # Check if it's a square matrix\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic constant (sum of any row, column, or diagonal)\n    magic_constant = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = 0\n        for row in range(n):\n            column_sum += matrix[row][col]\n        if column_sum != magic_constant:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += matrix[i][i]\n        diagonal_sum2 += matrix[i][n - 1 - i]\n\n    if diagonal_sum1 != magic_constant or diagonal_sum2 != magic_constant:\n        return False\n\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    if n == 0:\n        return False  # Handle empty matrix case\n\n    # Check if matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic constant (sum of any row/column/diagonal)\n    magic_constant = sum(matrix[0])  # Sum of the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for col_index in range(n):\n        column_sum = sum(matrix[row_index][col_index] for row_index in range(n))\n        if column_sum != magic_constant:\n            return False\n\n    # Check diagonals\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag1_sum != magic_constant or diag2_sum != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    if n == 0:\n        return False  # Handle empty matrix case\n\n    # Check if the matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic constant (sum of any row, column, or diagonal)\n    magic_constant = sum(matrix[0])  # Sum of the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_constant:\n            return False\n\n    # Check diagonals\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag1_sum != magic_constant or diag2_sum != magic_constant:\n        return False\n\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(square):\n    \"\"\"\n    Checks if a given square matrix is a magic square.\n\n    Args:\n      square: A list of lists representing the square matrix.\n\n    Returns:\n      True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(square)\n    if n == 0:\n        return False  #Handle empty matrix case\n\n    #Check if it's a square matrix\n    for row in square:\n        if len(row) != n:\n            return False\n\n    #Calculate the magic constant\n    magic_constant = sum(square[0])\n\n    #Check rows\n    for row in square:\n        if sum(row) != magic_constant:\n            return False\n\n    #Check columns\n    for col in range(n):\n        column_sum = sum(square[row][col] for row in range(n))\n        if column_sum != magic_constant:\n            return False\n\n    #Check diagonals\n    diag1_sum = sum(square[i][i] for i in range(n))\n    diag2_sum = sum(square[i][n - 1 - i] for i in range(n))\n    if diag1_sum != magic_constant or diag2_sum != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    if n == 0:  #Handle empty matrix case\n        return False\n\n    #Check if it's a square matrix\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    magic_sum = sum(matrix[0])  #Calculate the magic sum using the first row\n\n    #Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    #Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    #Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    if n == 0:  #Handle empty matrix case\n        return False\n\n    # Check if the matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic sum (sum of the first row)\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}]}, "Mbpp/130": {"dps": 99.10313901345292, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    Args:\n      input_list: A list of items.\n\n    Returns:\n      The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not input_list:\n        return None\n\n    counts = Counter(input_list)\n    max_item = max(counts, key=counts.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not input_list:\n        return None\n\n    count = Counter(input_list)\n    max_item = max(count, key=count.get)  #Finds the key (item) with the max value (count)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  If multiple items have the same maximum frequency, returns one of them.  Returns None if the list is empty.\n\n    \"\"\"\n    if not data:\n        return None\n    \n    counts = Counter(data)\n    max_item = max(counts, key=counts.get) #Finds the key (item) with the maximum value (count)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    Args:\n      input_list: A list of items.\n\n    Returns:\n      The item with the maximum frequency.  If multiple items have the same \n      maximum frequency, returns the first one encountered.  Returns None if \n      the input list is empty.\n    \"\"\"\n    if not input_list:\n        return None\n\n    counts = Counter(input_list)\n    max_item = max(counts, key=counts.get)  #Finds the key with the max value\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n      input_list: A list of items.\n\n    Returns:\n      The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not input_list:\n        return None\n\n    counts = Counter(input_list)\n    max_item = max(counts, key=counts.get)  #Finds the key (item) with the maximum value (count)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not data:\n        return None\n\n    counts = Counter(data)\n    max_item = max(counts, key=counts.get)  #Finds the key (item) with the max value (count)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not input_list:\n        return None\n\n    counts = Counter(input_list)\n    max_item = max(counts, key=counts.get)  #Finds the key with the max value\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not data:\n        return None\n    \n    counts = Counter(data)\n    max_item = max(counts, key=counts.get)  #Finds the key (item) with the maximum value (count)\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not input_list:\n        return None\n\n    count = Counter(input_list)\n    max_item = max(count, key=count.get)  #Finds the key (item) with the max value (count)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not input_list:\n        return None\n\n    counts = Counter(input_list)\n    max_item = max(counts, key=counts.get)  #Finds the key (item) with the maximum value (count)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not input_list:\n        return None\n\n    count = Counter(input_list)\n    max_item = max(count, key=count.get)  #Finds the key with the maximum value\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not input_list:\n        return None\n\n    counts = Counter(input_list)\n    max_item = max(counts, key=counts.get)  #Finds the key (item) with the max value (count)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n      data: A list of items.\n\n    Returns:\n      The item with the maximum frequency.  If multiple items have the same maximum frequency, \n      it returns the first one encountered.  Returns None if the list is empty.\n    \"\"\"\n    if not data:\n        return None\n    \n    counts = Counter(data)\n    max_item = max(counts, key=counts.get)  #Finds the key (item) with the max value (count)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n      data: A list of items.\n\n    Returns:\n      The item with the maximum frequency.  If multiple items have the same maximum frequency, \n      it returns the one that appears first in the input list.\n    \"\"\"\n    if not data:\n        return None  # Handle empty list case\n\n    count = Counter(data)\n    max_count = 0\n    max_item = None\n\n    for item, freq in count.items():\n        if freq > max_count:\n            max_count = freq\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    Args:\n      input_list: A list of items.\n\n    Returns:\n      The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not input_list:\n        return None\n\n    counts = Counter(input_list)\n    max_item = max(counts, key=counts.get)  #Finds the key (item) with the max value (count)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not data:\n        return None\n    \n    counts = Counter(data)\n    max_item = max(counts, key=counts.get)  #Get the key (item) with the max value (count)\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not data:\n        return None\n    \n    counts = Counter(data)\n    max_item = max(counts, key=counts.get)  #Finds the key (item) with the maximum value (count)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  If multiple items have the same maximum frequency, returns one of them arbitrarily.  Returns None if the input list is empty.\n    \"\"\"\n    if not input_list:\n        return None\n\n    counts = Counter(input_list)\n    max_item = max(counts, key=counts.get)  #get the key (item) with the max value (count)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not data:\n        return None\n\n    counts = Counter(data)\n    max_item = max(counts, key=counts.get)  #Finds the key (item) with the max value (count)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        The item with the maximum frequency.  Returns None if the list is empty.\n    \"\"\"\n    if not input_list:\n        return None\n\n    counts = Counter(input_list)\n    max_item = max(counts, key=counts.get)  #Finds the key (item) with the max value (count)\n    return max_item", "matching_cluster_idx": 4}]}, "Mbpp/137": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/140": {"dps": 93.7888198757764, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of unique numbers.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a set of unique numbers.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a set of unique numbers.\n\n    Args:\n      list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n      A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a set of unique numbers.\n\n    Args:\n      list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n      A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a set of unique numbers.\n\n    Args:\n      list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n      A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"Flattens a list of lists into a set of unique numbers.\"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"Flattens a list of lists into a set of unique numbers.\"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)  #Add all elements of inner list to flattened list\n    return set(flattened_list) #Convert to set to get unique numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of unique numbers.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"Flattens a list of lists into a set of unique numbers.\"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"Flattens a list of lists into a set of unique numbers.\"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)  #Efficiently adds all items from inner list to flattened list.\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a set of unique numbers.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)  # Efficiently extends the list\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a set of unique numbers.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"Flattens a list of lists into a set of unique numbers.\"\"\"\n    flat_list = []\n    for inner_list in list_of_lists:\n        flat_list.extend(inner_list)\n    return set(flat_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"Flattens a list of lists into a set of unique numbers.\"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of unique numbers.\n\n    Args:\n      list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n      A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a set of unique numbers.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a set of unique numbers.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a set of unique numbers.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a set of unique numbers.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)  #Efficiently adds elements of inner list to the flattened list\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a set of unique numbers.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_list = []\n    for inner_list in list_of_lists:\n        flattened_list.extend(inner_list)  #Efficiently adds all elements of inner list to flattened list\n    return set(flattened_list)", "matching_cluster_idx": 6}]}, "Mbpp/141": {"dps": 52.6077097505669, "dps_norm": 37.5, "pass@1": 69.0, "profiled": [{"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n      arr: The list of elements to be sorted.\n\n    Returns:\n      The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[0...i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Flip the subarray arr[0...max_index] to bring the maximum element to the beginning\n        arr[:max_index+1] = arr[:max_index+1][::-1]\n\n        # Flip the subarray arr[0...i] to move the maximum element to its correct position\n        arr[:i+1] = arr[:i+1][::-1]\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n        arr: The list of elements to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[0...i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Flip the subarray arr[0...max_index] to move the maximum element to the beginning\n        arr[:max_index+1] = arr[:max_index+1][::-1]\n\n        # Flip the subarray arr[0...i] to move the maximum element to its correct position\n        arr[:i+1] = arr[:i+1][::-1]\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n      arr: The list of elements to be sorted.\n\n    Returns:\n      A new list containing the sorted elements.\n    \"\"\"\n    n = len(arr)\n    arr_copy = arr[:] # Create a copy to avoid modifying the original list\n\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[0...i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr_copy[j] > arr_copy[max_index]:\n                max_index = j\n\n        # Flip the subarray arr[0...max_index] to bring the maximum element to the beginning\n        arr_copy[:max_index+1] = arr_copy[:max_index+1][::-1]\n\n        # Flip the subarray arr[0...i] to bring the maximum element to its correct position\n        arr_copy[:i+1] = arr_copy[:i+1][::-1]\n\n    return arr_copy", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the pancake sorting algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[0...i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Flip the subarray arr[0...max_index] to move the maximum element to the beginning\n        arr[:max_index + 1] = arr[:max_index + 1][::-1]\n\n        # Flip the subarray arr[0...i] to move the maximum element to its correct position\n        arr[:i + 1] = arr[:i + 1][::-1]\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n      arr: The list of elements to sort.\n\n    Returns:\n      A new list containing the sorted elements.\n    \"\"\"\n\n    n = len(arr)\n    arr_copy = arr[:]  # Create a copy to avoid modifying the original list\n\n    def flip(arr, k):\n        \"\"\"Flips the first k elements of the array.\"\"\"\n        arr[:k] = arr[:k][::-1]\n\n    for i in range(n - 1, 0, -1):\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr_copy[j] > arr_copy[max_index]:\n                max_index = j\n\n        if max_index != i:\n            flip(arr_copy, max_index + 1)\n            flip(arr_copy, i + 1)\n\n    return arr_copy", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n      arr: The list of elements to be sorted.\n\n    Returns:\n      The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[:i+1]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Flip the subarray to bring the maximum element to the beginning\n        arr[:max_index + 1] = arr[:max_index + 1][::-1]\n\n        # Flip the entire subarray to move the maximum element to its correct position\n        arr[:i + 1] = arr[:i + 1][::-1]\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the pancake sorting algorithm.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      A new list containing the sorted elements.\n    \"\"\"\n\n    n = len(arr)\n    arr_copy = arr[:]  # Create a copy to avoid modifying the original list\n\n    def flip(arr, k):\n        \"\"\"Flips the first k elements of the array.\"\"\"\n        left, right = 0, k - 1\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    for i in range(n, 0, -1):\n        # Find the index of the maximum element in the first i elements\n        max_index = 0\n        for j in range(1, i):\n            if arr_copy[j] > arr_copy[max_index]:\n                max_index = j\n\n        # Flip to bring the maximum element to the beginning\n        flip(arr_copy, max_index + 1)\n\n        # Flip to move the maximum element to its correct position\n        flip(arr_copy, i)\n\n    return arr_copy", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n      arr: The list of elements to be sorted.\n\n    Returns:\n      The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[0...i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Flip the subarray arr[0...max_index] to bring the maximum element to the beginning\n        arr[:max_index + 1] = arr[:max_index + 1][::-1]\n\n        # Flip the subarray arr[0...i] to move the maximum element to its correct position\n        arr[:i + 1] = arr[:i + 1][::-1]\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n        arr: The list of elements to be sorted.\n\n    Returns:\n        A new list containing the sorted elements.\n    \"\"\"\n\n    n = len(arr)\n    arr_copy = arr[:] # Create a copy to avoid modifying the original list\n\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[:i+1]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr_copy[j] > arr_copy[max_index]:\n                max_index = j\n\n        # Flip the subarray to bring the maximum element to the beginning\n        arr_copy[:max_index + 1] = arr_copy[:max_index + 1][::-1]\n\n        # Flip the entire subarray to move the maximum element to its correct position\n        arr_copy[:i + 1] = arr_copy[:i + 1][::-1]\n\n    return arr_copy", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the pancake sorting algorithm.\n\n    Args:\n      arr: The list to be sorted.\n\n    Returns:\n      A new list containing the sorted elements.\n    \"\"\"\n\n    arr_copy = arr[:]  # Create a copy to avoid modifying the original list\n\n    def flip(arr, k):\n        \"\"\"Flips the first k elements of the list.\"\"\"\n        arr[:k] = arr[:k][::-1]\n\n    n = len(arr_copy)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr_copy[j] > arr_copy[max_index]:\n                max_index = j\n\n        # Flip to bring the maximum element to the beginning\n        flip(arr_copy, max_index + 1)\n\n        # Flip to move the maximum element to its correct position\n        flip(arr_copy, i + 1)\n\n    return arr_copy", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n        arr: The list of elements to sort.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[0...i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Flip the subarray arr[0...max_index] to move the maximum element to the beginning\n        arr[:max_index + 1] = arr[:max_index + 1][::-1]\n\n        # Flip the subarray arr[0...i] to move the maximum element to its correct position\n        arr[:i + 1] = arr[:i + 1][::-1]\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n      arr: The list of elements to be sorted.\n\n    Returns:\n      A new list containing the sorted elements.\n    \"\"\"\n\n    n = len(arr)\n    arr_copy = arr[:]  # Create a copy to avoid modifying the original list\n\n    def flip(arr, k):\n        \"\"\"Flips the first k elements of the array.\"\"\"\n        left, right = 0, k - 1\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    for i in range(n - 1, 0, -1):\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr_copy[j] > arr_copy[max_index]:\n                max_index = j\n\n        if max_index != i:\n            flip(arr_copy, max_index + 1)\n            flip(arr_copy, i + 1)\n\n    return arr_copy", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sorting algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray [0, i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Flip the subarray [0, max_index] to bring the maximum element to the beginning\n        arr[:max_index + 1] = arr[:max_index + 1][::-1]\n\n        # Flip the subarray [0, i] to move the maximum element to its correct position\n        arr[:i + 1] = arr[:i + 1][::-1]\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the pancake sorting algorithm.\n\n    Args:\n      arr: The list to be sorted.\n\n    Returns:\n      The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[:i+1]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Flip the subarray to bring the maximum element to the beginning\n        arr[:max_index + 1] = arr[:max_index + 1][::-1]\n\n        # Flip the subarray to move the maximum element to its correct position\n        arr[:i + 1] = arr[:i + 1][::-1]\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n        arr: The list of elements to sort.\n\n    Returns:\n        A new list containing the sorted elements.\n    \"\"\"\n\n    n = len(arr)\n    arr_copy = arr[:]  # Create a copy to avoid modifying the original list\n\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[:i+1]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr_copy[j] > arr_copy[max_index]:\n                max_index = j\n\n        # Flip the subarray to bring the maximum element to the beginning\n        arr_copy[:max_index + 1] = arr_copy[:max_index + 1][::-1]\n\n        # Flip the subarray again to move the maximum element to its correct position\n        arr_copy[:i + 1] = arr_copy[:i + 1][::-1]\n\n    return arr_copy", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n      arr: The list of elements to be sorted.\n\n    Returns:\n      A new list containing the sorted elements.\n    \"\"\"\n\n    n = len(arr)\n    arr_copy = arr[:]  # Create a copy to avoid modifying the original list\n\n    def flip(arr, k):\n        \"\"\"Flips the first k elements of the list.\"\"\"\n        arr[:k] = arr[:k][::-1]\n\n    for i in range(n - 1, 0, -1):\n        # Find the maximum element in the subarray arr[0...i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr_copy[j] > arr_copy[max_index]:\n                max_index = j\n\n        # Flip the subarray to bring the maximum element to the beginning\n        flip(arr_copy, max_index + 1)\n\n        # Flip the subarray to move the maximum element to its correct position\n        flip(arr_copy, i + 1)\n\n    return arr_copy", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the pancake sorting algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[0...i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Flip the subarray arr[0...max_index] to move the maximum element to the beginning\n        arr[:max_index+1] = arr[:max_index+1][::-1]\n\n        # Flip the subarray arr[0...i] to move the maximum element to its correct position\n        arr[:i+1] = arr[:i+1][::-1]\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the pancake sorting algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[0...i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Flip the subarray arr[0...max_index] to move the maximum element to the beginning\n        arr[:max_index + 1] = arr[:max_index + 1][::-1]\n\n        # Flip the subarray arr[0...i] to move the maximum element to its correct position\n        arr[:i + 1] = arr[:i + 1][::-1]\n    return arr\narr = [15, 79, 25, 38, 69]", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n      arr: The list of elements to be sorted.\n\n    Returns:\n      A new list containing the sorted elements.\n    \"\"\"\n\n    n = len(arr)\n    arr_copy = arr[:]  # Create a copy to avoid modifying the original list\n\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[:i+1]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr_copy[j] > arr_copy[max_index]:\n                max_index = j\n\n        # Flip the subarray to bring the maximum element to the beginning\n        arr_copy[:max_index + 1] = arr_copy[:max_index + 1][::-1]\n\n        # Flip the entire subarray to move the maximum element to its correct position\n        arr_copy[:i + 1] = arr_copy[:i + 1][::-1]\n\n    return arr_copy", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n        arr: The list of elements to sort.\n\n    Returns:\n        The sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the subarray arr[0...i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Flip the subarray arr[0...max_index] to move the maximum element to the beginning\n        arr[:max_index + 1] = arr[:max_index + 1][::-1]\n\n        # Flip the subarray arr[0...i] to move the maximum element to its correct position\n        arr[:i + 1] = arr[:i + 1][::-1]\n\n    return arr", "matching_cluster_idx": 2}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      The number of pairs of integers in the list that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      The number of pairs of integers in the list that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs of integers in the list that xor to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      The number of pairs of integers in the list that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs of integers in the list that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 67.0, "profiled": [{"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of elements in a list within a specified range of indices.\n\n    Args:\n        data: The input list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of the numbers within the specified range.  Returns 0 if the input list is empty or indices are invalid.\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0\n    return sum(data[start_index : end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n      data: A list of numbers.\n      start_index: The starting index (inclusive).\n      end_index: The ending index (inclusive).\n\n    Returns:\n      The sum of numbers within the specified range.  Returns 0 if the input list is empty or indices are out of bounds.\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0\n    return sum(data[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range.\n\n    Args:\n        data: The input list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.  Returns 0 if the input list is empty or indices are invalid.\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0  # Handle empty list or invalid indices\n    return sum(data[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: The input list of numbers.\n        start_index: The starting index of the range (inclusive).\n        end_index: The ending index of the range (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.  Returns 0 if the input list is empty or indices are out of bounds.\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0\n    return sum(data[start_index : end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: The input list of numbers.\n        start_index: The starting index of the range (inclusive).\n        end_index: The ending index of the range (inclusive).\n\n    Returns:\n        The sum of the numbers within the specified range.  Returns 0 if the input list is empty or indices are invalid.\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0  #Handle empty list or invalid indices\n\n    return sum(data[start_index : end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: A list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of the numbers within the specified range.  Returns 0 if the input list is empty or indices are invalid.\n\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0\n    return sum(data[start_index : end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range.\n\n    Args:\n        data: The input list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.  Returns 0 if the input list is empty or indices are invalid.\n\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0  # Handle empty list or invalid indices\n    \n    return sum(data[start_index : end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: The input list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.  Returns 0 if the input list is empty or indices are out of bounds.\n\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0\n\n    return sum(data[start_index : end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: A list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of the numbers within the specified range.  Returns 0 if the input list is empty or indices are invalid.\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0\n    return sum(data[start_index : end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: The input list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.  Returns 0 if the list is empty or indices are invalid.\n\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0\n    return sum(data[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: The input list of numbers.\n        start_index: The starting index (inclusive) of the range.\n        end_index: The ending index (inclusive) of the range.\n\n    Returns:\n        The sum of the numbers within the specified range.  Returns 0 if the input list is empty or the indices are out of range.\n\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0  # Handle empty list or invalid indices\n\n    return sum(data[start_index : end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: The input list of numbers.\n        start_index: The starting index (inclusive) of the range.\n        end_index: The ending index (inclusive) of the range.\n\n    Returns:\n        The sum of the numbers within the specified range.  Returns 0 if the input list is empty or indices are out of bounds.\n\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0\n    return sum(data[start_index : end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range.\n\n    Args:\n      data: The input list of numbers.\n      start_index: The starting index (inclusive) of the range.\n      end_index: The ending index (inclusive) of the range.\n\n    Returns:\n      The sum of the numbers within the specified range.  Returns 0 if the input list is empty or the indices are invalid.\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0\n    return sum(data[start_index : end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: A list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of the numbers within the specified range.  Returns 0 if the input list is empty or indices are invalid.\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0\n    return sum(data[start_index : end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Finds the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: The input list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.  Returns 0 if the input list is empty or indices are invalid.\n\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0\n    return sum(data[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: A list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of the numbers within the specified range.  Returns 0 if the input list is empty or indices are invalid.\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0  # Handle empty list or invalid indices\n\n    return sum(data[start_index : end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: The input list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.  Returns 0 if the input list is empty or the indices are invalid.\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0  # Handle empty list or invalid indices\n\n    return sum(data[start_index : end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: The input list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.  Returns 0 if the input list is empty or indices are out of range.\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0  #Handle empty list or invalid indices\n\n    return sum(data[start_index : end_index + 1])\ndata = [2,1,5,6,8,3,4,9,10,11,8,12]\nstart_index = 8\nend_index = 10", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range.\n\n    Args:\n      data: A list of numbers.\n      start_index: The starting index (inclusive).\n      end_index: The ending index (inclusive).\n\n    Returns:\n      The sum of numbers within the specified range.  Returns 0 if the list is empty or indices are invalid.\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0  # Handle empty list or invalid indices\n    return sum(data[start_index : end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        data: The input list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.  Returns 0 if the input list is empty or indices are invalid.\n\n    \"\"\"\n    if not data or start_index < 0 or end_index >= len(data) or start_index > end_index:\n        return 0\n    return sum(data[start_index : end_index+1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 68.21705426356588, "dps_norm": 14.285714285714286, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with characters at odd indices removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:  # Check if index is even\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with characters at odd indices removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.  Returns an empty string if the input is invalid.\n    \"\"\"\n    if not isinstance(input_string, str):\n        return \"\"  #Handle non-string input gracefully\n\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:  #Check if index is even\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters from a string that have odd indices.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with characters at odd indices removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:  # Check if index is even\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters from a string that have odd index values.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:  # Check if the index is even\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.  Returns an empty string if input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with characters at odd indices removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:  # Check if index is even\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters from a string at odd indices.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.  Returns an empty string if the input is invalid.\n    \"\"\"\n    if not isinstance(input_string, str):\n        return \"\"\n\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:  # Check if index is even\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:  # Check if index is even\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:  #Check if index is even\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:  # Check if index is even\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.  Returns an empty string if the input is invalid.\n\n    \"\"\"\n    if not isinstance(input_string, str):\n        return \"\"  #Handle non-string input\n\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with characters at odd indices removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:  # Check if index is even\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with characters at odd indices removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:  # Check if index is even\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 96.58730158730158, "dps_norm": 99.375, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces blank spaces in a string with a specified character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace spaces with.\n\n    Returns:\n        The string with spaces replaced.  Returns an empty string if input is None.\n    \"\"\"\n    if input_string is None:\n        return \"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a specified character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The string with blank spaces replaced.  Returns the original string if no spaces are found.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a given character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The string with blank spaces replaced.  Returns the original string if input is invalid.\n\n    \"\"\"\n    if not isinstance(input_string, str) or not isinstance(char, str) or len(char) != 1:\n        return input_string #Handle invalid input\n\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 6}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a given character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The string with blank spaces replaced.  Returns the original string if no spaces are found.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a specified character.\n\n    Args:\n      input_string: The input string.\n      char: The character to replace blank spaces with.\n\n    Returns:\n      The string with blank spaces replaced.  Returns the original string if no spaces are found.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a specified character.\n\n    Args:\n      input_string: The input string.\n      char: The character to replace blank spaces with.\n\n    Returns:\n      The string with blank spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a specified character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The string with blank spaces replaced.  Returns the original string if no spaces are found.\n\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a given character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The string with blank spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a specified character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace spaces with.\n\n    Returns:\n        The string with spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a specified character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The string with blank spaces replaced.  Returns the original string if no spaces are present.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces blank spaces in a string with a specified character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string with spaces replaced.  Returns the original string if no spaces are found.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a given character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace spaces with.\n\n    Returns:\n        The string with spaces replaced.  Returns the original string if no spaces are present.\n\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a specified character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The string with blank spaces replaced.  Returns the original string if no spaces are found.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a given character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The string with blank spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces blank spaces in a string with a specified character.\n\n    Args:\n        input_string: The input string containing spaces.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The string with spaces replaced.  Returns the original string if no spaces are present.\n\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a given character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The string with blank spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a given character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The string with blank spaces replaced.  Returns the original string if no spaces are found.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a specified character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The string with blank spaces replaced.  Returns the original string if no spaces are found.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a specified character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace spaces with.\n\n    Returns:\n        The string with spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a given character.\n\n    Args:\n        input_string: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The string with blank spaces replaced.  Returns the original string if no spaces are present.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 47.06896551724138, "dps_norm": 58.0, "pass@1": 46.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m: The maximum value for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Base case: empty sequence\n\n    count = 0\n    if n == 1:\n        return m # Base case: sequence of length 1\n\n    def count_sequences(current_sequence, length):\n        nonlocal count\n        if length == n:\n            count += 1\n            return\n\n        last_element = current_sequence[-1]\n        for i in range(2 * last_element, m + 1):\n            count_sequences(current_sequence + [i], length + 1)\n\n    for i in range(1, m + 1):\n        count_sequences([i], 1)\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"\n    if n == 0:\n        return 1  # Base case: empty sequence is one sequence\n\n    count = 0\n    \n    def count_sequences(current_sequence, current_length):\n        nonlocal count\n        if current_length == n:\n            count += 1\n            return\n\n        last_element = current_sequence[-1] if current_sequence else 0 # Handle empty sequence\n        for i in range(max(1, 2 * last_element), m + 1):\n            count_sequences(current_sequence + [i], current_length + 1)\n\n    count_sequences([], 0)\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of possible sequences of length n, where each element is a positive integer\n    greater than or equal to twice the previous element and less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Empty sequence is a valid sequence\n\n    if m < 1 or n < 0:\n        return 0 #Invalid input\n\n    count = 0\n    \n    def count_sequences(current_sequence, current_length):\n        nonlocal count\n        if current_length == n:\n            count += 1\n            return\n\n        last_element = current_sequence[-1] if current_sequence else 0\n        for i in range(max(1, 2 * last_element), m + 1):\n            count_sequences(current_sequence + [i], current_length + 1)\n\n\n    count_sequences([], 0)\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Empty sequence is a valid sequence\n\n    dp = {}  # Memoization dictionary\n\n    def count_sequences(index, prev_element):\n        if index == n:\n            return 1\n\n        if (index, prev_element) in dp:\n            return dp[(index, prev_element)]\n\n        count = 0\n        for current_element in range(2 * prev_element, m + 1):\n            count += count_sequences(index + 1, current_element)\n\n        dp[(index, prev_element)] = count\n        return count\n\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(1, first_element)\n\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Empty sequence is considered a valid sequence.\n    if m < 1 or n < 0:\n        return 0 # Invalid input\n\n    dp = {}  # Memoization to avoid redundant calculations\n\n    def count_sequences(index, prev_element):\n        if index == n:\n            return 1\n        if (index, prev_element) in dp:\n            return dp[(index, prev_element)]\n\n        count = 0\n        for current_element in range(2 * prev_element, m + 1):\n            count += count_sequences(index + 1, current_element)\n\n        dp[(index, prev_element)] = count\n        return count\n\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(1, first_element)\n\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer \n    greater than or equal to twice the previous element and less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Base case: empty sequence is one possibility\n\n    count = 0\n    \n    def count_sequences(current_sequence, length):\n        nonlocal count  # Access and modify the outer count variable\n        if length == n:\n            count += 1\n            return\n\n        last_element = current_sequence[-1] if current_sequence else 0 #handle empty sequence case\n\n        for i in range(max(1, 2 * last_element), m + 1):\n            count_sequences(current_sequence + [i], length + 1)\n\n    count_sequences([], 0)  # Start with an empty sequence\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Empty sequence is a valid sequence\n\n    count = 0\n    \n    def count_sequences(current_sequence, length_so_far):\n        nonlocal count\n        if length_so_far == n:\n            count += 1\n            return\n\n        last_element = current_sequence[-1] if current_sequence else 0\n        \n        for i in range(max(1, 2 * last_element), m + 1):\n            count_sequences(current_sequence + [i], length_so_far + 1)\n\n    count_sequences([],0)\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Empty sequence is a valid sequence\n\n    dp = {}  # Memoization dictionary to store results\n\n    def count_sequences(index, prev_element):\n        if index == n:\n            return 1\n\n        if (index, prev_element) in dp:\n            return dp[(index, prev_element)]\n\n        count = 0\n        for current_element in range(2 * prev_element, m + 1):\n            count += count_sequences(index + 1, current_element)\n\n        dp[(index, prev_element)] = count\n        return count\n\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(1, first_element)\n\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Empty sequence is considered valid\n\n    if m < 1 or n < 0:\n      return 0 #invalid inputs\n\n    count = 0\n    \n    def count_sequences(current_sequence, length):\n        nonlocal count\n        if length == n:\n            count += 1\n            return\n\n        last_element = current_sequence[-1] if current_sequence else 0\n        \n        for i in range(max(1, 2 * last_element), m + 1):\n            count_sequences(current_sequence + [i], length + 1)\n\n    count_sequences([], 0)\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Empty sequence is a valid sequence\n\n    if m < 1 or n < 1:\n        return 0  # Invalid input\n\n    dp = {}  # Memoization dictionary\n\n    def count_sequences(index, prev):\n        if index == n:\n            return 1\n        if (index, prev) in dp:\n            return dp[(index, prev)]\n\n        count = 0\n        for i in range(max(1, 2 * prev), m + 1):\n            count += count_sequences(index + 1, i)\n        dp[(index, prev)] = count\n        return count\n\n    return count_sequences(0, 0)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Empty sequence is a valid sequence\n\n    count = 0\n    \n    def count_sequences(current_sequence, current_length):\n        nonlocal count\n        if current_length == n:\n            count += 1\n            return\n\n        last_element = current_sequence[-1] if current_sequence else 0\n        for i in range(max(1, 2 * last_element), m + 1):\n            count_sequences(current_sequence + [i], current_length + 1)\n\n    count_sequences([], 0)\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Empty sequence is a valid sequence\n\n    dp = {}  # Use dynamic programming to avoid redundant calculations\n\n    def count_sequences(index, prev_element):\n        if index == n:\n            return 1\n        if (index, prev_element) in dp:\n            return dp[(index, prev_element)]\n\n        count = 0\n        for current_element in range(max(1, 2 * prev_element), m + 1):\n            count += count_sequences(index + 1, current_element)\n\n        dp[(index, prev_element)] = count\n        return count\n\n    total_sequences = count_sequences(0, 0)  # Start with an initial element of 0\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"\n    if n == 0:\n        return 1  # Base case: empty sequence is one possibility\n\n    count = 0\n    if n == 1:\n      return m #Base case: only one element, any value from 1 to m is valid\n\n    \n    def count_sequences(current_sequence, current_length):\n        nonlocal count\n        if current_length == n:\n            count += 1\n            return\n\n        last_element = current_sequence[-1] if current_sequence else 0\n\n        for next_element in range(max(1, 2 * last_element), m + 1):\n            count_sequences(current_sequence + [next_element], current_length + 1)\n\n    count_sequences([], 0)\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"\n    if n == 0:\n        return 1  # Base case: empty sequence is one sequence\n\n    count = 0\n    if n == 1:\n        return m # Base case: only one element, any value from 1 to m is valid\n\n    def count_sequences(current_sequence, current_length):\n        nonlocal count\n        if current_length == n:\n            count += 1\n            return\n\n        last_element = current_sequence[-1]\n        for i in range(2 * last_element, m + 1):\n            count_sequences(current_sequence + [i], current_length + 1)\n\n    for i in range(1, m + 1):\n        count_sequences([i], 1)\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Base case: empty sequence is one sequence\n\n    if n == 1:\n        return m  # Base case: only one element, can be any from 1 to m\n\n\n    dp = {}  #Memoization dictionary\n\n    def count_sequences(index, prev_element):\n        if index == n:\n            return 1\n        \n        if (index, prev_element) in dp:\n            return dp[(index, prev_element)]\n\n        count = 0\n        for current_element in range(2 * prev_element, m + 1):\n            count += count_sequences(index + 1, current_element)\n\n        dp[(index, prev_element)] = count\n        return count\n\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(1, first_element)\n\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Base case: empty sequence\n\n    if n == 1:\n        return m  # Base case: sequence of length 1\n\n    count = 0\n    # Iterate through possible values for the first element\n    for i in range(1, m + 1):\n        count += get_total_number_of_sequences_helper(m, n - 1, i)\n\n    return count\ndef get_total_number_of_sequences_helper(m, n, prev):\n    \"\"\"\n    Helper function for recursive calculation.\n    \"\"\"\n    if n == 0:\n        return 1\n    count = 0\n    for i in range(max(2 * prev, 1), m + 1):\n        count += get_total_number_of_sequences_helper(m, n - 1, i)\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Base case: empty sequence\n\n    count = 0\n    if n == 1:\n      return m\n    \n    def count_sequences(current_sequence, current_length):\n        nonlocal count\n        if current_length == n:\n            count += 1\n            return\n\n        last_element = current_sequence[-1] if current_sequence else 0\n        for i in range(max(1, 2 * last_element), m + 1):\n            count_sequences(current_sequence + [i], current_length + 1)\n\n    count_sequences([], 0)\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m: The maximum value for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Base case: empty sequence is a valid sequence\n\n    if m < 1 or n < 0 :\n        return 0 #Handle invalid inputs\n\n    dp = {}  # Memoization dictionary to store results\n\n    def count_sequences(index, prev_element):\n        if index == n:\n            return 1  # Base case: reached the end of the sequence\n\n        if (index, prev_element) in dp:\n            return dp[(index, prev_element)]\n\n        count = 0\n        for current_element in range(2 * prev_element, m + 1):\n            count += count_sequences(index + 1, current_element)\n\n        dp[(index, prev_element)] = count\n        return count\n\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(1, first_element)\n\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"\n    if n == 0:\n        return 1  # Base case: empty sequence is one possibility\n\n    dp = {}  # Use dynamic programming to store results\n\n    def count_sequences(index, prev):\n        if index == n:\n            return 1  # Base case: reached the end of the sequence\n\n        if (index, prev) in dp:\n            return dp[(index, prev)]\n\n        count = 0\n        for i in range(max(2 * prev, 1), m + 1):\n            count += count_sequences(index + 1, i)\n\n        dp[(index, prev)] = count\n        return count\n\n    return count_sequences(0, 0)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n\n    if n == 0:\n        return 1  # Base case: empty sequence is one sequence\n\n    if m < 1 or n < 0 :\n        return 0 #Invalid inputs\n\n    count = 0\n    if n == 1:\n        return m # Base case: if n=1 there are m possibilities\n\n    # Use dynamic programming to avoid redundant calculations\n    dp = {}  \n\n    def count_sequences(index, prev_element):\n      if index == n:\n        return 1\n\n      if (index, prev_element) in dp:\n        return dp[(index, prev_element)]\n\n      total_count = 0\n      for current_element in range(2 * prev_element, m + 1):\n          total_count += count_sequences(index + 1, current_element)\n      dp[(index, prev_element)] = total_count\n      return total_count\n\n    #Start with the first element\n    for first_element in range(1,m+1):\n        count += count_sequences(1, first_element)\n    return count", "matching_cluster_idx": 7}]}, "Mbpp/240": {"dps": 45.853658536585364, "dps_norm": 65.55555555555556, "pass@1": 75.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n\n    Returns:\n      A new list with the last element of list1 replaced by the elements of list2.  Returns list1 if list1 is empty.\n    \"\"\"\n    if not list1:\n        return list1\n    list1 = list1[:-1]\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.  Returns list1 if list1 is empty.\n    \"\"\"\n    if not list1:\n        return list1\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.  Returns list1 unchanged if list1 is empty.\n    \"\"\"\n    if not list1:\n        return list1\n    \n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.  Returns list1 if list1 is empty.\n    \"\"\"\n    if not list1:\n        return list1\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n\n    Returns:\n      A new list with the last element of list1 replaced by the elements of list2.\n      Returns list1 if list1 is empty.  Returns list2 if list1 only contains one element.\n    \"\"\"\n    if not list1:\n        return list1\n    if len(list1) == 1:\n        return list2\n\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\"\"\"\n    if not list1:  # Handle empty list1 case\n        return list2\n    list1 = list1[:-1]  #remove last element from list1\n    list1.extend(list2) #add elements of list2 to the end of list1\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n\n    Returns:\n      A new list with the last element of list1 replaced by the elements of list2.  Returns list1 if list1 is empty.\n      Returns list2 if list1 contains only one element.\n\n    Raises:\n      TypeError: if input is not a list.\n    \"\"\"\n    if not isinstance(list1, list) or not isinstance(list2, list):\n        raise TypeError(\"Inputs must be lists.\")\n\n    if not list1:\n        return list1\n    elif len(list1) == 1:\n        return list2\n    else:\n        return list1[:-1] + list2", "matching_cluster_idx": 4}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\"\"\"\n    if not list1:  #Handle empty list1 case\n        return list2\n    list1 = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.\n        Returns list1 if list1 is empty.\n        Returns list2 if list1 has only one element.\n\n    Raises:\n      TypeError: if input is not a list.\n    \"\"\"\n    if not isinstance(list1, list) or not isinstance(list2, list):\n        raise TypeError(\"Inputs must be lists.\")\n\n    if not list1:\n        return list1\n    elif len(list1) == 1:\n        return list2\n    else:\n        return list1[:-1] + list2", "matching_cluster_idx": 4}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n\n    Returns:\n      A new list with the last element of list1 replaced by the elements of list2.\n      Returns list1 if list1 is empty.  Returns list2 if list1 contains only one element.\n    \"\"\"\n    if not list1:\n        return list1\n    elif len(list1) == 1:\n        return list2\n    else:\n        return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n\n    Returns:\n      A new list with the last element of list1 replaced by the elements of list2.\n      Returns list1 if list1 is empty.\n    \"\"\"\n    if not list1:\n        return list1\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\"\"\"\n    if not list1:\n        return list2  # Handle empty list1 case\n    list1 = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\"\"\"\n    if not list1:\n        return list2  # Handle empty list1 case\n\n    list1 = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n\n    Returns:\n      A new list with the last element of list1 replaced by the elements of list2.\n      Returns list1 if list1 is empty.  Returns list2 if list1 has only one element.\n\n    Raises:\n      TypeError: if either input is not a list.\n    \"\"\"\n    if not isinstance(list1, list) or not isinstance(list2, list):\n        raise TypeError(\"Both inputs must be lists.\")\n\n    if not list1:\n        return list1\n    elif len(list1) == 1:\n        return list2\n    else:\n        return list1[:-1] + list2", "matching_cluster_idx": 4}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\"\"\"\n    if not list1:\n        return list2  # Handle empty list1 case\n\n    list1 = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\"\"\"\n    if not list1:\n        return list2  # Handle empty list1 case\n    list1 = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by list2's elements.  Returns list1 unchanged if it's empty.\n\n    Raises:\n        TypeError: if input is not a list.\n    \"\"\"\n    if not isinstance(list1, list) or not isinstance(list2, list):\n        raise TypeError(\"Inputs must be lists.\")\n\n    if not list1:  #Handle empty list1 case\n        return list1\n\n    return list1[:-1] + list2", "matching_cluster_idx": 4}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\"\"\"\n    if not list1:\n        return list2  # Handle empty list1 case\n\n    list1 = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.  Returns list1 unchanged if list1 is empty.\n    \"\"\"\n    if not list1:\n        return list1\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\"\"\"\n    if not list1:\n        return list2  #Handle empty list1 case\n    list1 = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 5}]}, "Mbpp/251": {"dps": 91.95402298850576, "dps_norm": 77.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each element of the input list.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.extend([element, item])\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n      lst: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each original element.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.extend([element, item])\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n        input_list: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    output_list = []\n    for item in input_list:\n        output_list.extend([element, item])\n    return output_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.extend([element, item])\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.extend([element, item])\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n        input_list: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    output_list = []\n    for item in input_list:\n        output_list.append(element)\n        output_list.append(item)\n    return output_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each element of the input list.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.extend([element, item])\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n      lst: The input list.\n      elem: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.extend([elem, item])\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.extend([element, item])  #More efficient than appending individually\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.extend([element, item])  #Efficiently adds both element and item\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n      lst: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.extend([element, item])\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n      lst: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each original element.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.extend([element, item])\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(list_in, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n      list_in: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in list_in:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n      lst: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each original element.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.extend([element, item])\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n      lst: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each element of the input list.  Returns an empty list if the input list is empty.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.extend([element, item])  #More efficient than appending individually.\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n      input_list: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each element of the input list.  Returns an empty list if the input list is empty.\n    \"\"\"\n    if not input_list:\n        return []\n    \n    output_list = []\n    for item in input_list:\n        output_list.extend([element, item])\n    return output_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n      lst: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each element of the input list.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.extend([element, item])\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n      lst: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.extend([element, item])\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.extend([element, item])\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n      input_list: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in input_list:\n        result.extend([element, item])  #Efficiently adds element and item\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 61.32420091324201, "dps_norm": 58.8235294117647, "pass@1": 93.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n    \"\"\"\n    if n <= 0:\n        return 0\n    count = 0\n    for num in range(2, n):  #Start from 2 as 0 and 1 are not prime\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1): #Optimized primality test\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n      n: A non-negative integer.\n\n    Returns:\n      The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n\n    Raises:\n      TypeError: if input is not an integer.\n      ValueError: if input is negative.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if n <= 2:\n        return 0\n\n    count = 0\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n      n: A non-negative integer.\n\n    Returns:\n      The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n\n    Raises:\n      TypeError: if input is not an integer.\n      ValueError: if input is negative.\n\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if n <= 2:\n        return 0\n\n    count = 0\n    primes = [True] * n  # Initialize a list to track prime numbers\n    primes[0] = primes[1] = False  # 0 and 1 are not prime\n\n    for p in range(2, int(n**0.5) + 1):\n        if primes[p]:\n            for i in range(p * p, n, p):\n                primes[i] = False\n\n    for p in range(2, n):\n        if primes[p]:\n            count += 1\n\n    return count", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    count = 0\n    for num in range(2, n):  #Start from 2 since 1 is not prime\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):  #Optimized primality test\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    assert count_Primes_nums(5) == 3 #Corrected assertion. 2 is prime and less than 5.  Also 3 is prime and less than 5.\n    \"\"\"\n    if n <= 1:\n        return 0\n    count = 0\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime\n\n    for p in range(2, int(n**0.5) + 1):\n        if prime[p]:\n            for i in range(p * p, n, p):\n                prime[i] = False\n\n    for p in range(2, n):\n        if prime[p]:\n            count += 1\n    return count", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n    \"\"\"\n    if n <= 0:\n        return 0\n    count = 0\n    for num in range(2, n):  #Start from 2 as 1 is not prime\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n\n    Raises:\n        TypeError: if input is not an integer.\n        ValueError: if input is negative.\n\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if n <= 2:\n        return 0  #Handle base cases\n\n    count = 0\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):  # Optimize by checking only up to the square root\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n\n    Raises:\n        TypeError: if input is not an integer.\n        ValueError: if input is negative.\n\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be non-negative.\")\n    if n <= 2:\n        return 0\n\n    count = 0\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, int(i**0.5) + 1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n      n: A non-negative integer.\n\n    Returns:\n      The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    count = 0\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    assert count_Primes_nums(5) == 2\n    \"\"\"\n    if n <= 1:\n        return 0\n    count = 0\n    prime = [True] * n\n    prime[0] = prime[1] = False\n    for p in range(2, int(n**0.5) + 1):\n        if prime[p]:\n            for i in range(p * p, n, p):\n                prime[i] = False\n    for p in range(2, n):\n        if prime[p]:\n            count += 1\n    return count", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n      n: A non-negative integer.\n\n    Returns:\n      The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n\n    Raises:\n      TypeError: if input is not an integer.\n      ValueError: if input is negative.\n\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if n <= 2:\n        return 0\n\n    count = 0\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n\n    \"\"\"\n    if n <= 0:\n        return 0\n    count = 0\n    for num in range(2, n):  #Start from 2, as 0 and 1 are not prime\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n    \"\"\"\n    if n <= 2:\n        return 0  # 0 and 1 are not prime\n\n    count = 0\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n\n    Raises:\n        TypeError: If input is not an integer.\n        ValueError: If input is negative.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if n <= 2:\n        return 0\n\n    count = 0\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n    \"\"\"\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, int(i**0.5) + 1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    assert count_Primes_nums(5) == 2\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    count = 0\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    assert count_Primes_nums(5) == 2\n    \"\"\"\n    if n <= 1:\n        return 0\n\n    count = 0\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n    \"\"\"\n    if n <= 1:\n        return 0\n\n    count = 0\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n      n: A non-negative integer.\n\n    Returns:\n      The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    count = 0\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n      n: A non-negative integer.\n\n    Returns:\n      The number of prime numbers less than n.  Returns 0 if n is 0 or less.\n    \"\"\"\n    if n <= 1:\n        return 0\n    count = 0\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime\n\n    for p in range(2, int(n**0.5) + 1):\n        if prime[p]:\n            for i in range(p * p, n, p):\n                prime[i] = False\n\n    for p in range(2, n):\n        if prime[p]:\n            count += 1\n\n    return count", "matching_cluster_idx": 13}]}, "Mbpp/265": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/281": {"dps": 94.3, "dps_norm": 84.54545454545455, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: The input list.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    seen = set()\n    for item in input_list:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      lst: The input list.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    seen = set()\n    for item in input_list:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      lst: The input list.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      lst: The input list.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    seen = set()\n    for item in input_list:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    seen = set()\n    for item in input_list:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      lst: The input list.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: The input list.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      lst: The input list.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: The input list.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: The input list.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      lst: The input list.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      lst: A list of elements.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      input_list: A list of elements.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      lst: The input list.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 28.205128205128204, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n      arr: The input array of numbers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.  An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array of numbers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array of numbers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array of numbers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n      arr: The input array of numbers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array of numbers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array of numbers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array of numbers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.  An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array of numbers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array of numbers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n      arr: The input array of numbers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n      arr: The input array of numbers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n      arr: The input array of numbers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count\narr = [1, 20, 6, 4, 5]", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array of numbers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n      arr: The input array of numbers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array of numbers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n      arr: The input array of numbers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array. An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n      arr: The input array of numbers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array of numbers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n      arr: The input array of numbers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": 90.96551724137932, "dps_norm": 65.0, "pass@1": 100.0, "profiled": [{"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers selected from two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    products.sort(reverse=True)  #Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers in two lists.\n\n    Args:\n      list1: The first list of numbers.\n      list2: The second list of numbers.\n      n: The number of largest products to find.\n\n    Returns:\n      A list of the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    # Use a min-heap to efficiently track the n largest products\n    return heapq.nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers in two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or negative.\n    \"\"\"\n    if not list1 or not list2 or n <=0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    products.sort(reverse=True)  #Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers in two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    products.sort(reverse=True)  #Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers, one from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n\n    \"\"\"\n    if not list1 or not list2 or n <=0:\n        return []\n\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n    \n    products.sort(reverse=True)  #Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists, selecting one factor from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for a in list1:\n        for b in list2:\n            products.append(a * b)\n\n    products.sort(reverse=True)  #Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers, one from each list.\n\n    Args:\n      list1: The first list of numbers.\n      list2: The second list of numbers.\n      n: The number of largest products to return.\n\n    Returns:\n      A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    products.sort(reverse=True)  # Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers, one from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or negative.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    products.sort(reverse=True)  #Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers, one from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    products.sort(reverse=True)  #Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers, one from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    products.sort(reverse=True)  #Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers in two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    products.sort(reverse=True)  #Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers, one from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    products.sort(reverse=True)  #Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers in two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list of the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or negative.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    return heapq.nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "import itertools\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of elements, one from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for a, b in itertools.product(list1, list2):\n        products.append(a * b)\n\n    products.sort(reverse=True)  # Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists, selecting one factor from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    products.sort(reverse=True)  #Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers in two lists.\n\n    Args:\n      list1: The first list of numbers.\n      list2: The second list of numbers.\n      n: The number of largest products to find.\n\n    Returns:\n      A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n    \"\"\"\n\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    return heapq.nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers, one from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    products.sort(reverse=True)  #Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "import itertools\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers selected from two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or negative.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for pair in itertools.product(list1, list2):\n        products.append(pair[0] * pair[1])\n\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or negative.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from pairs of numbers, one from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.  Returns an empty list if either input list is empty or n is 0 or less.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    products.sort(reverse=True)  # Sort in descending order\n\n    return products[:n]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 96.73708920187794, "dps_norm": 96.53846153846153, "pass@1": 25.0, "profiled": [{"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible using the given equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    #Memoization to avoid redundant calculations.\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def calculate_sum(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_recursive = calculate_sum(n//2) + calculate_sum(n//3) + calculate_sum(n//4) + calculate_sum(n//5)\n        memo[n] = max(sum_recursive, n)\n        return memo[n]\n\n    return calculate_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible using the given recursive equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    #Memoization to avoid redundant calculations\n    memo = {}\n    memo[1] = 1\n    memo[0] = 0\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_recursive = helper(n//2) + helper(n//3) + helper(n//4) + helper(n//5)\n        memo[n] = max(sum_recursive,n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    #Memoization to avoid redundant calculations\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_parts = helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation.\n\n    Args:\n      n: The input integer.\n\n    Returns:\n      The maximum sum.\n    \"\"\"\n    if n <= 1:\n        return n  # Base cases: f(0) = 0, f(1) = 1\n\n    # Memoization to avoid redundant calculations.\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n\n    def calculate_f(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_parts = calculate_f(n // 2) + calculate_f(n // 3) + calculate_f(n // 4) + calculate_f(n // 5)\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n        \n\n    return calculate_f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    if n <= 1:\n        return n  # Base cases: f(0) = 0, f(1) = 1\n\n    #Memoization to avoid redundant calculations\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_parts = helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum possible using the given recursive equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    #Using memoization to avoid redundant calculations.\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def _get_max_sum(n):\n        if n in memo:\n            return memo[n]\n\n        sum_recursive = _get_max_sum(n//2) + _get_max_sum(n//3) + _get_max_sum(n//4) + _get_max_sum(n//5)\n        memo[n] = max(sum_recursive, n)\n        return memo[n]\n\n    return _get_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible using the given equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    memo = {} # Memoization to store results for already computed values of n\n\n    def f(n):\n        if n in memo:\n            return memo[n]\n        \n        if n <= 1:\n            result = n\n        else:\n            result = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        memo[n] = result\n        return result\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n    if n <= 1:  #Base cases for recursion\n        return n\n    else:\n        sum_recursive = get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5)\n        return max(sum_recursive, n)", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible using the given equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    memo = {} #Memoization to store results for previously computed n values.\n    memo[0] = 0\n    memo[1] = 1\n\n\n    def helper(n):\n      if n in memo:\n        return memo[n]\n      \n      sum_parts = helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)\n      memo[n] = max(sum_parts, n)\n      return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    #Using memoization to avoid redundant calculations.\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_recursive = helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)\n        memo[n] = max(sum_recursive, n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum possible using the given recursive equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    #Memoization to avoid redundant calculations.\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_recursive = helper(n//2) + helper(n//3) + helper(n//4) + helper(n//5)\n        memo[n] = max(sum_recursive, n)\n        return memo[n]\n    \n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible using the given equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    if n <= 1:  # Base cases\n        return n\n    \n    #Memoization to avoid redundant calculations.\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def calculate_max_sum(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_recursive = calculate_max_sum(n // 2) + calculate_max_sum(n // 3) + calculate_max_sum(n // 4) + calculate_max_sum(n // 5)\n        memo[n] = max(sum_recursive, n)\n        return memo[n]\n\n    return calculate_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible using the given recursive equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    #Use memoization to avoid redundant calculations\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_parts = helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum possible using the given recursive equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    # Use memoization to avoid redundant calculations\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_parts = helper(n//2) + helper(n//3) + helper(n//4) + helper(n//5)\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum possible using the given recursive equation.\n\n    Args:\n      n: The input integer.\n\n    Returns:\n      The maximum sum possible.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    #Memoization to avoid redundant calculations\n    memo = {}\n    memo[1] = 1\n    memo[2] = 2\n    memo[3] = 3\n    memo[4] = 4\n    memo[5] = 5\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_parts = helper(n//2) + helper(n//3) + helper(n//4) + helper(n//5)\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    # Memoization to avoid redundant calculations\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_parts = helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    if n <= 1:  # Base cases\n        return n\n    \n    #Memoization to avoid redundant calculations.\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def calculate_sum(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_recursive = calculate_sum(n // 2) + calculate_sum(n // 3) + calculate_sum(n // 4) + calculate_sum(n // 5)\n        memo[n] = max(sum_recursive, n)\n        return memo[n]\n    \n    return calculate_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible using the given equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    # Memoization to avoid redundant calculations\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def calculate_sum(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_parts = calculate_sum(n // 2) + calculate_sum(n // 3) + calculate_sum(n // 4) + calculate_sum(n // 5)\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n\n    return calculate_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum possible using the given recursive equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    if n <= 1:\n        return n  # Base cases: f(0) = 0, f(1) = 1\n\n    # Memoization to avoid redundant calculations\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_parts = helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible using the given equation.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    #Memoization to avoid redundant calculations\n    memo = {}\n    memo[0] = 0\n    memo[1] = 1\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        sum_parts = helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeating character in the string, or None if no such character exists.\n    \"\"\"\n    char_counts = {}  # Dictionary to store character counts\n\n    # Count character occurrences\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Find the first character with count 1\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None  # No non-repeating character found", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}  # Dictionary to store character counts\n\n    # Count character occurrences\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Find the first character with count 1\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None  # No non-repeated character found", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character in the string, or None if no such character exists.\n    \"\"\"\n    char_counts = {}\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeating character in the string, or None if no such character exists.\n    \"\"\"\n    char_counts = {}  # Dictionary to store character counts\n\n    # Count character occurrences\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Find the first character with count 1\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None  # No non-repeating character found", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeating character, or None if no such character exists.\n    \"\"\"\n    char_counts = Counter(input_string)\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeated character in the string, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}  # Dictionary to store character counts\n\n    # Count the occurrences of each character\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Find the first character with a count of 1\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None  # All characters are repeated", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeated character in the string, or None if no such character exists.\n    \"\"\"\n    char_counts = {}\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The first non-repeated character in the string, or None if no such character exists.\n    \"\"\"\n    char_counts = {}\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeated character in the string, or None if no such character exists.\n    \"\"\"\n    char_counts = {}\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeated character in the string, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeating character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}  # Dictionary to store character counts\n\n    # Count character occurrences\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Find the first character with count 1\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None  # No non-repeated character found", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = Counter(s)\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeated character in the string, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}  # Dictionary to store character counts\n\n    # Count character occurrences\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Find the first character with count 1\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None  # No non-repeated character found", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The first non-repeated character in the string, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}  # Dictionary to store character counts\n\n    # Count character occurrences\n    for char in input_string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Find the first character with count 1\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None  # All characters are repeated", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuple1, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n      tuple1: The input tuple.\n      element: The element to search for.\n\n    Returns:\n      True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple1", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_data, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n      tuple_data: The input tuple.\n      element: The element to search for.\n\n    Returns:\n      True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple_data", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(my_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n      my_tuple: The tuple to search.\n      element: The element to search for.\n\n    Returns:\n      True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in my_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_data,element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tuple_data: The input tuple.\n        element: The element to search for.\n\n    Returns: \n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple_data", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple1, element):\n    \"\"\"\n    Checks if an element exists in a tuple.\n\n    Args:\n      tuple1: The input tuple.\n      element: The element to search for.\n\n    Returns:\n      True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple1", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_data, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tuple_data: The input tuple.\n        element: The element to search for.\n\n    Returns:\n        True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple_data", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple1,element):\n    \"\"\"\n    This function checks if an element exists in a tuple.\n\n    Args:\n      tuple1: The input tuple.\n      element: The element to search for.\n\n    Returns:\n      True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple1\ntuple1 = (\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\")\nelement = 'r'", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(my_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        my_tuple: The tuple to search.\n        element: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in my_tuple\nmy_tuple = (\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\")", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_in, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n      tuple_in: The input tuple.\n      element: The element to check for.\n\n    Returns:\n      True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple_in", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_x, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tuple_x: The input tuple.\n        element: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple_x", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_in, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tuple_in: The input tuple.\n        element: The element to check for.\n\n    Returns:\n        True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple_in", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple1, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tuple1: The input tuple.\n        element: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple1", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple1, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n      tuple1: The input tuple.\n      element: The element to search for.\n\n    Returns:\n      True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple1", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_data, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n      tuple_data: The input tuple.\n      element: The element to search for.\n\n    Returns:\n      True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple_data", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(my_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        my_tuple: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in my_tuple\nmy_tuple = (\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\")", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_in, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tuple_in: The input tuple.\n        element: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple_in", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_input, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n      tuple_input: The input tuple.\n      element: The element to search for.\n\n    Returns:\n      True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple_input", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(my_tuple,element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n      my_tuple: The input tuple.\n      element: The element to search for.\n\n    Returns: \n      True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in my_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple1,element):\n    \"\"\"\n    This function takes a tuple and an element as input and returns True if the element is present in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple1\ntuple1 = (\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\")\nelement = 'r'", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple1, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n      tuple1: The input tuple.\n      element: The element to search for.\n\n    Returns:\n      True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple1", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 91.30434782608695, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if there's any overlap between two sequences.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any element of seq1 is present in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(x in seq2 for x in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence.\n        seq2: The second sequence.\n\n    Returns:\n        True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element from seq1 is present in seq2.\n\n    Args:\n        seq1: The first sequence.\n        seq2: The second sequence.\n\n    Returns:\n        True if any element of seq1 is found in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence.\n        seq2: The second sequence.\n\n    Returns:\n        True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence.\n        seq2: The second sequence.\n\n    Returns:\n        True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(x in seq2 for x in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence.\n        seq2: The second sequence.\n\n    Returns:\n        True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(x in seq2 for x in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence.\n        seq2: The second sequence.\n\n    Returns:\n        True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any value in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence.\n        seq2: The second sequence.\n\n    Returns:\n        True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence.\n        seq2: The second sequence.\n\n    Returns:\n        True if any value in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    return any(x in seq2 for x in seq1)", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 95.39094650205762, "dps_norm": 97.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The input tuple containing elements to concatenate.\n        delimiter: The delimiter to use between elements (default is '-').\n\n    Returns:\n        A string containing the concatenated elements.  Returns an empty string if the input tuple is empty.\n    \"\"\"\n    if not input_tuple:\n        return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The input tuple.  Elements can be of any type that can be converted to a string.\n        delimiter: The delimiter to use between elements (default is '-').\n\n    Returns:\n        A string with the elements of the tuple concatenated using the delimiter.  Returns an empty string if the input tuple is empty.\n\n    Raises:\n        TypeError: if input_tuple is not a tuple.\n\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    if not input_tuple:  # Handle empty tuple case\n        return \"\"\n\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter = \"-\"):\n    \"\"\"\n    Concatenates the elements of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.  Elements will be converted to strings.\n        delimiter: The delimiter to use between elements (default is \"-\").\n\n    Returns:\n        A string containing the concatenated elements.  Returns an empty string if the input tuple is empty.\n\n    Raises:\n        TypeError: if input_tuple is not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    if not input_tuple:  #handle empty tuple case\n        return \"\"\n\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter = \"-\"):\n    \"\"\"Concatenates elements of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The input tuple of elements to concatenate.\n        delimiter: The delimiter to use between elements (default is \"-\").\n\n    Returns:\n        A string containing the concatenated elements.  Returns an empty string if the input tuple is empty.\n    \"\"\"\n    if not input_tuple:\n        return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The input tuple containing elements to concatenate.\n        delimiter: The delimiter to use between elements (default is \"-\").\n\n    Returns:\n        A string with all elements from the tuple concatenated using the delimiter.  Returns an empty string if the input tuple is empty.\n    \"\"\"\n    if not input_tuple:\n        return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The input tuple of elements to concatenate.\n        delimiter: The delimiter to use between elements (default is \"-\").\n\n    Returns:\n        A string with the elements of the tuple concatenated by the delimiter.  Returns an empty string if the input tuple is empty.\n\n    Raises:\n        TypeError: if input_tuple is not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    if not input_tuple:\n        return \"\"\n\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter = \"-\"):\n    \"\"\"Concatenates elements of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.  Elements will be converted to strings.\n        delimiter: The delimiter to use between elements (default is \"-\").\n\n    Returns:\n        A string containing the concatenated elements.  Returns an empty string if the input tuple is empty.\n\n    \"\"\"\n    if not input_tuple:\n        return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter = \"-\"):\n    \"\"\"Concatenates elements of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.  Elements should be convertible to strings.\n        delimiter: The delimiter to use between elements (default is \"-\").\n\n    Returns:\n        A string containing the concatenated elements.  Returns an empty string if the input tuple is empty.\n\n    Raises:\n        TypeError: If input_tuple is not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter = \"-\"):\n    \"\"\"Concatenates elements of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The tuple of elements to concatenate.\n        delimiter: The delimiter to use between elements (default is \"-\").\n\n    Returns:\n        A string containing the concatenated elements.  Returns an empty string if the input tuple is empty.\n    \"\"\"\n    if not input_tuple:\n        return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.  Elements can be of any type that can be converted to a string.\n        delimiter: The delimiter to use between elements (default is \"-\").\n\n    Returns:\n        A string containing the concatenated elements.  Returns an empty string if the input tuple is empty.\n    \"\"\"\n    if not input_tuple:\n        return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The input tuple containing elements to concatenate.\n        delimiter: The delimiter to use between elements (default is \"-\").\n\n    Returns:\n        A string with elements from the tuple concatenated by the delimiter.\n        Returns an empty string if the input tuple is empty.\n\n    \"\"\"\n    if not input_tuple:\n        return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The input tuple containing elements to concatenate.\n        delimiter: The delimiter to use between elements (default is \"-\").\n\n    Returns:\n        A string containing the concatenated elements.  Returns an empty string if the input tuple is empty.\n    \"\"\"\n    if not input_tuple:\n        return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The input tuple.  Elements can be of any type that supports string conversion.\n        delimiter: The delimiter string to use (default is '-').\n\n    Returns:\n        A string with the tuple elements concatenated by the delimiter.  Returns an empty string if the input tuple is empty.\n    \"\"\"\n    if not input_tuple:\n        return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The input tuple of elements to concatenate.\n        delimiter: The delimiter to use between elements (default is '-').\n\n    Returns:\n        A string containing the concatenated elements.  Returns an empty string if the input tuple is empty.\n    \"\"\"\n    if not input_tuple:\n        return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter = \"-\"):\n    \"\"\"Concatenates elements of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.  Elements can be of any type that can be converted to a string.\n        delimiter: The delimiter to use between elements (default is \"-\").\n\n    Returns:\n        A string containing the concatenated elements.  Returns an empty string if the input tuple is empty.\n\n    \"\"\"\n    if not input_tuple:\n      return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter = \"-\"):\n    \"\"\"Concatenates elements of a tuple using a specified delimiter.\n\n    Args:\n      input_tuple: The input tuple.  Elements can be strings or numbers.\n      delimiter: The delimiter to use between elements (default is \"-\").\n\n    Returns:\n      A string with the elements of the tuple concatenated using the delimiter.  \n      Returns an empty string if the input tuple is empty.\n\n    Raises:\n      TypeError: if input_tuple is not a tuple.\n    \"\"\"\n\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    if not input_tuple:\n        return \"\"\n\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The input tuple of elements to concatenate.\n        delimiter: The delimiter to use between elements (default is '-').\n\n    Returns:\n        A string containing the concatenated elements, or an empty string if the input tuple is empty.  \n        Raises TypeError if input is not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter = \"-\"):\n    \"\"\"Concatenates elements of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.  Elements will be converted to strings.\n        delimiter: The delimiter to use between elements (default is '-').\n\n    Returns:\n        A string containing all elements of the tuple concatenated with the delimiter.  Returns an empty string if the input tuple is empty.\n    \"\"\"\n    if not input_tuple:\n        return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter = \"-\"):\n    \"\"\"Concatenates elements of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.  Elements can be of any type that can be converted to a string.\n        delimiter: The delimiter to use between elements (default is \"-\").\n\n    Returns:\n        A string with the elements of the tuple concatenated using the delimiter.  Returns an empty string if the input tuple is empty.\n\n    \"\"\"\n    if not input_tuple:\n        return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter = \"-\"):\n    \"\"\"Concatenates elements of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The input tuple containing elements to concatenate.\n        delimiter: The delimiter to use between concatenated elements (default is '-').\n\n    Returns:\n        A string containing the concatenated elements of the tuple.  Returns an empty string if the input tuple is empty.\n    \"\"\"\n    if not input_tuple:\n        return \"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}]}, "Mbpp/424": {"dps": 25.36101083032491, "dps_norm": 61.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n      input_tuple: A tuple of strings.\n\n    Returns:\n      A list containing the last character of each string in the input tuple.  Returns an empty list if the input is empty or None.\n    \"\"\"\n    if not input_tuple:\n        return []\n    return [string[-1] for string in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n      input_tuple: A tuple of strings.\n\n    Returns:\n      A list containing the last character of each string in the input tuple.\n      Returns an empty list if the input tuple is empty or contains non-string elements.\n\n    \"\"\"\n    if not input_tuple:\n        return []\n\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str):\n            if len(item) > 0:\n                result.append(item[-1])\n            else:\n                #Handle empty strings - could raise an exception or append \"\" depending on requirements\n                result.append(\"\")\n        else:\n            # Handle non-string elements - could raise an exception or skip depending on requirements.\n            return [] #Choosing to return empty list for simplicity\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character from each string in a tuple.\n\n    Args:\n      input_tuple: A tuple of strings.\n\n    Returns:\n      A list of strings, where each string is the last character of the corresponding string in the input tuple.\n      Returns an empty list if the input tuple is empty or contains non-string elements.\n\n    \"\"\"\n    if not input_tuple:\n        return []\n\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and len(item) > 0:\n            result.append(item[-1])\n        else:\n            # Handle cases where the input tuple contains non-strings or empty strings\n            return [] #or raise an exception: raise TypeError(\"Input tuple must contain only strings.\")\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n      input_tuple: A tuple of strings.\n\n    Returns:\n      A list containing the last character of each string in the input tuple.  Returns an empty list if the input is empty or None.\n    \"\"\"\n    if not input_tuple:\n        return []\n    return [string[-1] for string in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.  Returns an empty list if the input is empty or not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return []\n    if not input_tuple:\n        return []\n    return [string[-1] for string in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.  Returns an empty list if the input is empty or not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return []\n    if not input_tuple:\n        return []\n    return [string[-1] for string in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.  Returns an empty list if the input is empty or not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return []\n    if not input_tuple:\n        return []\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-string elements.\n\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return []  # Handle non-tuple input\n\n    if not input_tuple:\n        return []  # Handle empty tuple\n\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and len(item) > 0:\n            result.append(item[-1])\n        else:\n            return [] # Handle non-string or empty string elements\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-string elements.\n\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return [] #Handle cases where input is not a tuple.\n\n    if not all(isinstance(item, str) for item in input_tuple):\n        return [] #Handle cases with non-string elements.\n\n    if not input_tuple:\n        return [] #Handle empty tuple\n\n    return [item[-1] for item in input_tuple]", "matching_cluster_idx": 2}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.  Returns an empty list if the input is empty or not a tuple.\n\n    Raises:\n        TypeError: if input is not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n    if not input_tuple:\n        return []\n    return [string[-1] for string in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character from each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-string elements.\n\n    \"\"\"\n    if not input_tuple:\n        return []\n\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str):\n            if len(item) > 0:\n                result.append(item[-1])\n            else:\n                result.append(\"\") #Handle empty strings\n        else:\n            return [] #Handle non-string elements\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n      input_tuple: A tuple of strings.\n\n    Returns:\n      A list containing the last character of each string in the input tuple.  Returns an empty list if the input is empty or not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return []\n    if not input_tuple:\n        return []\n    return [string[-1] for string in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character from each string in a tuple.\n\n    Args:\n      input_tuple: A tuple of strings.\n\n    Returns:\n      A list containing the last character of each string in the input tuple.\n      Returns an empty list if the input tuple is empty or contains non-string elements.\n\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return []  #Handle cases where input isn't a tuple\n\n    if not input_tuple:\n        return []\n\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and len(item) > 0:\n            result.append(item[-1])\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.  Returns an empty list if the input is empty or not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return []\n    if not input_tuple:\n        return []\n    return [string[-1] for string in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-string elements.\n\n    \"\"\"\n    if not input_tuple:\n        return []\n\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and len(item) > 0:\n            result.append(item[-1])\n        else:\n            #Handle cases with empty strings or non-string elements gracefully.\n            pass #Could also raise an error here depending on desired behavior.\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n      input_tuple: A tuple of strings.\n\n    Returns:\n      A list containing the last character of each string in the input tuple.\n      Returns an empty list if the input tuple is empty or contains non-string elements.\n\n    \"\"\"\n    if not input_tuple:\n        return []\n    \n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and len(item) > 0:\n            result.append(item[-1])\n        else:\n            #Handle cases with empty strings or non-string elements.  Could raise an exception instead.\n            pass\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.  Returns an empty list if the input is empty or not a tuple of strings.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return []\n    if not all(isinstance(s, str) for s in input_tuple):\n        return []\n    \n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 2}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n      input_tuple: A tuple of strings.\n\n    Returns:\n      A list containing the last character of each string in the input tuple.  Returns an empty list if the input is empty or not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return []\n    if not input_tuple:\n        return []\n    return [string[-1] for string in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-string elements.\n\n    \"\"\"\n    if not input_tuple:\n        return []\n\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str):\n            if len(item) > 0:  #Handle empty strings\n                result.append(item[-1])\n        else:\n            return [] #Handle non-string elements\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character from each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.  Returns an empty list if the input is empty or not a tuple of strings.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return []\n    if not all(isinstance(s, str) for s in input_tuple):\n        return []\n    \n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 2}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to count.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to count.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to count.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to count.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to count.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to count.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to count.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to count.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to count.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to count.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to count.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to count.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to count.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to count.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to count.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to count.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to count.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to count.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to count.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to search for.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.29752066115702, "dps_norm": 55.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Args:\n        arr: The array to be sorted.\n\n    Returns:\n        The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce gap by half\n\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Args:\n        arr: The array to be sorted.\n\n    Returns:\n        The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using Shell Sort.\n\n    Args:\n      arr: The array to be sorted.\n\n    Returns:\n      The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using Shell Sort.\n\n    Args:\n        arr: The array to be sorted.\n\n    Returns:\n        The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell sort algorithm.\n\n    Args:\n      arr: The array to be sorted.\n\n    Returns:\n      The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell Sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce gap\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using the Shell sort algorithm.\n\n    Args:\n      arr: The array to be sorted.\n\n    Returns:\n      The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce gap\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using the Shell sort algorithm.\n\n    Args:\n      arr: The array to be sorted.\n\n    Returns:\n      The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using the Shell sort algorithm.\n\n    Args:\n        arr: The array to be sorted.\n\n    Returns:\n        The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap\n\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell sort algorithm.\n\n    Args:\n        arr: The array to be sorted.\n\n    Returns:\n        The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell Sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce gap\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using the Shell sort algorithm.\n\n    Args:\n        arr: The array to be sorted.\n\n    Returns:\n        The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell Sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap\n\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using the Shell sort algorithm.\n\n    Args:\n        arr: The array to be sorted.\n\n    Returns:\n        The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 98.24468085106383, "dps_norm": 99.0, "pass@1": 99.0, "profiled": [{"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the entered number is greater than all elements of the given array.\n\n    Args:\n      arr: A list of numbers.\n      num: A number to compare against the elements of the array.\n\n    Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: The input array of numbers.\n        num: The number to compare against.\n\n    Returns: \n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: A list of numbers.\n      num: A number to compare against the array elements.\n\n    Returns:\n      True if the number is greater than all elements in the array, \n      False otherwise.  Returns True for an empty array.\n    \"\"\"\n    if not arr:\n        return True  #Consider an empty array as satisfying the condition.\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: A list of numbers.\n      num: The number to compare.\n\n    Returns: \n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:  # Note: <= to handle cases where num is equal to or less than an element\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: A list of numbers.\n      num: The number to compare.\n\n    Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:  #Corrected the comparison to <=\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: The input array of numbers.\n        num: The number to compare against.\n\n    Returns: \n        True if the number is greater than all elements in the array, \n        False otherwise.  Returns True for an empty array.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: The input array of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, \n        False otherwise.  Returns True for an empty array.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the entered number is greater than all elements of the given array.\n\n    Args:\n      arr: A list of numbers.\n      num: A number to compare against the elements of the array.\n\n    Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:  #Note: <= used for greater than or equal to check.  < would only check strictly greater than.\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: A list of numbers.\n      num: The number to compare.\n\n    Returns:\n      True if the number is greater than all elements in the array, \n      False otherwise.  Returns True for an empty array.\n    \"\"\"\n    if not arr:\n        return True  #Consider an empty array as satisfying the condition.\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the entered number is greater than all elements of the given array.\n\n    Args:\n      arr: A list of numbers.\n      num: A number to compare against the array elements.\n\n    Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:  #Note the <=,  it must be greater than ALL elements.\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: A list of numbers.\n      num: The number to compare.\n\n    Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: A list of numbers.\n      num: The number to compare.\n\n    Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: A list of numbers.\n      num: The number to compare.\n\n    Returns:\n      True if the number is greater than all elements in the array, \n      False otherwise.  Returns True for an empty array.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: A list of numbers.\n      num: The number to compare.\n\n    Returns:\n      True if the number is greater than all elements in the array, \n      False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:  #Note the <= to ensure it's strictly greater\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: The input array of numbers.\n      num: The number to compare against.\n\n    Returns:\n      True if the number is greater than all elements in the array, \n      False otherwise.  Returns True for an empty array.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: A list of numbers.\n      num: A number to compare against the array elements.\n\n    Returns:\n      True if the number is greater than all elements in the array, \n      False otherwise.  Returns True for an empty array.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: A list of numbers.\n      num: The number to compare.\n\n    Returns: \n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:  # Note: We use <= to check if num is greater than ALL elements.\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: The input array of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: The input array of numbers.\n      num: The number to compare against.\n\n    Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:  # Note: <= to handle cases where num is equal to or less than an element.\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: A list of numbers.\n      num: A number to compare against the array elements.\n\n    Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/437": {"dps": 70.58823529411765, "dps_norm": 20.0, "pass@1": 86.0, "profiled": [{"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check if index is odd\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check for odd index\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check if index is odd\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  # Check if index is odd\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check if index is odd.\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check for odd index\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check if index is odd (starts from 0)\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with odd-indexed characters removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check if index is odd.\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check for odd index\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.  Returns an empty string if the input is invalid.\n    \"\"\"\n    if not isinstance(input_string, str):\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check if index is odd.\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with odd-indexed characters removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check for odd index\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with odd-indexed characters removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check if index is odd.  Python uses 0-based indexing.\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check if index is odd.  Python uses 0 based indexing.\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with odd-indexed characters removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check for odd index. Note that index starts from 0.\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check for odd index. Remember that indexing starts from 0.\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.  Returns an empty string if the input is invalid.\n    \"\"\"\n    if not isinstance(input_string, str):\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check for odd index\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.  Returns an empty string if the input is empty or None.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check if index is odd\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      A new string with odd-indexed characters removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  #Check if index is odd. \n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  # Check if index is odd\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with odd-indexed characters removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 != 0:  # Check if index is odd\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 99.21182266009852, "dps_norm": 92.0, "pass@1": 29.0, "profiled": [{"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n      input_tuple: The input tuple to search within.\n      input_list: The list of elements to count.\n\n    Returns:\n      The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n    \"\"\"\n    try:\n        count = 0\n        tuple_counts = Counter(input_tuple)\n        for element in input_list:\n            count += tuple_counts[element]\n        return count\n    except (TypeError, KeyError):\n        return 0", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if the input tuple is empty.\n    \"\"\"\n    if not input_tuple:\n        return 0\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_list, list):\n        return 0\n\n    tuple_counts = Counter(input_tuple)\n    total_count = 0\n    for element in input_list:\n        total_count += tuple_counts.get(element, 0)  #Handles cases where element is not in tuple\n\n    return total_count", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_list, list):\n        return 0\n\n    tuple_counts = Counter(input_tuple)\n    total_count = 0\n    for item in input_list:\n        total_count += tuple_counts[item]\n    return total_count", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_list, list):\n        return 0\n\n    tuple_counts = Counter(input_tuple)\n    total_count = 0\n    for item in input_list:\n        total_count += tuple_counts[item]\n    return total_count", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if the input tuple or list is empty.\n    \"\"\"\n    if not input_tuple or not input_list:\n        return 0\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_list, list):\n        return 0\n\n    tuple_counts = Counter(input_tuple)\n    total_count = 0\n    for element in input_list:\n        total_count += tuple_counts[element]\n    return total_count", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_list, list):\n        return 0\n\n    try:\n        tuple_counts = Counter(input_tuple)\n        total_count = sum(tuple_counts[item] for item in input_list)\n        return total_count\n    except TypeError:  # Handle cases where elements are not hashable.\n        return 0", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        tuple_data: The input tuple.\n        list_data: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list that are present in the tuple.  Returns 0 if either input is invalid.\n    \"\"\"\n    if not isinstance(tuple_data, tuple) or not isinstance(list_data, list):\n        return 0\n\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_list, list):\n        return 0\n\n    try:\n        tuple_counts = Counter(input_tuple)\n        total_count = sum(tuple_counts[item] for item in input_list)\n        return total_count\n    except TypeError:  # Handle potential errors if elements are not hashable\n        return 0", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n\n    \"\"\"\n    try:\n        tuple_counts = Counter(input_tuple)\n        total_count = 0\n        for element in input_list:\n            total_count += tuple_counts.get(element, 0)  #Handles cases where element is not in tuple.\n        return total_count\n    except (TypeError):\n        return 0", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_list, list):\n        return 0\n\n    tuple_counts = Counter(input_tuple)\n    total_count = 0\n    for element in input_list:\n        total_count += tuple_counts.get(element, 0)  #Handles cases where element is not in tuple\n\n    return total_count", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_list, list):\n        return 0\n\n    try:\n        tuple_counts = Counter(input_tuple)\n        total_count = sum(tuple_counts[item] for item in input_list)\n        return total_count\n    except TypeError: #Handles cases where tuple elements are not hashable.\n        return 0", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        tuple_data: The input tuple.\n        list_data: The list of elements to count.\n\n    Returns:\n        The total count of elements from list_data found in tuple_data.  Returns 0 if either input is invalid.\n\n    \"\"\"\n    if not isinstance(tuple_data, tuple) or not isinstance(list_data, list):\n        return 0\n\n    try:\n        tuple_counts = Counter(tuple_data)\n        total_count = sum(tuple_counts[element] for element in list_data)\n        return total_count\n    except TypeError: #Handles cases where tuple contains unhashable types\n        return 0", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_list, list):\n        return 0\n\n    count = 0\n    tuple_counts = Counter(input_tuple)\n    for element in input_list:\n        count += tuple_counts.get(element, 0)  #Handles cases where list element isn't in tuple\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        tuple_data: The input tuple.\n        list_data: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list that are present in the tuple.  Returns 0 if either input is invalid.\n    \"\"\"\n    if not isinstance(tuple_data, tuple) or not isinstance(list_data, list):\n        return 0\n\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_list, list):\n        return 0\n\n    tuple_counts = Counter(input_tuple)\n    total_count = 0\n    for element in input_list:\n        total_count += tuple_counts[element]\n    return total_count", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_list, list):\n        return 0\n\n    count = 0\n    tuple_counts = Counter(input_tuple)\n    for item in input_list:\n        count += tuple_counts.get(item, 0)  #handle case where item not in tuple\n\n    return count", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total count of elements from the list found in the tuple.  Returns 0 if either input is invalid.\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_list, list):\n        return 0\n\n    try:\n        count = 0\n        tuple_counts = Counter(input_tuple)\n        for element in input_list:\n            count += tuple_counts[element]  \n        return count\n    except TypeError: # handles cases where elements in the tuple are not hashable\n        return 0", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(my_tuple, my_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n      my_tuple: The tuple to search within.\n      my_list: The list of elements to count.\n\n    Returns:\n      The total count of elements from my_list found in my_tuple.  Returns 0 if either input is invalid.\n    \"\"\"\n    try:\n        counts = Counter(my_tuple)\n        total_count = sum(counts[item] for item in my_list)\n        return total_count\n    except (TypeError, KeyError):\n        return 0", "matching_cluster_idx": 4}]}, "Mbpp/451": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        str_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.  Returns an empty list if the input is not a list or is empty.\n    \"\"\"\n    if not isinstance(str_list, list) or not str_list:\n        return []\n    \n    reversed_list = [s[::-1] for s in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n        str_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.  Returns an empty list if input is invalid.\n    \"\"\"\n    if not isinstance(str_list, list):\n        return []\n    if not all(isinstance(s, str) for s in str_list):\n        return []\n\n    reversed_list = [s[::-1] for s in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n      string_list: A list of strings.\n\n    Returns:\n      A new list containing the reversed strings.  Returns an empty list if the input is invalid.\n    \"\"\"\n    if not isinstance(string_list, list):\n        return []\n    if not all(isinstance(s, str) for s in string_list):\n        return []\n\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n      str_list: A list of strings.\n\n    Returns:\n      A list of strings where each string is the reverse of the corresponding \n      string in the input list.  Returns an empty list if the input is not a list.\n    \"\"\"\n    if not isinstance(str_list, list):\n        return []\n    reversed_list = [string[::-1] for string in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.  Returns an empty list if the input is not a list or is empty.\n    \"\"\"\n    if not isinstance(string_list, list):\n        return []\n    if not string_list:\n        return []\n\n    reversed_list = [string[::-1] for string in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Write a function to reverse each string in a given list of string values.\n    assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])==['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    reversed_list = [s[::-1] for s in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n        str_list: A list of strings.\n\n    Returns:\n        A list of strings with each string reversed.  Returns an empty list if the input is not a list or the list is empty.\n    \"\"\"\n    if not isinstance(str_list, list):\n        return []\n    if not str_list:\n        return []\n\n    reversed_list = [string[::-1] for string in str_list]  #Using list comprehension for efficiency.\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string in a given list of strings.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.  Returns an empty list if the input is not a list or if the list is empty.\n    \"\"\"\n    if not isinstance(string_list, list):\n        return []\n    if not string_list:\n        return []\n    reversed_list = [string[::-1] for string in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n        str_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.  Returns an empty list if input is invalid.\n    \"\"\"\n    if not isinstance(str_list, list):\n        return []\n    if not all(isinstance(s, str) for s in str_list):\n        return []\n\n    reversed_list = [s[::-1] for s in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n      str_list: A list of strings.\n\n    Returns:\n      A new list containing the reversed strings.  Returns an empty list if the input is not a list.  \n      Returns an empty list if the input list contains non-string elements.\n    \"\"\"\n    if not isinstance(str_list, list):\n        return []\n    \n    if not all(isinstance(s, str) for s in str_list):\n        return []\n\n    reversed_list = [s[::-1] for s in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n      string_list: A list of strings.\n\n    Returns:\n      A new list containing the reversed strings.  Returns an empty list if the input is invalid.\n\n    \"\"\"\n    if not isinstance(string_list, list):\n        return []\n    \n    reversed_list = []\n    for string in string_list:\n        if isinstance(string, str):\n            reversed_list.append(string[::-1])\n        else:\n            return [] #Handle non-string elements gracefully.  Could also raise an exception.\n\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n        str_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.  Returns an empty list if input is invalid.\n    \"\"\"\n    if not isinstance(str_list, list):\n        return []\n    reversed_list = []\n    for string in str_list:\n        if isinstance(string, str):\n            reversed_list.append(string[::-1])\n        else:\n            return [] #Handle cases where list contains non-string elements.\n\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n      str_list: A list of strings.\n\n    Returns:\n      A new list containing the reversed strings.  Returns an empty list if the input is invalid.\n    \"\"\"\n    if not isinstance(str_list, list):\n        return []\n    \n    reversed_list = []\n    for string in str_list:\n        if not isinstance(string, str):\n            return [] #Handle non-string elements gracefully.\n        reversed_list.append(string[::-1])  #Efficient string reversal using slicing\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n        str_list: A list of strings.\n\n    Returns:\n        A list of strings with each string reversed.  Returns an empty list if the input is not a list or is empty.\n    \"\"\"\n    if not isinstance(str_list, list) or not str_list:\n        return []\n    reversed_list = [string[::-1] for string in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.  Returns an empty list if the input is not a list or if the list is empty.\n\n    \"\"\"\n    if not isinstance(string_list, list):\n        return []\n    if not string_list:\n        return []\n\n    reversed_list = [string[::-1] for string in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        str_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.  Returns an empty list if the input is invalid.\n    \"\"\"\n    if not isinstance(str_list, list):\n        return []\n    \n    reversed_list = []\n    for string in str_list:\n        if isinstance(string, str):\n            reversed_list.append(string[::-1])\n        else:\n            # Handle non-string elements gracefully.  Could raise an error instead.\n            reversed_list.append(string) \n\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n        str_list: A list of strings.\n\n    Returns:\n        A list of strings with each string reversed.  Returns an empty list if the input is not a list.\n        Returns an empty list if the input list contains non-string elements.\n\n    \"\"\"\n    if not isinstance(str_list, list):\n        return []\n\n    if not all(isinstance(s, str) for s in str_list):\n        return []\n\n    reversed_list = [s[::-1] for s in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A list of strings where each string is the reverse of the corresponding string in the input list.\n        Returns an empty list if the input is not a list or if the list is empty.\n\n    \"\"\"\n    if not isinstance(string_list, list):\n        return []\n    if not string_list:\n        return []\n\n    reversed_list = [string[::-1] for string in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n      string_list: A list of strings.\n\n    Returns:\n      A new list containing the reversed strings.  Returns an empty list if the input is not a list.\n      Returns an empty list if the input list contains non-string elements.\n    \"\"\"\n    if not isinstance(string_list, list):\n        return []\n\n    if not all(isinstance(s, str) for s in string_list):\n        return []\n\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n      str_list: A list of strings.\n\n    Returns:\n      A new list containing the reversed strings.  Returns an empty list if the input is invalid.\n\n    \"\"\"\n    if not isinstance(str_list, list):\n        return []\n    \n    reversed_list = []\n    for string in str_list:\n        if not isinstance(string, str):\n            return [] #Handle non-string elements gracefully\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 19.134615384615383, "dps_norm": 57.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    \"\"\"\n    first_elements = []\n    for sublist in list_of_lists:\n        if sublist:  # Check if the sublist is not empty\n            first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains at least one element.\n\n    Returns:\n        A list containing the first element of each sublist.  Returns an empty list if the input is empty.\n        Raises a TypeError if the input is not a list or if a sublist is not a list.\n        Raises a ValueError if any sublist is empty.\n    \"\"\"\n\n    if not isinstance(list_of_lists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n\n    if not list_of_lists:\n        return []\n\n    first_elements = []\n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            raise TypeError(\"All sublists must be lists.\")\n        if not sublist:\n            raise ValueError(\"Sublists cannot be empty.\")\n        first_elements.append(sublist[0])\n\n    return first_elements", "matching_cluster_idx": 1}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n      list_of_lists: A list of lists.\n\n    Returns:\n      A list containing the first element of each sublist.  Returns an empty list if the input is empty or contains empty sublists.\n\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return [sublist[0] for sublist in list_of_lists if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(matrix):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n      matrix: A list of lists (a matrix).\n\n    Returns:\n      A list containing the first element of each sublist in the input matrix.\n      Returns an empty list if the input matrix is empty or contains empty sublists.\n\n    \"\"\"\n    if not matrix:\n        return []\n    return [sublist[0] for sublist in matrix if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    \"\"\"\n    first_elements = []\n    for sublist in list_of_lists:\n        if sublist:  # Check if the sublist is not empty\n            first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    \"\"\"\n    first_elements = []\n    for sublist in list_of_lists:\n        if sublist: #handle empty sublists\n            first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 2}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each sublist contains at least one element.\n\n    Returns:\n        A new list containing the first element of each sublist.  Returns an empty list if the input is empty.\n        Raises a TypeError if the input is not a list.  Raises a ValueError if any sublist is empty.\n\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n    \n    if not list_of_lists:\n        return []\n\n    first_elements = []\n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            raise TypeError(\"Input must be a list of lists.\")\n        if not sublist:\n            raise ValueError(\"Sublists cannot be empty.\")\n        first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 1}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n      list_of_lists: A list of lists, where each sublist contains at least one element.\n\n    Returns:\n      A new list containing the first element of each sublist.  Returns an empty list if the input is empty.\n      Raises a TypeError if the input is not a list or if any sublist is not a list.\n      Raises a ValueError if any sublist is empty.\n\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n\n    if not list_of_lists: #Handle empty input list\n        return []\n\n    first_elements = []\n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            raise TypeError(\"All sublists must be lists.\")\n        if not sublist:\n            raise ValueError(\"Sublists cannot be empty.\")\n        first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 1}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    \"\"\"\n    first_elements = []\n    for sublist in list_of_lists:\n        if sublist: #check for empty sublists to avoid IndexError\n            first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    \"\"\"\n    first_elements = []\n    for sublist in list_of_lists:\n        if sublist:  #Check if sublist is not empty\n            first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n      lists: A list of lists, where each sublist contains at least one element.\n\n    Returns:\n      A list containing the first element of each sublist.  Returns an empty list if the input is empty.\n      Raises a TypeError if input is not a list.\n      Raises a ValueError if any sublist is empty.\n\n    \"\"\"\n    if not isinstance(lists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n    \n    if not lists:\n        return []\n\n    first_elements = []\n    for sublist in lists:\n        if not isinstance(sublist, list):\n            raise TypeError(\"Input must be a list of lists.\")\n        if not sublist:\n            raise ValueError(\"Sublists cannot be empty.\")\n        first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 1}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each sublist contains at least one element.\n\n    Returns:\n        A new list containing the first element of each sublist.  Returns an empty list if the input is empty.\n        Raises TypeError if input is not a list.  Raises ValueError if any sublist is empty.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n    \n    if not list_of_lists:\n        return []\n\n    first_elements = []\n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            raise TypeError(\"Input must be a list of lists.\")\n        if not sublist:\n            raise ValueError(\"Sublists cannot be empty.\")\n        first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 1}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist within a list of lists.\n\n    Args:\n      list_of_lists: A list of lists, where each sublist contains at least one element.\n\n    Returns:\n      A new list containing the first element of each sublist.  Returns an empty list if the input is empty.  Raises an error if a sublist is empty.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    \n    first_elements = []\n    for sublist in list_of_lists:\n        if not sublist:\n            raise ValueError(\"Sublist cannot be empty\")\n        first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 2}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each sublist contains at least one element.\n\n    Returns:\n        A new list containing the first element of each sublist.  Returns an empty list if the input is empty.  Raises an exception if a sublist is empty.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    \n    first_elements = []\n    for sublist in list_of_lists:\n        if not sublist:\n            raise ValueError(\"Sublist cannot be empty\")\n        first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 2}, {"solution": "def Extract(data):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n      data: A list of lists.\n\n    Returns:\n      A list containing the first element of each sublist.  Returns an empty list if the input is empty or not a list of lists.\n    \"\"\"\n    if not isinstance(data, list):\n        return []\n    if not data:\n        return []\n    if not all(isinstance(sublist, list) for sublist in data):\n        return []\n\n    result = []\n    for sublist in data:\n        if sublist:  # Check if sublist is not empty\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 1}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each sublist contains at least one element.\n\n    Returns:\n        A new list containing the first element of each sublist.  Returns an empty list if the input is empty.\n        Raises a TypeError if the input is not a list or if any sublist is not a list.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n    \n    if not list_of_lists: #Handle empty list case\n        return []\n\n    first_elements = []\n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            raise TypeError(\"All sublists must be lists.\")\n        if not sublist: #Handle empty sublist case.  Could also raise an error here.\n            continue #Skip empty sublists.\n        first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 1}, {"solution": "def Extract(List):\n    \"\"\"\n    This function takes a list of lists as input and returns a new list containing the first element of each sublist.\n\n    Args:\n        List: A list of lists.\n\n    Returns:\n        A new list containing the first element of each sublist.  Returns an empty list if the input is empty or not a list of lists.\n    \"\"\"\n    if not isinstance(List, list):\n        return []\n    if not List:\n        return []\n    \n    first_elements = []\n    for sublist in List:\n        if isinstance(sublist, list) and sublist:  #Check if sublist is a list and not empty\n            first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 1}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A list containing the first element of each sublist. Returns an empty list if the input is empty or contains empty sublists.  Raises TypeError if input is not a list.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n\n    first_elements = []\n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            raise TypeError(\"Input must be a list of lists.\")\n        if sublist: #check for empty sublist\n            first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 1}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each sublist contains at least one element.\n\n    Returns:\n        A new list containing the first element of each sublist.  Returns an empty list if the input is empty.\n        Raises a TypeError if input is not a list.  Raises a ValueError if any sublist is empty.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n    \n    if not list_of_lists:\n        return []\n\n    first_elements = []\n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            raise TypeError(\"Input must be a list of lists.\")\n        if not sublist:\n            raise ValueError(\"Sublists cannot be empty.\")\n        first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 1}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n\n    Args:\n      input_string: The string to modify.\n      char_to_replace: The character to be replaced.\n      replacement_char: The character to replace with.\n\n    Returns:\n      The modified string with the characters replaced.  Returns the original string if char_to_replace is not found.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The string to modify.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with characters replaced.  Returns the original string if char_to_replace is not found.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"Replaces all occurrences of a character in a string with another character.\n\n    Args:\n      input_string: The input string.\n      char_to_replace: The character to be replaced.\n      replacement_char: The character to replace with.\n\n    Returns:\n      The string with the characters replaced.  Returns the original string if char_to_replace is not found.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The string to modify.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with the character replaced.  Returns the original string if char_to_replace is not found.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The string to modify.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with the characters replaced.  Returns the original string if char_to_replace is not found.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The input string.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The string with the characters replaced.  Returns the original string if char_to_replace is not found.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The string to modify.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with the character replaced.  Returns the original string if char_to_replace is not found.\n\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The string in which to replace characters.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The string with the characters replaced.  Returns the original string if char_to_replace is not found.\n\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The string to modify.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with the replacements made.  Returns the original string if char_to_replace is not found.\n\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The input string.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The string with the characters replaced.  Returns the original string if char_to_replace is not found.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The string to modify.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with characters replaced.  Returns the original string if char_to_replace is not found.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The string to modify.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with the character replaced.  Returns the original string if char_to_replace is not found.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a specified character in a string with another character.\n\n    Args:\n        input_string: The input string.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with the character replaced.  Returns the original string if char_to_replace is not found.\n\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The input string.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The string with the characters replaced.  Returns the original string if char_to_replace is not found.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The string to modify.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with the characters replaced.  Returns the original string if char_to_replace is not found.\n\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a specific character in a string with another character.\n\n    Args:\n        input_string: The input string.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The string with the characters replaced.  Returns the original string if char_to_replace is not found.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The string to modify.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with the replacements made.  Returns the original string if char_to_replace is not found.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The input string.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with characters replaced.  Returns the original string if char_to_replace is not found.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The input string.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with the characters replaced.  Returns the original string if char_to_replace is not found.\n\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        input_string: The string to modify.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with the character replaced.  Returns the original string if char_to_replace is not found.\n\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 73.89261744966443, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n      arr: A list of numbers.\n\n    Returns:\n      The sum of the largest and smallest numbers in the array.  Returns 0 if the array is empty.\n\n    Raises:\n      TypeError: if input is not a list.\n      ValueError: if input list contains non-numeric values.\n\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list.\")\n    if not arr:\n        return 0\n    if not all(isinstance(x, (int, float)) for x in arr):\n        raise ValueError(\"List must contain only numbers.\")\n\n    min_val = min(arr)\n    max_val = max(arr)\n    return min_val + max_val", "matching_cluster_idx": 1}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest values in the array.  Returns 0 for an empty array.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n      arr: A list of numbers.\n\n    Returns:\n      The sum of the largest and smallest numbers in the array.  Returns 0 for an empty array.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in an array.\n\n    Args:\n      arr: A list of numbers.\n\n    Returns:\n      The sum of the largest and smallest numbers in the array.  Returns 0 for empty arrays.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n      arr: A list of numbers.\n\n    Returns:\n      The sum of the largest and smallest numbers in the array.  Returns 0 if the array is empty.\n\n    Raises:\n      TypeError: if input is not a list.\n      ValueError: if input list contains non-numeric values.\n\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list.\")\n    if not arr:\n        return 0\n    if not all(isinstance(x, (int, float)) for x in arr):\n        raise ValueError(\"List must contain only numbers.\")\n\n    min_val = min(arr)\n    max_val = max(arr)\n    return min_val + max_val", "matching_cluster_idx": 1}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest numbers in the array.  Returns 0 for empty arrays.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest numbers in the array.  Returns 0 for empty arrays.\n\n    Raises:\n        TypeError: if input is not a list.\n        ValueError: if input list contains non-numeric values.\n\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list.\")\n    if not all(isinstance(x, (int, float)) for x in arr):\n        raise ValueError(\"List must contain only numbers.\")\n    if not arr:\n        return 0  #Handle empty list case.\n    return max(arr) + min(arr)", "matching_cluster_idx": 1}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Write a python function to find the sum of the largest and smallest value in a given array.\n    assert big_sum([1,2,3]) == 4\n    \"\"\"\n    if not arr:\n        return 0  # Handle empty array case\n    \n    min_val = arr[0]\n    max_val = arr[0]\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Write a python function to find the sum of the largest and smallest value in a given array.\n    assert big_sum([1,2,3]) == 4\n    \"\"\"\n    if not arr:\n        return 0  # Handle empty array case\n\n    min_val = arr[0]\n    max_val = arr[0]\n\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest numbers in the array.  Returns 0 for empty arrays.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest numbers in the array.  Returns 0 for empty arrays.\n    \"\"\"\n    if not arr:\n        return 0\n    else:\n        return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest numbers in the array.  Returns 0 for empty arrays.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest numbers in the array.  Returns 0 for empty arrays.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n      arr: A list of numbers.\n\n    Returns:\n      The sum of the largest and smallest values in the array.  Returns 0 for empty arrays.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n      arr: A list of numbers.\n\n    Returns:\n      The sum of the largest and smallest numbers in the array.  Returns 0 for empty arrays.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest numbers in the array.\n        Returns 0 if the array is empty.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n      arr: A list of numbers.\n\n    Returns:\n      The sum of the largest and smallest numbers in the array.  Returns 0 for empty arrays.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n      arr: A list of numbers.\n\n    Returns:\n      The sum of the largest and smallest numbers in the array.  Returns 0 for an empty array.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n      arr: A list of numbers.\n\n    Returns:\n      The sum of the largest and smallest numbers in the array.  Returns 0 for empty arrays.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n      arr: A list of numbers.\n\n    Returns:\n      The sum of the largest and smallest numbers in the array.  Returns 0 for empty arrays.\n\n    Raises:\n      TypeError: if input is not a list.\n      ValueError: if input list contains non-numeric values.\n\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list.\")\n    if not all(isinstance(x, (int, float)) for x in arr):\n        raise ValueError(\"List must contain only numbers.\")\n    if not arr:\n        return 0  # Handle empty list case\n\n    return max(arr) + min(arr)", "matching_cluster_idx": 1}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts a given string to lowercase.\n\n    Args:\n      input_string: The string to convert.\n\n    Returns:\n      The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n  \"\"\"Converts a given string to lowercase.\n\n  Args:\n    input_string: The string to convert.\n\n  Returns:\n    The lowercase version of the input string.\n  \"\"\"\n  return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n  \"\"\"\n  Converts the given string to lower case.\n\n  Args:\n    input_string: The string to convert.\n\n  Returns:\n    The lower case version of the input string.\n  \"\"\"\n  return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n  \"\"\"Converts a given string to lowercase.\n\n  Args:\n    input_string: The string to convert.\n\n  Returns:\n    The lowercase version of the input string.\n  \"\"\"\n  return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n  \"\"\"Converts a given string to lowercase.\n\n  Args:\n    input_string: The string to convert.\n\n  Returns:\n    The lowercase version of the input string.\n  \"\"\"\n  return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n  \"\"\"Converts a given string to lowercase.\n\n  Args:\n    input_string: The string to convert.\n\n  Returns:\n    The lowercase version of the input string.\n  \"\"\"\n  return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n  \"\"\"\n  Converts the given string to lower case.\n\n  Args:\n    input_string: The string to convert.\n\n  Returns:\n    The lower case version of the string.\n  \"\"\"\n  return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n  \"\"\"Converts a given string to lowercase.\n\n  Args:\n    input_string: The string to convert.\n\n  Returns:\n    The lowercase version of the input string.\n  \"\"\"\n  return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n      input_string: The string to convert.\n\n    Returns:\n      The lower case version of the string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n  \"\"\"\n  Converts the given string to lower case.\n\n  Args:\n    input_string: The string to convert.\n\n  Returns:\n    The lower case version of the input string.\n  \"\"\"\n  return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lower case version of the string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n      input_string: The string to convert.\n\n    Returns:\n      The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lower case version of the string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n  \"\"\"Converts a given string to lowercase.\n\n  Args:\n    input_string: The string to convert.\n\n  Returns:\n    The lowercase version of the input string.\n  \"\"\"\n  return input_string.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 80.3825136612022, "dps_norm": 80.9090909090909, "pass@1": 98.0, "profiled": [{"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string: The input string containing values enclosed in quotation marks.\n\n    Returns:\n        A list of strings, where each string is a value extracted from the input string.\n        Returns an empty list if no values are found.  Handles nested quotes poorly.\n    \"\"\"\n    matches = re.findall(r'\"([^\"]*)\"', input_string)  #Finds all strings inside double quotes\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The input string containing values in double quotes.\n\n    Returns:\n        A list of strings, where each string is a value extracted from \n        the input string.  Returns an empty list if no values are found.\n    \"\"\"\n    \n    values = re.findall(r'\"(.*?)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The input string containing values in double quotes.\n\n    Returns:\n        A list of strings, where each string is a value extracted from \n        the input string.  Returns an empty list if no values are found.\n    \"\"\"\n    \n    #Use regular expression to find all strings enclosed in double quotes.\n    values = re.findall(r'\"([^\"]*)\"', input_string)  \n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The input string containing values in double quotes.\n\n    Returns:\n        A list of strings, where each string is a value extracted from the input string.  Returns an empty list if no values are found.\n    \"\"\"\n    values = re.findall(r'\"(.*?)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The input string containing values in double quotes.\n\n    Returns:\n        A list of strings, where each string is a value extracted from \n        the input string. Returns an empty list if no values are found.\n    \"\"\"\n    \n    # Use regular expression to find all strings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n      input_string: The input string containing values in double quotes.\n\n    Returns:\n      A list of strings, where each string is a value extracted from the input string.  Returns an empty list if no values are found.\n    \"\"\"\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The input string containing quoted values.\n\n    Returns:\n        A list of strings, where each string is a value extracted from \n        the input string.  Returns an empty list if no quoted values are found.\n    \"\"\"\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string: The input string containing values enclosed in quotation marks.\n\n    Returns:\n        A list of strings, where each string is a value extracted from the input string.\n        Returns an empty list if no values are found.  Handles nested quotes poorly.\n    \"\"\"\n    \n    #Using regular expressions for a more robust solution.  This handles spaces within the quotes\n    matches = re.findall(r'\"([^\"]*)\"', input_string) \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string: The input string containing values enclosed in quotation marks.\n\n    Returns:\n        A list of strings, where each string is a value extracted from the input string.  Returns an empty list if no values are found.\n    \"\"\"\n    #Use regular expression to find all strings enclosed in double quotes.\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string: The input string containing values enclosed in quotation marks.\n\n    Returns:\n        A list of strings, where each string is a value extracted from the input string.\n        Returns an empty list if no values are found.  Handles nested quotes gracefully.\n    \"\"\"\n    matches = re.findall(r'\"([^\"]*)\"', input_string)  #Finds all strings within double quotes\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The input string containing values in double quotes.\n\n    Returns:\n        A list of strings, where each string is a value extracted from the input string.\n        Returns an empty list if no values are found.  Handles escaped quotes.\n    \"\"\"\n    # Use a regular expression to find all strings enclosed in double quotes, handling escaped quotes\n    matches = re.findall(r'\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"', input_string)\n    return matches", "matching_cluster_idx": 7}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n      input_string: The input string containing values in double quotes.\n\n    Returns:\n      A list of strings, where each string is a value extracted from \n      the input string.  Returns an empty list if no values are found.\n    \"\"\"\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string: The input string containing values enclosed in quotation marks.\n\n    Returns:\n        A list of strings, where each string is a value extracted from the input string.  Returns an empty list if no values are found.\n    \"\"\"\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The input string containing values in double quotes.\n\n    Returns:\n        A list of strings, where each string is a value extracted from the input string.\n        Returns an empty list if no values are found.  Handles cases with escaped quotes.\n    \"\"\"\n    \n    #Use a regular expression to find all strings enclosed in double quotes, handling escaped quotes\n    matches = re.findall(r'\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"', input_string)\n    return matches", "matching_cluster_idx": 7}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The input string containing values in double quotes.\n\n    Returns:\n        A list of strings, where each string is a value extracted from the input string.\n        Returns an empty list if no values are found.\n    \"\"\"\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The input string containing quoted values.\n\n    Returns:\n        A list of strings, where each string is a value extracted from \n        the input string.  Returns an empty list if no quoted values are found.\n    \"\"\"\n    \n    # Use regular expression to find all strings enclosed in double quotes.\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The input string containing values in double quotes.\n\n    Returns:\n        A list of strings, where each string is a value extracted from the input string.  Returns an empty list if no values are found.\n    \"\"\"\n    \n    # Use regular expression to find all strings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string: The input string containing values enclosed in quotation marks.\n\n    Returns:\n        A list of strings, where each string is a value extracted from the input string.  Returns an empty list if no values are found.\n    \"\"\"\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches\ninput_string = '\"Python\", \"PHP\", \"Java\"'", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The input string containing values in double quotes.\n\n    Returns:\n        A list of strings, where each string is a value extracted from the input string.  Returns an empty list if no values are found.\n    \"\"\"\n    #Use regular expression to find all strings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string: The input string containing values enclosed in quotation marks.\n\n    Returns:\n        A list of strings, where each string is a value extracted from the input string.  Returns an empty list if no values are found.\n    \"\"\"\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 57.345679012345684, "dps_norm": 76.42857142857143, "pass@1": 39.0, "profiled": [{"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    \n    #The problem description is ambiguous.  It says \"remove duplicate numbers\" but the assertion only seems to keep numbers that appear only once.\n    #This section addresses the ambiguity by only keeping numbers that appear once.\n\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    \n    final_result = [num for num in result if counts[num] == 1]\n\n    return final_result", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    \n    # This part addresses the specific assertion.  The original problem statement was ambiguous.\n    # This ensures only numbers that appear only once in the original list are kept.\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    \n    final_result = []\n    for num in result:\n        if counts[num] == 1:\n            final_result.append(num)\n            \n    return final_result", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    \n    #The problem statement is slightly ambiguous.  This version keeps only numbers appearing only once.\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num,0) + 1\n\n    final_result = [num for num in result if counts[num] == 1]\n\n    return final_result", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from a list, keeping only numbers that appear exactly once.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      A new list containing only the numbers that appeared exactly once in the input list.  \n      The order of elements is preserved from the original list.\n    \"\"\"\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    unique_nums = []\n    for num in nums:\n        if counts[num] == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from a given list, leaving only numbers that appear exactly once.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A list containing only the numbers that appeared exactly once in the input list.  \n        Returns an empty list if the input is invalid.\n    \"\"\"\n    if not isinstance(nums, list):\n        return []  # Handle invalid input\n\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    unique_nums = [num for num, count in counts.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    \n    #The problem description implies we should only keep numbers appearing exactly twice.  The assert is wrong.  This section addresses that implied requirement.  The docstring is incorrect.\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    final_result = []\n    for num, count in counts.items():\n        if count == 1:\n            final_result.append(num)\n    return final_result", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    \n    #The problem statement is ambiguous.  Should it only return unique numbers\n    #that appear once, or should it return unique numbers regardless of frequency?\n    #The assertion implies the former. This section implements that.\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num,0) + 1\n    \n    final_result = []\n    for num in result:\n        if counts[num] == 1:\n            final_result.append(num)\n    return final_result", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    \n    #To get only the numbers that appear exactly once.  The original prompt was ambiguous\n    counts = {}\n    for x in nums:\n        counts[x] = counts.get(x,0) + 1\n    \n    final_result = [x for x in result if counts[x] == 1]\n\n\n    return final_result", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    \"\"\"\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    unique_nums = []\n    for num, count in counts.items():\n        if count == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    \n    #This part addresses the specific assertion example, implying only numbers appearing twice or more should be removed.\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    \n    final_result = []\n    for num in result:\n        if counts[num] == 1:\n            final_result.append(num)\n            \n    return final_result", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    \n    #The problem statement is unclear.  It states removing duplicates but the assert shows only unique numbers appearing only once.\n    #This section handles the case where it's actually intended to remove elements appearing more than once.\n\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num,0) +1\n\n    final_result = []\n    for num in result:\n        if counts[num] == 1:\n            final_result.append(num)\n\n    return final_result", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from a list, keeping only numbers that appear exactly once.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      A new list containing only the numbers that appeared exactly once in the input list.  The order is preserved from the original list.\n    \"\"\"\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    unique_nums = []\n    for num in nums:\n        if counts[num] == 1:\n            unique_nums.append(num)\n\n    return unique_nums", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from a given list, keeping only numbers that appear exactly once.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      A new list containing only the numbers that appeared exactly once in the input list.  The order is preserved from the original list.\n    \"\"\"\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    unique_nums = []\n    for num in nums:\n        if counts[num] == 1:\n            unique_nums.append(num)\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    \n    #This part addresses the assertion example.  The prompt was slightly unclear\n    # about whether to return only numbers appearing twice, or removing duplicates\n    # entirely.  This next section finds numbers that appear only once.\n\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    final_result = []\n    for num in result:\n        if counts[num] == 1:\n            final_result.append(num)\n\n    return final_result", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    \"\"\"\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    unique_nums = []\n    for num, count in counts.items():\n        if count == 1:\n            unique_nums.append(num)\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    \n    #This section handles the assertion failure scenario described in the comments.\n    #The problem statement is ambiguous.  This section assumes the intent is to \n    #return only numbers that appear exactly once in the input list.\n\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    final_result = []\n    for num in result:\n        if counts[num] == 1:\n            final_result.append(num)\n\n    return final_result", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from a given list, returning only numbers that appear exactly once.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      A list containing only the numbers that appeared exactly once in the input list.  The order is preserved from the original list.\n    \"\"\"\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    \n    result = []\n    for num in nums:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from a given list, returning only numbers that appear exactly once.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      A list containing only the numbers that appeared exactly once in the input list.  The order is preserved from the original list.\n    \"\"\"\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    unique_nums = []\n    for num in nums:\n        if counts[num] == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from a list, preserving order.  Returns a list containing only numbers that appear exactly once in the input.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A list of numbers that appear only once in the input list, maintaining their original order.\n\n    \"\"\"\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    unique_nums = []\n    for num in nums:\n        if counts[num] == 1:\n            unique_nums.append(num)\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    \"\"\"\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    result = []\n    for num, count in counts.items():\n        if count == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 58.41269841269841, "dps_norm": 63.63636363636363, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n    \"\"\"\n    if not list1 or not list2 or not list3 or len(list1) != len(list2) or len(list1) != len(list3):\n        return []\n    \n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n    Returns:\n      A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n    \"\"\"\n    if not list1 or not list2 or not list3 or len(list1) != len(list2) or len(list1) != len(list3):\n        return []\n    \n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n    Returns:\n      A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n      ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length\")\n    \n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Lists must be of the same length\")\n    \n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Lists must be of the same length\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n    Returns:\n      A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n      ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n        ValueError: if input lists are not of the same length.\n\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Lists must be of the same length\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements of the input lists.\n        Returns an empty list if any input list is empty or they are not of the same length.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3 or len(list1) != len(list2) or len(list1) != len(list3):\n        return []\n    \n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n    Returns:\n      A new list containing the interleaved elements of the input lists.\n      Returns an empty list if any input list is empty or of different length.\n\n    Raises:\n      ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3 or len(list1) != len(list2) or len(list1) != len(list3):\n        return []\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n    Returns:\n      A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n      ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements, or None if the lists are not of equal length.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        return None  # Handle unequal length lists\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length.\")\n    \n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements of the input lists.\n        Returns an empty list if any input list is empty or they are not of the same length.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n        ValueError: if input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.  Returns an empty list if input lists are empty or of different lengths.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not list1 or not list2 or not list3:\n        return []\n\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n      arr: The input list.\n      n: The index at which to split the list (0-indexed).\n\n    Returns:\n      A new list with the first n elements moved to the end.  Returns the original list if n is invalid.\n    \"\"\"\n    if not isinstance(arr, list) or n < 0 or n >= len(arr):\n        return arr  # Handle invalid input\n\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n      arr: The input list.\n      n: The index at which to split the list (0-based).\n\n    Returns:\n      A new list with the first part added to the end.  Returns the original list if n is out of bounds.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle cases where n is out of bounds\n    \n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n      arr: The input list.\n      n: The index at which to split the list (0-indexed).\n\n    Returns:\n      A new list with the first part moved to the end.  Returns the original list if n is invalid.\n\n    \"\"\"\n    if not isinstance(arr, list) or n < 0 or n >= len(arr):\n        return arr #Handle invalid input\n\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list (0-indexed).\n\n    Returns:\n        A new list with the first part added to the end.  Returns the original list if n is out of bounds.\n\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr\n    \n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n      arr: The input list.\n      n: The index at which to split the list (0-indexed).\n\n    Returns:\n      A new list with the first part appended to the end.  Returns the original list if n is out of bounds.\n\n    \"\"\"\n    if n >= len(arr) or n < 0:\n        return arr\n    \n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n      arr: The input list.\n      n: The index at which to split the list (0-indexed).\n\n    Returns:\n      A new list with the first part moved to the end.  Returns the original list if n is invalid.\n    \"\"\"\n    if not isinstance(arr, list) or n < 0 or n >= len(arr):\n        return arr  # Handle invalid input\n\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list (0-based).\n\n    Returns:\n        A new list with the first part added to the end.  Returns the original list if n is out of bounds.\n\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  #Handle out of bounds cases\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n      arr: The input list.\n      n: The index at which to split the list (0-based).\n\n    Returns:\n      A new list with the first n elements moved to the end.  Returns the original list if n is invalid.\n    \"\"\"\n    if not isinstance(arr, list) or n < 0 or n >= len(arr):\n        return arr  # Handle invalid input\n\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n      arr: The input list.\n      n: The index at which to split the list (0-indexed).\n\n    Returns:\n      A new list with the first part moved to the end.  Returns the original list if n is out of bounds.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle out-of-bounds index\n    \n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list (0-indexed).\n\n    Returns:\n        A new list with the first part added to the end.  Returns the original list if n is out of bounds.\n\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle out-of-bounds index\n\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list (0-indexed).\n\n    Returns:\n        A new list with the first part appended to the end.  Returns the original list if n is out of bounds.\n\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle out-of-bounds index\n    \n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list (0-indexed).\n\n    Returns:\n        A new list with the first part moved to the end.  Returns the original list if n is out of bounds.\n\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle out-of-bounds index\n    \n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list (0-indexed).\n\n    Returns:\n        A new list with the first part added to the end.  Returns the original list if n is out of bounds.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle out-of-bounds index\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n      arr: The input list.\n      n: The index at which to split the list (0-indexed).\n\n    Returns:\n      A new list with the first part moved to the end.  Returns the original list if n is out of bounds.\n    \"\"\"\n    if not 0 <= n < len(arr):\n        return arr  # Handle out-of-bounds index\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n      arr: The input list.\n      n: The index at which to split the list (0-indexed).\n\n    Returns:\n      A new list with the first n elements moved to the end.  Returns the original list if n is out of bounds.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  #Handle cases where n is out of bounds.\n    \n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list (0-indexed).\n\n    Returns:\n        A new list with the first part moved to the end.  Returns the original list if n is invalid.\n    \"\"\"\n    if not isinstance(arr, list) or not isinstance(n, int) or n < 0 or n >= len(arr):\n        return arr  # Handle invalid input\n\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n      arr: The input list.\n      n: The index at which to split the list (0-indexed).\n\n    Returns:\n      A new list with the first part appended to the end.  Returns the original list if n is out of bounds.\n\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle cases where n is out of bounds\n\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list (0-indexed).\n\n    Returns:\n        A new list with the first n elements moved to the end.  Returns the original list if n is invalid.\n    \"\"\"\n    if not isinstance(arr, list) or n < 0 or n >= len(arr):\n        return arr  # Handle invalid input\n\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list (0-indexed).\n\n    Returns:\n        A new list with the first part added to the end.  Returns the original list if n is out of bounds.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle out-of-bounds index\n    \n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list (0-indexed).\n\n    Returns:\n        A new list with the first part appended to the end.  Returns the original list if n is invalid.\n\n    \"\"\"\n    if not isinstance(arr, list) or n < 0 or n >= len(arr):\n        return arr  # Handle invalid input\n\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(list_in):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n      list_in: The input list.\n\n    Returns:\n      A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list_in)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        input_list: The input list.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list1):\n    \"\"\"\n    Write a function to convert a list to a tuple.\n    assert list_tuple([5, 10, 7, 4, 15, 3])==(5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(list1)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_in):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n      list_in: The input list.\n\n    Returns:\n      A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list_in)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_input):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n      list_input: The input list.\n\n    Returns:\n      A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list_input)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n      input_list: A list of any data type.\n\n    Returns:\n      A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        input_list: The input list.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_in):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n      list_in: The input list.\n\n    Returns:\n      A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list_in)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_in):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list_in: The input list.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list_in)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list1):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list1: The input list.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list1)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_input):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n      list_input: The input list.\n\n    Returns:\n      A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list_input)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_in):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list_in: The input list.\n\n    Returns:\n        A tuple containing the same elements as the input list.  Returns an empty tuple if the input is not a list.\n    \"\"\"\n    if isinstance(list_in, list):\n        return tuple(list_in)\n    else:\n        return ()", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_):\n    \"\"\"\n    Write a function to convert a list to a tuple.\n    assert list_tuple([5, 10, 7, 4, 15, 3])==(5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(list_)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_in):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list_in: The input list.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list_in)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_in):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list_in: The input list.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list_in)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_input):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list_input: The input list.\n\n    Returns:\n        A tuple containing the elements of the input list.\n    \"\"\"\n    return tuple(list_input)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_in):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list_in: The input list.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list_in)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_input):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n      list_input: The input list.\n\n    Returns:\n      A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list_input)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_in):\n    \"\"\"\n    Write a function to convert a list to a tuple.\n    assert list_tuple([5, 10, 7, 4, 15, 3])==(5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(list_in)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list_input):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list_input: The input list.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list_input)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 95.9862385321101, "dps_norm": 97.5, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(nums):\n    \"\"\"\n    Write a python function to find the difference between largest and smallest value in a given list.\n    assert big_diff([1,2,3,4]) == 3\n    \"\"\"\n    if not nums:\n        return 0  # Handle empty list case\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.\n      Returns 0 if the list is empty or contains only one element.  \n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.\n      Returns 0 if the list is empty or contains only one element.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.\n      Returns 0 if the list is empty or contains only one element.  \n    \"\"\"\n    if not nums:\n        return 0\n    \n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a given list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.  Returns 0 if the list is empty or contains only one element.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.  Returns 0 if the list is empty or contains only one element.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.  Returns 0 if the list is empty or contains only one element.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.  Returns 0 if the list is empty or contains only one element.\n\n    Raises:\n      TypeError: if input is not a list.\n      ValueError: if the list contains non-numeric values.\n\n    \"\"\"\n    if not isinstance(nums, list):\n        raise TypeError(\"Input must be a list.\")\n    if not nums:\n        return 0\n    if not all(isinstance(num, (int, float)) for num in nums):\n        raise ValueError(\"List must contain only numbers.\")\n\n    return max(nums) - min(nums)", "matching_cluster_idx": 2}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.\n      Returns 0 if the list is empty or contains only one element.  \n    \"\"\"\n    if not nums:\n        return 0\n    \n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.\n      Returns 0 if the list is empty or contains only one element.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.\n      Returns 0 if the list is empty or contains only one element.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.\n      Returns 0 if the list is empty or contains only one element.  \n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Write a python function to find the difference between largest and smallest value in a given list.\n    assert big_diff([1,2,3,4]) == 3\n    \"\"\"\n    if not nums:\n        return 0  # Handle empty list case\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a given list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.\n      Returns 0 if the list is empty or contains only one element.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest numbers in the list.\n        Returns 0 if the list is empty.  \n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.\n      Returns 0 if the list is empty or contains only one element.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest numbers in the list.  Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Write a python function to find the difference between largest and smallest value in a given list.\n    assert big_diff([1,2,3,4]) == 3\n    \"\"\"\n    if not nums:\n        return 0  # Handle empty list case\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Write a python function to find the difference between largest and smallest value in a given list.\n    assert big_diff([1,2,3,4]) == 3\n    \"\"\"\n    if not nums:\n        return 0  # Handle empty list case\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 56.466666666666676, "dps_norm": 51.5, "pass@1": 76.0, "profiled": [{"solution": "import math\ndef combinations(n, k):\n    \"\"\"Calculates binomial coefficient C(n, k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    if k > n // 2:\n        k = n - k\n    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients:\n    \u03a3_{i=0}^{n-1} C(n, i) * C(n, i+1)\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += combinations(n, i) * combinations(n, i + 1)\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "import math\ndef combinations(n, k):\n    \"\"\"\n    Calculates the binomial coefficient C(n, k) using the formula n! / (k! * (n-k)!)\n    \"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    if k > n // 2:\n        k = n - k\n    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n\n    Args:\n      n: An integer representing the upper limit of the binomial coefficients.\n\n    Returns:\n      An integer representing the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += combinations(n, i) * combinations(n, i + 1)\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "import math\ndef ncr(n, r):\n    \"\"\"Calculates binomial coefficient nCr.\"\"\"\n    if r > n or r < 0:\n        return 0\n    return math.comb(n, r)\ndef sum_Of_product(n):\n    \"\"\"Calculates the sum of the product of consecutive binomial coefficients.\"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += ncr(n, i) * ncr(n, i + 1)\n    return total_sum\nn = 3", "matching_cluster_idx": 5}, {"solution": "def nCr(n, r):\n    \"\"\"\n    Calculates the binomial coefficient nCr.\n    \"\"\"\n    if r > n:\n        return 0\n    if r * 2 > n:\n        r = n - r\n    res = 1\n    for i in range(r):\n        res = res * (n - i)\n        res = res // (i + 1)\n    return res\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n\n    Args:\n      n: The upper limit for the binomial coefficients (nCr where r goes from 0 to n).\n\n    Returns:\n      The sum of the products of consecutive binomial coefficients.  Returns 0 if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    total_sum = 0\n    for i in range(n):\n        total_sum += nCr(n, i) * nCr(n, i + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def combinations(n, k):\n    \"\"\"Calculates binomial coefficient nCk using the formula n!/(k!(n-k)!)\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    if k > n // 2:\n        k = n - k\n    res = 1\n    for i in range(k):\n        res = res * (n - i) // (i + 1)\n    return res\ndef sum_Of_product(n):\n    \"\"\"Calculates the sum of the product of consecutive binomial coefficients.\"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += combinations(n, i) * combinations(n, i + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def nCr(n, r):\n    \"\"\"\n    Calculates the binomial coefficient nCr using the formula n! / (r! * (n-r)!)\n    \"\"\"\n    if r > n:\n        return 0\n    if r * 2 > n:\n        r = n - r\n    res = 1\n    for i in range(r):\n        res = res * (n - i)\n        res = res // (i + 1)\n    return res\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients:\n    \u03a3 (nCr * nC(r+1)) for r = 0 to n-1.\n    \"\"\"\n    total_sum = 0\n    for r in range(n):\n        total_sum += nCr(n, r) * nCr(n, r + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef nCr(n, r):\n    \"\"\"\n    Calculates the binomial coefficient nCr.\n    \"\"\"\n    if r > n:\n        return 0\n    return math.comb(n, r)\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += nCr(n, i) * nCr(n, i + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def nCr(n, r):\n    \"\"\"\n    Calculates the binomial coefficient nCr.\n    \"\"\"\n    if r > n:\n        return 0\n    if r * 2 > n:\n        r = n - r\n    res = 1\n    for i in range(r):\n        res = res * (n - i)\n        res = res // (i + 1)\n    return res\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += nCr(n, i) * nCr(n, i + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def ncr(n, r):\n    \"\"\"Calculates nCr (n choose r) using the formula n! / (r! * (n-r)!).\"\"\"\n    if r > n or r < 0:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    if r > n // 2:\n        r = n - r\n    res = 1\n    for i in range(r):\n        res = res * (n - i) // (i + 1)\n    return res\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients:\n    \u03a3 (nCr * nC(r+1)) for r = 0 to n-1.\n    \"\"\"\n    total_sum = 0\n    for r in range(n):\n        total_sum += ncr(n, r) * ncr(n, r + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef combinations(n, k):\n    \"\"\"\n    Calculates the binomial coefficient C(n, k).\n    \"\"\"\n    if k < 0 or k > n:\n        return 0\n    return math.comb(n, k)\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += combinations(n, i) * combinations(n, i + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def nCr(n, r):\n    \"\"\"\n    Calculates the binomial coefficient nCr.\n    \"\"\"\n    if r > n:\n        return 0\n    if r * 2 > n:\n        r = n - r\n    if r == 0:\n        return 1\n    if r == 1:\n        return n\n    \n    res = 1\n    for i in range(r):\n        res = res * (n - i)\n        res = res // (i + 1)\n    return res\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += nCr(n, i) * nCr(n, i + 1)\n    return total_sum\nn = 5", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n\n    Args:\n      n: An integer representing the upper limit of the binomial coefficients.\n\n    Returns:\n      The sum of the products of consecutive binomial coefficients from 0 to n-1.  Returns 0 if n is less than 1.\n\n    \"\"\"\n    if n < 1:\n        return 0\n    total_sum = 0\n    for i in range(n):\n        total_sum += comb(n, i) * comb(n, i + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef combinations(n, k):\n    \"\"\"Calculates binomial coefficient C(n, k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    return math.comb(n,k)\ndef sum_Of_product(n):\n  \"\"\"\n  Calculates the sum of the product of consecutive binomial coefficients:\n  \u03a3_{k=0}^{n-1} C(n,k) * C(n,k+1) for n >=1\n\n  Args:\n      n: An integer representing the upper limit of the summation.\n\n  Returns:\n      The sum of the products of consecutive binomial coefficients.  Returns 0 if n<1.\n  \"\"\"\n  if n < 1:\n    return 0\n  total_sum = 0\n  for k in range(n):\n    total_sum += combinations(n, k) * combinations(n, k + 1)\n  return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef nCr(n, r):\n    \"\"\"\n    Calculates the binomial coefficient nCr.\n    \"\"\"\n    if r > n:\n        return 0\n    return math.comb(n, r)\ndef sum_Of_product(n):\n    \"\"\"\n    Finds the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += nCr(n, i) * nCr(n, i + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def ncr(n, r):\n    \"\"\"Calculates the binomial coefficient nCr.\"\"\"\n    if r > n or r < 0:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    if r > n // 2:\n        r = n - r\n    result = 1\n    for i in range(r):\n        result = result * (n - i) // (i + 1)\n    return result\ndef sum_Of_product(n):\n    \"\"\"Calculates the sum of the product of consecutive binomial coefficients.\"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += ncr(n, i) * ncr(n, i + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculates the binomial coefficient (n choose k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    if k > n // 2:\n        k = n - k  # Optimization: nCk = nC(n-k)\n    res = 1\n    for i in range(k):\n        res = res * (n - i) // (i + 1)\n    return res\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients:\n    \u03a3_{k=0}^{n-1} (n choose k) * (n choose k+1)\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef combinations(n, k):\n    \"\"\"Calculates binomial coefficient C(n, k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    if k > n // 2:\n        k = n - k\n    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients:\n    \u03a3_{k=0}^{n-1} C(n, k) * C(n, k+1)\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += combinations(n, k) * combinations(n, k + 1)\n    return total_sum\nn = 5", "matching_cluster_idx": 2}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n\n    Args:\n        n: An integer representing the upper limit for the binomial coefficients.\n\n    Returns:\n        The sum of the product of consecutive binomial coefficients from 0 to n-1.  Returns 0 if n is less than 1.\n\n    Raises:\n        TypeError: if input is not an integer.\n        ValueError: if input is negative.\n\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be non-negative.\")\n    if n < 1:\n        return 0\n\n    total_sum = 0\n    for i in range(n):\n        total_sum += comb(n, i) * comb(n, i + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef combinations(n, k):\n    \"\"\"Calculates the binomial coefficient C(n, k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    return math.comb(n, k)\ndef sum_Of_product(n):\n    \"\"\"Calculates the sum of the product of consecutive binomial coefficients.\"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += combinations(n, i) * combinations(n, i + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef combinations(n, k):\n    \"\"\"Calculates binomial coefficient C(n, k)\"\"\"\n    if k < 0 or k > n:\n        return 0\n    return math.comb(n, k)\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients:\n    \u03a3_{k=0}^{n-1} C(n, k) * C(n, k+1)\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += combinations(n, k) * combinations(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}]}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n      input_string: The input string containing words separated by spaces.\n\n    Returns:\n      A string with the words reversed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    words = input_string.split()\n    reversed_words = words[::-1]  # Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      A string with the words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]  # Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string, separated by spaces.\n\n    Args:\n        input_string: The input string containing words separated by spaces.\n\n    Returns:\n        A string with the words reversed.  Returns an empty string if the input is empty or None.\n\n    \"\"\"\n    if not input_string:\n        return \"\"\n    words = input_string.split()\n    reversed_words = words[::-1]  #Efficient way to reverse a list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n      input_string: The input string containing words separated by spaces.\n\n    Returns:\n      A string with the words reversed.  Returns an empty string if the input is None or empty.\n\n    \"\"\"\n    if not input_string:\n        return \"\"\n    words = input_string.split()\n    reversed_words = words[::-1]  #Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Write a function to reverse words seperated by spaces in a given string.\n    assert reverse_words(\"python program\")==(\"program python\")\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]  #Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"Reverses the order of words in a string.\n\n    Args:\n        input_string: The input string containing words separated by spaces.\n\n    Returns:\n        A string with the words reversed.  Returns an empty string if the input is empty or None.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    words = input_string.split()\n    reversed_words = words[::-1]  # Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n      input_string: The input string containing words separated by spaces.\n\n    Returns:\n      A string with the words reversed.  Returns an empty string if the input is empty or None.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    words = input_string.split()\n    reversed_words = words[::-1]  #Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      A string with the words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]  # Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a string.\n\n    Args:\n        s: The input string containing words separated by spaces.\n\n    Returns:\n        A string with the words reversed.  Returns an empty string if the input is empty or None.\n\n    \"\"\"\n    if not s:\n        return \"\"\n    words = s.split()\n    reversed_words = words[::-1]  #Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n        input_string: The input string containing words separated by spaces.\n\n    Returns:\n        A string with the words reversed.  Returns an empty string if the input is empty or None.\n\n    \"\"\"\n    if not input_string:\n        return \"\"\n    words = input_string.split()\n    reversed_words = words[::-1] # Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n      input_string: The input string containing words separated by spaces.\n\n    Returns:\n      A string with the words reversed.  Returns an empty string if the input is empty or None.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    words = input_string.split()\n    reversed_words = words[::-1]  #Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"Reverses the order of words in a string.\n\n    Args:\n        input_string: The input string containing words separated by spaces.\n\n    Returns:\n        A string with the words reversed.  Returns an empty string if the input is empty or None.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    words = input_string.split()\n    reversed_words = words[::-1]  #Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with words reversed.  Returns an empty string if input is empty or None.\n    \"\"\"\n    if not s:\n        return \"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string, separated by spaces.\n\n    Args:\n        input_string: The input string containing words separated by spaces.\n\n    Returns:\n        A string with the words reversed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    words = input_string.split()\n    reversed_words = words[::-1]  # Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n      input_string: The input string containing words separated by spaces.\n\n    Returns:\n      A string with the words reversed.  Returns an empty string if the input is empty or None.\n\n    \"\"\"\n    if not input_string:\n        return \"\"\n    words = input_string.split()\n    reversed_words = words[::-1]  #Efficient way to reverse a list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      A string with the words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]  #Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n      input_string: The input string containing words separated by spaces.\n\n    Returns:\n      A string with the words reversed.  Returns an empty string if the input is empty or None.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    words = input_string.split()\n    reversed_words = words[::-1]  #Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n      input_string: The input string containing words separated by spaces.\n\n    Returns:\n      A string with the words reversed.  Returns an empty string if the input is empty or None.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    words = input_string.split()\n    reversed_words = words[::-1]  #Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The string with words reversed.  Returns an empty string if the input is None or empty.\n    \"\"\"\n    if not s:\n        return \"\"\n    words = s.split()\n    reversed_words = words[::-1]  # Efficient way to reverse a list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Args:\n      input_string: The input string containing words separated by spaces.\n\n    Returns:\n      A string with the words reversed.  Returns an empty string if the input is empty or None.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    words = input_string.split()\n    reversed_words = words[::-1]  #Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 58.69565217391305, "dps_norm": 57.142857142857146, "pass@1": 62.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    \"\"\"Removes the k-th element from a list (1-based index).\n\n    Args:\n        lst: The input list.\n        k: The index of the element to remove (1-based).\n\n    Returns:\n        A new list with the k-th element removed.  Returns the original list if k is invalid.\n    \"\"\"\n    if not 1 <= k <= len(lst):\n        return lst  # Handle invalid k\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from a list (k is 1-indexed).\n\n    Args:\n        input_list: The input list.\n        k: The index of the element to remove (1-indexed).\n\n    Returns:\n        A new list with the k'th element removed.  Returns the original list if k is invalid.\n    \"\"\"\n    if not 1 <= k <= len(input_list):\n        return input_list  # Handle invalid k\n\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from a list (1-indexed).\n\n    Args:\n        input_list: The input list.\n        k: The index of the element to remove (1-indexed).\n\n    Returns:\n        A new list with the k'th element removed.  Returns the original list if k is invalid.\n    \"\"\"\n    if not isinstance(input_list, list) or not isinstance(k, int) or k <= 0 or k > len(input_list):\n        return input_list  # Handle invalid input\n\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k-th element from a list (1-based index).\n\n    Args:\n      input_list: The input list.\n      k: The index of the element to remove (1-based index).\n\n    Returns:\n      A new list with the k-th element removed.  Returns the original list if k is invalid.\n\n    \"\"\"\n    if not isinstance(input_list, list) or k <= 0 or k > len(input_list):\n        return input_list  # Handle invalid input\n\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k-th element from a list (1-indexed).\n\n    Args:\n      input_list: The input list.\n      k: The index of the element to remove (1-based index).\n\n    Returns:\n      A new list with the k-th element removed.  Returns the original list if k is out of bounds.\n    \"\"\"\n    if not 1 <= k <= len(input_list):\n        return input_list  # Handle out-of-bounds k\n    return input_list[:k-1] + input_list[k:]\nk = 3", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(list_in, k):\n    \"\"\"\n    Removes the k'th element from a list (using 1-based indexing).\n\n    Args:\n      list_in: The input list.\n      k: The index of the element to remove (1-based).\n\n    Returns:\n      A new list with the k'th element removed.  Returns the original list if k is invalid.\n    \"\"\"\n    try:\n        return list_in[:k-1] + list_in[k:]\n    except IndexError:\n        return list_in", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"Removes the k-th element from a list (1-indexed).\n\n    Args:\n      input_list: The input list.\n      k: The index of the element to remove (1-indexed).\n\n    Returns:\n      A new list with the k-th element removed.  Returns the original list if k is invalid.\n\n    \"\"\"\n    if not 1 <= k <= len(input_list):\n        return input_list  # Handle invalid k\n\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from a list (1-indexed).\n\n    Args:\n      input_list: The input list.\n      k: The index of the element to remove (1-indexed).\n\n    Returns:\n      A new list with the k'th element removed.  Returns the original list if k is out of bounds.\n\n    \"\"\"\n    if not 1 <= k <= len(input_list):\n        return input_list  #Handle out-of-bounds k\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(data, k):\n    \"\"\"Removes the k-th element from a list.\n\n    Args:\n        data: The input list.\n        k: The index of the element to remove (0-indexed).\n\n    Returns:\n        A new list with the k-th element removed.  Returns the original list if k is out of bounds.\n    \"\"\"\n    try:\n        return data[:k-1] + data[k:]  #Efficiently creates a new list without the k-th element.\n    except IndexError:\n        return data", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from a list (1-indexed).\n\n    Args:\n      lst: The input list.\n      k: The index of the element to remove (1-based index).\n\n    Returns:\n      A new list with the k-th element removed.  Returns the original list if k is out of bounds.\n    \"\"\"\n    if not 1 <= k <= len(lst):\n        return lst  # Handle out-of-bounds k\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"Removes the k-th element from a list (1-indexed).\n\n    Args:\n        input_list: The input list.\n        k: The index of the element to remove (1-based index).\n\n    Returns:\n        A new list with the k-th element removed.  Returns the original list if k is out of bounds.\n    \"\"\"\n    if not 1 <= k <= len(input_list):\n        return input_list  #Handle out of bounds k\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k-th element from a list (1-based indexing).\n\n    Args:\n        input_list: The input list.\n        k: The index of the element to remove (1-based).\n\n    Returns:\n        A new list with the k-th element removed.  Returns the original list if k is invalid.\n    \"\"\"\n    if not isinstance(input_list, list) or not isinstance(k, int) or k <= 0 or k > len(input_list):\n        return input_list  # Handle invalid input\n\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k-th element from a list (1-based index).\n\n    Args:\n        input_list: The input list.\n        k: The index of the element to remove (1-based).\n\n    Returns:\n        A new list with the k-th element removed.  Returns the original list if k is invalid.\n    \"\"\"\n    try:\n        #Adjust k to be 0-based index\n        k -=1\n        if k < 0 or k >= len(input_list):\n            return input_list  # Handle out-of-bounds index\n        return input_list[:k] + input_list[k+1:]\n    except TypeError:\n        return input_list #Handle cases where k is not an integer", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k-th element from a list (1-indexed).\n\n    Args:\n        input_list: The input list.\n        k: The index of the element to remove (1-indexed).\n\n    Returns:\n        A new list with the k-th element removed.  Returns the original list if k is invalid.\n    \"\"\"\n    if not isinstance(input_list, list) or not isinstance(k, int) or k <= 0 or k > len(input_list):\n      return input_list\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k-th element from a list (1-indexed).\n\n    Args:\n        input_list: The input list.\n        k: The index of the element to remove (1-indexed).\n\n    Returns:\n        A new list with the k-th element removed.  Returns the original list if k is invalid.\n\n    \"\"\"\n    if not 1 <= k <= len(input_list):\n        return input_list  # Handle invalid k\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(list_in, k):\n    \"\"\"Removes the k-th element from a list (1-based index).\n\n    Args:\n        list_in: The input list.\n        k: The index of the element to remove (1-based index).\n\n    Returns:\n        A new list with the k-th element removed.  Returns the original list if k is out of bounds.\n\n    \"\"\"\n    if not 1 <= k <= len(list_in):\n        return list_in  #Handle out-of-bounds index\n    return list_in[:k-1] + list_in[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k-th element from a list (1-based index).\n\n    Args:\n      input_list: The input list.\n      k: The index of the element to remove (1-based index).\n\n    Returns:\n      A new list with the k-th element removed.  Returns the original list if k is out of bounds.\n    \"\"\"\n    if not 1 <= k <= len(input_list):\n        return input_list  # Handle out-of-bounds k\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(list_in, k):\n    \"\"\"\n    Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n    assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    if not isinstance(list_in, list):\n        raise TypeError(\"Input must be a list.\")\n    if not isinstance(k, int) or k <=0 or k > len(list_in):\n        raise ValueError(\"k must be a positive integer less than or equal to the length of the list.\")\n\n    return list_in[:k-1] + list_in[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from a list (using 1-based indexing).\n\n    Args:\n        lst: The input list.\n        k: The index of the element to remove (1-based).\n\n    Returns:\n        A new list with the k'th element removed.  Returns the original list if k is invalid.\n    \"\"\"\n    if not 1 <= k <= len(lst):\n        return lst  # Handle invalid k\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k-th element from a list (using 1-based indexing).\n\n    Args:\n        input_list: The input list.\n        k: The index of the element to remove (1-based indexing).\n\n    Returns:\n        A new list with the k-th element removed.  Returns the original list if k is invalid.\n    \"\"\"\n    if not 1 <= k <= len(input_list):\n        return input_list  #Handle invalid k\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/631": {"dps": 43.74999999999999, "dps_norm": 36.875, "pass@1": 80.0, "profiled": [{"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    result = \"\"\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces whitespaces with underscores and vice versa in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces and underscores replaced.\n    \"\"\"\n    result = \"\"\n    for char in input_string:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice versa in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces and underscores replaced.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces spaces with underscores and vice versa in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == ' ':\n            output_string += '_'\n        elif char == '_':\n            output_string += ' '\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice-versa in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces and underscores replaced.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice versa in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces and underscores replaced.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces spaces with underscores and vice versa in a given string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    result = \"\"\n    for char in input_string:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice versa in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces and underscores replaced.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == ' ':\n            output_string += '_'\n        elif char == '_':\n            output_string += ' '\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with whitespaces and underscores replaced.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == ' ':\n            output_string += '_'\n        elif char == '_':\n            output_string += ' '\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice-versa in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces and underscores replaced.\n    \"\"\"\n    \n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with whitespaces and underscores replaced.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with whitespaces and underscores replaced.\n    \"\"\"\n    result = \"\"\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    result = \"\"\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces whitespaces with underscores and vice versa in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with whitespaces and underscores replaced.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice versa in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces and underscores replaced.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == ' ':\n            output_string += '_'\n        elif char == '_':\n            output_string += ' '\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces spaces with underscores and vice versa in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    result = \"\"\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice versa in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    \n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces spaces with underscores and vice-versa in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces and underscores replaced.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == ' ':\n            output_string += '_'\n        elif char == '_':\n            output_string += ' '\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice versa in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces and underscores replaced.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 1}]}, "Mbpp/632": {"dps": 95.29080675422139, "dps_norm": 99.28571428571429, "pass@1": 100.0, "profiled": [{"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a list while maintaining the order of other elements.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      A new list with all zeroes moved to the end.\n    \"\"\"\n\n    #Efficient Approach: Two Pointers\n    left = 0  # Pointer for non-zero elements\n    right = 0 # Pointer for iterating through the list\n\n    while right < len(nums):\n        if nums[right] != 0:\n            nums[left], nums[right] = nums[right], nums[left] #Swap if non-zero\n            left += 1\n        right += 1\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a given list while maintaining the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero_nums = [num for num in nums if num != 0]\n    zero_count = nums.count(0)\n    return non_zero_nums + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a given list while maintaining the order of other elements.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      A new list with all zeroes moved to the end.\n    \"\"\"\n\n    #Count the number of zeros\n    zero_count = nums.count(0)\n    \n    #Create a new list without zeros\n    non_zero_nums = [num for num in nums if num != 0]\n\n    #Append zeros to the end of the new list\n    non_zero_nums.extend([0] * zero_count)\n\n    return non_zero_nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a list while maintaining the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n    \n    #Efficient solution using two pointers\n    left = 0\n    right = 0\n    while right < len(nums):\n        if nums[right] != 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n        right += 1\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list while maintaining the order of other elements.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      A new list with all zeroes moved to the end.\n    \"\"\"\n\n    #Efficient approach using two pointers\n    left = 0\n    right = 0\n    while right < len(nums):\n        if nums[right] != 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            left +=1\n        right += 1\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a list while preserving the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n    \n    #Efficient approach using two pointers\n    non_zero_index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index] = nums[i]\n            non_zero_index +=1\n    \n    #Fill the remaining elements with zeros.\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n        \n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a list while maintaining the relative order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n    \n    #Efficient approach using two pointers\n    non_zero_index = 0  #Index to track the position for next non-zero element\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index] = nums[i]\n            non_zero_index += 1\n\n    #Fill the remaining elements with zeros\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a given list while maintaining the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n    \n    non_zero_elements = [num for num in nums if num != 0]\n    num_zeroes = nums.count(0)\n    return non_zero_elements + [0] * num_zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a given list while maintaining the relative order of other elements.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero_nums = [num for num in nums if num != 0]\n    zero_count = nums.count(0)\n    return non_zero_nums + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a list while preserving the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n\n    #Efficient approach using two pointers\n    left = 0\n    right = 0\n    while right < len(nums):\n        if nums[right] != 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            left +=1\n        right +=1\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a given list while maintaining the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A list with all zeroes moved to the end, preserving the order of non-zero elements.\n    \"\"\"\n    \n    #Efficient approach using two pointers\n    non_zero_index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index] = nums[i]\n            non_zero_index += 1\n\n    #Fill remaining elements with zeros.\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n        \n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a given list while preserving the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n    \n    non_zero_elements = [num for num in nums if num != 0]\n    zero_count = nums.count(0)\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a given list while maintaining the relative order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n\n    #Efficient approach using two pointers\n    non_zero_index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index] = nums[i]\n            non_zero_index += 1\n    \n    #Fill the remaining elements with zeros\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Write a python function to move all zeroes to the end of the given list.\n    assert move_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]\n    \"\"\"\n    if not nums:\n        return []\n\n    left = 0\n    right = 0\n\n    while right < len(nums):\n        if nums[right] != 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n        right += 1\n    return nums", "matching_cluster_idx": 5}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes in a list to the end of the list while maintaining the relative order of other elements.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      A new list with all zeroes moved to the end.\n    \"\"\"\n    \n    non_zero_elements = []\n    zero_count = 0\n\n    for num in nums:\n        if num != 0:\n            non_zero_elements.append(num)\n        else:\n            zero_count += 1\n\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a list while preserving the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n\n    #Efficient approach using two pointers.\n    left = 0  #Pointer for non-zero elements.\n    right = 0 #Pointer iterating through the list.\n\n    while right < len(nums):\n        if nums[right] != 0:\n            nums[left], nums[right] = nums[right], nums[left] #Swap if non-zero.\n            left += 1 #Increment left pointer.\n        right += 1 #Always increment right pointer.\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes in a list to the end while maintaining the order of other elements.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      A new list with all zeroes moved to the end.\n    \"\"\"\n    \n    non_zero_elements = [num for num in nums if num != 0]\n    num_zeros = nums.count(0)\n    return non_zero_elements + [0] * num_zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a list while maintaining the order of other elements.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      A new list with all zeroes moved to the end.\n    \"\"\"\n    \n    #Efficient approach using two pointers\n    non_zero_index = 0  #Pointer for placing non-zero elements.\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index] = nums[i]\n            non_zero_index +=1\n    \n    #Fill remaining elements with zeros.\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a list while preserving the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n    \n    non_zero_nums = [num for num in nums if num != 0]\n    num_zeroes = nums.count(0)\n    return non_zero_nums + [0] * num_zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a list while maintaining the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n    \n    non_zero_nums = [num for num in nums if num != 0]\n    num_zeros = nums.count(0)\n    return non_zero_nums + [0] * num_zeros", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 94.3089430894309, "dps_norm": 50.0, "pass@1": 53.0, "profiled": [{"solution": "def pair_xor_Sum(nums,n):\n    \"\"\"\n    Write a python function to find the sum of xor of all pairs of numbers in the given list.\n    assert pair_xor_Sum([5,9,7,6],4) == 47\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            sum_xor += nums[i]^nums[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n      nums: A list of integers.\n      n: The length of the list (provided for clarity, though not strictly necessary).\n\n    Returns:\n      The sum of XORs of all pairs of numbers in the list.\n    \"\"\"\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        nums: A list of integers.\n        n: The length of the list (provided for clarity, but not strictly necessary).\n\n    Returns:\n        The sum of XORs of all pairs of numbers in the list.\n    \"\"\"\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        nums: A list of integers.\n        n: The length of the list (redundant, but included for consistency with problem statement).\n\n    Returns:\n        The sum of XORs of all pairs of numbers in the list.\n    \"\"\"\n\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums,n):\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            sum_xor += nums[i]^nums[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XOR values for all pairs of numbers in a list.\n\n    Args:\n        nums: A list of integers.\n        n: The length of the list (provided for clarity; not strictly necessary).\n\n    Returns:\n        The sum of XOR values for all pairs of numbers in the list.\n    \"\"\"\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums,n):\n    \"\"\"\n    Write a python function to find the sum of xor of all pairs of numbers in the given list.\n    assert pair_xor_Sum([5,9,7,6],4) == 47\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            sum_xor += nums[i]^nums[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Finds the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        nums: A list of integers.\n        n: The length of the list (provided for clarity, not strictly necessary).\n\n    Returns:\n        The sum of XORs of all pairs of numbers in the list.  Returns 0 for empty or single-element lists.\n    \"\"\"\n    if not nums or len(nums) < 2:\n        return 0\n\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n      nums: A list of integers.\n      n: The length of the list (provided for clarity, not strictly necessary).\n\n    Returns:\n      The sum of XORs of all pairs of numbers in the list.  Returns 0 for empty or single-element lists.\n\n    \"\"\"\n    if not nums or len(nums) < 2:  #Handle empty or single-element list cases\n        return 0\n\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums,n):\n    \"\"\"\n    This function calculates the sum of XOR of all pairs of numbers in a given list.\n\n    Args:\n      nums: A list of integers.\n      n: The length of the list (provided for clarity, not strictly necessary).\n\n    Returns:\n      The sum of XORs of all pairs of numbers in the list.\n    \"\"\"\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums,n):\n    \"\"\"\n    Write a python function to find the sum of xor of all pairs of numbers in the given list.\n    assert pair_xor_Sum([5,9,7,6],4) == 47\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            sum_xor += nums[i]^nums[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums,n):\n    \"\"\"\n    Write a python function to find the sum of xor of all pairs of numbers in the given list.\n    assert pair_xor_Sum([5,9,7,6],4) == 47\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            sum_xor += nums[i]^nums[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums,n):\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            sum_xor += nums[i]^nums[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n      nums: A list of integers.\n      n: The length of the list (provided for clarity, not strictly necessary).\n\n    Returns:\n      The sum of XORs of all pairs of numbers in the list.  Returns 0 for empty lists.\n    \"\"\"\n    if not nums:\n        return 0\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Finds the sum of XOR of all pairs of numbers in a given list.\n\n    Args:\n      nums: A list of integers.\n      n: The length of the list (provided for clarity, not strictly necessary).\n\n    Returns:\n      The sum of XOR of all pairs of numbers in the list.  Returns 0 for empty lists.\n\n    \"\"\"\n    if not nums:\n        return 0\n\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        nums: A list of integers.\n        n: The length of the list (provided for clarity, though not strictly necessary).\n\n    Returns:\n        The sum of XORs of all pairs of numbers in the list.  Returns 0 for empty list.\n    \"\"\"\n    if not nums:\n        return 0\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums,n):\n    \"\"\"\n    Write a python function to find the sum of xor of all pairs of numbers in the given list.\n    assert pair_xor_Sum([5,9,7,6],4) == 47\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            sum_xor += nums[i]^nums[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        nums: A list of integers.\n        n: The length of the list (provided for clarity, not strictly necessary).\n\n    Returns:\n        The sum of XORs of all pairs of numbers in the list.  Returns 0 for empty or single-element lists.\n    \"\"\"\n    if not nums or len(nums) < 2:\n        return 0\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums,n):\n    \"\"\"\n    Write a python function to find the sum of xor of all pairs of numbers in the given list.\n    assert pair_xor_Sum([5,9,7,6],4) == 47\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            sum_xor += nums[i]^nums[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        nums: A list of integers.\n        n: The length of the list (provided for clarity, but not strictly necessary).\n\n    Returns:\n        The sum of XORs of all pairs of numbers in the list.\n    \"\"\"\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum\nnums = [5, 9, 7, 6]\nn = len(nums)", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 73.43085106382978, "dps_norm": 75.0, "pass@1": 78.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array (list).\n        k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n        A new array with elements up to k reversed.  Returns the original array if k is invalid.\n\n    \"\"\"\n    if not isinstance(arr, list) or k <= 0 or k > len(arr):\n        return arr  # Handle invalid input\n\n    #Efficient reversal using slicing\n    reversed_part = arr[:k][::-1]\n    remaining_part = arr[k:]\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n      arr: The input array.\n      k: The position up to which the array should be reversed (1-based index).\n\n    Returns:\n      A new array with the elements up to position k reversed.  Returns the original array if k is invalid.\n    \"\"\"\n    if not isinstance(arr, list) or k <=0 or k > len(arr):\n        return arr #Handle invalid input\n\n    #Efficiently reverse the first k elements using slicing\n    reversed_part = arr[:k][::-1]  \n    \n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n\n    Args:\n      arr: The input array (list).\n      k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n      A new array with elements up to position k reversed.  Returns the original array if k is invalid.\n\n    \"\"\"\n    if not isinstance(arr, list) or k <= 0 or k > len(arr):\n        return arr  # Handle invalid input\n\n    reversed_part = arr[:k][::-1]  # Reverse the first k elements\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n\n    Args:\n      arr: The input array (list).\n      k: The position up to which the array should be reversed (1-indexed).\n\n    Returns:\n      A new array with elements up to position k reversed.  Returns the original array if k is out of bounds.\n\n    \"\"\"\n    if not isinstance(arr, list) or k <= 0 or k > len(arr):\n        return arr  # Handle invalid input\n\n    #Reverse the portion of the array upto k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array (list).\n        k: The position up to which the array should be reversed (1-based index).\n\n    Returns:\n        A new array with elements up to position k reversed.  Returns the original array if k is invalid.\n\n    Raises:\n        TypeError: if input array is not a list or k is not an integer.\n        ValueError: if k is less than 1 or greater than the length of the array.\n\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input array must be a list.\")\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer.\")\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k must be between 1 and the length of the array.\")\n\n    #Efficiently reverse the array slice\n    reversed_part = arr[:k][::-1]\n    #Concatenate reversed part and remaining part of the original array\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array (list).\n        k: The position up to which the array should be reversed (1-based index).\n\n    Returns:\n        A new array with the elements up to position k reversed.  Returns the original array if k is out of bounds or invalid.\n\n    \"\"\"\n    if not isinstance(arr, list) or k <= 0 or k > len(arr):\n        return arr  # Handle invalid input\n\n    reversed_part = arr[:k][::-1]  # Reverse the portion of the array up to k\n    remaining_part = arr[k:]       #Get the remaining part of the array\n\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n        A new array with the elements up to position k reversed.  Returns the original array if k is invalid.\n\n    \"\"\"\n    if not isinstance(arr, list) or k <= 0 or k > len(arr):\n        return arr  # Handle invalid input\n\n    reversed_part = arr[:k][::-1]  # Reverse the first k elements\n    remaining_part = arr[k:]      # Keep the rest of the array as is\n\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n      arr: The input array.\n      k: The position up to which the array should be reversed (1-based index).\n\n    Returns:\n      A new array with the elements up to position k reversed.  Returns the original array if k is invalid.\n    \"\"\"\n    if not 1 <= k <= len(arr):\n        return arr  #Handle invalid k\n\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array (list).\n        k: The position up to which the array should be reversed (1-based index).\n\n    Returns:\n        A new array with the elements up to position k reversed.  Returns the original array if k is invalid.\n\n    \"\"\"\n    if not isinstance(arr, list) or k <= 0 or k > len(arr):\n        return arr  #Handle invalid input\n\n    reversed_part = arr[:k][::-1] #Reverse the portion of the array up to k\n    remaining_part = arr[k:]      #Keep the rest of the array unchanged\n\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n      arr: The input array.\n      k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n      A new array with the elements up to position k reversed.  Returns the original array if k is out of bounds.\n\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n      arr: The input array (list).\n      k: The position up to which the array should be reversed (1-indexed).\n\n    Returns:\n      A new array with elements up to position k reversed.  Returns the original array if k is out of bounds or less than or equal to 0.\n\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    reversed_part = arr[:k][::-1]  # Reverse the portion up to k\n    remaining_part = arr[k:]       #Keep the remaining part unchanged\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array (list).\n        k: The position up to which the array should be reversed (1-based index).\n\n    Returns:\n        A new array with the elements up to position k reversed.  Returns the original array if k is invalid.\n\n    \"\"\"\n    if not isinstance(arr, list) or k <= 0 or k > len(arr):\n        return arr  # Handle invalid input\n\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array (list).\n        k: The position up to which the array should be reversed (1-based index).\n\n    Returns:\n        A new array with elements up to position k reversed.  Returns the original array if k is invalid.\n\n    \"\"\"\n    if not isinstance(arr, list) or k <=0 or k > len(arr):\n        return arr  #Handle invalid input\n\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n        A new array with the elements up to position k reversed.  Returns the original array if k is out of bounds.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr  # Handle invalid k values\n\n    reversed_part = arr[:k][::-1]  # Reverse the portion up to k\n    remaining_part = arr[k:]      # Keep the remaining part unchanged\n\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n        A new array with the elements up to position k reversed.\n        Returns the original array if k is out of bounds or less than 1.\n\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n        The array with elements up to position k reversed.  Returns the original array if k is invalid.\n\n    \"\"\"\n    if not isinstance(arr, list) or k <= 0 or k > len(arr):\n        return arr  #Handle invalid input\n\n    arr[:k] = arr[:k][::-1] #Reverse the slice in place\n    return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n      arr: The input array.\n      k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n      A new array with the elements up to position k reversed.  Returns the \n      original array if k is out of bounds or less than 1.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr  #Handle edge cases: k is invalid\n\n    #Efficient reversal using slicing\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n        A new array with the elements up to position k reversed.  Returns the original array if k is invalid.\n\n    \"\"\"\n    if not isinstance(arr, list) or not 0 <= k <= len(arr):\n      return arr\n\n    reversed_part = arr[:k][::-1]  # Reverse the portion of the array up to k\n    remaining_part = arr[k:]       # Keep the remaining part unchanged\n\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n      arr: The input array.\n      k: The position up to which the array should be reversed (1-based index).\n\n    Returns:\n      A new array with the elements up to position k reversed.  Returns the original array if k is invalid.\n\n    \"\"\"\n    if not isinstance(arr, list) or k <= 0 or k > len(arr):\n        return arr  # Handle invalid input\n\n    #Efficiently reverse using slicing\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n        A new array with the elements up to position k reversed.  Returns the original array if k is out of bounds.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr  #Handle edge cases where k is invalid\n\n    reversed_part = arr[:k][::-1]  #Reverse the portion of the array up to k\n    remaining_part = arr[k:]       #Keep the remaining part unchanged\n\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}]}, "Mbpp/720": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(tuple_data, dict_data):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        tuple_data: The input tuple.\n        dict_data: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.  Returns the original tuple if input is invalid.\n    \"\"\"\n    try:\n        return tuple_data + (dict_data,)\n    except TypeError:\n        #Handle cases where input is not a tuple or dictionary.  Could raise an exception instead.\n        return tuple_data", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The input tuple.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.  Returns the original tuple if input is not a tuple and dictionary\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_dict, dict):\n        return input_tuple\n\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_data, dict_data):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        tuple_data: The input tuple.\n        dict_data: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.  Returns the original tuple if input is invalid.\n\n    \"\"\"\n    if not isinstance(tuple_data, tuple) or not isinstance(dict_data, dict):\n        return tuple_data #Return original tuple if input is invalid.\n\n    return tuple_data + (dict_data,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(my_tuple, my_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        my_tuple: The input tuple.\n        my_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.  Returns the original tuple if input is invalid.\n\n    \"\"\"\n    if not isinstance(my_tuple, tuple) or not isinstance(my_dict, dict):\n        return my_tuple #Handle invalid input\n\n    return my_tuple + (my_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_data, dict_data):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        tuple_data: The input tuple.\n        dict_data: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.  Returns the original tuple if input is invalid.\n    \"\"\"\n    if not isinstance(tuple_data, tuple) or not isinstance(dict_data, dict):\n        return tuple_data  #Return original tuple if input is not a tuple and dictionary\n\n    return tuple_data + (dict_data,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n      input_tuple: The input tuple.\n      input_dict: The dictionary to add.\n\n    Returns:\n      A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_data, dict_data):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        tuple_data: The input tuple.\n        dict_data: The dictionary to be added.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return tuple_data + (dict_data,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The input tuple.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.  Returns the original tuple if input_tuple is not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return input_tuple\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_data, dict_data):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        tuple_data: The input tuple.\n        dict_data: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return tuple_data + (dict_data,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_data, dict_data):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        tuple_data: The input tuple.\n        dict_data: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.  Returns the original tuple if input is invalid.\n    \"\"\"\n    try:\n        if not isinstance(tuple_data, tuple) or not isinstance(dict_data, dict):\n            return tuple_data #Handle invalid inputs gracefully\n        return tuple_data + (dict_data,)\n    except Exception as e:\n      print(f\"An error occurred: {e}\")\n      return tuple_data", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The input tuple.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(my_tuple, my_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n      my_tuple: The input tuple.\n      my_dict: The dictionary to add.\n\n    Returns:\n      A new tuple with the dictionary appended.\n    \"\"\"\n    return my_tuple + (my_dict,)\nmy_tuple = (4, 5, 6)\nmy_dict = {\"MSAM\": 1, \"is\": 2, \"best\": 3}", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(my_tuple, my_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n      my_tuple: The input tuple.\n      my_dict: The dictionary to add.\n\n    Returns:\n      A new tuple with the dictionary appended.\n    \"\"\"\n    return my_tuple + (my_dict,)\nmy_tuple = (4, 5, 6)\nmy_dict = {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3}", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The input tuple.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.  Returns the original tuple if input is not a tuple and a dictionary.\n\n    \"\"\"\n    if not isinstance(input_tuple, tuple) or not isinstance(input_dict, dict):\n        return input_tuple\n\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_data, dict_data):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        tuple_data: The input tuple.\n        dict_data: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.  Returns the original tuple if input is invalid.\n\n    \"\"\"\n    try:\n        return tuple_data + (dict_data,)\n    except TypeError:\n        return tuple_data", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The input tuple.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.  Returns the original tuple if input is not a tuple and dictionary.\n\n    Raises:\n        TypeError: if input_tuple is not a tuple or input_dict is not a dictionary.\n\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"input_tuple must be a tuple\")\n    if not isinstance(input_dict, dict):\n        raise TypeError(\"input_dict must be a dictionary\")\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_data, dict_data):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n      tuple_data: The input tuple.\n      dict_data: The dictionary to add.\n\n    Returns:\n      A new tuple with the dictionary appended.\n    \"\"\"\n    return tuple_data + (dict_data,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The input tuple.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.  Returns the original tuple if input_tuple is not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return input_tuple\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(my_tuple, my_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        my_tuple: The input tuple.\n        my_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.  Returns the original tuple if input is invalid.\n    \"\"\"\n    if not isinstance(my_tuple, tuple) or not isinstance(my_dict, dict):\n        return my_tuple  #Handle invalid input\n\n    return my_tuple + (my_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_data, dict_data):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        tuple_data: The input tuple.\n        dict_data: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return tuple_data + (dict_data,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 78.46994535519126, "dps_norm": 77.5, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)\ntext = 'Cortex \"A53\" Based \"multi\" tasking \"Processor\"'", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)\ntext = 'Cortex \"A53\" Based \"multi\" tasking \"Processor\"'", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)\ntext = 'Cortex \"A53\" Based \"multi\" tasking \"Processor\"'", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)\ntext = 'Cortex \"A53\" Based \"multi\" tasking \"Processor\"'", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches\ntext = 'Cortex \"A53\" Based \"multi\" tasking \"Processor\"'", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)\ntext = 'Cortex \"A53\" Based \"multi\" tasking \"Processor\"'", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)\ntext = 'Cortex \"A53\" Based \"multi\" tasking \"Processor\"'", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)\ntext = 'Cortex \"A53\" Based \"multi\" tasking \"Processor\"'", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)\ntext = 'Cortex \"A53\" Based \"multi\" tasking \"Processor\"'", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A list of strings extracted from between quotation marks.  Returns an empty list if no quoted strings are found.\n    \"\"\"\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 6}]}, "Mbpp/732": {"dps": 57.6937984496124, "dps_norm": 91.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    for char in [' ', ',', '.']:\n        input_string = input_string.replace(char, ':')\n    return input_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    #Using translate for efficiency\n    translation_table = str.maketrans(\" ,.\", \":::\")\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    #Using translate for efficiency\n    translation_table = str.maketrans(\" ,.\", \":::\")\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    # Using translate for efficiency\n    translation_table = str.maketrans(\" ,.\", \":::\")\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    for char in \" ,.\":\n        input_string = input_string.replace(char, \":\")\n    return input_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    return input_string.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    #Using translate for efficiency\n    translator = str.maketrans(\" ,.\", \":::\")\n    return input_string.translate(translator)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots in a string with colons.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    #Using translate for efficiency\n    translation_table = str.maketrans(\" ,.\", \":::\")\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "import re\ndef replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    #Using re.sub for efficiency and readability\n    return re.sub(r\"[ ,.]\", \":\", input_string)", "matching_cluster_idx": 2}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    #Using translate for efficiency\n    translation_table = str.maketrans(\" ,.\", \":::\")\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    #Using translate for efficiency.  Creating a translation table.\n    translation_table = str.maketrans(\" ,.\", \":::\")\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    # Using translate for efficiency\n    translation_table = str.maketrans(\" ,.\", \":::\")\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots in a string with colons.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    # Using translate for efficiency\n    translation_table = str.maketrans(\" ,.\", \":::\")\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    #Using translate for efficiency\n    translation_table = str.maketrans(\" ,.\", \":::\")\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    for char in [' ', ',', '.']:\n        input_string = input_string.replace(char, ':')\n    return input_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    for char in [' ', ',', '.']:\n        input_string = input_string.replace(char, ':')\n    return input_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    \n    #Using translate for efficiency\n    translation_table = str.maketrans(\" ,.\", \":::\")\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    for char in [' ', ',', '.']:\n        input_string = input_string.replace(char, ':')\n    return input_string", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 80.32727272727273, "dps_norm": 66.11111111111111, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length into a dictionary where adjacent pairs form key-value pairs.\n\n    Args:\n        input_tuple: A tuple containing an even number of elements.\n\n    Returns:\n        A dictionary where adjacent elements from the input tuple are key-value pairs.\n        Returns an empty dictionary if the input tuple is empty or has an odd length.\n\n    Raises:\n        TypeError: if input is not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    if len(input_tuple) == 0 or len(input_tuple) % 2 != 0:\n        return {}\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length to a dictionary using adjacent pairs as key-value pairs.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary where adjacent pairs from the input tuple are key-value pairs.\n        Returns an empty dictionary if the input tuple is empty or has an odd length.\n\n    Raises:\n        TypeError: if input is not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n    \n    if len(input_tuple) == 0 or len(input_tuple) % 2 != 0:\n        return {}\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length into a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary where adjacent pairs from the tuple are key-value pairs.  Returns an empty dictionary if the input is invalid.\n\n    Raises:\n        ValueError: If the input tuple has an odd number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements.\")\n    \n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length to a dictionary using adjacent pairs as key-value pairs.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary where adjacent elements form key-value pairs.  Returns an empty dictionary if the input is invalid.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        return {}  # Handle tuples with odd length\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        key = input_tuple[i]\n        value = input_tuple[i+1]\n        result_dict[key] = value\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length into a dictionary where adjacent pairs are key-value pairs.\n\n    Args:\n        input_tuple: A tuple containing an even number of elements.\n\n    Returns:\n        A dictionary where adjacent pairs from the input tuple are key-value pairs.  Returns an empty dictionary if the input is invalid.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        return {}  # Handle tuples with odd lengths\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        key = input_tuple[i]\n        value = input_tuple[i + 1]\n        result_dict[key] = value\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length into a dictionary where adjacent pairs form key-value pairs.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary where adjacent pairs from the input tuple are key-value pairs.\n        Returns an empty dictionary if the input tuple is empty or has an odd number of elements.\n\n    Raises:\n        TypeError: if input is not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    if len(input_tuple) == 0 or len(input_tuple) % 2 != 0:\n        return {}\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length into a dictionary using adjacent pairs as key-value pairs.\n\n    Args:\n        input_tuple: A tuple containing an even number of elements.\n\n    Returns:\n        A dictionary where adjacent pairs from the input tuple are key-value pairs.  Returns an empty dictionary if the input is invalid.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        return {}  # Handle tuples with odd length\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        key = input_tuple[i]\n        value = input_tuple[i + 1]\n        result_dict[key] = value\n    return result_dict", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple of even length into a dictionary where adjacent elements are key-value pairs.\n\n    Args:\n      input_tuple: A tuple with an even number of elements.\n\n    Returns:\n      A dictionary where adjacent pairs from the input tuple form key-value pairs.  Returns an empty dictionary if the input is invalid.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        return {}  #Handle odd length tuples gracefully.\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length into a dictionary where adjacent elements form key-value pairs.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary with key-value pairs formed from adjacent elements in the input tuple.\n        Returns an empty dictionary if the input tuple is empty or has an odd length.  \n    \"\"\"\n    if len(input_tuple) == 0 or len(input_tuple) % 2 != 0:\n        return {}\n    \n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length to a dictionary where adjacent pairs form key-value pairs.\n\n    Args:\n      input_tuple: A tuple with an even number of elements.\n\n    Returns:\n      A dictionary where adjacent elements of the input tuple are key-value pairs.  Returns an empty dictionary if the input is invalid.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        return {}  # Handle tuples with odd length\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        key = input_tuple[i]\n        value = input_tuple[i + 1]\n        result_dict[key] = value\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length into a dictionary where adjacent elements form key-value pairs.\n\n    Args:\n      input_tuple: A tuple with an even number of elements.\n\n    Returns:\n      A dictionary where adjacent elements of the input tuple are key-value pairs.  Returns an empty dictionary if the input is invalid.\n\n    Raises:\n      TypeError: If input is not a tuple.\n      ValueError: If input tuple has an odd number of elements.\n\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements.\")\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple of even length to a dictionary where adjacent pairs form key-value pairs.\n\n    Args:\n        input_tuple: A tuple containing an even number of elements.\n\n    Returns:\n        A dictionary where adjacent elements of the input tuple are key-value pairs.\n        Returns an empty dictionary if the input tuple is empty or has an odd length.\n\n    \"\"\"\n    if len(input_tuple) == 0 or len(input_tuple) % 2 != 0:\n        return {}\n    \n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple of even length to a dictionary where adjacent elements are key-value pairs.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary with key-value pairs from the input tuple.  Returns an empty dictionary if the input is invalid.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        return {}  #Handle odd length tuples\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length into a dictionary using adjacent pairs as key-value pairs.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary where keys and values are taken from adjacent elements in the input tuple.\n        Returns an empty dictionary if the input tuple is empty or has an odd length.  \n    \"\"\"\n    if len(input_tuple) == 0 or len(input_tuple) % 2 != 0:\n        return {}\n    \n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length into a dictionary where adjacent elements form key-value pairs.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary where the elements at even indices are keys and the elements at odd indices are values.  Returns an empty dictionary if the input is invalid.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        return {}  # Handle odd-length tuples\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length to a dictionary using adjacent pairs as key-value pairs.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary where adjacent pairs from the input tuple are key-value pairs.\n        Returns an empty dictionary if the input tuple is empty or has an odd number of elements.\n\n    Raises:\n        TypeError: if input is not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    if len(input_tuple) % 2 != 0 or len(input_tuple) == 0:\n        return {}  #Handle empty or odd-length tuples\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length into a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary where adjacent pairs from the tuple are key-value pairs.  Returns an empty dictionary if the input is invalid.\n\n    Raises:\n        ValueError: If the input tuple has an odd number of elements.\n\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements.\")\n    \n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length to a dictionary where adjacent elements form key-value pairs.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary where adjacent elements of the input tuple are key-value pairs.\n        Returns an empty dictionary if the input tuple is empty or has an odd length.\n\n    Raises:\n        TypeError: If the input is not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    if len(input_tuple) == 0 or len(input_tuple) % 2 != 0:\n        return {}\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length into a dictionary where adjacent elements form key-value pairs.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary where the elements at even indices are keys and the elements at odd indices are values.\n        Returns an empty dictionary if the input tuple is empty or has an odd length.\n\n    Raises:\n        TypeError: if input is not a tuple.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    if len(input_tuple) == 0 or len(input_tuple) % 2 != 0:\n        return {}\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple of even length into a dictionary with adjacent pairs as key-value pairs.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary where adjacent elements in the tuple are key-value pairs. \n        Returns an empty dictionary if the input is invalid.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        return {}  # Handle odd-length tuples\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        key = input_tuple[i]\n        value = input_tuple[i + 1]\n        result_dict[key] = value\n    return result_dict", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 90.41095890410959, "dps_norm": 93.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n      input_tuple: The tuple to check.\n\n    Returns:\n      True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n      input_tuple: The tuple to check.\n\n    Returns:\n      True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n      input_tuple: The tuple to check.\n\n    Returns:\n      True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n      input_tuple: The tuple to check.\n\n    Returns:\n      True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a given tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n      input_tuple: The tuple to check.\n\n    Returns:\n      True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n      input_tuple: The input tuple.\n\n    Returns:\n      True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n      input_tuple: The tuple to check.\n\n    Returns:\n      True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n      input_tuple: The tuple to check.\n\n    Returns:\n      True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n      input_tuple: The tuple to check.\n\n    Returns:\n      True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n      input_tuple: The tuple to check.\n\n    Returns:\n      True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 4}]}, "Mbpp/750": {"dps": 48.02721088435374, "dps_norm": 53.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(list_in, tuple_in):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n        list_in: The input list.\n        tuple_in: The input tuple.\n\n    Returns:\n        A new list containing all elements from the input list and tuple.  Returns the original list if input is invalid.\n    \"\"\"\n    if not isinstance(list_in, list) or not isinstance(tuple_in, tuple):\n        return list_in #Handle invalid input gracefully\n\n    return list_in + list(tuple_in)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(list1, tuple1):\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    \"\"\"\n    list1.extend(tuple1)\n    return list1", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list_in, tuple_in):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n        list_in: The input list.\n        tuple_in: The input tuple.\n\n    Returns:\n        A new list containing all elements from the input list and tuple.  Returns the original list if input is invalid.\n    \"\"\"\n    if not isinstance(list_in, list) or not isinstance(tuple_in, tuple):\n        return list_in #Return original list if input is not a list and tuple\n\n    return list_in + list(tuple_in)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(list_in, tuple_in):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n        list_in: The input list.\n        tuple_in: The input tuple.\n\n    Returns:\n        A new list containing all elements from the input list and tuple.  Returns None if input is invalid.\n    \"\"\"\n    if not isinstance(list_in, list) or not isinstance(tuple_in, tuple):\n        return None  # Handle invalid input types\n\n    return list_in + list(tuple_in)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(list_in, tuple_in):\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    \"\"\"\n    list_in.extend(tuple_in)\n    return list_in", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list_in, tuple_in):\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    \"\"\"\n    list_in.extend(tuple_in)\n    return list_in", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list_in, tuple_in):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n        list_in: The input list.\n        tuple_in: The input tuple.\n\n    Returns:\n        A new list with the tuple's elements appended.  Returns the original list if input is invalid.\n    \"\"\"\n    if not isinstance(list_in, list) or not isinstance(tuple_in, tuple):\n        return list_in  # Handle invalid input types\n\n    return list_in + list(tuple_in)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(list_a, tuple_b):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n        list_a: The list to add to.\n        tuple_b: The tuple to add.\n\n    Returns:\n        A new list containing all elements from list_a and tuple_b.\n    \"\"\"\n    return list_a + list(tuple_b)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_in, tuple_in):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n        list_in: The input list.\n        tuple_in: The input tuple.\n\n    Returns:\n        A new list containing all elements from the input list and tuple.  Returns the original list if the input is invalid.\n\n    \"\"\"\n    if not isinstance(list_in, list) or not isinstance(tuple_in, tuple):\n        return list_in #Handle invalid input gracefully\n\n    return list_in + list(tuple_in)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(list_input, tuple_input):\n    \"\"\"\n    Adds a tuple to the end of a list.\n\n    Args:\n        list_input: The list to add to.\n        tuple_input: The tuple to add.\n\n    Returns:\n        A new list with the tuple appended.  Returns the original list if input is invalid.\n    \"\"\"\n    if not isinstance(list_input, list) or not isinstance(tuple_input, tuple):\n        return list_input #Return original list if input types are invalid.\n\n    return list_input + list(tuple_input)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(list1, tuple1):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n        list1: The list to add to.\n        tuple1: The tuple to add.\n\n    Returns:\n        A new list with the tuple appended.\n    \"\"\"\n    return list1 + list(tuple1)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_in, tuple_in):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n        list_in: The input list.\n        tuple_in: The input tuple.\n\n    Returns:\n        A new list containing all elements from the input list and tuple.\n    \"\"\"\n    return list_in + list(tuple_in)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_a, tuple_b):\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    \"\"\"\n    list_a.extend(tuple_b)\n    return list_a", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list_a, tuple_b):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n        list_a: The list to add to.\n        tuple_b: The tuple to add.\n\n    Returns:\n        A new list with the tuple appended.\n    \"\"\"\n    return list_a + list(tuple_b)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_in, tuple_in):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n        list_in: The input list.\n        tuple_in: The input tuple.\n\n    Returns:\n        A new list containing all elements from the input list and tuple.\n    \"\"\"\n    return list_in + list(tuple_in)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_in, tuple_in):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n      list_in: The input list.\n      tuple_in: The input tuple.\n\n    Returns:\n      A new list containing all elements from the input list and tuple.\n    \"\"\"\n    return list_in + list(tuple_in)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_input, tuple_input):\n    \"\"\"Adds a tuple to the end of a list.\n\n    Args:\n        list_input: The list to add to.\n        tuple_input: The tuple to add.\n\n    Returns:\n        A new list with the tuple appended.  Returns None if input is invalid.\n    \"\"\"\n    if not isinstance(list_input, list) or not isinstance(tuple_input, tuple):\n        return None\n    return list_input + list(tuple_input)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(list1, tuple1):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n        list1: The list to add to.\n        tuple1: The tuple to add.\n\n    Returns:\n        A new list with the tuple appended.\n    \"\"\"\n    return list1 + list(tuple1)\nlist1 = [5, 6, 7]\ntuple1 = (9, 10)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n        list1: The list to add to.\n        tuple1: The tuple to add.\n\n    Returns:\n        A new list with the tuple appended.\n    \"\"\"\n    return list1 + list(tuple1)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_in, tuple_in):\n    \"\"\"Adds a tuple to a list.\n\n    Args:\n        list_in: The input list.\n        tuple_in: The input tuple.\n\n    Returns:\n        A new list containing all elements from the input list and tuple.  Returns the original list if input is invalid.\n    \"\"\"\n    if not isinstance(list_in, list) or not isinstance(tuple_in, tuple):\n        return list_in  #Return original list if inputs are not of correct type.\n\n    return list_in + list(tuple_in)", "matching_cluster_idx": 1}]}, "Mbpp/753": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/754": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/755": {"dps": 65.06753609687937, "dps_norm": 85.08771929824562, "pass@1": 19.0, "profiled": [{"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list.  Returns None if the list has fewer than 2 elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    #Remove duplicates to avoid issues with multiple smallest numbers\n    unique_numbers = list(set(numbers))\n    \n    if len(unique_numbers) < 2:\n        return None\n\n    unique_numbers.sort()\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list.  Returns None if the list has fewer than 2 unique elements.\n    \"\"\"\n    if len(set(numbers)) < 2:  #Handle cases with fewer than 2 unique numbers\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))\n    return unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The second smallest number in the list.  Returns None if the list has fewer than 2 elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None  # Handle cases with less than 2 elements\n\n    # Remove duplicates to avoid issues with multiple occurrences of the smallest number\n    unique_numbers = list(set(numbers))\n    \n    if len(unique_numbers) < 2:\n        return None #Handle cases with only one unique number\n\n    unique_numbers.sort()\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list.  Returns None if the list has fewer than 2 elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    #Remove duplicates to avoid issues with multiple occurrences of the smallest number.\n    unique_numbers = list(set(numbers))\n    \n    if len(unique_numbers) < 2:\n        return None\n\n    unique_numbers.sort()\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list.  Returns None if the list has fewer than 2 unique elements.\n\n    \"\"\"\n    if len(set(numbers)) < 2:  #Check for insufficient unique numbers\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))  #Remove duplicates and sort\n    return unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The second smallest number in the list.  Returns None if the list \n      has fewer than 2 unique numbers.\n    \"\"\"\n    if len(set(numbers)) < 2:\n        return None  # Handle cases with fewer than 2 unique numbers\n\n    unique_numbers = sorted(list(set(numbers)))  #Efficiently get unique sorted numbers\n\n    return unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The second smallest number in the list.  Returns None if the list has fewer than 2 elements.\n\n    Raises:\n      TypeError: if input is not a list.\n      ValueError: if the list contains non-numeric values.\n\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    if len(numbers) < 2:\n        return None\n\n    #Handle potential errors related to non-numeric values.\n    if not all(isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"List must contain only numbers.\")\n\n    unique_numbers = sorted(list(set(numbers)))  #Remove duplicates and sort\n\n    if len(unique_numbers) < 2:\n        return None #Handle case with only one unique number.\n    else:\n        return unique_numbers[1]", "matching_cluster_idx": 2}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list.  Returns None if the list \n        has fewer than 2 unique elements.\n    \"\"\"\n    if len(set(numbers)) < 2:  #Check for less than 2 unique numbers\n        return None\n\n    unique_numbers = sorted(list(set(numbers))) #remove duplicates and sort\n    return unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list.  Returns None if the list has fewer than 2 unique elements.\n    \"\"\"\n    if len(set(numbers)) < 2:  #Handle cases with fewer than 2 unique numbers.\n        return None\n    \n    unique_numbers = sorted(list(set(numbers))) #remove duplicates and sort\n    return unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list.  Returns None if the list \n        has fewer than 2 unique numbers.\n    \"\"\"\n    if len(set(numbers)) < 2:  #Handle cases with fewer than 2 unique numbers\n        return None\n\n    unique_numbers = sorted(list(set(numbers))) #remove duplicates and sort\n    return unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list.  Returns None if the list \n        has fewer than 2 unique numbers.\n    \"\"\"\n    if len(set(numbers)) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))\n    return unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list.  Returns None if the list has fewer than 2 elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None  # Handle cases with fewer than 2 numbers\n\n    # Remove duplicates to avoid issues with multiple occurrences of the smallest number\n    unique_numbers = sorted(list(set(numbers)))\n\n    if len(unique_numbers) < 2:\n      return None #Handle cases with only one unique number\n\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The second smallest number in the list.  Returns None if the list has fewer than 2 elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    #Remove duplicates to avoid issues with lists containing only one unique element.\n    unique_numbers = list(set(numbers))\n    if len(unique_numbers) < 2:\n      return None\n\n    unique_numbers.sort()\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list.  Returns None if the list has fewer than 2 unique elements.\n    \"\"\"\n    if len(set(numbers)) < 2:  #Handle cases with less than 2 unique numbers\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))\n    return unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The second smallest number in the list.  Returns None if the list has fewer than 2 elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    # Remove duplicates to avoid issues with multiple smallest numbers\n    unique_numbers = list(set(numbers))\n\n    if len(unique_numbers) < 2:\n        return None\n\n    unique_numbers.sort()\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The second smallest number in the list.  Returns None if the list \n      has fewer than 2 unique elements.\n    \"\"\"\n    if len(set(numbers)) < 2:  #Handle cases with fewer than 2 unique numbers.\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))\n    return unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The second smallest number in the list.  Returns None if the list has fewer than 2 elements.\n\n    Raises:\n      TypeError: if input is not a list.\n      ValueError: if the list contains non-numeric values.\n\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    if len(numbers) < 2:\n        return None\n\n    for num in numbers:\n        if not isinstance(num,(int,float)):\n            raise ValueError(\"List must contain only numbers.\")\n\n\n    unique_numbers = sorted(list(set(numbers)))  #Remove duplicates and sort\n\n    if len(unique_numbers) < 2:\n        return None #Handle cases with only one unique number\n    else:\n        return unique_numbers[1]", "matching_cluster_idx": 1}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list. Returns None if the list has fewer than 2 elements or if all elements are the same.\n\n    Raises:\n      TypeError: if input is not a list.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))  #Remove duplicates and sort\n\n    if len(unique_numbers) < 2:\n      return None\n\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list.  Returns None if the list \n        has fewer than 2 unique numbers.\n    \"\"\"\n    if len(set(numbers)) < 2:  #Check for at least two unique numbers\n        return None\n\n    unique_numbers = sorted(list(set(numbers))) #Efficiently get unique numbers and sort\n\n    return unique_numbers[1]", "matching_cluster_idx": 4}]}, "Mbpp/757": {"dps": 82.71028037383178, "dps_norm": 23.076923076923077, "pass@1": 39.0, "profiled": [{"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n        strings: A list of strings.\n\n    Returns:\n        The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n      string_list: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    n = len(string_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n        strings: A list of strings.\n\n    Returns:\n        The number of pairs of reverse strings.\n    \"\"\"\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n      string_list: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    n = len(string_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n      string_list: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    n = len(string_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    n = len(string_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    n = len(string_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n        strings: A list of strings.\n\n    Returns:\n        The number of pairs of reverse strings.\n    \"\"\"\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the pairs of reverse strings in a given string list.\n\n    Args:\n        strings: A list of strings.\n\n    Returns:\n        The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n      strings: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n      strings: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings.\n    \"\"\"\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    Counts the number of pairs of reverse strings in a given list.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        The number of pairs of reverse strings.\n    \"\"\"\n    count = 0\n    n = len(string_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n      string_list: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    n = len(string_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the number of pairs of reverse strings in a given list of strings.\n\n    Args:\n      strings: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings.\n    \"\"\"\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts pairs of reverse strings in a given list of strings.\n\n    Args:\n      strings: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings in the list.\n    \"\"\"\n\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] == strings[j][::-1]:  # Check for reverse using slicing\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n      strings: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n      strings: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the number of pairs of reverse strings in a given list.\n\n    Args:\n      strings: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings.\n    \"\"\"\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n      string_list: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    n = len(string_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the number of pairs of reverse strings in a given list.\n\n    Args:\n        strings: A list of strings.\n\n    Returns:\n        The number of pairs of reverse strings.\n    \"\"\"\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 84.69111969111968, "dps_norm": 83.75, "pass@1": 100.0, "profiled": [{"solution": "from collections import defaultdict\ndef unique_sublists(list_of_lists):\n    \"\"\"Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (representing the sublists) and values are their counts.  Returns an empty dictionary if the input is not a list.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        return {}\n\n    counts = defaultdict(int)\n    for sublist in list_of_lists:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"Counts the occurrences of each sublist in a list of lists.\n\n    Args:\n      list_of_lists: A list of lists.\n\n    Returns:\n      A dictionary where keys are tuples (representing the sublists) and values are \n      the number of times each sublist appears in the input list.\n    \"\"\"\n\n    counts = {}\n    for sublist in list_of_lists:\n        tuple_sublist = tuple(sublist)  # Convert list to tuple for hashability\n        counts[tuple_sublist] = counts.get(tuple_sublist, 0) + 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (converted from sublists) and values are their counts.\n    \"\"\"\n\n    counts = {}\n    for sublist in list_of_lists:\n        tuple_sublist = tuple(sublist)  # Convert list to tuple for hashability\n        if tuple_sublist in counts:\n            counts[tuple_sublist] += 1\n        else:\n            counts[tuple_sublist] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(list_of_lists):\n    \"\"\"Counts the occurrences of sublists within a list.\n\n    Args:\n      list_of_lists: A list of lists.\n\n    Returns:\n      A dictionary where keys are tuples (representing the sublists) and values are their counts.  Returns an empty dictionary if the input is not a list.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        return {}\n\n    tuple_list = [tuple(sublist) for sublist in list_of_lists]\n    counts = Counter(tuple_list)\n    return dict(counts)", "matching_cluster_idx": 7}, {"solution": "from collections import defaultdict\ndef unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (representing the sublists) and values are their counts.\n    \"\"\"\n    counts = defaultdict(int)\n    for sublist in list_of_lists:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef unique_sublists(list_of_lists):\n    \"\"\"Counts the occurrences of each sublist in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (representing the sublists) and values are their counts.  Returns an empty dictionary if input is invalid.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        return {}\n    if not all(isinstance(sublist, list) for sublist in list_of_lists):\n        return {}\n\n    tuple_list = [tuple(sublist) for sublist in list_of_lists]\n    counts = Counter(tuple_list)\n    return dict(counts)", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n      list_of_lists: A list of lists.\n\n    Returns:\n      A dictionary where keys are tuples (representing the sublists) and values are their counts.\n    \"\"\"\n\n    counts = defaultdict(int)\n    for sublist in list_of_lists:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list containing lists as elements.\n\n    Returns:\n        A dictionary where keys are tuples (representing unique sublists) and \n        values are their counts.  Returns an empty dictionary if input is invalid.\n    \"\"\"\n\n    if not isinstance(list_of_lists, list):\n        return {}  # Handle invalid input\n\n    counts = {}\n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            return {} #Handle invalid input containing non-list elements.\n\n        tuple_sublist = tuple(sublist)\n        counts[tuple_sublist] = counts.get(tuple_sublist, 0) + 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (representing the sublists) and values are their counts.  Returns an empty dictionary if input is invalid.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        return {}  # Handle invalid input\n\n    counts = {}\n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            return {} #Handle invalid input containing non-list elements\n        tuple_sublist = tuple(sublist)\n        counts[tuple_sublist] = counts.get(tuple_sublist, 0) + 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (converted from sublists) and values are their counts.  Returns an empty dictionary if input is invalid.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        return {}\n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            return {}\n\n    tuple_list = [tuple(sublist) for sublist in list_of_lists]\n    return dict(Counter(tuple_list))", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list containing other lists.\n\n    Returns:\n        A dictionary where keys are tuples (representing the sublists) and values are their counts.  Returns an empty dictionary if the input is not a list.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        return {}\n\n    counts = {}\n    for sublist in list_of_lists:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in counts:\n            counts[tuple_sublist] += 1\n        else:\n            counts[tuple_sublist] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (representing sublists) and values are their counts.\n    \"\"\"\n\n    counts = defaultdict(int)\n    for sublist in list_of_lists:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (representing the sublists) and values are their counts.\n    \"\"\"\n\n    counts = {}\n    for sublist in list_of_lists:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in counts:\n            counts[tuple_sublist] += 1\n        else:\n            counts[tuple_sublist] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (representing the sublists) and values are their counts.\n    \"\"\"\n\n    counts = defaultdict(int)\n    for lst in list_of_lists:\n        counts[tuple(lst)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (representing the sublists) and values are their counts.\n    \"\"\"\n\n    counts = defaultdict(int)\n    for sublist in list_of_lists:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (representing sublists) and values are their counts.\n    \"\"\"\n\n    counts = defaultdict(int)\n    for sublist in list_of_lists:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list containing other lists.\n\n    Returns:\n        A dictionary where keys are tuples (representing the sublists) and values are their counts.\n    \"\"\"\n\n    counts = {}\n    for sublist in list_of_lists:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in counts:\n            counts[tuple_sublist] += 1\n        else:\n            counts[tuple_sublist] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of each sublist within a list of lists.\n\n    Args:\n      list_of_lists: A list of lists.\n\n    Returns:\n      A dictionary where keys are tuples (representing the sublists) and values are their counts.  Returns an empty dictionary if the input is not a list.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        return {}\n\n    counts = {}\n    for sublist in list_of_lists:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in counts:\n            counts[tuple_sublist] += 1\n        else:\n            counts[tuple_sublist] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list containing lists as elements.\n\n    Returns:\n        A dictionary where keys are tuples (representing the sublists) and \n        values are their counts.  Returns an empty dictionary if the input\n        is not a list.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        return {}\n\n    tuple_counts = Counter(tuple(sublist) for sublist in list_of_lists)\n    return dict(tuple_counts)", "matching_cluster_idx": 7}, {"solution": "from collections import defaultdict\ndef unique_sublists(list_of_lists):\n    \"\"\"Counts the occurrences of sublists within a list.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (representing the sublists) and values are their counts.\n    \"\"\"\n\n    counts = defaultdict(int)\n    for sublist in list_of_lists:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}]}, "Mbpp/760": {"dps": 99.27007299270073, "dps_norm": 87.5, "pass@1": 89.0, "profiled": [{"solution": "def unique_Element(numbers):\n    \"\"\"\n    Checks if a list of numbers contains only one distinct element.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not numbers:  # Handle empty list case\n        return False\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(list_):\n    \"\"\"\n    Write a python function to check whether a list of numbers contains only one distinct element or not.\n    assert unique_Element([1,1,1]) == True\n    \"\"\"\n    if not list_:  #Handle empty list case\n        return False\n    return len(set(list_)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  #Handle empty list case\n        return False\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Write a python function to check whether a list of numbers contains only one distinct element or not.\n    assert unique_Element([1,1,1]) == True\n    \"\"\"\n    if not nums:  #Handle empty list case\n        return False\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n      input_list: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not input_list:  #Handle empty list case\n        return False\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Checks if a list of numbers contains only one distinct element.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not numbers:  # Handle empty list case\n        return False\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Write a python function to check whether a list of numbers contains only one distinct element or not.\n    assert unique_Element([1,1,1]) == True\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return False\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n      input_list: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not input_list:\n        return True  #Empty list considered as having only one distinct element.\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(list_):\n    \"\"\"\n    Write a python function to check whether a list of numbers contains only one distinct element or not.\n    assert unique_Element([1,1,1]) == True\n    \"\"\"\n    return len(set(list_)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n      input_list: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not input_list:  #Handle empty list case\n        return False\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n      input_list: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not input_list:  # Handle empty list case\n        return False\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(list_num):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        list_num: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not list_num:  # Handle empty list case\n        return False\n    return len(set(list_num)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(l):\n    \"\"\"\n    Write a python function to check whether a list of numbers contains only one distinct element or not.\n    assert unique_Element([1,1,1]) == True\n    \"\"\"\n    if not l:\n        return False #Handle empty list case\n    return len(set(l)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Checks if a list of numbers contains only one distinct element.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not numbers:  #Handle empty list case\n        return False\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Write a python function to check whether a list of numbers contains only one distinct element or not.\n    assert unique_Element([1,1,1]) == True\n    \"\"\"\n    if not nums:\n        return False  # Handle empty list case\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n      input_list: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not input_list:  # Handle empty list case\n        return False\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n      input_list: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n      Returns True for empty lists.\n    \"\"\"\n    if not input_list:  #Handle empty list case\n        return True\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(l):\n    \"\"\"\n    Write a python function to check whether a list of numbers contains only one distinct element or not.\n    assert unique_Element([1,1,1]) == True\n    \"\"\"\n    if not l:  #Handle empty list case\n        return False\n    return len(set(l)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        input_list: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not input_list:  #Handle empty list case\n        return True\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n      input_list: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not input_list:  # Handle empty list case\n        return False\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(input_string):\n    \"\"\"Counts the number of digits in a given string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The number of digits in the input string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The number of digits in the input string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The number of digits in the input string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"Counts the number of digits in a given string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The number of digits in the input string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The number of digits in the input string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The number of digits in the input string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Write a python function to count number of digits in a given string.\n    assert number_ctr('program2bedone') == 1\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The number of digits in the input string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The number of digits in the input string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Write a python function to count number of digits in a given string.\n    assert number_ctr('program2bedone') == 1\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 57.38317757009346, "dps_norm": 52.5, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(data):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    assert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    if not data:\n        return []\n    \n    pairs = []\n    for i in range(len(data) - 1):\n        pairs.append((data[i], data[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Generates a list of tuples, where each tuple contains consecutive pairs from the input list.\n\n    Args:\n      data: A list of any data type.\n\n    Returns:\n      A list of tuples, where each tuple represents a consecutive pair from the input list.\n      Returns an empty list if the input list has fewer than 2 elements.\n    \"\"\"\n    if len(data) < 2:\n        return []\n    result = []\n    for i in range(len(data) - 1):\n        result.append((data[i], data[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Generates a list of consecutive pairs from a given list.\n\n    Args:\n        data: The input list.\n\n    Returns:\n        A list of tuples, where each tuple represents a consecutive pair from the input list.  Returns an empty list if the input list has fewer than 2 elements.\n    \"\"\"\n    if len(data) < 2:\n        return []\n    return list(zip(data, data[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(items):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n        items: A list of items.\n\n    Returns:\n        A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n        Returns an empty list if the input list has fewer than 2 items.\n    \"\"\"\n    if len(items) < 2:\n        return []\n    pairs = []\n    for i in range(len(items) - 1):\n        pairs.append((items[i], items[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    assert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    if not data:\n        return []\n    \n    result = []\n    for i in range(len(data) - 1):\n        result.append((data[i], data[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Generates a list of consecutive item pairs from a given list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        A list of tuples, where each tuple contains a pair of consecutive items from the input list.  Returns an empty list if the input list has fewer than 2 elements.\n    \"\"\"\n    if len(data) < 2:\n        return []\n    result = []\n    for i in range(len(data) - 1):\n        result.append((data[i], data[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    assert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    if not input_list:\n        return []\n    \n    pairs = []\n    for i in range(len(input_list) - 1):\n        pairs.append((input_list[i], input_list[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Generates a list of consecutive pairs from a given list.\n\n    Args:\n        data: The input list.\n\n    Returns:\n        A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n        Returns an empty list if the input list has fewer than 2 elements.\n\n    \"\"\"\n    if len(data) < 2:\n        return []\n    \n    pairs = []\n    for i in range(len(data) - 1):\n        pairs.append((data[i], data[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    assert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    if not input_list:\n        return []\n    \n    result = []\n    for i in range(len(input_list) - 1):\n        result.append((input_list[i], input_list[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    assert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    if not input_list:\n        return []\n    \n    result = []\n    for i in range(len(input_list) -1):\n        result.append((input_list[i], input_list[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n        Returns an empty list if the input list is empty or has only one element.\n\n    \"\"\"\n    if len(input_list) < 2:\n        return []\n    \n    pairs = []\n    for i in range(len(input_list) - 1):\n        pairs.append((input_list[i], input_list[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Generates pairs of consecutive items from a list.\n\n    Args:\n      data: The input list.\n\n    Returns:\n      A list of tuples, where each tuple contains a pair of consecutive items.\n      Returns an empty list if the input list has fewer than 2 elements.\n\n    \"\"\"\n    if len(data) < 2:\n        return []\n    result = []\n    for i in range(len(data) - 1):\n        result.append((data[i], data[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    assert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    if not data:\n        return []\n    \n    result = []\n    for i in range(len(data) - 1):\n        result.append((data[i], data[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n        Returns an empty list if the input list has fewer than 2 items.\n    \"\"\"\n    if len(data) < 2:\n        return []\n    \n    result = []\n    for i in range(len(data) - 1):\n        result.append((data[i], data[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    assert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    if not input_list:\n        return []\n    \n    result = []\n    for i in range(len(input_list) - 1):\n        result.append((input_list[i], input_list[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    assert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    if not input_list:\n        return []\n    \n    pairs = []\n    for i in range(len(input_list) - 1):\n        pairs.append((input_list[i], input_list[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(items):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    assert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    if not items:\n        return []\n    \n    pairs = []\n    for i in range(len(items) - 1):\n        pairs.append((items[i], items[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n        Returns an empty list if the input list has fewer than 2 items.\n    \"\"\"\n    if len(data) < 2:\n        return []\n    \n    pairs = []\n    for i in range(len(data) - 1):\n        pairs.append((data[i], data[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Generates pairs of consecutive items from a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n        Returns an empty list if the input list has fewer than 2 elements.\n    \"\"\"\n    if len(data) < 2:\n        return []\n    result = []\n    for i in range(len(data) - 1):\n        result.append((data[i], data[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    assert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    if not input_list:\n        return []\n    \n    pairs = []\n    for i in range(len(input_list) - 1):\n        pairs.append((input_list[i], input_list[i+1]))\n    return pairs", "matching_cluster_idx": 2}]}, "Mbpp/775": {"dps": 94.39999999999999, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      data: A list of numbers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n        data: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not data:\n        return True\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(input_list):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      input_list: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not input_list:\n        return True  #Handle empty list case\n\n    for i in range(1, len(input_list), 2):\n        if input_list[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.\n      Returns True for empty lists.\n    \"\"\"\n    if not nums:\n        return True\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Write a python function to check whether every odd index contains odd numbers of a given list.\n    assert odd_position([2,1,4,3,6,7,6,3]) == True\n    \"\"\"\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      data: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not data:\n        return True  #Empty list considered to satisfy the condition\n\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      data: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not data:\n        return True\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      data: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not data:\n        return True\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      data: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not data:\n        return True\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n        data: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not data:\n        return True  #Handle empty list case\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      data: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not data:\n        return True\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      data: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not data:\n        return True\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      data: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not data:\n        return True  #Handle empty list case\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(input_list):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      input_list: A list of numbers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    for i in range(1, len(input_list), 2):\n        if input_list[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      data: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not data:\n        return True  #Empty list satisfies the condition\n\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      data: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(data):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n      data: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.  Returns True for empty lists.\n    \"\"\"\n    if not data:\n        return True\n    for i in range(1, len(data), 2):\n        if data[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/781": {"dps": 99.48818897637796, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n        n: An integer greater than 0.\n\n    Returns:\n        True if the number of divisors is even, False otherwise.  Returns False if input is invalid.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n      n: An integer greater than 0.\n\n    Returns:\n      True if the number of divisors is even, False otherwise.  Returns False for invalid input.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n      n: An integer greater than 0.\n\n    Returns:\n      True if the number of divisors is even, False otherwise.  Returns False if input is invalid.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n      n: An integer greater than 0.\n\n    Returns:\n      True if the number of divisors is even, False otherwise.  Returns False for n <= 0.\n    \"\"\"\n    if n <= 0:\n        return False\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n      n: The integer to check.\n\n    Returns:\n      True if the number of divisors is even, False otherwise.  Returns False if n <=0.\n    \"\"\"\n    if n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the count of divisors of a number is even.\n\n    Args:\n        n: An integer greater than 0.\n\n    Returns:\n        True if the number of divisors is even, False otherwise.  Returns False if input is invalid.\n\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given number is even.\n\n    Args:\n      n: An integer greater than 0.\n\n    Returns:\n      True if the number of divisors is even, False otherwise.  Returns False for invalid input.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n      n: An integer greater than 0.\n\n    Returns:\n      True if the number of divisors is even, False otherwise.  Returns False for n <=0.\n\n    \"\"\"\n    if n <= 0:\n        return False\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n      n: An integer greater than 0.\n\n    Returns:\n      True if the number of divisors is even, False otherwise.  Returns False if input is invalid.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of divisors of a number is even.\n\n    Args:\n      n: The input integer.\n\n    Returns:\n      True if the count of divisors is even, False otherwise.  Returns False for n <= 0.\n    \"\"\"\n    if n <= 0:\n        return False  # Handle non-positive inputs\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of divisors of a number is even.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.  Returns False for n <=0\n    \"\"\"\n    if n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of divisors of a number is even.\n\n    Args:\n      n: An integer greater than 0.\n\n    Returns:\n      True if the count of divisors is even, False otherwise.  Returns False for invalid input.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n      n: The input integer.\n\n    Returns:\n      True if the number of divisors is even, False otherwise.  Returns False if n <=0.\n    \"\"\"\n    if n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n      n: The input integer.\n\n    Returns:\n      True if the number of divisors is even, False otherwise.  Returns False for n <= 0.\n    \"\"\"\n    if n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n        n: An integer greater than 0.\n\n    Returns: \n        True if the number of divisors is even, False otherwise.  Returns False if input is invalid.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:  # Handle perfect squares\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n        n: The input integer.\n\n    Returns: \n        True if the count of divisors is even, False otherwise.  Returns False if n is less than 1.\n    \"\"\"\n    if n < 1:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of divisors of a number is even.\n\n    Args:\n      n: The input integer.\n\n    Returns:\n      True if the number of divisors is even, False otherwise.  Returns False for n <= 0.\n    \"\"\"\n    if n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n      n: The input integer.\n\n    Returns:\n      True if the count of divisors is even, False otherwise.  Returns False for n <= 0.\n    \"\"\"\n    if n <= 0:\n        return False\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n      n: An integer greater than 0.\n\n    Returns:\n      True if the count of divisors is even, False otherwise.  Returns False for invalid input.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of a given integer is even.\n\n    Args:\n      n: An integer greater than 0.\n\n    Returns:\n      True if the number of divisors is even, False otherwise.  Returns False if n <=0.\n    \"\"\"\n    if n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}]}, "Mbpp/800": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 12.0, "profiled": [{"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n  \"\"\"Removes all whitespace characters from a string.\n\n  Args:\n    input_string: The input string.\n\n  Returns:\n    The string with all whitespace characters removed.\n  \"\"\"\n  return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n  \"\"\"\n  Removes all whitespace characters from a string.\n\n  Args:\n    input_string: The input string.\n\n  Returns:\n    The string with all whitespace characters removed.\n  \"\"\"\n  return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n  \"\"\"Removes all whitespace characters from a string.\n\n  Args:\n    input_string: The input string.\n\n  Returns:\n    The string with all whitespace characters removed.\n  \"\"\"\n  return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespace from.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n  \"\"\"\n  Removes all whitespace characters from a string.\n\n  Args:\n    input_string: The input string.\n\n  Returns:\n    The string with all whitespace characters removed.\n  \"\"\"\n  return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n  \"\"\"\n  Removes all whitespace characters from a string.\n\n  Args:\n    input_string: The input string.\n\n  Returns:\n    A new string with all whitespace characters removed.\n  \"\"\"\n  return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 55.30927835051546, "dps_norm": 64.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list in a list of lists with the highest sum of elements.\n\n    Args:\n        list_of_lists: A list of lists of numbers.\n\n    Returns:\n        The list with the highest sum of elements.  Returns an empty list if the input is empty.\n        Raises TypeError if input is not a list of lists of numbers.\n\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n    if not all(isinstance(sublist, list) for sublist in list_of_lists):\n        raise TypeError(\"Input must be a list of lists.\")\n    if not all(all(isinstance(item, (int, float)) for item in sublist) for sublist in list_of_lists):\n        raise TypeError(\"Input lists must contain only numbers.\")\n\n\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = []\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 0}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements within a list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        The list with the highest sum of its elements.  Returns an empty list if the input is empty or invalid.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    \n    max_sum = -float('inf')  # Initialize with negative infinity to handle negative numbers\n    max_list = []\n\n    for lst in list_of_lists:\n        if not all(isinstance(x, (int, float)) for x in lst): #check if all elements are numbers\n            return []\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list", "matching_cluster_idx": 0}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of its elements within a list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        The inner list with the highest sum of its elements.  Returns an empty list if the input is empty or invalid.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity to handle negative numbers\n    max_list = []\n\n    for lst in list_of_lists:\n        if not isinstance(lst, list):\n            return [] #handle invalid input\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n        list_of_lists: A list of lists of numbers.\n\n    Returns:\n        The list with the highest sum of elements.  Returns an empty list if the input is empty or invalid.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    if not all(isinstance(sublist, list) for sublist in list_of_lists):\n        return [] # Handle cases with non-list elements\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = []\n\n    for sublist in list_of_lists:\n        try:\n          current_sum = sum(sublist)\n        except TypeError:\n          return [] # Handle cases with non-numeric elements in sublists\n\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        The list with the highest sum of its elements.  Returns an empty list if the input is empty.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = []\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of its elements within a list of lists.\n\n    Args:\n      list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n      The list with the highest sum of its elements.  Returns an empty list if the input is empty or invalid.\n\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity to handle negative numbers\n    max_list = []\n\n    for lst in list_of_lists:\n        if not all(isinstance(x, (int, float)) for x in lst): #Check for valid numeric input\n            return []\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list", "matching_cluster_idx": 0}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list in a list of lists with the highest sum of elements.\n\n    Args:\n        list_of_lists: A list of lists of numbers.\n\n    Returns:\n        The list with the highest sum of elements.  Returns an empty list if the input is empty or invalid.\n\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    if not all(isinstance(inner_list, list) for inner_list in list_of_lists):\n        return []\n\n    if not all(all(isinstance(num, (int, float)) for num in inner_list) for inner_list in list_of_lists):\n        return []\n\n\n    max_sum = -float('inf')\n    max_list = []\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 0}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists of numbers.\n\n    Returns:\n        The list with the maximum sum of elements.  Returns an empty list if the input is empty or invalid.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity to handle negative numbers\n    max_list = []\n\n    for lst in list_of_lists:\n        if not all(isinstance(x, (int, float)) for x in lst): #check for valid input\n            return []\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 0}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        The list with the highest sum of its elements.  Returns an empty list if the input is empty.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = []\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements in a list of lists.\n\n    Args:\n      list_of_lists: A list of lists of numbers.\n\n    Returns:\n      The list with the highest sum of its elements.  Returns an empty list if the input is empty.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = []\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists of numbers.\n\n    Returns:\n        The list with the maximum sum of elements.  Returns an empty list if the input is empty.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = []\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements within a list of lists.\n\n    Args:\n        list_of_lists: A list of lists of numbers.\n\n    Returns:\n        The list with the highest sum of its elements.  Returns an empty list if the input is empty or invalid.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity to handle negative numbers\n    max_list = []\n\n    for lst in list_of_lists:\n        if not isinstance(lst, list):\n            return [] #Handle invalid input\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        The list with the maximum sum of its elements.  Returns an empty list if the input is empty or invalid.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = []\n\n    for lst in list_of_lists:\n        if not all(isinstance(x, (int, float)) for x in lst): #check if all elements are numbers.\n            return []\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 0}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list in a list of lists with the highest sum of elements.\n\n    Args:\n        list_of_lists: A list of lists of numbers.\n\n    Returns:\n        The list with the highest sum of elements.  Returns an empty list if the input is empty.\n        Raises TypeError if input is not a list of lists of numbers.\n\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n    if not all(isinstance(sublist, list) for sublist in list_of_lists):\n        raise TypeError(\"Input must be a list of lists.\")\n    if not all(all(isinstance(num, (int, float)) for num in sublist) for sublist in list_of_lists):\n        raise TypeError(\"Input lists must contain only numbers.\")\n\n\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = []\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 0}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements within a list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n        The list with the highest sum of its elements.  Returns an empty list if the input is empty or invalid.\n\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    if not all(isinstance(inner_list, list) for inner_list in list_of_lists):\n        return []\n\n    if not all(all(isinstance(num, (int, float)) for num in inner_list) for inner_list in list_of_lists):\n        return []\n\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = []\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 0}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements in a list of lists.\n\n    Args:\n      list_of_lists: A list of lists of numbers.\n\n    Returns:\n      The list with the maximum sum of elements.  Returns an empty list if the input is empty or invalid.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = []\n\n    for lst in list_of_lists:\n        if not isinstance(lst, list):\n            return [] #Handle cases with non-list elements.\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list in a list of lists with the highest sum of elements.\n\n    Args:\n      list_of_lists: A list of lists of numbers.\n\n    Returns:\n      The list with the highest sum of elements.  Returns an empty list if the input is empty.\n      Raises TypeError if input is not a list of lists of numbers.\n\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n    if not all(isinstance(inner_list, list) for inner_list in list_of_lists):\n        raise TypeError(\"Input must be a list of lists.\")\n    if not all(all(isinstance(num, (int, float)) for num in inner_list) for inner_list in list_of_lists):\n        raise TypeError(\"Inner lists must contain only numbers.\")\n\n\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = []\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 0}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements in a list of lists.\n\n    Args:\n      list_of_lists: A list of lists of numbers.\n\n    Returns:\n      The list with the highest sum of its elements.  Returns an empty list if the input is empty.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity to handle negative numbers\n    max_list = []\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists of numbers.\n\n    Returns:\n        The list with the maximum sum of elements.  Returns an empty list if the input is empty or invalid.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    if not all(isinstance(sublist, list) for sublist in list_of_lists):\n        return []  #Handle invalid input\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = []\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list in a list of lists with the highest sum of elements.\n\n    Args:\n      list_of_lists: A list of lists of numbers.\n\n    Returns:\n      The list with the highest sum of elements.  Returns an empty list if the input is empty.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity to handle negative numbers\n    max_list = []\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tuple_data, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n        tuple_data: The input tuple.\n        k: The element to check for.\n\n    Returns:\n        True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in tuple_data", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n        input_tuple: The tuple to search within.\n        k: The element to search for.\n\n    Returns:\n        True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n      input_tuple: The input tuple to search.\n      k: The element to search for.\n\n    Returns:\n      True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n        input_tuple: The input tuple.\n        k: The element to search for.\n\n    Returns:\n        True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific value k.\n\n    Args:\n        input_tuple: The tuple to search within.\n        k: The value to search for.\n\n    Returns:\n        True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n      input_tuple: The input tuple to search.\n      k: The element to search for.\n\n    Returns:\n      True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(my_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n        my_tuple: The input tuple.\n        k: The element to search for.\n\n    Returns:\n        True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in my_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n      input_tuple: The input tuple.\n      k: The element to search for.\n\n    Returns:\n      True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_data, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n        tuple_data: The input tuple.\n        k: The element to search for.\n\n    Returns:\n        True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in tuple_data", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific value k.\n\n    Args:\n        input_tuple: The tuple to search within.\n        k: The value to search for.\n\n    Returns:\n        True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(my_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n      my_tuple: The input tuple.\n      k: The element to search for.\n\n    Returns:\n      True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in my_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n      input_tuple: The input tuple to search.\n      k: The element to search for.\n\n    Returns:\n      True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific value k.\n\n    Args:\n        input_tuple: The input tuple to search.\n        k: The value to search for.\n\n    Returns:\n        True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n        input_tuple: The tuple to search within.\n        k: The element to search for.\n\n    Returns:\n        True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(my_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific value k.\n\n    Args:\n        my_tuple: The input tuple.\n        k: The value to search for.\n\n    Returns:\n        True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in my_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n        input_tuple: The tuple to search within.\n        k: The element to search for.\n\n    Returns:\n        True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(my_tuple, k):\n    \"\"\"\n    Write a function to check if the given tuples contain the k or not.\n    assert check_K((10, 4, 5, 6, 8), 6) == True\n    \"\"\"\n    return k in my_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n        input_tuple: The input tuple to search.\n        k: The element to search for.\n\n    Returns:\n        True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(my_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific element k.\n\n    Args:\n      my_tuple: The input tuple.\n      k: The element to search for.\n\n    Returns:\n      True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in my_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains a specific value k.\n\n    Args:\n        input_tuple: The input tuple to search.\n        k: The value to search for.\n\n    Returns:\n        True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}]}}}
