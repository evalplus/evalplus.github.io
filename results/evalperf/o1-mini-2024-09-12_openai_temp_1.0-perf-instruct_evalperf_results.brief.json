{"date": "2024-11-04 05:09", "config": {"n_samples": 50, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 84.9469710497461, "dps_norm": 83.40681921310014, "pass@1": 86.96610169491525}, "eval": {"HumanEval/9": {"dps": 97.63406940063092, "dps_norm": 98.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum elements found up to each position\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    >>> rolling_max([])\n    []\n    >>> rolling_max([5, 4, 3, 2, 1])\n    [5, 5, 5, 5, 5]\n    >>> rolling_max([2, 2, 2, 2])\n    [2, 2, 2, 2]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum elements found\n    up to each position in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list where each element is the maximum value up to that index.\n\n    Example:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    current_max = numbers[0]\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\nimport doctest\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    >>> rolling_max([])\n    []\n    >>> rolling_max([-1, -2, -3, -2, -1])\n    [-1, -1, -1, -1, -1]\n    >>> rolling_max([5])\n    [5]\n    \"\"\"\n    result = []\n    current_max = None\n    for num in numbers:\n        if current_max is None or num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until each position\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    >>> rolling_max([])\n    []\n    >>> rolling_max([-1, -2, -3])\n    [-1, -1, -1]\n    >>> rolling_max([5, 1, 5, 3, 7, 7, 2])\n    [5, 5, 5, 5, 7, 7, 7]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    >>> rolling_max([5, 1, 5, 3, 7, 2])\n    [5, 5, 5, 5, 7, 7]\n    >>> rolling_max([])\n    []\n    >>> rolling_max([-1, -2, -3, -2, -1])\n    [-1, -1, -1, -1, -1]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\nimport doctest\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum elements found up to\n    each position in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    >>> rolling_max([-1, -2, -3, -2, -1])\n    [-1, -1, -1, -1, -1]\n    >>> rolling_max([5])\n    [5]\n    >>> rolling_max([])\n    []\n    \"\"\"\n    result = []\n    current_max = None\n\n    for num in numbers:\n        if current_max is None or num > current_max:\n            current_max = num\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum elements found up to each position in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"Generate a list of rolling maximum elements found up to each position in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list where each element is the maximum of all elements up to that index.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until each\n    corresponding position in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found up to each position in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum elements found \n    up to each position in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n\n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\nimport doctest\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    >>> rolling_max([5, 1, 5, 3, 7, 2])\n    [5, 5, 5, 5, 7, 7]\n    >>> rolling_max([])\n    []\n    >>> rolling_max([10])\n    [10]\n    \"\"\"\n    result = []\n    current_max = float('-inf')  # Initialize to negative infinity to handle all integer inputs\n\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum elements found up to each position.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    current_max = numbers[0]\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/0": {"dps": 38.72093023255814, "dps_norm": 52.85714285714286, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        return False\n\n    # Sort the list to bring close elements next to each other\n    sorted_numbers = sorted(numbers)\n\n    # Iterate through the sorted list and check adjacent differences\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i + 1] - sorted_numbers[i]) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in the given list of numbers, any two numbers are closer to each other \n    than the given threshold.\n\n    Args:\n        numbers (List[float]): The list of numbers to check.\n        threshold (float): The threshold distance.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n    \"\"\"\n    if len(numbers) < 2:\n        return False  # No pairs to compare.\n\n    # Sort the list to ensure that any close elements are adjacent.\n    sorted_numbers = sorted(numbers)\n\n    # Iterate through the sorted list and check the difference between adjacent elements.\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i + 1] - sorted_numbers[i]) < threshold:\n            return True  # Found a pair closer than threshold.\n\n    return False  # No pairs closer than threshold found.", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers:\n        return False\n    sorted_numbers = sorted(numbers)\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    >>> has_close_elements([], 1.0)\n    False\n    >>> has_close_elements([1.5], 0.5)\n    False\n    >>> has_close_elements([1.0, 1.4, 2.5, 3.1], 0.5)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    >>> has_close_elements([], 1.0)\n    False\n    >>> has_close_elements([5.0], 1.0)\n    False\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i + 1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers or threshold < 0:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if any two numbers in the list are closer to each other than the given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    # Sort the list to bring close elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    >>> has_close_elements([], 1.0)\n    False\n    >>> has_close_elements([1.5], 1.0)\n    False\n    >>> has_close_elements([1.0, 1.4, 2.9, 3.1], 0.5)\n    True\n    >>> has_close_elements([10.0, 20.0, 30.0], 15.0)\n    True\n    >>> has_close_elements([5.5, 5.5, 5.5], 0.0)\n    True\n    >>> has_close_elements([0.1, 0.2, 0.3, 0.4], 0.15)\n    True\n    >>> has_close_elements([100.0, 200.0, 300.0], 50.0)\n    False\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i + 1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in a given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False  # No pairs exist\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    Args:\n        numbers (List[float]): The list of floating-point numbers to check.\n        threshold (float): The threshold distance.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        return False\n\n    # Sort the list to ensure that the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n\n    # Iterate through the sorted list and check adjacent pairs\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in a given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        return False\n\n    # Sort the list to bring close elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through sorted numbers and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    \n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    # Sort the list to bring close elements next to each other\n    sorted_numbers = sorted(numbers)\n\n    # Iterate through sorted list and check adjacent differences\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i + 1] - sorted_numbers[i]) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 86.13924050632912, "dps_norm": 95.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the Mean Absolute Deviation (MAD) around the mean of the dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and the mean of the dataset:\n    \n    MAD = average |x - x_mean|\n    \n    Args:\n        numbers (List[float]): A list of numerical values.\n    \n    Returns:\n        float: The mean absolute deviation of the input numbers.\n    \n    Raises:\n        ValueError: If the input list is empty.\n    \n    Examples:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    \n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([5.5, 6.5, 7.5])\n    0.6666666666666666\n    >>> mean_absolute_deviation([])\n    0.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    total_absolute_deviation = sum(abs(x - mean) for x in numbers)\n    mad = total_absolute_deviation / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([10, 20, 30])\n    6.666666666666667\n    >>> mean_absolute_deviation([])\n    0.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    mean = sum(numbers) / len(numbers)\n    total_deviation = sum(abs(x - mean) for x in numbers)\n    return total_deviation / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the Mean Absolute Deviation (MAD) around the mean of the dataset.\n\n    MAD is the average absolute difference between each element and the mean of the dataset.\n\n    Args:\n        numbers (List[float]): A list of numerical values.\n\n    Returns:\n        float: The Mean Absolute Deviation.\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n\n    mean = sum(numbers) / len(numbers)\n    total_absolute_deviation = sum(abs(x - mean) for x in numbers)\n    mad = total_absolute_deviation / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([5.5, 2.2, 3.3, 4.4, 1.1])\n    1.76\n    >>> mean_absolute_deviation([])\n    Traceback (most recent call last):\n        ...\n    ValueError: The list of numbers is empty\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty\")\n    \n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Calculate the Mean Absolute Deviation (MAD) around the mean of a dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each\n    element and the mean of the dataset.\n\n    Args:\n        numbers (List[float]): A list of numerical values.\n\n    Returns:\n        float: The Mean Absolute Deviation.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = (abs(x - mean) for x in numbers)\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport doctest\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([5.0, 7.0, 3.0, 7.0])\n    2.0\n    >>> mean_absolute_deviation([])\n    Traceback (most recent call last):\n        ...\n    ValueError: The list of numbers is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    total_deviation = sum(abs(x - mean) for x in numbers)\n    mad = total_deviation / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    \n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    total_absolute_diff = sum(abs(x - mean) for x in numbers)\n    mad = total_absolute_diff / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    total_deviation = sum(abs(x - mean) for x in numbers)\n    mad = total_deviation / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([10.0, 20.0, 30.0])\n    6.666666666666667\n    >>> mean_absolute_deviation([])\n    Traceback (most recent call last):\n        ...\n    ValueError: The list of numbers is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the Mean Absolute Deviation (MAD) around the mean of the dataset.\n\n    MAD is the average absolute difference between each element and the mean of the dataset.\n    \n    Args:\n        numbers (List[float]): A list of numerical values.\n    \n    Returns:\n        float: The Mean Absolute Deviation.\n    \n    Examples:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    total_absolute_deviation = sum(abs(x - mean) for x in numbers)\n    mad = total_absolute_deviation / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    total_absolute_deviation = sum(abs(x - mean) for x in numbers)\n    mad = total_absolute_deviation / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport doctest\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and the mean of the dataset:\n    \n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([5.0, 7.0, 3.0, 7.0])\n    1.5\n    >>> mean_absolute_deviation([])\n    0.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    mean = sum(numbers) / len(numbers)\n    total_deviation = sum(abs(x - mean) for x in numbers)\n    mad = total_deviation / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    total_absolute_diff = sum(abs(x - mean) for x in numbers)\n    mad = total_absolute_diff / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n\n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate the absolute differences from the mean\n    absolute_differences = (abs(x - mean) for x in numbers)\n\n    # Calculate the Mean Absolute Deviation\n    mad = sum(absolute_differences) / len(numbers)\n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([5.0, 5.0, 5.0])\n    0.0\n    >>> mean_absolute_deviation([])\n    Traceback (most recent call last):\n        ...\n    ValueError: The list of numbers is empty\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty\")\n    \n    mean = sum(numbers) / len(numbers)\n    total_deviation = sum(abs(x - mean) for x in numbers)\n    return total_deviation / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([5.0, 7.0, 3.0, 7.0])\n    1.5\n    >>> mean_absolute_deviation([10.0])\n    0.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n\n    mean = sum(numbers) / len(numbers)\n    total_deviation = 0.0\n    for number in numbers:\n        total_deviation += abs(number - mean)\n    mad = total_deviation / len(numbers)\n    return mad", "matching_cluster_idx": 5}]}, "HumanEval/16": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('')\n    0\n    >>> count_distinct_characters('AaBbCc123!@#')\n    9\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    normalized_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    >>> count_distinct_characters('')\n    0\n    \"\"\"\n    # Convert the string to lowercase to ensure case-insensitivity\n    lowercased_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercased_string)\n    # Remove any whitespace or non-alphabetic characters if needed\n    # unique_characters = set(char for char in lowercased_string if char.isalpha())\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    >>> count_distinct_characters('')\n    0\n    >>> count_distinct_characters('AaBbCc')\n    3\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lower_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lower_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('')\n    0\n    >>> count_distinct_characters('AaAaA')\n    1\n    >>> count_distinct_characters('Hello, World!')\n    10\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    normalized_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('')\n    0\n    >>> count_distinct_characters('AaBbCc123!@#')\n    9\n    \"\"\"\n    # Normalize the string to lowercase to ensure case-insensitivity\n    normalized_string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set(normalized_string)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lower_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lower_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    >>> count_distinct_characters('')\n    0\n    \"\"\"\n    # Convert the string to lowercase to ensure case-insensitivity\n    lowercase_string = string.lower()\n    # Create a set of characters to eliminate duplicates\n    distinct_chars = set(lowercase_string)\n    # Optionally, remove non-alphabetic characters if only letters are considered\n    # distinct_chars = set(filter(str.isalpha, lowercase_string))\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case-insensitivity\n    normalized_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    >>> count_distinct_characters('')\n    0\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lowered_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowered_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    normalized_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    normalized_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    normalized_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    >>> count_distinct_characters('')\n    0\n    >>> count_distinct_characters('AaAaA')\n    1\n    \"\"\"\n    # Convert the string to lowercase to make the function case-insensitive\n    normalized_string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    \n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string to evaluate.\n\n    Returns:\n        int: The number of distinct characters in the string, case-insensitive.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to lowercase to ensure case-insensitivity\n    lowercase_string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    \n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    >>> count_distinct_characters('')\n    0\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lower_string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(lower_string)\n    # If you want to count only alphabetic characters, uncomment the next line\n    # unique_chars = set(char for char in lower_string if char.isalpha())\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string to evaluate.\n\n    Returns:\n        int: The number of distinct characters in the string, case-insensitive.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n        >>> count_distinct_characters('Hello, World!')\n        10\n        >>> count_distinct_characters('')\n        0\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lower_string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(lower_string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    >>> count_distinct_characters('')\n    0\n    >>> count_distinct_characters('AaBbCc')\n    3\n    \"\"\"\n    # Convert the string to lowercase to ensure case-insensitivity\n    normalized_string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    \n    # If you want to exclude non-alphabetic characters, uncomment the following line:\n    # unique_characters = set(filter(str.isalpha, normalized_string))\n    \n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    Args:\n        string (str): The input string to evaluate.\n        \n    Returns:\n        int: The number of distinct characters in the string, ignoring case.\n        \n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    normalized_string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    \n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -3.2, -2.8, 0.0, 4.5])\n    (-2.8, -1.5)\n    >>> find_closest_elements([10.0, 10.0])\n    (10.0, 10.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list to bring closest elements near each other\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate through the sorted list to find the minimal difference\n    for i in range(1, len(sorted_numbers)):\n        current = sorted_numbers[i]\n        previous = sorted_numbers[i - 1]\n        diff = current - previous\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (previous, current)\n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -3.2, -4.8, -2.1, -3.1])\n    (-3.2, -3.1)\n    >>> find_closest_elements([10.5, 10.1, 9.8, 10.3])\n    (10.1, 10.3)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(1, len(sorted_numbers)):\n        current = sorted_numbers[i]\n        previous = sorted_numbers[i - 1]\n        diff = current - previous\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (previous, current)\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"At least two numbers are required\")\n    \n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    for i in range(1, len(sorted_numbers)):\n        current = sorted_numbers[i]\n        previous = sorted_numbers[i - 1]\n        diff = current - previous\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (previous, current)\n            if min_diff == 0:\n                break  # Early exit since you can't get closer than this\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the smallest difference\n    for i in range(1, len(sorted_numbers)):\n        current_diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n\n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize with the first pair\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n\n    # Iterate through the sorted list to find the minimum difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the closest pair\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n    \n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize with the first pair\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    # Sort the numbers to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(len(sorted_numbers) - 1):\n        current = sorted_numbers[i]\n        next_num = sorted_numbers[i + 1]\n        diff = next_num - current\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (current, next_num)\n            # If the smallest possible difference is found, break early\n            if min_diff == 0:\n                break\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list to bring closest numbers next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize with the first pair\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -3.2, -2.1, 0.0])\n    (-2.1, -1.5)\n    >>> find_closest_elements([10.5, 10.1, 10.3, 10.2])\n    (10.1, 10.2)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    for i in range(len(sorted_numbers) - 1):\n        first = sorted_numbers[i]\n        second = sorted_numbers[i + 1]\n        diff = second - first\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (first, second)\n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -3.2, -1.4, 0.0])\n    (-1.5, -1.4)\n    >>> find_closest_elements([10.0, 10.0])\n    (10.0, 10.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    min_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(2, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            min_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n\n    return min_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        current = sorted_numbers[i]\n        next_num = sorted_numbers[i + 1]\n        diff = next_num - current\n        \n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (current, next_num)\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference to a large number\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list and find the pair with the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n            \n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n                \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference with the first pair\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate through the list to find the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n            if min_diff == 0:\n                break  # Can't get smaller than zero\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference with the first pair\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -3.2, -1.4, 0.0, 2.2])\n    (-1.5, -1.4)\n    >>> find_closest_elements([10.0, 10.1])\n    (10.0, 10.1)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list and find the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n            # If the smallest possible difference is found, break early\n            if min_diff == 0:\n                break\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -3.2, -2.8, 0.0, 2.1])\n    (-2.8, -2.0)\n    >>> find_closest_elements([10.5, 10.4])\n    (10.4, 10.5)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport sys\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -3.2, -2.8, 0.0, 4.5])\n    (-2.8, -1.5)\n    >>> find_closest_elements([10.0, 10.0])\n    (10.0, 10.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = sys.float_info.max\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(len(sorted_numbers) - 1):\n        first, second = sorted_numbers[i], sorted_numbers[i + 1]\n        diff = second - first\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (first, second)\n            # Early exit if the smallest possible difference is found\n            if min_diff == 0.0:\n                break\n\n    return closest_pair", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 85.34013605442178, "dps_norm": 61.25, "pass@1": 96.0, "profiled": [{"solution": "import math\nimport doctest\ndef largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(1)\n    None\n    >>> largest_divisor(0)\n    None\n    \"\"\"\n    if n <= 1:\n        return None  # No divisors less than n for n <= 1\n\n    max_divisor = 1\n    sqrt_n = int(math.sqrt(n))\n\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            counterpart = n // i\n            if counterpart < n and counterpart > max_divisor:\n                max_divisor = counterpart\n            if i < n and i > max_divisor:\n                max_divisor = i\n\n    return max_divisor", "matching_cluster_idx": 6}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(0)\n    0\n    >>> largest_divisor(-10)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # No proper divisors for n <= 1\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback, though it should never reach here for n > 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 0  # In case no divisor is found, which only happens if n <=1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    Args:\n        n (int): The number to find the largest proper divisor for.\n\n    Returns:\n        int: The largest proper divisor of n.\n\n    Raises:\n        ValueError: If n is less than or equal to 1.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(16)\n        8\n        >>> largest_divisor(13)\n        1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    \n    # Start checking from 2 up to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, n//i will be the largest proper divisor\n            return n // i\n    \n    # If no divisor found, n is prime and its largest proper divisor is 1\n    return 1", "matching_cluster_idx": 5}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    Args:\n        n (int): The number to find the largest divisor for.\n        \n    Returns:\n        int: The largest divisor of n smaller than n.\n        \n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(28)\n        14\n        >>> largest_divisor(7)\n        1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1.\")\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback, though for n > 1, 1 is always a divisor", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(16)\n    8\n    >>> largest_divisor(17)\n    1\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(0)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # No proper divisors for n <= 1\n    # Start checking from the largest possible divisor down to 1\n    # To optimize, find the smallest prime factor and divide n by it\n    def smallest_prime_factor(x: int) -> int:\n        if x % 2 == 0:\n            return 2\n        for i in range(3, int(x**0.5) + 1, 2):\n            if x % i == 0:\n                return i\n        return x  # x is prime\n\n    spf = smallest_prime_factor(n)\n    if spf == n:\n        return 1  # n is prime\n    return n // spf", "matching_cluster_idx": 7}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1.\")\n    \n    # Start checking from the largest possible divisor\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1  # Fallback, though 1 is always a divisor", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(100)\n    50\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(13)\n    1\n    \"\"\"\n    if n <= 1:\n        return 0  # No divisors less than n for n <= 1\n\n    # Start checking from n//2 down to 1 for the largest divisor\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n\n    return 0  # Fallback, though for n > 1, this line should never be reached", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(21)\n    7\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1.\")\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <= 1:\n        return 0  # No proper divisors for n <= 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback, though the loop should return before this", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <= 1:\n        return 0  # No divisors smaller than n for n <= 1\n\n    # Start checking from n//2 down to 1\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1  # Fallback, should never reach here for n > 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(16)\n    8\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(1)\n    1\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    # Function to find the smallest prime factor\n    def smallest_prime_factor(x: int) -> int:\n        if x % 2 == 0:\n            return 2\n        for i in range(3, int(x**0.5) + 1, 2):\n            if x % i == 0:\n                return i\n        return x  # x is prime\n    \n    spf = smallest_prime_factor(n)\n    if spf == n:\n        return 1\n    return n // spf", "matching_cluster_idx": 7}, {"solution": "import doctest\ndef largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(100)\n    50\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # No proper divisors for n <= 1\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(1)\n    None\n    >>> largest_divisor(0)\n    None\n    \"\"\"\n    if n <= 1:\n        return None  # No divisors exist for n <= 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # No divisors less than n for n <= 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback, should never reach here for n > 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(0)\n    0\n    >>> largest_divisor(-10)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # No proper divisors for n <= 1\n\n    # Start checking from n//2 down to 1 for the largest divisor\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor\n\n    return 1  # Fallback, although this line should never be reached for n > 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1.\")\n\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1.\")\n    \n    # Start checking from n//2 down to 1\n    for d in range(n // 2, 0, -1):\n        if n % d == 0:\n            return d", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    \"\"\"\n    if n <= 1:\n        return 0  # No divisors for numbers less than or equal to 1\n\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor\n\n    return 1  # Fallback, though the loop should always return", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(1)\n    None\n    \"\"\"\n    if n <= 1:\n        return None  # No divisors less than n for n <= 1\n\n    max_divisor = 1\n    sqrt_n = int(n ** 0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            corresponding_divisor = n // i\n            if i != n and i > max_divisor:\n                max_divisor = i\n            if corresponding_divisor != n and corresponding_divisor > max_divisor:\n                max_divisor = corresponding_divisor\n\n    return max_divisor", "matching_cluster_idx": 6}]}, "HumanEval/26": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([5, 5, 5, 5])\n    []\n    >>> remove_duplicates([10, 20, 30, 40, 50])\n    [10, 20, 30, 40, 50]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5])\n    [1, 3, 5]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([10, 20, 30, 40])\n    [10, 20, 30, 40]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 5, 4, 6, 7])\n    [6, 7]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\nimport doctest\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([10])\n    [10]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    >>> remove_duplicates([1,1,1,1])\n    []\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\nimport doctest\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 6, 5, 4, 7])\n    [6, 7]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    >>> remove_duplicates([2, 2, 2, 2])\n    []\n    \"\"\"\n    # Count the occurrences of each number\n    counts = Counter(numbers)\n    \n    # Filter out numbers that occur more than once, preserving order\n    unique_numbers = [num for num in numbers if counts[num] == 1]\n    \n    return unique_numbers", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([5, 5, 5, 5])\n    []\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the frequency of each number in the list\n    counts = Counter(numbers)\n    \n    # Collect numbers that occur exactly once, preserving order\n    unique_numbers = [num for num in numbers if counts[num] == 1]\n    \n    return unique_numbers", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 85.75949367088607, "dps_norm": 84.375, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True", "matching_cluster_idx": 5}, {"solution": "import math\nimport doctest\ndef is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    sqrt_n = int(math.sqrt(n)) + 1\n    for i in range(5, sqrt_n, 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True", "matching_cluster_idx": 5}, {"solution": "import math\nimport doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True  # 2 and 3 are primes\n    if n % 2 == 0 or n % 3 == 0:\n        return False  # eliminate multiples of 2 and 3\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(math.sqrt(n)) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import math\nimport doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    sqrt_n = int(math.isqrt(n))\n    i = 5\n    while i <= sqrt_n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n\n    sqrt_n = int(n**0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n ** 0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w  # This allows us to check 6k \u00b1 1\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": 97.22222222222223, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three,\n    while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Identify the indices divisible by three\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Replace the values at the divisible indices with the sorted values\n    for index, sorted_val in zip(divisible_by_three_indices, sorted_values):\n        sorted_list[index] = sorted_val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices\n    that are divisible by three are equal to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    \n    # Extract the indices divisible by three\n    indices = list(range(0, len(l), 3))\n    \n    # Extract the values at these indices\n    values = [l[i] for i in indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values)\n    \n    # Assign the sorted values back to their respective positions\n    for idx, val in zip(indices, sorted_values):\n        result[idx] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract indices divisible by three\n    divisible_by_three_indices = range(0, len(l), 3)\n    \n    # Extract and sort the values at these indices\n    sorted_values = sorted(l[i] for i in divisible_by_three_indices)\n    \n    # Create an iterator for the sorted values\n    sorted_iter = iter(sorted_values)\n    \n    # Build the new list with sorted values at the specified indices\n    return [next(sorted_iter) if i % 3 == 0 else x for i, x in enumerate(l)]", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Find all indices divisible by three\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract and sort the values at these indices\n    sorted_values = sorted(l[i] for i in indices)\n    \n    # Create a copy of the original list to avoid modifying it\n    l_new = l.copy()\n    \n    # Replace the values at the divisible indices with the sorted values\n    for i, val in zip(indices, sorted_values):\n        l_new[i] = val\n    \n    return l_new", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([9, 1, 4, 3, 7, 2, 6, 5, 8, 0, 3])\n    [0, 1, 4, 3, 7, 2, 6, 5, 8, 0, 3]\n    \"\"\"\n    # Find indices divisible by 3 (0-based indexing)\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to avoid mutating it\n    sorted_list = l.copy()\n    \n    # Replace the values at the specified indices with the sorted values\n    for index, sorted_val in zip(divisible_by_three_indices, sorted_values):\n        sorted_list[index] = sorted_val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Identify indices divisible by three\n    divisible_indices = [i for i in range(len(l)) if i % 3 == 0]\n    # Extract corresponding values\n    divisible_values = [l[i] for i in divisible_indices]\n    # Sort the extracted values\n    sorted_values = sorted(divisible_values)\n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    # Assign sorted values back to their respective indices\n    for idx, value in zip(divisible_indices, sorted_values):\n        sorted_list[idx] = value\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three,\n    while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([9, 1, 4, 3, 7, 2, 8, 5, 6, 0])\n    [3, 1, 4, 5, 7, 2, 6, 5, 6, 0]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    indices = list(range(0, len(l), 3))\n    elements_to_sort = [l[i] for i in indices]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements_to_sort)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Replace the elements at the specified indices with sorted values\n    for idx, val in zip(indices, sorted_elements):\n        sorted_list[idx] = val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([10, 20, 30, 40, 50, 60, 70, 80, 90])\n    [10, 20, 30, 40, 50, 60, 70, 80, 90]\n    >>> sort_third([9, 1, 5, 3, 7, 2, 8, 4, 6])\n    [3, 1, 5, 4, 7, 2, 6, 4, 6]\n    \"\"\"\n    # Identify indices divisible by three (0-based)\n    divisible_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    divisible_values = [l[i] for i in divisible_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(divisible_values)\n    \n    # Create a copy of the original list to avoid modifying it directly\n    sorted_list = l.copy()\n    \n    # Assign the sorted values back to their respective indices\n    for idx, value in zip(divisible_indices, sorted_values):\n        sorted_list[idx] = value\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Identify indices that are divisible by three\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to modify\n    sorted_list = l.copy()\n    \n    # Replace the values at the specified indices with the sorted values\n    for index, value in zip(divisible_by_three_indices, sorted_values):\n        sorted_list[index] = value\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Identify the indices divisible by three (0-based)\n    divisible_by_three_indices = list(range(0, len(l), 3))\n    \n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Assign the sorted values back to their respective positions\n    for index, value in zip(divisible_by_three_indices, sorted_values):\n        l[index] = value\n    \n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Identify indices divisible by three (0-based)\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to modify\n    sorted_list = l.copy()\n    \n    # Replace the values at the specified indices with the sorted values\n    for index, sorted_val in zip(divisible_by_three_indices, sorted_values):\n        sorted_list[index] = sorted_val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Find all indices divisible by three\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Replace the original values with the sorted values at the specified indices\n    for idx, sorted_val in zip(divisible_by_three_indices, sorted_values):\n        sorted_list[idx] = sorted_val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Identify indices divisible by three\n    divisible_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to modify\n    sorted_list = l.copy()\n    \n    # Replace the values at the divisible indices with the sorted values\n    for idx, value in zip(divisible_indices, sorted_values):\n        sorted_list[idx] = value\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Identify indices divisible by three\n    divisible_by_three = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract elements at those indices\n    elements = [l[i] for i in divisible_by_three]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements)\n    \n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    \n    # Replace the elements at the divisible indices with the sorted elements\n    for idx, sorted_val in zip(divisible_by_three, sorted_elements):\n        result[idx] = sorted_val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by three\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    sorted_values = sorted(l[i] for i in indices)\n    \n    # Create a copy of the list to avoid modifying the original\n    result = l.copy()\n    \n    # Replace the values at the specified indices with sorted values\n    for idx, sorted_val in zip(indices, sorted_values):\n        result[idx] = sorted_val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([9, 1, 7, 3, 5, 2, 8, 4, 6])\n    [3, 1, 7, 4, 5, 2, 6, 4, 9]\n    \"\"\"\n    # Identify indices divisible by three\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract values at these indices\n    values_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to avoid mutating it\n    sorted_list = l.copy()\n    \n    # Assign the sorted values back to their respective indices\n    for index, value in zip(divisible_by_three_indices, sorted_values):\n        sorted_list[index] = value\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list `l` and returns a list `l'` such that\n    `l'` is identical to `l` in the indices that are not divisible by three,\n    while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of `l`, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Identify indices divisible by three\n    divisible_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    divisible_values = [l[i] for i in divisible_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(divisible_values)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Replace the values at divisible indices with the sorted values\n    for idx, val in zip(divisible_indices, sorted_values):\n        sorted_list[idx] = val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([9, 1, 4, 3, 5, 2, 7, 8, 6])\n    [3, 1, 4, 6, 5, 2, 7, 8, 9]\n    \"\"\"\n    # Find the indices divisible by three (0-based)\n    divisible_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    divisible_values = [l[i] for i in divisible_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(divisible_values)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Replace the values at the divisible indices with the sorted values\n    for idx, val in zip(divisible_indices, sorted_values):\n        sorted_list[idx] = val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Find all indices divisible by three\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the elements at these indices\n    elements_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements_to_sort)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Replace the elements at the divisible indices with the sorted elements\n    for index, sorted_value in zip(divisible_by_three_indices, sorted_elements):\n        sorted_list[index] = sorted_value\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [value for index, value in enumerate(l) if index % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible = sorted(divisible_by_three)\n    \n    # Create an iterator for the sorted elements\n    sorted_iter = iter(sorted_divisible)\n    \n    # Build the new list by replacing elements at divisible indices with sorted ones\n    result = [\n        next(sorted_iter) if index % 3 == 0 else value\n        for index, value in enumerate(l)\n    ]\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 97.98387096774192, "dps_norm": 82.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    multiples = set()\n\n    # Add multiples of 11\n    for i in range(11, n, 11):\n        multiples.add(i)\n\n    # Add multiples of 13\n    for i in range(13, n, 13):\n        multiples.add(i)\n\n    # Count the number of '7's in all collected multiples\n    count = sum(str(number).count('7') for number in multiples)\n\n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    multiples = set()\n\n    # Add multiples of 11\n    for i in range(11, n, 11):\n        multiples.add(i)\n\n    # Add multiples of 13\n    for i in range(13, n, 13):\n        multiples.add(i)\n\n    # Count the number of '7's in all unique multiples\n    count = 0\n    for number in multiples:\n        count += str(number).count('7')\n\n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(11, n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    multiples = set(range(11, n, 11)) | set(range(13, n, 13))\n    return sum(str(num).count('7') for num in multiples)", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(11, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    lcm = 11 * 13  # Least common multiple of 11 and 13 to avoid double-counting\n\n    # Count '7's in multiples of 11\n    for multiple in range(11, n, 11):\n        count += str(multiple).count('7')\n\n    # Count '7's in multiples of 13\n    for multiple in range(13, n, 13):\n        # Skip multiples of both 11 and 13 to avoid double-counting\n        if multiple % lcm == 0:\n            continue\n        count += str(multiple).count('7')\n\n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    # Calculate the least common multiple of 11 and 13 to avoid double counting\n    lcm_11_13 = 11 * 13  # 143\n    \n    # Count multiples of 11\n    for num in range(11, n, 11):\n        count += str(num).count('7')\n    \n    # Count multiples of 13\n    for num in range(13, n, 13):\n        # Skip multiples of both 11 and 13 to prevent double counting\n        if num % lcm_11_13 != 0:\n            count += str(num).count('7')\n    \n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    # Calculate the least common multiple of 11 and 13 to handle overlapping multiples\n    lcm = 11 * 13\n\n    # Count '7's in multiples of 11\n    for i in range(11, n, 11):\n        count += str(i).count('7')\n    \n    # Count '7's in multiples of 13\n    for i in range(13, n, 13):\n        # Avoid double-counting numbers divisible by both 11 and 13\n        if i % 11 != 0:\n            count += str(i).count('7')\n    \n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    2\n    \"\"\"\n    multiples = set()\n    \n    # Add multiples of 11\n    for i in range(11, n, 11):\n        multiples.add(i)\n    \n    # Add multiples of 13\n    for i in range(13, n, 13):\n        multiples.add(i)\n    \n    # Count the number of '7's in all multiples\n    count = 0\n    for num in multiples:\n        count += str(num).count('7')\n    \n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(1, n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    multiples = set(range(11, n, 11)).union(range(13, n, 13))\n    return sum(str(num).count('7') for num in multiples)", "matching_cluster_idx": 6}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(1, n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    def count_sevens(num: int) -> int:\n        return str(num).count('7')\n    \n    def sum_sevens(divisor: int) -> int:\n        return sum(count_sevens(num) for num in range(divisor, n, divisor))\n    \n    total_sevens = sum_sevens(11) + sum_sevens(13) - sum_sevens(143)\n    return total_sevens", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    multiples = set()\n\n    # Add multiples of 11\n    for i in range(11, n, 11):\n        multiples.add(i)\n        \n    # Add multiples of 13\n    for i in range(13, n, 13):\n        multiples.add(i)\n    \n    # Count the number of '7's in all collected multiples\n    count = sum(str(num).count('7') for num in multiples)\n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(11, n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # Generate all multiples of 11 and 13 below n\n    multiples = set(range(11, n, 11)) | set(range(13, n, 13))\n    # Count the number of '7's in the string representation of each multiple\n    return sum(str(number).count('7') for number in multiples)", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    multiples = set()\n\n    # Generate multiples of 11\n    for i in range(11, n, 11):\n        multiples.add(i)\n    \n    # Generate multiples of 13\n    for i in range(13, n, 13):\n        multiples.add(i)\n    \n    # Count the occurrences of digit '7' in all collected multiples\n    count = sum(str(number).count('7') for number in multiples)\n    \n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(1, n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    multiples = set()\n    \n    # Add multiples of 11\n    multiples.update(range(11, n, 11))\n    \n    # Add multiples of 13\n    multiples.update(range(13, n, 13))\n    \n    # Count the number of '7's in all collected multiples\n    count_sevens = sum(str(number).count('7') for number in multiples)\n    \n    return count_sevens", "matching_cluster_idx": 6}]}, "HumanEval/37": {"dps": 96.70212765957447, "dps_norm": 93.5, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 8, 3, 6, 5])\n    [6, 1, 8, 3, 10, 5]\n    >>> sort_even([])\n    []\n    >>> sort_even([7])\n    [7]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even elements\n    sorted_evens = sorted(even_elements)\n    \n    # Initialize a list to store the result\n    result = []\n    # Pointer for sorted even elements\n    even_ptr = 0\n    \n    # Iterate through the original list\n    for index in range(len(l)):\n        if index % 2 == 0:\n            # Replace even index with sorted even element\n            result.append(sorted_evens[even_ptr])\n            even_ptr += 1\n        else:\n            # Keep odd index elements unchanged\n            result.append(l[index])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    sorted_evens = sorted(l[::2])\n    \n    # Create a copy of the original list to avoid modifying it\n    l_prime = l.copy()\n    \n    # Replace even-indexed elements with the sorted ones\n    l_prime[::2] = sorted_evens\n    \n    return l_prime", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([])\n    []\n    >>> sort_even([10])\n    [10]\n    >>> sort_even([4, 1, 3, 2, 5, 0])\n    [3, 1, 4, 2, 5, 0]\n    \"\"\"\n    # Extract values at even indices\n    even_indices = list(range(0, len(l), 2))\n    even_values = [l[i] for i in even_indices]\n    \n    # Sort the even values\n    sorted_evens = sorted(even_values)\n    \n    # Create a copy of the original list to modify\n    sorted_list = l.copy()\n    \n    # Replace the even indices with sorted values\n    for idx, sorted_val in zip(even_indices, sorted_evens):\n        sorted_list[idx] = sorted_val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even elements\n    sorted_evens = sorted(even_elements)\n    \n    # Create an iterator for the sorted even elements\n    sorted_iter = iter(sorted_evens)\n    \n    # Build the resulting list\n    result = []\n    for index, value in enumerate(l):\n        if index % 2 == 0:\n            # Replace with the next sorted even element\n            result.append(next(sorted_iter))\n        else:\n            # Keep the original odd index element\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([])\n    []\n    >>> sort_even([10])\n    [10]\n    >>> sort_even([4, 1, 2, 3, 5])\n    [2, 1, 4, 3, 5]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    # Replace the even indices with the sorted elements\n    result[::2] = sorted_even\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([])\n    []\n    >>> sort_even([10])\n    [10]\n    >>> sort_even([4, 1, 3, 2, 5, 0])\n    [3, 1, 4, 2, 5, 0]\n    \"\"\"\n    # Extract values at even indices\n    even_values = l[::2]\n    # Sort the even-indexed values\n    sorted_even = sorted(even_values)\n    # Create an iterator for the sorted even values\n    sorted_iter = iter(sorted_even)\n    # Reconstruct the list with sorted even-indexed values and original odd-indexed values\n    return [next(sorted_iter) if idx % 2 == 0 else val for idx, val in enumerate(l)]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 8, 3, 6, 5])\n    [6, 1, 8, 3, 10, 5]\n    >>> sort_even([])\n    []\n    >>> sort_even([7])\n    [7]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even-indexed elements\n    sorted_evens = sorted(even_elements)\n    \n    # Initialize an iterator for the sorted even elements\n    sorted_iter = iter(sorted_evens)\n    \n    # Reconstruct the list by replacing even indices with sorted elements\n    result = []\n    for index, value in enumerate(l):\n        if index % 2 == 0:\n            result.append(next(sorted_iter))\n        else:\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 7, 3, 5, 2])\n    [5, 1, 7, 3, 10, 2]\n    >>> sort_even([])\n    []\n    >>> sort_even([4])\n    [4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even-indexed elements\n    sorted_evens = sorted(even_elements)\n    # Create a copy of the original list to hold the result\n    result = l.copy()\n    # Replace the even indices with the sorted elements\n    even_indices = range(0, len(l), 2)\n    for idx, val in zip(even_indices, sorted_evens):\n        result[idx] = val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the even elements\n    sorted_evens = sorted(even_elements)\n    # Create an iterator for the sorted even elements\n    sorted_evens_iter = iter(sorted_evens)\n    # Build the new list by replacing even indices with sorted elements\n    sorted_list = [\n        next(sorted_evens_iter) if i % 2 == 0 else l[i]\n        for i in range(len(l))\n    ]\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([])\n    []\n    >>> sort_even([10])\n    [10]\n    >>> sort_even([4, 1, 3, 2, 5])\n    [3, 1, 4, 2, 5]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even-indexed elements\n    sorted_evens = sorted(even_elements)\n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    # Replace the even indices with the sorted even elements\n    result[::2] = sorted_evens\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([])\n    []\n    >>> sort_even([10])\n    [10]\n    >>> sort_even([4, 1, 3, 2, 5, 0])\n    [3, 1, 4, 2, 5, 0]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even elements\n    sorted_evens = sorted(even_elements)\n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    # Replace the even indices with sorted even elements\n    sorted_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = sorted_evens[sorted_index]\n        sorted_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even elements\n    sorted_evens = sorted(even_elements)\n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    # Replace the even indices with the sorted even elements\n    result[::2] = sorted_evens\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 8, 3, 2, 4])\n    [2, 1, 8, 3, 10, 4]\n    >>> sort_even([])\n    []\n    >>> sort_even([7])\n    [7]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the extracted even elements\n    sorted_evens = sorted(even_elements)\n    # Create an iterator for the sorted even elements\n    sorted_evens_iter = iter(sorted_evens)\n    # Reconstruct the list with sorted even indices and original odd indices\n    result = [\n        next(sorted_evens_iter) if index % 2 == 0 else value\n        for index, value in enumerate(l)\n    ]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([4, 1, 3, 2, 5, 0])\n    [3, 1, 4, 2, 5, 0]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = sorted(l[::2])\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Assign the sorted even elements back to their respective positions\n    sorted_list[::2] = even_elements\n    \n    return sorted_list", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices = range(0, len(l), 2)\n    evens = [l[i] for i in even_indices]\n    \n    # Sort the even-indexed elements\n    sorted_evens = sorted(evens)\n    \n    # Create an iterator for the sorted even elements\n    sorted_iter = iter(sorted_evens)\n    \n    # Reconstruct the list with sorted even elements and original odd elements\n    result = [\n        next(sorted_iter) if i % 2 == 0 else l[i]\n        for i in range(len(l))\n    ]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the even elements\n    sorted_evens = sorted(even_elements)\n    # Create a copy of the original list to maintain odd indices\n    result = l.copy()\n    # Assign sorted even elements back to their respective positions\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = sorted_evens[even_index]\n        even_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a copy of the original list to avoid modifying it\n    result = list(l)\n    \n    # Replace the even indices with the sorted even elements\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "import doctest\ndef sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 8, 3, 6, 5])\n    [6, 1, 8, 3, 10, 5]\n    >>> sort_even([])\n    []\n    >>> sort_even([7])\n    [7]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even-indexed elements\n    sorted_evens = sorted(even_elements)\n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    # Replace the even indices with the sorted values\n    even_indices = range(0, len(l), 2)\n    for index, sorted_val in zip(even_indices, sorted_evens):\n        result[index] = sorted_val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 8, 3, 2, 4])\n    [2, 1, 8, 3, 10, 4]\n    >>> sort_even([])\n    []\n    >>> sort_even([7])\n    [7]\n    \"\"\"\n    # Extract the even-indexed elements\n    even_elements = l[::2]\n    # Sort the even-indexed elements\n    sorted_evens = sorted(even_elements)\n    \n    # Create an iterator for the sorted even elements\n    sorted_evens_iter = iter(sorted_evens)\n    \n    # Reconstruct the list by replacing even indices with sorted values\n    result = [next(sorted_evens_iter) if index % 2 == 0 else value for index, value in enumerate(l)]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = l[::2]\n    # Sort the even-indexed elements\n    sorted_evens = sorted(even_elements)\n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    # Replace the even indices with the sorted even elements\n    sorted_list[::2] = sorted_evens\n    return sorted_list", "matching_cluster_idx": 9}]}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 58.0, "profiled": [{"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p using efficient exponentiation.\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0  # As any number modulo 1 is 0\n\n    result = 1\n    base = 2 % p\n    exponent = n\n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0  # Since any number mod 1 is 0\n    result = 1\n    base = 2 % p\n    exponent = n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2 % p\n    exponent = n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0  # Since any number modulo 1 is 0\n    result = 1\n    base = 2 % p\n    exponent = n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2 % p\n    exponent = n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2 % p\n    exponent = n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2 % p\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        n = n // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p using efficient exponentiation by squaring.\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0  # As any number modulo 1 is 0\n    result = 1\n    base = 2 % p\n    exponent = n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p.\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of (2 ** n) % p.\n\n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    if p <= 0:\n        raise ValueError(\"Modulus p must be a positive integer.\")\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p using efficient exponentiation.\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 96.28019323671498, "dps_norm": 76.25, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    Vowels are considered to be 'a', 'e', 'i', 'o', 'u' in both lowercase and uppercase.\n\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return text.translate(str.maketrans('', '', 'aeiouAEIOU'))", "matching_cluster_idx": 6}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    translation_table = str.maketrans('', '', vowels)\n    return text.translate(translation_table)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return text.translate(str.maketrans('', '', vowels))", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same unique characters.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same unique characters.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same unique characters.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 97.75590551181102, "dps_norm": 95.0, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow efficient lookup\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1 & set2\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list of elements.\n        l2 (list): The second list of elements.\n        \n    Returns:\n        list: A sorted list of unique elements common to both l1 and l2.\n    \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Convert both lists to sets to eliminate duplicates and allow efficient intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1 & set2\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef common(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to eliminate duplicates and allow for efficient intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1 & set2  # Alternatively, set1.intersection(set2)\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert both lists to sets to eliminate duplicates and allow for efficient operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1 & set2  # Alternatively, set1.intersection(set2)\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to eliminate duplicates and perform intersection\n    common_elements = set(l1).intersection(l2)\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 5}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 94.0, "profiled": [{"solution": "import math\nimport doctest\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest = None\n\n    # Divide out the factor 2\n    while n % 2 == 0:\n        largest = 2\n        n //= 2\n\n    # Now n is odd, start checking odd factors\n    factor = 3\n    max_factor = math.isqrt(n) + 1\n    while factor <= max_factor and n > 1:\n        while n % factor == 0:\n            largest = factor\n            n //= factor\n            max_factor = math.isqrt(n) + 1\n        factor += 2\n\n    # If n is still greater than 1, then it is a prime factor\n    if n > 1:\n        largest = n\n\n    return largest", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1.\")\n    \n    largest = None\n\n    # Remove factors of 2\n    while n % 2 == 0:\n        largest = 2\n        n = n // 2\n\n    # Now n must be odd. Start checking from 3 onwards.\n    factor = 3\n    max_factor = n**0.5 + 1\n    while factor <= max_factor and n != 1:\n        while n % factor == 0:\n            largest = factor\n            n = n // factor\n            max_factor = n**0.5 + 1\n        factor += 2\n\n    if n > 1:\n        largest = n\n\n    return int(largest)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    factor = 2\n    last_factor = 1\n    \n    # Divide n by 2 to remove all even factors\n    while n % factor == 0:\n        last_factor = factor\n        n //= factor\n    \n    # Now, n must be odd. Start checking from 3 onwards\n    factor = 3\n    max_factor = n**0.5\n    while factor <= max_factor and n > 1:\n        while n % factor == 0:\n            last_factor = factor\n            n //= factor\n            max_factor = n**0.5\n        factor += 2  # Only check odd numbers\n    \n    # If n is a prime number greater than 2\n    if n > 1:\n        last_factor = n\n    \n    return int(last_factor)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1 if factor == 2 else 2  # After 2, check only odd numbers\n    if n > last_factor:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "import math\nimport doctest\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest factor\n    largest = None\n\n    # Remove any factors of 2\n    while n % 2 == 0:\n        largest = 2\n        n = n // 2\n\n    # Now n must be odd. Start checking from 3 onwards\n    factor = 3\n    max_factor = math.isqrt(n) + 1\n    while factor <= max_factor and n > 1:\n        while n % factor == 0:\n            largest = factor\n            n = n // factor\n            max_factor = math.isqrt(n) + 1\n        factor += 2\n\n    # If n is still greater than 2, then n itself is a prime factor\n    if n > 2:\n        largest = n\n\n    return largest", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n = n // factor\n            while n % factor == 0:\n                n = n // factor\n        factor += 1\n        if factor * factor > n:\n            if n > 1:\n                last_factor = n\n            break\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Divide out factors of 2\n    while n % 2 == 0:\n        max_factor = 2\n        n = n // 2\n\n    # Check for odd factors from 3 upwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            max_factor = factor\n            n = n // factor\n        factor += 2\n\n    # If remaining n is a prime number greater than 2\n    if n > 2:\n        max_factor = n\n\n    return int(max_factor)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1.\")\n    \n    max_prime = -1\n\n    # Divide out factors of 2\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n\n    # Now n is odd, start checking from 3\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            max_prime = factor\n            n //= factor\n        factor += 2\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n\n    return max_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Handle the factor 2 separately\n    while n % 2 == 0:\n        last_factor = 2\n        n = n // 2\n    \n    # Check odd factors from 3 upwards\n    factor = 3\n    max_factor = n ** 0.5\n    while factor <= max_factor:\n        while n % factor == 0:\n            last_factor = factor\n            n = n // factor\n            max_factor = n ** 0.5\n        factor += 2\n    \n    if n > 1:\n        last_factor = n\n    \n    return int(last_factor)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1 if factor == 2 else 2  # After 2, check only odd numbers\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = None\n    while factor * factor <= n:\n        while n % factor == 0:\n            last_factor = factor\n            n //= factor\n        factor += 1\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1 if factor == 2 else 2  # After 2, consider only odd numbers\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Remove factors of 2\n    while n % 2 == 0:\n        largest = 2\n        n //= 2\n    \n    # Check for odd factors from 3 upwards\n    factor = 3\n    max_factor = n ** 0.5\n    while factor <= max_factor:\n        while n % factor == 0:\n            largest = factor\n            n //= factor\n            max_factor = n ** 0.5\n        factor += 2\n    \n    # If n is still greater than 2, then n is a prime number\n    if n > 2:\n        largest = n\n    \n    return int(largest)", "matching_cluster_idx": 8}, {"solution": "import math\ndef largest_prime_factor(n: int):\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest = -1\n\n    # Divide out the factor 2\n    while n % 2 == 0:\n        largest = 2\n        n //= 2\n\n    # Now n must be odd. Start checking odd factors from 3 upwards.\n    factor = 3\n    max_factor = math.isqrt(n) + 1\n    while factor <= max_factor and n > 1:\n        while n % factor == 0:\n            largest = factor\n            n //= factor\n            max_factor = math.isqrt(n) + 1\n        factor += 2\n\n    # If n is still greater than 2, then n itself is a prime factor\n    if n > 2:\n        largest = n\n\n    return largest", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1.\")\n    \n    factor = 2\n    last_factor = None\n\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1 if factor == 2 else 2  # After 2, check only odd numbers\n\n    if n > 1:\n        last_factor = n\n\n    if last_factor is None:\n        raise ValueError(\"No prime factors found, input may be prime.\")\n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(k):\n        if k <= 1:\n            return False\n        if k <= 3:\n            return True\n        if k % 2 == 0 or k % 3 == 0:\n            return False\n        i = 5\n        while i * i <= k:\n            if k % i == 0 or k % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = None\n\n    # Divide out factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Now n must be odd, start checking from 3\n    factor = 3\n    max_factor = n**0.5\n    while factor <= max_factor and n > 1:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n            max_factor = n**0.5\n        factor += 2\n\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n = n // factor\n        factor += 1 if factor == 2 else 2  # After 2, consider only odd numbers\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n = n // factor\n        else:\n            factor += 1\n    return n", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 48.57142857142857, "dps_norm": 52.5, "pass@1": 94.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"rhythmy\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"my\")\n    1\n    >>> vowels_count(\"python\")\n    1\n    >>> vowels_count(\"PYTHONY\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"queueing\")\n    5\n    >>> vowels_count(\"Fly\")\n    1\n    >>> vowels_count(\"Gym\")\n    0\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"yellow\")\n    2\n    \"\"\"\n\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s[:-1]:\n        if char in vowels:\n            count += 1\n    # Check if the last character is a vowel or 'y'/'Y'\n    if s:\n        last_char = s[-1]\n        if last_char in vowels or last_char in ('y', 'Y'):\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"PYTHON\")\n    1\n    >>> vowels_count(\"Queue\")\n    3\n    >>> vowels_count(\"Fly\")\n    1\n    >>> vowels_count(\"BY\")\n    1\n    >>> vowels_count(\"Crypt\")\n    0\n    >>> vowels_count(\"AeIoUy\")\n    6\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    \n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y':\n            if i == length - 1:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"beauty\")\n    3\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"HELLO\")\n    2\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"y\")\n    1\n    >>> vowels_count(\"syzygy\")\n    1\n    \"\"\"\n    vowels = set('aeiou')\n    s_lower = s.lower()\n    count = 0\n\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y':\n            if i == len(s_lower) - 1:\n                count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"PYTHON\")\n    1\n    >>> vowels_count(\"queueing\")\n    5\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"crypt\")\n    0\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s = s.lower()\n    count = 0\n    \n    # Count vowels except possibly the last character\n    for char in s[:-1]:\n        if char in vowels:\n            count += 1\n    \n    # Check the last character\n    if s:\n        last_char = s[-1]\n        if last_char in vowels or last_char == 'y':\n            count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"happy\")\n    2\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    3\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"Y\")\n    1\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char in {'y', 'Y'} and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiou')\n    s_lower = s.lower()\n    count = sum(1 for char in s_lower if char in vowels)\n    if s_lower.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiou')\n    s = s.lower()\n    count = 0\n    length = len(s)\n    \n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"Python\")\n    1\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"A quick brown fox jumps over the lazy dog\")\n    11\n    >>> vowels_count(\"Why?\")\n    1\n    >>> vowels_count(\"HELLO\")\n    2\n    \"\"\"\n\n    vowels = set(\"aeiou\")\n    s = s.lower()\n    count = 0\n\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y':\n            if i == len(s) - 1:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char in ('y', 'Y') and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "import doctest\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"y\")\n    1\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"APPLE\")\n    2\n    >>> vowels_count(\"queue\")\n    3\n    >>> vowels_count(\"myth\")\n    0\n    >>> vowels_count(\"crypt\")\n    1\n    >>> vowels_count(\"Python\")\n    1\n    \"\"\"\n    vowels = set('aeiou')\n    count = 0\n    s_lower = s.lower()\n    length = len(s_lower)\n    \n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"syzygy\")\n    3\n    >>> vowels_count(\"tree\")\n    2\n    >>> vowels_count(\"hymn\")\n    0\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"try\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"by\")\n    1\n    >>> vowels_count(\"Python\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"AeiouY\")\n    6\n    >>> vowels_count(\"bcdfg\")\n    0\n    >>> vowels_count(\"queueing\")\n    5\n    \"\"\"\n    vowels = set('aeiou')\n    s = s.lower()\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char in ('y', 'Y') and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"Python\")\n    1\n    >>> vowels_count(\"PYTHON\")\n    1\n    >>> vowels_count(\"aeiouy\")\n    6\n    >>> vowels_count(\"bcdfg\")\n    0\n    \"\"\"\n    vowels = set('aeiou')\n    s_lower = s.lower()\n    count = 0\n    length = len(s_lower)\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y':\n            if i == length - 1:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char in ('y', 'Y') and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    3\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"crypt\")\n    0\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"PYTHON\")\n    1\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for index, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char in ('y', 'Y') and index == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"aeiou\")\n    5\n    >>> vowels_count(\"bcdfg\")\n    0\n    >>> vowels_count(\"happy\")\n    2\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"HYMNS\")\n    0\n    >>> vowels_count(\"y\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"Sky\")\n    1\n    \"\"\"\n    vowels = set('aeiou')\n    s_lower = s.lower()\n    count = 0\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "import doctest\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    1\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"PYTHON\")\n    1\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"Rhythms\")\n    0\n    >>> vowels_count(\"syzygy\")\n    2\n    >>> vowels_count(\"yellow\")\n    2\n    >>> vowels_count(\"queue\")\n    4\n    \"\"\"\n\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char in {'y', 'Y'} and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    \n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char in ('y', 'Y') and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"hello\")\n    2\n    >>> vowels_count(\"BY\")\n    1\n    >>> vowels_count(\"Queue\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n\n    # Check each character except possibly the last\n    for char in s[:-1]:\n        if char in vowels:\n            count += 1\n\n    # Check the last character\n    if s:\n        last_char = s[-1]\n        if last_char in vowels or last_char in {'y', 'Y'}:\n            count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given string.\n    Vowels considered are 'a', 'e', 'i', 'o', 'u'. The letter 'y' is also considered\n    a vowel only if it appears at the end of the word.\n\n    Parameters:\n    s (str): The input string to evaluate.\n\n    Returns:\n    int: The count of vowels in the string.\n\n    Examples:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"Beautiful\")\n    5\n    >>> vowels_count(\"Fly\")\n    1\n    >>> vowels_count(\"why\")\n    1\n    >>> vowels_count(\"HELLO\")\n    2\n    >>> vowels_count(\"PYTHON\")\n    1\n    \"\"\"\n\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s = s.lower()\n    length = len(s)\n\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y':\n            if i == length - 1:\n                count += 1\n\n    return count", "matching_cluster_idx": 3}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total1 = total_chars(lst1)\n    total2 = total_chars(lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1  # If equal, return the first list", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total number of characters in each list\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    # Compare totals and return the appropriate list\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total1 = total_chars(lst1)\n    total2 = total_chars(lst2)\n    \n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n    \n    if sum1 < sum2:\n        return lst1\n    elif sum2 < sum1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n\n    # Compare the totals and return the appropriate list\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1  # If totals are equal, return the first list", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total number of characters in each list\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    # Compare totals and return the appropriate list\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n    \n    if sum1 < sum2:\n        return lst1\n    elif sum2 < sum1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n    if sum1 < sum2:\n        return lst1\n    elif sum2 < sum1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n\n    total1 = total_chars(lst1)\n    total2 = total_chars(lst2)\n\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 85.76732673267327, "dps_norm": 54.166666666666664, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 8, 10, 12])\n        20\n        >>> add([2])\n        0\n    \"\"\"\n    # Sum even elements at odd indices (1, 3, 5, ...)\n    return sum(element for index, element in enumerate(lst) if index % 2 == 1 and element % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 7])\n        0\n        >>> add([10, 20, 30, 40, 50, 60])\n        120\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Args:\n        lst (list of int): The list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 4, 3, 6, 5, 8])\n        18\n        >>> add([2, 4, 6, 8, 10])\n        12\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 1 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, return the sum of the even elements\n    that are located at odd indices.\n\n    Args:\n        lst (list of int): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 2, 3, 4, 5, 6])\n        12\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 1 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([10, 20, 30, 40, 50, 60]) ==> 120\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (List[int]): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 7, 9])\n        0\n        >>> add([10, 12, 14, 16, 18, 20])\n        48\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Args:\n        lst (list of int): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 8, 10, 12])\n        20\n        >>> add([2, 4, 6, 8, 10])\n        12\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 4, 3, 6, 5, 8]) ==> 12\n    \"\"\"\n    return sum(element for index, element in enumerate(lst) if index % 2 == 1 and element % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Parameters:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 8, 10, 12])\n        20\n    \"\"\"\n    # Sum even elements where their index is odd\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4, 5, 6]) ==> 12\n    \"\"\"\n    return sum(num for index, num in enumerate(lst) if index % 2 == 1 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4, 5, 6]) ==> 12\n    \"\"\"\n    return sum(element for index, element in enumerate(lst) if index % 2 == 1 and element % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 4, 3, 6, 5, 8])\n        18\n        >>> add([10, 11, 12, 13, 14, 15])\n        11\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4, 5, 6]) ==> 12\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Parameters:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 2, 3, 4, 5, 6])\n        12\n    \"\"\"\n    return sum(element for index, element in enumerate(lst) if index % 2 == 1 and element % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 4, 3, 6, 5, 8]) ==> 18\n    \"\"\"\n    return sum(element for index, element in enumerate(lst) if index % 2 == 1 and element % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([1, 4, 3, 6, 5, 8]) ==> 18\n        add([2, 3, 4, 5]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Parameters:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 2, 3, 4, 5, 6])\n        12\n        >>> add([2])\n        0\n    \"\"\"\n    return sum(x for x in lst[1::2] if x % 2 == 0)", "matching_cluster_idx": 4}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 8, 10, 12])\n        20\n        >>> add([2])\n        0\n    \"\"\"\n    return sum(element for index, element in enumerate(lst) if index % 2 == 1 and element % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([10, 20, 30, 40, 50])\n        60\n        >>> add([1, 3, 5, 7])\n        0\n    \"\"\"\n    # Using a generator expression to iterate over indices and elements\n    # and summing elements that are even and located at odd indices\n    return sum(element for index, element in enumerate(lst) if index % 2 == 1 and element % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, sum the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even integers located at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 4, 3, 6, 5, 8])\n        18\n        >>> add([2, 3, 4, 5])\n        0\n    \"\"\"\n    # Using list slicing to get elements at odd indices and summing the even ones\n    return sum(x for x in lst[1::2] if x % 2 == 0)", "matching_cluster_idx": 4}]}, "HumanEval/86": {"dps": null, "dps_norm": null, "pass@1": 10.0, "profiled": []}, "HumanEval/87": {"dps": 93.94812680115274, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        # Collect columns where element == x\n        cols = [col_idx for col_idx, elem in enumerate(row) if elem == x]\n        # Sort columns in descending order\n        sorted_cols = sorted(cols, reverse=True)\n        # Append tuples (row_idx, col_idx) to coordinates\n        for col in sorted_cols:\n            coordinates.append((row_idx, col))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2-dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find all occurrences of x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...], such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of each row by columns in descending order.\n    \n    Examples:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    >>> get_row([], 1)\n    []\n    \n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \n    >>> get_row([[5, 5, 5], [5], [5, 5]], 5)\n    [(0, 2), (0, 1), (0, 0), (1, 0), (2, 1), (2, 0)]\n    \n    >>> get_row([[0, -1], [-1, 0, -1]], -1)\n    [(0, 1), (1, 2), (1, 0)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        # Find all column indices where the element is x\n        cols = [col_index for col_index, value in enumerate(row) if value == x]\n        if cols:\n            # Sort the column indices in descending order\n            cols_sorted = sorted(cols, reverse=True)\n            # Append tuples of (row_index, col_index) to the result\n            for col in cols_sorted:\n                result.append((row_index, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the element equals x\n        matching_cols = [col_idx for col_idx, elem in enumerate(row) if elem == x]\n        # Sort the column indices in descending order\n        matching_cols_sorted = sorted(matching_cols, reverse=True)\n        # Append the (row, col) tuples to the result\n        for col in matching_cols_sorted:\n            result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx in reversed(range(len(row))):\n            if row[col_idx] == x:\n                result.append((row_idx, col_idx))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of each row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the value equals x\n        cols = [col_idx for col_idx, val in enumerate(row) if val == x]\n        # Sort the column indices in descending order\n        cols_sorted = sorted(cols, reverse=True)\n        # Append the (row, column) tuples to the result\n        for col in cols_sorted:\n            result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        # Find all column indices where the element is equal to x\n        cols = [col_index for col_index, element in enumerate(row) if element == x]\n        # Sort column indices in descending order\n        cols_sorted = sorted(cols, reverse=True)\n        # Append tuples to the coordinates list\n        for col in cols_sorted:\n            coordinates.append((row_index, col))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find all occurrences of x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    \n    The returned list is sorted by:\n    1. Rows in ascending order.\n    2. Within each row, columns in descending order.\n    \n    Parameters:\n    - lst: List[List[int]] - The 2D data as nested lists.\n    - x: int - The integer to search for.\n    \n    Returns:\n    - List[Tuple[int, int]] - Sorted list of coordinates where x is found.\n    \n    Examples:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    >>> get_row([], 1)\n    []\n    \n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort by row ascending and column descending within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2-dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates within each row by columns in descending order.\n\n    Examples:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\n    >>> get_row([], 1)\n    []\n\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the value equals x\n        cols = [col_idx for col_idx, val in enumerate(row) if val == x]\n        if cols:\n            # Sort the column indices in descending order\n            sorted_cols = sorted(cols, reverse=True)\n            # Append each coordinate to the result\n            for col in sorted_cols:\n                result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    \n    Given lst and an integer x, find all occurrences of x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2), ...] where\n    each tuple represents the coordinates (row, column), starting with 0.\n    \n    Sorting Requirements:\n    - Sort the coordinates by rows in ascending order.\n    - Within each row, sort the column indices in descending order.\n    \n    Examples:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    >>> get_row([], 1)\n    []\n    \n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the element is x\n        col_indices = [col_idx for col_idx, value in enumerate(row) if value == x]\n        # Sort the column indices in descending order\n        col_indices_sorted = sorted(col_indices, reverse=True)\n        # Append the coordinates to the result list\n        for col in col_indices_sorted:\n            result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates within each row by columns in descending order.\n    \n    Examples:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    >>> get_row([], 1)\n    []\n    \n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the value equals x\n        matches = [col_idx for col_idx, val in enumerate(row) if val == x]\n        if matches:\n            # Sort column indices in descending order\n            matches.sort(reverse=True)\n            # Append (row, column) tuples to the result\n            result.extend((row_idx, col) for col in matches)\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates within each row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    get_row([], 1) == []\n    \n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        # Find all column indices where the value is x\n        matching_columns = [col_index for col_index, value in enumerate(row) if value == x]\n        # Sort the column indices in descending order\n        matching_columns_sorted = sorted(matching_columns, reverse=True)\n        # Append the (row, column) tuples to the result\n        for col in matching_columns_sorted:\n            result.append((row_index, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of each row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the element equals x\n        cols = [col_idx for col_idx, val in enumerate(row) if val == x]\n        # Sort the column indices in descending order\n        cols_sorted = sorted(cols, reverse=True)\n        # Append the coordinates to the result\n        for col in cols_sorted:\n            result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the element equals x\n        cols = [col_idx for col_idx, value in enumerate(row) if value == x]\n        # Sort the column indices in descending order\n        sorted_cols = sorted(cols, reverse=True)\n        # Append the (row, column) tuples to the result\n        for col in sorted_cols:\n            result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    >>> get_row([], 1)\n    []\n    \n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the value equals x\n        cols = [col_idx for col_idx, value in enumerate(row) if value == x]\n        # Sort the column indices in descending order\n        cols_sorted = sorted(cols, reverse=True)\n        # Append the coordinates to the result\n        result.extend([(row_idx, col) for col in cols_sorted])\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        # Find all column indices where the element is x\n        cols = [col_index for col_index, value in enumerate(row) if value == x]\n        # Sort column indices in descending order\n        cols_sorted = sorted(cols, reverse=True)\n        # Add the (row, column) tuples to the result\n        for col in cols_sorted:\n            result.append((row_index, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find occurrences of x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates within each row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    get_row([], 1) == []\n    \n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    # Sort by row ascending, then by column descending within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        # Collect all column indices where the element equals x\n        matching_cols = [col_idx for col_idx, elem in enumerate(row) if elem == x]\n        if matching_cols:\n            # Sort the matching columns in descending order\n            matching_cols_sorted = sorted(matching_cols, reverse=True)\n            # Add the coordinates to the list\n            coordinates.extend([(row_idx, col) for col in matching_cols_sorted])\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2-dimensional data as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find occurrences of x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2), ...] where\n    each tuple is a coordinate (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates within each row by columns in descending order.\n\n    Examples:\n    >>> get_row([\n    ...   [1, 2, 3, 4, 5, 6],\n    ...   [1, 2, 3, 4, 1, 6],\n    ...   [1, 2, 3, 4, 5, 1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\n    >>> get_row([], 1)\n    []\n\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the value equals x\n        indices = [col_idx for col_idx, value in enumerate(row) if value == x]\n        if indices:\n            # Sort the column indices in descending order\n            sorted_indices = sorted(indices, reverse=True)\n            # Append tuples of (row_idx, col_idx) to the coordinates list\n            coordinates.extend((row_idx, col_idx) for col_idx in sorted_indices)\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2-dimensional data structure as nested lists,\n    which is similar to a matrix. Unlike traditional matrices,\n    each row may contain a different number of columns.\n    Given lst and an integer x, find all occurrences of x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2), ...] where each tuple\n    represents the coordinates (row, column) of x. Coordinates start at 0.\n    \n    The returned list is sorted by:\n    1. Rows in ascending order.\n    2. Within each row, columns in descending order.\n    \n    Examples:\n    >>> get_row([\n    ...   [1, 2, 3, 4, 5, 6],\n    ...   [1, 2, 3, 4, 1, 6],\n    ...   [1, 2, 3, 4, 5, 1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    >>> get_row([], 1)\n    []\n    \n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the element equals x\n        column_indices = [col_idx for col_idx, val in enumerate(row) if val == x]\n        # Sort the column indices in descending order\n        sorted_columns = sorted(column_indices, reverse=True)\n        # Append the coordinates to the result list\n        for col_idx in sorted_columns:\n            result.append((row_idx, col_idx))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of each row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the value is x\n        cols = [col_idx for col_idx, val in enumerate(row) if val == x]\n        # Sort the column indices in descending order\n        sorted_cols = sorted(cols, reverse=True)\n        # Append the coordinates to the result list\n        for col in sorted_cols:\n            result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.70103092783506, "dps_norm": 31.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"\n    Create a function `encrypt` that takes a string as an argument and\n    returns a string encrypted by rotating each alphabet letter forward by 4 places.\n    \n    The rotation wraps around the alphabet, so 'z' becomes 'd', 'y' becomes 'c', etc.\n\n    For example:\n        encrypt('hi') returns 'lm'\n        encrypt('asdfghjkl') returns 'ewhjklnop'\n        encrypt('gf') returns 'kj'\n        encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions with wrap-around\n            shifted = (ord(char) - ord('a') + 4) % 26 + ord('a')\n            encrypted.append(chr(shifted))\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters similarly\n            shifted = (ord(char) - ord('A') + 4) % 26 + ord('A')\n            encrypted.append(chr(shifted))\n        else:\n            # Non-alphabet characters remain unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions\n            shifted = ord(char) + 4\n            if shifted > ord('z'):\n                shifted -= 26\n            encrypted.append(chr(shifted))\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase characters as well\n            shifted = ord(char) + 4\n            if shifted > ord('Z'):\n                shifted -= 26\n            encrypted.append(chr(shifted))\n        else:\n            # Non-alphabet characters remain unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    shift = 4  # 2 multiplied by 2 as per the requirement\n\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate shifted character with wrap-around\n            shifted_ord = ord(char) + shift\n            if shifted_ord > ord('z'):\n                shifted_ord -= 26\n            encrypted.append(chr(shifted_ord))\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters similarly\n            shifted_ord = ord(char) + shift\n            if shifted_ord > ord('Z'):\n                shifted_ord -= 26\n            encrypted.append(chr(shifted_ord))\n        else:\n            # Non-alphabetic characters are unchanged\n            encrypted.append(char)\n    \n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet is rotated by shifting each letter forward by 4 places.\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions\n            shifted = ord(char) - ord('a')  # 0-25\n            shifted = (shifted + 4) % 26\n            result.append(chr(shifted + ord('a')))\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase characters similarly\n            shifted = ord(char) - ord('A')  # 0-25\n            shifted = (shifted + 4) % 26\n            result.append(chr(shifted + ord('A')))\n        else:\n            # Non-alphabetic characters are unchanged\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., shift by 4 places).\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    shift = 4  # 2 multiplied by 2\n    \n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character and wrap around using modulo\n            shifted = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            result.append(shifted)\n        elif 'A' <= char <= 'Z':\n            shifted = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            # Non-alphabet characters are unchanged\n            result.append(char)\n    \n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 4  # 2 multiplied by 2\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions\n            shifted_ord = ord(char) - ord('a')\n            shifted_ord = (shifted_ord + shift) % 26\n            encrypted_char = chr(shifted_ord + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters\n            shifted_ord = ord(char) - ord('A')\n            shifted_ord = (shifted_ord + shift) % 26\n            encrypted_char = chr(shifted_ord + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Non-alphabetic characters remain unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts the input string by shifting each letter 4 places forward in the alphabet.\n\n    Parameters:\n    s (str): The string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions, wrapping around if necessary\n            shifted = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters similarly\n            shifted = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(shifted)\n        else:\n            # Non-alphabetic characters are unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions with wrap-around\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase characters similarly\n            shifted = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted.append(shifted)\n        else:\n            # Non-alphabetic characters are unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet is rotated by shifting each letter forward by four places.\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift lowercase letters\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase letters\n            shifted = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted.append(shifted)\n        else:\n            # Non-alphabetic characters are unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet is rotated by shifting each letter forward by four places.\n    \n    For example:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions with wrap-around\n            shifted = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters if needed\n            shifted = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(shifted)\n        else:\n            # Non-alphabetic characters are left unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the input string by shifting each lowercase letter forward by four places.\n    \n    The alphabet is rotated such that each letter shifts down by two multiplied by two places (4 places).\n    Non-lowercase characters are returned unchanged.\n    \n    Examples:\n        encrypt('hi') returns 'lm'\n        encrypt('asdfghjkl') returns 'ewhjklnop'\n        encrypt('gf') returns 'kj'\n        encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions with wrap-around\n            shifted = ((ord(char) - ord('a') + 4) % 26) + ord('a')\n            encrypted.append(chr(shifted))\n        elif 'A' <= char <= 'Z':\n            # If uppercase letters need to be handled\n            shifted = ((ord(char) - ord('A') + 4) % 26) + ord('A')\n            encrypted.append(chr(shifted))\n        else:\n            # Non-alphabetic characters are unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts the input string by shifting each lowercase alphabet character\n    four places forward in the alphabet. Wraps around from 'z' to 'a'.\n    Non-lowercase characters are left unchanged.\n\n    Args:\n        s (str): The input string to encrypt.\n\n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions\n            shifted = ord(char) + 4\n            if shifted > ord('z'):\n                shifted -= 26  # Wrap around\n            result.append(chr(shifted))\n        else:\n            # Leave non-lowercase characters unchanged\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts the input string by shifting each alphabetical character down by 4 places.\n    Non-alphabet characters are unchanged. The shift wraps around the alphabet.\n\n    Parameters:\n    s (str): The string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    shift = 4\n    encrypted = []\n    \n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate shifted character with wrap-around\n            shifted = chr(((ord(char) - ord('a') + shift) % 26) + ord('a'))\n            encrypted.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters similarly\n            shifted = chr(((ord(char) - ord('A') + shift) % 26) + ord('A'))\n            encrypted.append(shifted)\n        else:\n            # Non-alphabet characters are added unchanged\n            encrypted.append(char)\n    \n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shifted = []\n    shift_amount = 2 * 2  # Shift by two multiplied by two places\n\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate shifted character with wrap-around\n            shifted_char = chr((ord(char) - ord('a') + shift_amount) % 26 + ord('a'))\n            shifted.append(shifted_char)\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters if needed\n            shifted_char = chr((ord(char) - ord('A') + shift_amount) % 26 + ord('A'))\n            shifted.append(shifted_char)\n        else:\n            # Non-alphabet characters are unchanged\n            shifted.append(char)\n\n    return ''.join(shifted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts the input string by shifting each lowercase letter forward by 4 places \n    in the alphabet. The shift wraps around from 'z' to 'a'. Non-lowercase characters \n    remain unchanged.\n\n    Args:\n        s (str): The input string to encrypt.\n\n    Returns:\n        str: The encrypted string with letters shifted by +4.\n        \n    Examples:\n        >>> encrypt('hi')\n        'lm'\n        >>> encrypt('asdfghjkl')\n        'ewhjklnop'\n        >>> encrypt('gf')\n        'kj'\n        >>> encrypt('et')\n        'ix'\n    \"\"\"\n    encrypted = []\n    shift = 4  # 2 multiplied by 2 as per the problem statement\n\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character and wrap around using modulo 26\n            shifted_ord = ((ord(char) - ord('a') + shift) % 26) + ord('a')\n            encrypted.append(chr(shifted_ord))\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters similarly\n            shifted_ord = ((ord(char) - ord('A') + shift) % 26) + ord('A')\n            encrypted.append(chr(shifted_ord))\n        else:\n            # Non-alphabetic characters are left unchanged\n            encrypted.append(char)\n    \n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 4  # 2 multiplied by 2 as per the problem description\n    encrypted = []\n    \n    for char in s:\n        if 'a' <= char <= 'z':\n            # Perform the shift with wrap-around using modulo\n            shifted = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            encrypted.append(shifted)\n        elif 'A' <= char <= 'Z':\n            shifted = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            encrypted.append(shifted)\n        else:\n            # Non-alphabet characters are added unchanged\n            encrypted.append(char)\n    \n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by shifting each lowercase letter forward by four positions\n    in the alphabet. The shift wraps around from 'z' to 'a'.\n\n    Parameters:\n    s (str): The input string to encrypt.\n\n    Returns:\n    str: The encrypted string.\n    \n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions with wrap-around\n            shifted = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase characters similarly\n            shifted = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(shifted)\n        else:\n            # Non-alphabetic characters are unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts the input string by shifting each letter 4 places forward in the alphabet.\n    The alphabet wraps around, so shifting 'z' results in 'd'.\n    \n    Args:\n        s (str): The string to encrypt.\n    \n    Returns:\n        str: The encrypted string.\n    \n    Examples:\n        >>> encrypt('hi')\n        'lm'\n        >>> encrypt('asdfghjkl')\n        'ewhjklnop'\n        >>> encrypt('gf')\n        'kj'\n        >>> encrypt('et')\n        'ix'\n    \"\"\"\n    result = []\n    shift = 4  # Shift each character by 4 positions\n\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate shifted character with wrap-around\n            shifted = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            result.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters similarly\n            shifted = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            # Non-alphabet characters are added unchanged\n            result.append(char)\n\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    shift = 2 * 2  # Shift by 4 positions\n\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate shifted character for lowercase letters\n            shifted = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            result.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Calculate shifted character for uppercase letters\n            shifted = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            # Non-alphabetic characters are unchanged\n            result.append(char)\n\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "import string\ndef encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Calculate the total shift: 2 multiplied by 2 equals 4\n    shift = 2 * 2\n    \n    # Create the shifted alphabet by rotating the original alphabet by 'shift' places\n    shifted_alphabet = string.ascii_lowercase[shift:] + string.ascii_lowercase[:shift]\n    \n    # Create a translation table for lowercase letters\n    translation_table = str.maketrans(string.ascii_lowercase, shifted_alphabet)\n    \n    # Translate and return the encrypted string\n    return s.translate(translation_table)", "matching_cluster_idx": 5}]}, "HumanEval/90": {"dps": 15.622568093385214, "dps_norm": 31.666666666666668, "pass@1": 100.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    smallest = None\n    second_smallest = None\n\n    for num in lst:\n        if smallest is None or num < smallest:\n            if smallest != num:\n                second_smallest = smallest\n            smallest = num\n        elif num != smallest:\n            if second_smallest is None or num < second_smallest:\n                second_smallest = num\n\n    return second_smallest", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    if not lst or len(lst) < 2:\n        return None\n\n    first = second = None\n\n    for num in lst:\n        if first is None or num < first:\n            second = first\n            first = num\n        elif num != first:\n            if second is None or num < second:\n                second = num\n\n    return second", "matching_cluster_idx": 4}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst or len(lst) < 2:\n        return None\n    \n    first = second = float('inf')\n    for num in lst:\n        if num < first:\n            second, first = first, num\n        elif first < num < second:\n            second = num\n            \n    return second if second != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    first = second = None\n    for num in lst:\n        if num == first:\n            continue\n        if first is None or num < first:\n            second = first\n            first = num\n        elif second is None or (num < second and num != first):\n            second = num\n    return second", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    first = second = None\n    for num in lst:\n        if first is None or num < first:\n            if first != num:\n                second = first\n                first = num\n        elif num != first:\n            if second is None or num < second:\n                second = num\n\n    return second", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest distinct element in the list.\n    Returns None if there is no such element.\n\n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    first = second = None\n\n    for num in lst:\n        if first is None or num < first:\n            if num != first:\n                second = first\n            first = num\n        elif first < num:\n            if second is None or num < second:\n                second = num\n\n    return second", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = set(lst)\n    \n    if len(unique_elements) < 2:\n        return None\n    \n    first_min = second_min = float('inf')\n    \n    for num in unique_elements:\n        if num < first_min:\n            second_min, first_min = first_min, num\n        elif first_min < num < second_min:\n            second_min = num\n    \n    return second_min if second_min != float('inf') else None", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    first = second = None\n    for num in lst:\n        if first is None or num < first:\n            if first != num:\n                second = first\n            first = num\n        elif num != first:\n            if second is None or num < second:\n                second = num\n\n    return second", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    first = second = None\n    for num in lst:\n        if first is None or num < first:\n            if first != num:\n                second = first\n                first = num\n        elif num != first:\n            if second is None or num < second:\n                second = num\n    return second", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst or len(lst) < 2:\n        return None\n\n    min1, min2 = float('inf'), float('inf')\n    for num in lst:\n        if num < min1:\n            min2, min1 = min1, num\n        elif min1 < num < min2:\n            min2 = num\n\n    return min2 if min2 != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    first = second = None\n\n    for num in lst:\n        if first is None or num < first:\n            if first != num:\n                second = first\n                first = num\n        elif first < num:\n            if second is None or num < second:\n                second = num\n\n    return second", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst or len(lst) < 2:\n        return None\n\n    first = second = None\n    for num in lst:\n        if first is None or num < first:\n            second = first\n            first = num\n        elif num != first:\n            if second is None or num < second:\n                second = num\n\n    return second", "matching_cluster_idx": 4}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    sorted_elements = sorted(unique_elements)\n    return sorted_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = set(lst)\n    \n    if len(unique_elements) < 2:\n        return None\n    \n    first, second = None, None\n    for num in unique_elements:\n        if first is None or num < first:\n            second = first\n            first = num\n        elif second is None or num < second:\n            second = num\n    return second", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first = second = None\n    for num in lst:\n        if first is None or num < first:\n            if first != num:\n                second = first\n            first = num\n        elif num != first:\n            if second is None or num < second:\n                second = num\n\n    return second", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n        next_smallest([1, 2, 3, 4, 5]) == 2\n        next_smallest([5, 1, 4, 3, 2]) == 2\n        next_smallest([]) == None\n        next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst or len(lst) < 2:\n        return None\n\n    first = second = None\n    for num in lst:\n        if first is None or num < first:\n            second = first\n            first = num\n        elif num != first:\n            if second is None or num < second:\n                second = num\n\n    return second", "matching_cluster_idx": 4}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest distinct element of the list.\n    Return None if there is no such element.\n\n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    first_min = second_min = None\n    for num in lst:\n        if first_min is None or num < first_min:\n            if first_min != num:\n                second_min = first_min\n                first_min = num\n        elif num != first_min:\n            if second_min is None or num < second_min:\n                second_min = num\n    return second_min", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique = set(lst)\n    if len(unique) < 2:\n        return None\n\n    min1, min2 = None, None\n    for num in unique:\n        if min1 is None or num < min1:\n            min2 = min1\n            min1 = num\n        elif min2 is None or num < min2:\n            min2 = num\n    return min2", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst or len(lst) < 2:\n        return None\n\n    first = second = None\n    for number in lst:\n        if first is None or number < first:\n            if number != first:\n                second = first\n            first = number\n        elif first < number and (second is None or number < second):\n            second = number\n\n    return second", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    unique_nums = set(lst)\n    if len(unique_nums) < 2:\n        return None\n\n    first = second = float('inf')\n    for num in unique_nums:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n\n    return second if second != float('inf') else None", "matching_cluster_idx": 2}]}, "HumanEval/113": {"dps": 99.59432048681542, "dps_norm": 79.16666666666666, "pass@1": 92.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    template = \"the number of odd elements in the string i of the input.\"\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if c in '13579')\n        sentence = template.replace('i', str(count))\n        result.append(sentence)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if char in '13579')\n        formatted_str = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Create the formatted string with the count\n        formatted_str = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n    where all the count's should be replaced by the number of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if char in '13579')\n        message = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(message)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements kn the strkng k of the knput.\"\n    where k is the number of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    >>> odd_count([])\n    []\n    >>> odd_count(['24680'])\n    [\"the number of odd elements 0n the str0ng 0 of the 0nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        k = sum(1 for char in s if char in '13579')\n        message = f\"the number of odd elements {k}n the str{k}ng {k} of the {k}nput.\"\n        result.append(message)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if c in '13579')\n        result.append(\n            f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        )\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements Xn the strXng X of the Xnput.\"\n    where X is the number of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    odd_digits = {'1', '3', '5', '7', '9'}\n    result = [\n        f\"the number of odd elements {sum(1 for c in s if c in odd_digits)}n the str{sum(1 for c in s if c in odd_digits)}ng {sum(1 for c in s if c in odd_digits)} of the {sum(1 for c in s if c in odd_digits)}nput.\"\n        for s in lst\n    ]\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    template = \"the number of odd elements in the string i of the input.\"\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if c in '13579')\n        phrase = template.replace('i', str(count))\n        result.append(phrase)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements {N}n the str{N}ng {N} of the {N}nput.\"\n    where all the N's are replaced by the number of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if char in {'1', '3', '5', '7', '9'})\n        # Format the output string with the count\n        formatted_str = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        sentence = (\n            f\"the number of odd elements {count}n the str{count}ng \"\n            f\"{count} of the {count}nput.\"\n        )\n        result.append(sentence)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements {n}n the str{n}ng {n} of the {n}nput.\"\n    where {n} is the number of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    template = \"the number of odd elements in the string i of the input.\"\n    result = []\n    for s in lst:\n        count = sum(1 for ch in s if ch in '13579')\n        replaced = template.replace('i', str(count))\n        result.append(replaced)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    template = \"the number of odd elements in the string i of the input.\"\n\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_digits = sum(1 for char in s if char in {'1','3','5','7','9'})\n        # Replace all occurrences of 'i' with the count\n        modified = template.replace('i', str(odd_digits))\n        result.append(modified)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements Xn the strXng X of the Xnput.\"\n    where X is the number of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if char.isdigit() and int(char) % 2 == 1)\n        # Create the formatted string with the count\n        description = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(description)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element of the output should be \"the number of odd elements Xn the strXng X of the Xnput.\"\n    where all the 'i's are replaced by the number of odd digits in the respective input string.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    template = \"the number of odd elements in the string i of the input.\"\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if c in '13579')\n        replaced_string = template.replace('i', str(count))\n        result.append(replaced_string)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element of the output should describe the number of odd digits in the corresponding\n    input string by replacing all 'i's in the template with this count.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    template = \"the number of odd elements in the string i of the input.\"\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if c in '13579')\n        output = template.replace('i', str(count))\n        result.append(output)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    odd_digits = {'1', '3', '5', '7', '9'}\n    result = []\n    for s in lst:\n        count = sum(char in odd_digits for char in s)\n        formatted_str = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    base_sentence = \"the number of odd elements in the string i of the input.\"\n    result = []\n    \n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_digits = sum(1 for char in s if char in '13579')\n        # Replace all occurrences of 'i' with the count\n        modified_sentence = base_sentence.replace('i', str(odd_digits))\n        result.append(modified_sentence)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element of the output should be \"the number of odd elements Xn the strXng X of the Xnput.\"\n    where X is the number of odd digits in the corresponding string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    odd_digits = {'1', '3', '5', '7', '9'}\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if char in odd_digits)\n        message = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(message)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    odd_digits = {'1', '3', '5', '7', '9'}\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if c in odd_digits)\n        message = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(message)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if char in '13579')\n        formatted_str = (\n            f\"the number of odd elements {count}n the str{count}ng \"\n            f\"{count} of the {count}nput.\"\n        )\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 4}]}, "HumanEval/119": {"dps": 85.0, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n\n    s1, s2 = lst\n    # Check both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    if len(lst) != 2:\n        return 'No'  # Invalid input\n\n    s1, s2 = lst\n    concatenations = [s1 + s2, s2 + s1]\n\n    for concat in concatenations:\n        if is_balanced(concat):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    a, b = lst\n    if is_balanced(a + b) or is_balanced(b + a):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def get_balance_info(s):\n        balance = 0\n        min_balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            min_balance = min(min_balance, balance)\n        return min_balance, balance\n\n    s1, s2 = lst\n    min1, net1 = get_balance_info(s1)\n    min2, net2 = get_balance_info(s2)\n\n    # Check concatenation order: s1 + s2\n    good1 = (min1 >= 0) and (min2 + net1 >= 0) and (net1 + net2 == 0)\n\n    # Check concatenation order: s2 + s1\n    good2 = (min2 >= 0) and (min1 + net2 >= 0) and (net1 + net2 == 0)\n\n    return \"Yes\" if good1 or good2 else \"No\"", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            # If balance is negative, there's a closing parenthesis without a matching opening\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenation orders\n    first_order = lst[0] + lst[1]\n    second_order = lst[1] + lst[0]\n    \n    if is_good(first_order) or is_good(second_order):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_valid(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    concat1 = lst[0] + lst[1]\n    concat2 = lst[1] + lst[0]\n\n    if is_valid(concat1) or is_valid(concat2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    # Check both possible concatenations\n    concat1 = lst[0] + lst[1]\n    if is_balanced(concat1):\n        return 'Yes'\n    \n    concat2 = lst[1] + lst[0]\n    if is_balanced(concat2):\n        return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            # If balance is negative, there's a closing parenthesis without a matching opening\n            if balance < 0:\n                return False\n        # All opening parentheses must be closed\n        return balance == 0\n\n    # Extract the two strings\n    first, second = lst\n\n    # Check both possible concatenation orders\n    if is_balanced(first + second):\n        return 'Yes'\n    if is_balanced(second + first):\n        return 'Yes'\n\n    # If neither order results in a balanced string\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            # If balance is negative, there are more closing parentheses\n            if balance < 0:\n                return False\n        # In the end, balance should be zero for a balanced string\n        return balance == 0\n\n    # Extract the two strings\n    s1, s2 = lst\n\n    # Check both possible concatenations\n    concatenated1 = s1 + s2\n    concatenated2 = s2 + s1\n\n    if is_balanced(concatenated1) or is_balanced(concatenated2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            # If balance goes negative, there's a closing parenthesis without a matching opening\n            if balance < 0:\n                return False\n        # All opening parentheses should be closed\n        return balance == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n\n    s1, s2 = lst\n\n    # Check both possible concatenations\n    concat1 = s1 + s2\n    concat2 = s2 + s1\n\n    if is_balanced(concat1) or is_balanced(concat2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    first, second = lst\n    # Try first + second\n    if is_balanced(first + second):\n        return 'Yes'\n    # Try second + first\n    if is_balanced(second + first):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def get_balance_info(s):\n        balance = 0\n        min_balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            min_balance = min(min_balance, balance)\n        return balance, min_balance\n\n    s1, s2 = lst\n    # Get balance and minimum prefix balance for both strings\n    balance1, min1 = get_balance_info(s1)\n    balance2, min2 = get_balance_info(s2)\n\n    def is_valid_concat(b1, m1, b2, m2):\n        # When concatenating s1 + s2\n        # The minimum balance in s2 should not drop below -b1\n        if b1 + b2 != 0:\n            return False\n        if m1 < 0:\n            return False\n        if m2 + b1 < 0:\n            return False\n        return True\n\n    # Check s1 + s2\n    if is_valid_concat(balance1, min1, balance2, min2):\n        return 'Yes'\n    # Check s2 + s1\n    if is_valid_concat(balance2, min2, balance1, min1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            else:\n                # Invalid character\n                return False\n            if balance < 0:\n                return False\n        return balance == 0\n\n    if len(lst) != 2:\n        return 'No'  # Invalid input\n\n    s1, s2 = lst\n\n    # Check both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    s1, s2 = lst\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def get_balance_info(s):\n        balance = 0\n        min_balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            min_balance = min(min_balance, balance)\n        return balance, min_balance\n\n    s1, s2 = lst\n    balance1, min_balance1 = get_balance_info(s1)\n    balance2, min_balance2 = get_balance_info(s2)\n\n    # Function to check if concatenation order is valid\n    def is_valid_concat(first_balance, first_min, second_balance, second_min):\n        # After first string, the current balance is first_balance\n        # The second string should not drop below zero when starting from first_balance\n        return first_balance + second_min >= 0\n\n    # Check both possible concatenations\n    valid_order1 = (balance1 + balance2 == 0) and (min_balance1 >= 0) and is_valid_concat(balance1, min_balance1, balance2, min_balance2)\n    valid_order2 = (balance2 + balance1 == 0) and (min_balance2 >= 0) and is_valid_concat(balance2, min_balance2, balance1, min_balance1)\n\n    if valid_order1 or valid_order2:\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Check first order: s1 + s2\n    combined1 = s1 + s2\n    if is_balanced(combined1):\n        return 'Yes'\n    \n    # Check second order: s2 + s1\n    combined2 = s2 + s1\n    if is_balanced(combined2):\n        return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Check both concatenation orders\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    # Extract the two strings from the list\n    s1, s2 = lst\n\n    # Check both possible concatenations\n    concatenated1 = s1 + s2\n    concatenated2 = s2 + s1\n\n    if is_balanced(concatenated1) or is_balanced(concatenated2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    if len(lst) != 2:\n        return 'No'  # Based on problem description, input list should have exactly two strings\n\n    s1, s2 = lst\n    # Check both possible concatenations\n    concatenations = [s1 + s2, s2 + s1]\n    for concat in concatenations:\n        if is_balanced(concat):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n\n    s1, s2 = lst\n    # Check both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": 41.896551724137936, "dps_norm": 65.71428571428572, "pass@1": 100.0, "profiled": [{"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Get the k largest elements\n    max_k = heapq.nlargest(k, arr)\n    # Sort them in ascending order\n    return sorted(max_k)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Use heapq.nlargest to get the k largest elements\n    largest_k = heapq.nlargest(k, arr)\n    \n    # Sort the k largest elements in ascending order\n    return sorted(largest_k)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Parameters:\n    arr (List[int]): The input array of integers.\n    k (int): The number of maximum elements to return.\n\n    Returns:\n    List[int]: A sorted list containing the k largest integers from arr.\n    \"\"\"\n    if k == 0:\n        return []\n    # Use heapq.nlargest to get the k largest elements efficiently\n    largest_k = heapq.nlargest(k, arr)\n    # Sort the result in ascending order before returning\n    return sorted(largest_k)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    if k >= len(arr):\n        return sorted(arr)\n    \n    # Use a min heap to keep track of the top k elements\n    min_heap = arr[:k]\n    heapq.heapify(min_heap)\n    \n    for num in arr[k:]:\n        if num > min_heap[0]:\n            heapq.heappushpop(min_heap, num)\n    \n    return sorted(min_heap)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Use a min-heap to keep track of the top k elements\n    import heapq\n    heap = []\n    for num in arr:\n        if len(heap) < k:\n            heapq.heappush(heap, num)\n        else:\n            if num > heap[0]:\n                heapq.heappushpop(heap, num)\n    # Sort the heap to return the result in ascending order\n    return sorted(heap)", "matching_cluster_idx": 4}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Use a min-heap of size k to keep track of the k largest elements\n    min_heap = arr[:k]\n    heapq.heapify(min_heap)\n\n    for num in arr[k:]:\n        if num > min_heap[0]:\n            heapq.heappushpop(min_heap, num)\n    \n    # Sort the k largest elements in ascending order\n    return sorted(min_heap)", "matching_cluster_idx": 5}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Use heapq.nlargest to get the k largest elements efficiently\n    top_k = heapq.nlargest(k, arr)\n    \n    # Sort the result in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Use heapq to find the k largest elements efficiently\n    import heapq\n    largest_k = heapq.nlargest(k, arr)\n    \n    # Sort the k largest elements in ascending order\n    return sorted(largest_k)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Use heapq.nlargest to find the k largest elements efficiently\n    largest_elements = heapq.nlargest(k, arr)\n    \n    # Sort the resulting list in ascending order\n    return sorted(largest_elements)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Use heapq.nlargest to find the k largest elements\n    k_largest = heapq.nlargest(k, arr)\n    \n    # Sort the k largest elements in ascending order\n    return sorted(k_largest)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Find the k largest elements\n    k_max = heapq.nlargest(k, arr)\n    # Return them sorted in ascending order\n    return sorted(k_max)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Retrieve the k largest elements\n    largest_elements = heapq.nlargest(k, arr)\n    \n    # Return the sorted list of the k largest elements\n    return sorted(largest_elements)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Use heapq.nlargest to find the k largest elements\n    import heapq\n    k_largest = heapq.nlargest(k, arr)\n    # Return the sorted list in ascending order\n    return sorted(k_largest)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Find the k largest elements using a heap\n    largest_k = heapq.nlargest(k, arr)\n    \n    # Sort the k largest elements in ascending order\n    return sorted(largest_k)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Use heapq.nlargest to find the k largest elements efficiently\n    import heapq\n    largest_k = heapq.nlargest(k, arr)\n    # Sort the result in ascending order\n    return sorted(largest_k)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Use heapq to find the k largest elements efficiently\n    largest_k = heapq.nlargest(k, arr)\n    \n    # Sort the result in ascending order\n    return sorted(largest_k)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Use a min-heap to keep track of the top k elements\n    min_heap = []\n    for num in arr:\n        if len(min_heap) < k:\n            heapq.heappush(min_heap, num)\n        else:\n            if num > min_heap[0]:\n                heapq.heappushpop(min_heap, num)\n    # Sort the result before returning\n    return sorted(min_heap)", "matching_cluster_idx": 4}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Use heapq to find the k largest elements efficiently\n    import heapq\n    # heapq.nlargest returns the k largest elements in descending order\n    largest_k = heapq.nlargest(k, arr)\n    # Sort the result in ascending order before returning\n    return sorted(largest_k)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Return the last k elements, which are the largest k numbers\n    return sorted_arr[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Slice the last k elements\n    return sorted_arr[-k:]", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 80.94170403587444, "dps_norm": 60.714285714285715, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(num for index, num in enumerate(lst) if index % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Parameters:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: Sum of odd elements in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(num for index, num in enumerate(lst) if index % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Even positions have indices 0, 2, 4, ...\n    # Check if the element at these positions is odd\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for idx, x in enumerate(lst) if idx % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Sum of elements at even indices (0, 2, 4, ...) that are odd\n    return sum(item for index, item in enumerate(lst) if index % 2 == 0 and item % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for idx, x in enumerate(lst) if idx % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate over even indices (0, 2, 4, ...)\n    for index in range(0, len(lst), 2):\n        if lst[index] % 2 != 0:\n            total += lst[index]\n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(x for x in lst[::2] if x % 2 != 0)", "matching_cluster_idx": 5}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(num for index, num in enumerate(lst) if index % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Extract elements at even indices (0, 2, 4, ...)\n    even_position_elements = lst[::2]\n    # Filter out the odd elements from the extracted elements\n    odd_elements = [num for num in even_position_elements if num % 2 != 0]\n    # Return the sum of the filtered odd elements\n    return sum(odd_elements)", "matching_cluster_idx": 5}]}, "HumanEval/149": {"dps": 87.24409448818899, "dps_norm": 61.42857142857143, "pass@1": 42.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    \n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    \n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    \n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Writes a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list:\n    # First by length (ascending), then alphabetically\n    sorted_lst = sorted(filtered, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    \n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    \n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    \n    If two words have the same length, sort the list alphabetically.\n    \n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    \n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered = [word for word in lst if len(word) % 2 == 0]\n    # Sort the filtered list first by length, then alphabetically\n    sorted_list = sorted(filtered, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    \n    The function should return a list of strings in sorted order.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first alphabetically, then by length\n    # This ensures that when lengths are equal, alphabetical order is used\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    \n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    \n    If two words have the same length, sort the list alphabetically.\n    \n    You may assume that all words will have the same length.\n    \n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the resulting list sorted in ascending order by length.\n    If two strings have the same length, they are sorted alphabetically.\n\n    Parameters:\n    lst (list of str): The list of strings to process.\n\n    Returns:\n    list of str: The sorted list with only even-length strings.\n    \n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # Sort first alphabetically to ensure correct order when lengths are equal\n    even_length_strings.sort()\n    # Then sort by length\n    even_length_strings.sort(key=len)\n    return even_length_strings", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the resulting list sorted by ascending length.\n    If two strings have the same length, they are sorted alphabetically.\n    \n    Parameters:\n    lst (List[str]): The list of strings to sort.\n    \n    Returns:\n    List[str]: The sorted list with only even-length strings.\n    \n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    >>> sorted_list_sum([\"apple\", \"bat\", \"car\", \"door\", \"egg\"])\n    ['door']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort first by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the sorted list. The sorting is done primarily\n    by the length of each word in ascending order, and alphabetically\n    for words of the same length.\n\n    Args:\n        lst (list of str): The list of strings to process.\n\n    Returns:\n        list of str: The processed and sorted list of strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the sorted list. The sorting is done first by\n    ascending length of each word, and then alphabetically\n    for words with the same length.\n\n    Parameters:\n    lst (list of str): The input list of strings.\n\n    Returns:\n    list of str: The filtered and sorted list of strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    sorted_lst = sorted(filtered, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function accepts a list of strings, removes the strings with odd lengths,\n    and returns the resulting list sorted by ascending length and alphabetically\n    for strings of the same length.\n\n    Args:\n        lst (list of str): The input list of strings.\n\n    Returns:\n        list of str: The filtered and sorted list of strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_filtered = sorted(filtered, key=lambda x: (len(x), x))\n    \n    return sorted_filtered", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the resulting list sorted by length ascending.\n    If two strings have the same length, they are sorted alphabetically.\n    \n    Parameters:\n    lst (list of str): The input list of strings.\n    \n    Returns:\n    list of str: The filtered and sorted list of strings.\n    \n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered = [s for s in lst if len(s) % 2 == 0]\n    # Sort by length ascending, then alphabetically\n    sorted_filtered = sorted(filtered, key=lambda x: (len(x), x))\n    return sorted_filtered", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the resulting list sorted by length (ascending).\n    If two words have the same length, they are sorted alphabetically.\n\n    Args:\n        lst (list of str): The list of strings to process.\n\n    Returns:\n        list of str: The filtered and sorted list of strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first alphabetically, then by length\n    even_length_strings.sort()  # Sort alphabetically\n    even_length_strings.sort(key=len)  # Then sort by length\n\n    return even_length_strings", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the sorted list. The sorting is done first by\n    ascending length of each word, and then alphabetically\n    for words of the same length.\n\n    Parameters:\n    lst (list of str): The input list of strings.\n\n    Returns:\n    list of str: The filtered and sorted list of strings.\n    \n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    \n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    \n    The function should return a list of strings in sorted order.\n    \n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    assert sorted_list_sum([\"apple\", \"bat\", \"car\", \"door\", \"egg\"]) == [\"door\", \"apple\"]\n    assert sorted_list_sum([]) == []\n    assert sorted_list_sum([\"one\", \"three\", \"five\", \"seven\"]) == []\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the resulting list sorted in ascending order by\n    length and alphabetically for strings of the same length.\n\n    Parameters:\n    lst (list of str): The list of strings to process.\n\n    Returns:\n    list of str: The filtered and sorted list of strings.\n    \n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the list sorted by ascending length and alphabetically\n    for strings of the same length.\n    \n    Parameters:\n    lst (list of str): The input list of strings.\n    \n    Returns:\n    list of str: The sorted list with only even-length strings.\n    \n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    \n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    \n    If two words have the same length, sort the list alphabetically.\n    \n    The function should return a list of strings in sorted order.\n    \n    You may assume that all words will have the same length.\n    \n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    # Although all words have the same length as per assumption,\n    # sorting alphabetically is sufficient\n    sorted_words = sorted(even_length_words, key=lambda x: (len(x), x))\n    \n    return sorted_words", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    \n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length after filtering.\n\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length ascending, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    \n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    \n    The function should return a list of strings in sorted order.\n    \n    Examples:\n        assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n        assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_words = sorted(even_length_words, key=lambda x: (len(x), x))\n    \n    return sorted_words", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine whether a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False if n is prime.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Exclude other even numbers\n\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True  # Found a divisor, not prime\n    return False  # No divisors found, prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n\n    sqrt_n = int(n**0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine whether a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n\n    sqrt_n = int(n**0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    sqrt_n = int(n ** 0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines whether a given number is not a prime.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    sqrt_n = int(n ** 0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines whether a given number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True  # Found a divisor, not prime\n    return False  # No divisors found, prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines whether a number is not prime.\n    \n    Args:\n        n (int): The number to check.\n        \n    Returns:\n        bool: True if n is not prime, False if n is prime.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Other even numbers are not prime\n\n    sqrt_n = int(n**0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not a prime number.\n    \n    Args:\n    - n (int): The number to check.\n    \n    Returns:\n    - bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Multiples of 2 and 3 are not primes\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False if n is prime.\n    \"\"\"\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n    sqrt_n = int(n ** 0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"Return True if n is not a prime number, False otherwise.\"\"\"\n    if n < 2:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    sqrt_n = int(n**0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines whether a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Other even numbers are not primes\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Identify if a number is non-prime.\n    \n    Args:\n        n (int): The number to check.\n        \n    Returns:\n        bool: True if the number is not prime, False otherwise.\n    \n    Example:\n        >>> is_not_prime(2)\n        False\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Returns True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines whether a number is not prime.\n    \n    Args:\n        n (int): The number to check.\n        \n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from the given list in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to return\n    :return: List of n largest integers in descending order\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Returns the n largest integers from the given list in descending order.\n\n    Parameters:\n    nums (list): The list of integers.\n    n (int): The number of largest integers to retrieve.\n\n    Returns:\n    list: A list containing the n largest integers sorted in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from the given list, returned in descending order.\n    \n    Parameters:\n    numbers (List[int]): The list of integers to search.\n    n (int): The number of largest integers to find.\n    \n    Returns:\n    List[int]: A list containing the n largest integers in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    if n >= len(numbers):\n        return sorted(numbers, reverse=True)\n    \n    # Initialize a min-heap with the first n elements\n    min_heap = numbers[:n]\n    heapq.heapify(min_heap)\n    \n    # Iterate over the remaining elements\n    for num in numbers[n:]:\n        if num > min_heap[0]:\n            heapq.heappushpop(min_heap, num)\n    \n    # Extract the n largest elements and sort them in descending order\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Parameters:\n    nums (List[int]): The list of integers.\n    n (int): The number of largest integers to find.\n\n    Returns:\n    List[int]: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Parameters:\n    nums (List[int]): The list of integers.\n    n (int): The number of largest integers to find.\n    \n    Returns:\n    List[int]: A list containing the n largest integers in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use a min-heap of size n\n    min_heap = nums[:n]\n    heapq.heapify(min_heap)\n    \n    for num in nums[n:]:\n        if num > min_heap[0]:\n            heapq.heappushpop(min_heap, num)\n    \n    # Extract the elements from the heap and sort them in descending order\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from the given list, returned in descending order.\n\n    Args:\n        nums (list): List of numerical values.\n        n (int): Number of largest values to find.\n\n    Returns:\n        list: List containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Returns the n largest integers from the list nums in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Write a function to find the n largest integers from a given list of numbers, returned in descending order.\n    assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65]\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from the given list and return them in descending order.\n    \n    Parameters:\n    numbers (List[int]): The list of integers to search.\n    n (int): The number of largest integers to find.\n    \n    Returns:\n    List[int]: A list containing the n largest integers in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    if n >= len(numbers):\n        return sorted(numbers, reverse=True)\n    \n    # Initialize a min-heap with the first n elements\n    min_heap = numbers[:n]\n    heapq.heapify(min_heap)\n    \n    # Iterate through the remaining elements\n    for num in numbers[n:]:\n        if num > min_heap[0]:\n            heapq.heappushpop(min_heap, num)\n    \n    # Return the sorted list in descending order\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Return the n largest integers from the list 'nums' in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Returns the n largest integers from the given list in descending order.\n    \n    Parameters:\n    nums (List[int]): The list of integers.\n    n (int): The number of largest integers to return.\n    \n    Returns:\n    List[int]: A list of the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from the given list in descending order.\n\n    Parameters:\n    numbers (list): The list of integers.\n    n (int): The number of largest integers to return.\n\n    Returns:\n    list: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list, returned in descending order.\n\n    Args:\n        numbers (list): List of integers.\n        n (int): Number of largest integers to find.\n\n    Returns:\n        list: The n largest integers in descending order.\n    \n    Example:\n        >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n        [85, 75, 65]\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        numbers (List[int]): The list of integers to search.\n        n (int): The number of largest integers to find.\n\n    Returns:\n        List[int]: A list of the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from the given list and return them in descending order.\n    \n    Parameters:\n    numbers (list): The list of integers.\n    n (int): Number of top largest integers to return.\n    \n    Returns:\n    list: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from the given list and return them in descending order.\n\n    Args:\n        nums (List[int]): The list of integers to search.\n        n (int): The number of largest integers to find.\n\n    Returns:\n        List[int]: A list containing the n largest integers in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n    \n    # Initialize a min-heap with the first n elements\n    min_heap = nums[:n]\n    heapq.heapify(min_heap)\n    \n    # Iterate through the remaining elements\n    for num in nums[n:]:\n        if num > min_heap[0]:\n            heapq.heappushpop(min_heap, num)\n    \n    # Sort the heap in descending order before returning\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Write a function to find the n largest integers from a given list of numbers, returned in descending order.\n    assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    min_heap = []\n    \n    for num in numbers:\n        if len(min_heap) < n:\n            heapq.heappush(min_heap, num)\n        else:\n            if num > min_heap[0]:\n                heapq.heappushpop(min_heap, num)\n    \n    # Sort the heap in descending order before returning\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers and return them in descending order.\n\n    Args:\n        numbers (list): The list of integers to search.\n        n (int): The number of top elements to return.\n\n    Returns:\n        list: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Parameters:\n    numbers (list): The list of integers to search.\n    n (int): The number of top elements to retrieve.\n\n    Returns:\n    list: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Returns the n largest integers from the given list in descending order.\n    \n    Parameters:\n    nums (List[int]): The list of integers.\n    n (int): The number of largest integers to find.\n    \n    Returns:\n    List[int]: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 90.71428571428571, "dps_norm": 65.5, "pass@1": 96.0, "profiled": [{"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    A rotation is defined as moving the first character to the end of the string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        int: The minimum number of rotations needed to return to the original string.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0  # Edge case: empty string requires 0 rotations\n\n    # Compute the Longest Prefix Suffix (LPS) array using KMP preprocessing\n    lps = [0] * n\n    length = 0  # length of the previous longest prefix suffix\n\n    for i in range(1, n):\n        while length > 0 and s[i] != s[length]:\n            length = lps[length - 1]\n        \n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n        else:\n            lps[i] = 0\n\n    # The minimal period\n    p = n - lps[-1]\n\n    if p != n and n % p == 0:\n        return p\n    else:\n        return n", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Parameters:\n    s (str): The input string to be rotated.\n    \n    Returns:\n    int: The minimum number of rotations required to return to the original string.\n    \"\"\"\n    n = len(s)\n    pi = [0] * n  # Prefix function\n\n    # Build the prefix function using KMP algorithm\n    for i in range(1, n):\n        j = pi[i - 1]\n        while j > 0 and s[i] != s[j]:\n            j = pi[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        pi[i] = j\n\n    # Calculate the minimal period\n    p = n - pi[-1]\n    \n    if p != 0 and n % p == 0:\n        return p\n    else:\n        return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The minimal number of rotations required to return to the original string.\n    \"\"\"\n    n = len(s)\n    pi = [0] * n  # Prefix function array\n\n    # Compute the prefix function (KMP algorithm)\n    for i in range(1, n):\n        j = pi[i - 1]\n        while j > 0 and s[i] != s[j]:\n            j = pi[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        pi[i] = j\n\n    # Calculate the minimal period\n    p = n - pi[-1]\n\n    # If the string can be constructed by repeating its minimal period\n    if p < n and n % p == 0:\n        return p\n    else:\n        return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    lps = [0] * n  # Longest Prefix Suffix array\n    length = 0  # Length of the previous longest prefix suffix\n\n    # Preprocess the pattern to compute lps array\n    for i in range(1, n):\n        while length > 0 and s[i] != s[length]:\n            length = lps[length - 1]\n\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n        else:\n            lps[i] = 0\n\n    # Calculate the minimal rotation\n    p = n - lps[-1]\n    if p > 0 and n % p == 0:\n        return p\n    else:\n        return n", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of left rotations required to return the string to its original form.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    lps = [0] * n  # Longest Prefix Suffix array\n    length = 0  # Length of the previous longest prefix suffix\n\n    # Build the LPS array using the KMP preprocessing algorithm\n    for i in range(1, n):\n        while length > 0 and s[i] != s[length]:\n            length = lps[length - 1]\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n        else:\n            lps[i] = 0\n\n    # The minimum rotation is based on the smallest period of the string\n    minimal_period = n - lps[-1]\n    if n % minimal_period == 0:\n        return minimal_period\n    else:\n        return n", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    lps = [0] * n  # Longest Prefix Suffix (LPS) array\n    length = 0  # Length of the previous longest prefix suffix\n\n    # Build the LPS array using the KMP preprocessing algorithm\n    for i in range(1, n):\n        while length > 0 and s[i] != s[length]:\n            length = lps[length - 1]\n\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n        else:\n            lps[i] = 0\n\n    # Calculate the minimal rotation\n    minimal_period = n - lps[-1]\n    if minimal_period != n and n % minimal_period == 0:\n        return minimal_period\n    else:\n        return n", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string to rotate.\n    \n    Returns:\n    int: The minimum number of rotations needed to return to the original string.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        if n % k != 0:\n            continue  # Rotation must evenly divide the string length\n        rotated = s[k:] + s[:k]\n        if rotated == s:\n            return k\n    return n  # In the worst case, the entire string needs to be rotated", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations required to return the string to its original form.\n    \n    Parameters:\n    s (str): The input string to be rotated.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    lps = [0] * n  # Longest Prefix Suffix (LPS) array\n\n    # Build the LPS array using the KMP preprocessing algorithm\n    for i in range(1, n):\n        length = lps[i - 1]\n        while length > 0 and s[i] != s[length]:\n            length = lps[length - 1]\n        if s[i] == s[length]:\n            length += 1\n        lps[i] = length\n\n    # The smallest period is the length minus the last value in the LPS array\n    period = n - lps[-1]\n\n    # If the string length is divisible by the period, return the period\n    # Otherwise, the period is the length of the string itself\n    if n % period == 0:\n        return period\n    else:\n        return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0  # Edge case: empty string requires 0 rotations\n\n    # Compute the Longest Prefix Suffix (LPS) array using KMP preprocessing\n    lps = [0] * n\n    length = 0  # length of the previous longest prefix suffix\n\n    for i in range(1, n):\n        while length > 0 and s[i] != s[length]:\n            length = lps[length - 1]\n\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n        else:\n            lps[i] = 0\n\n    # The minimal period is n - lps[-1]\n    p = n - lps[-1]\n\n    # If n is divisible by the period, return the period\n    # Otherwise, the string does not have a smaller period, so return n\n    if n % p == 0:\n        return p\n    else:\n        return n", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    :param s: The input string.\n    :return: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    lps = [0] * n  # Longest Prefix Suffix array\n    length = 0  # Length of the previous longest prefix suffix\n\n    # Preprocess the pattern (calculate lps array)\n    for i in range(1, n):\n        while length > 0 and s[i] != s[length]:\n            length = lps[length - 1]\n\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n        else:\n            lps[i] = 0\n\n    # The minimal period is n - lps[-1]\n    period = n - lps[-1]\n    if n % period == 0:\n        return period\n    else:\n        return n", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    A rotation is defined as moving the first k characters to the end of the string.\n    \n    Parameters:\n    s (str): The input string to be rotated.\n    \n    Returns:\n    int: The minimum number of rotations required to return to the original string.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        if s == s[k:] + s[:k]:\n            return k\n    return n  # In case no smaller rotation satisfies the condition", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    A rotation is defined as moving the first character to the end of the string.\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        int: The minimum number of rotations needed to return to the original string.\n             Returns the length of the string if no smaller rotation exists.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        if n % k == 0:\n            rotated = s[k:] + s[:k]\n            if rotated == s:\n                return k\n    return n  # In the worst case, full rotation returns the string", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations required to return the string to its original form.\n    \n    A rotation is defined as moving the first character to the end of the string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations needed.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        if n % k == 0:\n            rotated = s[k:] + s[:k]\n            if rotated == s:\n                return k\n    return n  # In the worst case, the string returns to itself after n rotations", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations required to return the string to its original form.\n    A rotation is defined as moving the first character to the end of the string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required to return to the original string.\n    \"\"\"\n    n = len(s)\n    # Compute the prefix function (KMP failure function)\n    lps = [0] * n\n    length = 0  # length of the previous longest prefix suffix\n\n    # the loop calculates lps[i] for i from 1 to n-1\n    for i in range(1, n):\n        while length > 0 and s[i] != s[length]:\n            length = lps[length - 1]\n\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n        else:\n            lps[i] = 0\n\n    # The minimal period is n - lps[-1]\n    minimal_period = n - lps[-1]\n\n    # If the string is not composed of repeated patterns, the minimal period is n\n    if n % minimal_period == 0:\n        return minimal_period\n    else:\n        return n", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations needed.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        if n % k == 0:\n            rotated = s[k:] + s[:k]\n            if rotated == s:\n                return k\n    return n  # In worst case, full rotation is needed", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    A rotation is defined as moving the first character of the string to the end.\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        int: The minimum number of rotations needed to return to the original string.\n             Returns -1 if no such rotation exists (which shouldn't happen for non-empty strings).\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return -1  # Undefined for empty string\n\n    # Compute the longest prefix which is also a suffix\n    lps = [0] * n\n    length = 0  # Length of the previous longest prefix suffix\n\n    for i in range(1, n):\n        while length > 0 and s[i] != s[length]:\n            length = lps[length - 1]\n\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n        else:\n            lps[i] = 0\n\n    # The minimal period is n - lps[-1]\n    period = n - lps[-1]\n\n    if period != n and n % period == 0:\n        return period\n    else:\n        return n  # The string doesn't repeat, so full length is the period", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    A rotation is defined as moving the first character to the end of the string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations needed to return to the original string.\n    \"\"\"\n    n = len(s)\n    lps = [0] * n  # Longest Prefix Suffix array\n    length = 0  # Length of the previous longest prefix suffix\n    i = 1\n\n    # Build the LPS array using the KMP preprocessing algorithm\n    while i < n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    # The minimal period is n - lps[-1]\n    minimal_period = n - lps[-1]\n\n    # If the string can be constructed by repeating its minimal period\n    if n % minimal_period == 0:\n        return minimal_period\n    else:\n        return n  # The whole string is the period", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string to rotate.\n    \n    Returns:\n    int: The minimum number of rotations required to return to the original string.\n    \"\"\"\n    n = len(s)\n    lps = [0] * n  # Longest Prefix Suffix array\n\n    # Build the LPS array using KMP preprocessing\n    length = 0  # length of the previous longest prefix suffix\n    for i in range(1, n):\n        while length > 0 and s[i] != s[length]:\n            length = lps[length - 1]\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n        else:\n            lps[i] = 0\n\n    # The minimal period p\n    p = n - lps[-1]\n\n    # If n is divisible by p, then p is the minimal rotation\n    if n % p == 0:\n        return p\n    else:\n        return n  # The whole string is the period", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    A rotation is defined as moving the first character of the string to the end.\n    For example, rotating \"abcde\" once results in \"bcdea\".\n    \n    Args:\n        s (str): The input string to rotate.\n\n    Returns:\n        int: The minimum number of rotations needed to return to the original string.\n             Returns the length of the string if no smaller rotation cycle exists.\n             \n    Examples:\n        >>> find_Rotations(\"aaaa\")\n        1\n        >>> find_Rotations(\"abcde\")\n        5\n        >>> find_Rotations(\"abab\")\n        2\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n  # If no rotation smaller than n returns the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations needed to return to the original string.\n    \"\"\"\n    n = len(s)\n    for rotation in range(1, n + 1):\n        if rotation == n:\n            return n\n        rotated = s[rotation:] + s[:rotation]\n        if rotated == s:\n            return rotation\n    return n  # Fallback, should not reach here", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": 40.3584229390681, "dps_norm": 91.11111111111111, "pass@1": 98.0, "profiled": [{"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Removes the first and last occurrence of character `c` from string `s`.\n    If `c` occurs only once, it is removed.\n    If `c` does not exist in `s`, the original string is returned.\n    \n    :param s: The original string.\n    :param c: The character to remove.\n    :return: Modified string with specified characters removed.\n    \"\"\"\n    first = s.find(c)\n    if first == -1:\n        # Character not found\n        return s\n\n    last = s.rfind(c)\n    \n    if first == last:\n        # Character occurs only once\n        return s[:first] + s[first+1:]\n    else:\n        # Remove last occurrence first to not mess up the first index\n        s = s[:last] + s[last+1:]\n        s = s[:first] + s[first+1:]\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of `char` from the string `s`.\n    \n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n    \n    Returns:\n    str: The modified string with the first and last occurrence of `char` removed.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n    \n    if first == -1:\n        # Character not found\n        return s\n    if first == last:\n        # Only one occurrence found\n        return s[:first] + s[first+1:]\n    \n    # Remove the last occurrence first to avoid shifting the first index\n    s = s[:last] + s[last+1:]\n    # Then remove the first occurrence\n    s = s[:first] + s[first+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of 'char' from the string 's'.\n    \n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n    \n    Returns:\n    str: The modified string with the first and last occurrence of 'char' removed.\n    \"\"\"\n    try:\n        first = s.index(char)\n        last = s.rindex(char)\n        if first == last:\n            # Only one occurrence, remove it\n            return s[:first] + s[first+1:]\n        else:\n            # Remove last first to not mess up the first index\n            s = s[:last] + s[last+1:]\n            s = s[:first] + s[first+1:]\n            return s\n    except ValueError:\n        # Character not found, return original string\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a specified character from the string.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The string after removing the first and last occurrence of the specified character.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n\n    if first == -1:\n        # Character not found; return the original string\n        return s\n    elif first == last:\n        # Only one occurrence; remove it\n        return s[:first] + s[first+1:]\n    else:\n        # Remove the last occurrence first to avoid affecting the first index\n        s = s[:last] + s[last+1:]\n        # Remove the first occurrence\n        s = s[:first] + s[first+1:]\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, c: str) -> str:\n    \"\"\"\n    Removes the first and last occurrence of the character 'c' from the string 's'.\n    \n    Parameters:\n    s (str): The original string.\n    c (str): The character to remove.\n    \n    Returns:\n    str: The string after removing the first and last occurrence of 'c'.\n    \"\"\"\n    first = s.find(c)\n    last = s.rfind(c)\n    \n    if first == -1:\n        # Character not found; return original string\n        return s\n    elif first == last:\n        # Character occurs only once; remove it\n        return s[:first] + s[first+1:]\n    else:\n        # Remove the last occurrence first to not affect the position of the first\n        s = s[:last] + s[last+1:]\n        # Then remove the first occurrence\n        s = s[:first] + s[first+1:]\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Removes the first and last occurrence of the given character 'c' from the string 's'.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of 'c' removed.\n    \"\"\"\n    # Find the index of the first occurrence of 'c'\n    first = s.find(c)\n    # Find the index of the last occurrence of 'c'\n    last = s.rfind(c)\n\n    if first == -1:\n        # If 'c' is not found in the string, return the original string\n        return s\n    if first == last:\n        # If 'c' occurs only once, remove that single occurrence\n        return s[:first] + s[first+1:]\n    \n    # Remove the first and last occurrence of 'c'\n    # Ensure that removing the first occurrence doesn't affect the last index\n    # by slicing the string appropriately\n    without_first = s[:first] + s[first+1:]\n    # Adjust the last index if it was after the first removed character\n    if last > first:\n        last -= 1\n    # Remove the last occurrence from the string without the first removal\n    result = without_first[:last] + without_first[last+1:]\n    return result", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of the specified character from the string.\n\n    Args:\n        s (str): The original string.\n        char (str): The character to remove.\n\n    Returns:\n        str: The modified string with the first and last occurrences of `char` removed.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first == -1:\n        return s\n    \n    # If the character occurs only once, remove that single occurrence\n    if first == last:\n        return s[:first] + s[first+1:]\n    \n    # Remove the last occurrence first to avoid affecting the first index\n    s = s[:last] + s[last+1:]\n    \n    # Remove the first occurrence\n    first = s.find(char)\n    s = s[:first] + s[first+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of the specified character from the string.\n\n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of `char` removed.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n\n    if first == -1:\n        # Character not found in the string\n        return s\n    if first == last:\n        # Character occurs only once\n        return s[:first] + s[first+1:]\n    \n    # Remove first and last occurrences\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Removes the first and last occurrence of the character `c` from the string `s`.\n\n    Parameters:\n    s (str): The original string.\n    c (str): The character to remove.\n\n    Returns:\n    str: The modified string after removing the first and last occurrence of `c`.\n    \"\"\"\n    first = s.find(c)\n    if first == -1:\n        # Character not found, return original string\n        return s\n\n    last = s.rfind(c)\n    \n    if first == last:\n        # Only one occurrence, remove it\n        return s[:first] + s[first+1:]\n    else:\n        # Remove last occurrence first to not affect the index of first occurrence\n        s = s[:last] + s[last+1:]\n        s = s[:first] + s[first+1:]\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Removes the first and last occurrence of the character `c` from the string `s`.\n    \n    Parameters:\n    s (str): The original string.\n    c (str): The character to remove.\n    \n    Returns:\n    str: The modified string with the first and last occurrences of `c` removed.\n    \"\"\"\n    first = s.find(c)\n    last = s.rfind(c)\n    \n    # If the character is not found, return the original string\n    if first == -1:\n        return s\n    \n    # If the first and last occurrence are the same, remove it once\n    if first == last:\n        return s[:first] + s[first+1:]\n    \n    # Remove the last occurrence first to avoid index shifting\n    s = s[:last] + s[last+1:]\n    # Then remove the first occurrence\n    s = s[:first] + s[first+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Removes the first and last occurrence of the character `c` from the string `s`.\n    \n    :param s: The original string.\n    :param c: The character to remove.\n    :return: A new string with the first and last occurrence of `c` removed.\n    \"\"\"\n    first = s.find(c)\n    last = s.rfind(c)\n\n    if first == -1:\n        # Character not found, return original string\n        return s\n    elif first == last:\n        # Character found only once, remove it\n        return s[:first] + s[first+1:]\n    else:\n        # Remove last occurrence first to not affect the first index\n        s = s[:last] + s[last+1:]\n        # Then remove the first occurrence\n        s = s[:first] + s[first+1:]\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Removes the first and last occurrence of character `c` from the string `s`.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to remove.\n\n    Returns:\n    str: The string after removing the first and last occurrence of `c`.\n    \"\"\"\n    first = s.find(c)\n    last = s.rfind(c)\n    \n    if first == -1:\n        # Character not found\n        return s\n    if first == last:\n        # Only one occurrence found\n        return s[:first] + s[first+1:]\n    \n    # Remove the last occurrence first to not affect the first index\n    s = s[:last] + s[last+1:]\n    # Then remove the first occurrence\n    s = s[:first] + s[first+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, c: str) -> str:\n    \"\"\"\n    Removes the first and last occurrence of the character `c` from the string `s`.\n    If the character occurs only once, it removes that single occurrence.\n    If the character does not exist in the string, it returns the original string.\n    \"\"\"\n    first = s.find(c)\n    last = s.rfind(c)\n\n    if first == -1:\n        # Character not found, return original string\n        return s\n    elif first == last:\n        # Character found only once, remove it\n        return s[:first] + s[first+1:]\n    else:\n        # Remove the last occurrence first to avoid altering the index of the first\n        s = s[:last] + s[last+1:]\n        # Then remove the first occurrence\n        s = s[:first] + s[first+1:]\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of 'char' from the string 's'.\n    If 'char' occurs only once, it removes that single occurrence.\n    If 'char' does not exist in 's', returns the original string.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n\n    # If the character is not found, return the original string\n    if first == -1:\n        return s\n\n    # If the first and last occurrences are the same, remove it once\n    if first == last:\n        return s[:first] + s[first+1:]\n\n    # Remove the last occurrence first to avoid affecting the first index\n    s = s[:last] + s[last+1:]\n    # Remove the first occurrence\n    s = s[:first] + s[first+1:]\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of the specified character from the string.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The string after removing the first and last occurrence of the character.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n\n    if first == -1:\n        # Character not found in the string\n        return s\n    if first == last:\n        # Character occurs only once\n        return s[:first] + s[first+1:]\n    # Remove first and last occurrence\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of char from string s.\n    \n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n    \n    Returns:\n    str: The string after removing the first and last occurrence of char.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n    \n    if first == -1:\n        # Character not found\n        return s\n    if first == last:\n        # Character found only once\n        return s[:first] + s[first+1:]\n    \n    # Remove last occurrence first to not affect the index of first\n    s = s[:last] + s[last+1:]\n    # Then remove first occurrence\n    s = s[:first] + s[first+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of the specified character from the string.\n\n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with first and last occurrences of char removed.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n\n    # If the character is not found, return the original string\n    if first == -1:\n        return s\n\n    # If the character occurs only once, remove that single occurrence\n    if first == last:\n        return s[:first] + s[first+1:]\n\n    # Remove the last occurrence first to avoid affecting the first index\n    s = s[:last] + s[last+1:]\n    # Then remove the first occurrence\n    s = s[:first] + s[first+1:]\n\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    :param s: The original string.\n    :param ch: The character to remove.\n    :return: The modified string with first and last occurrences of ch removed.\n    \"\"\"\n    first = s.find(ch)\n    if first == -1:\n        # Character not found, return original string\n        return s\n\n    last = s.rfind(ch)\n    if first == last:\n        # Only one occurrence, remove it\n        return s[:first] + s[first + 1:]\n\n    # Remove first occurrence\n    s = s[:first] + s[first + 1:]\n    # Adjust last index since the string has been modified\n    last -= 1\n    # Remove last occurrence\n    s = s[:last] + s[last + 1:]\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Remove the first and last occurrence of the character `c` from the string `s`.\n    \n    Example:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    \"\"\"\n    first = s.find(c)\n    if first == -1:\n        # Character not found, return original string\n        return s\n    last = s.rfind(c)\n    if first == last:\n        # Only one occurrence, remove it\n        return s[:first] + s[first+1:]\n    # Remove both first and last occurrences\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The string after removing the first and last occurrence of the character.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n\n    if first == -1:\n        # Character not found, return the original string\n        return s\n    if first == last:\n        # Character occurs only once, remove it\n        return s.replace(char, '', 1)\n    \n    # Remove the first and last occurrence\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (List[List[int]]): The matrix to sort.\n\n    Returns:\n        List[List[int]]: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to sort.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): A 2D list where each sublist represents a row in the matrix.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of list of int): The matrix to be sorted.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n        matrix (list of lists): The matrix to be sorted.\n    \n    Returns:\n        list of lists: The sorted matrix.\n    \n    Example:\n        >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n        [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to sort.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (list of lists): The input matrix to be sorted.\n\n    Returns:\n        list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of each row.\n\n    Parameters:\n    matrix (List[List[int]]): A list of lists where each sublist represents a row in the matrix.\n\n    Returns:\n    List[List[int]]: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to sort.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to sort.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (list of lists): The input matrix to sort.\n\n    Returns:\n        list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of list of int): The matrix to be sorted.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (List[List[int]]): A list of lists where each sublist represents a row in the matrix.\n\n    Returns:\n        List[List[int]]: The matrix sorted by the sum of each row in ascending order.\n\n    Example:\n        >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n        [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    if not all(isinstance(row, list) for row in matrix):\n        raise ValueError(\"The matrix should be a list of lists.\")\n    \n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (list of lists): The matrix to sort.\n\n    Returns:\n        list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 87.3170731707317, "dps_norm": 95.0, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters \n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string consists of lowercase letters separated by underscores.\n    Otherwise, returns False.\n    \"\"\"\n    pattern = re.compile(r'^[a-z]+(?:_[a-z]+)*$')\n    return bool(pattern.fullmatch(s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, False otherwise.\n    \n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"aab_cbbBc\")\n    False\n    >>> text_lowercase_underscore(\"aab__cbbbc\")\n    False\n    >>> text_lowercase_underscore(\"_aab_cbbbc\")\n    False\n    >>> text_lowercase_underscore(\"aab-cbbbc\")\n    False\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with a single underscore. Otherwise, returns False.\n    \n    Args:\n    - s (str): The input string to check.\n    \n    Returns:\n    - bool: True if pattern matches, False otherwise.\n    \"\"\"\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    return bool(pattern.match(s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, otherwise False.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string consists of sequences of lowercase letters\n    joined by underscores, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore\n    and False otherwise.\n    \n    Examples:\n        >>> text_lowercase_underscore(\"aab_cbbbc\")\n        True\n        >>> text_lowercase_underscore(\"Aab_cbbbc\")\n        False\n        >>> text_lowercase_underscore(\"aab__cbbbc\")\n        False\n        >>> text_lowercase_underscore(\"aabcbbbc\")\n        True\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string consists of lowercase letters sequences\n    separated by a single underscore, and False otherwise.\n    \n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"Aab_cbbbc\")\n    False\n    >>> text_lowercase_underscore(\"aab__cbbbc\")\n    False\n    >>> text_lowercase_underscore(\"aab_cbbbC\")\n    False\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n\n    Args:\n        s (str): The input string to check.\n\n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n\n    Example:\n        >>> text_lowercase_underscore(\"aab_cbbbc\")\n        True\n        >>> text_lowercase_underscore(\"Aab_cbbbc\")\n        False\n        >>> text_lowercase_underscore(\"aab-cbbbc\")\n        False\n    \"\"\"\n    pattern = re.compile(r'^[a-z]+(?:_[a-z]+)*$')\n    return bool(pattern.match(s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string consists of sequences of lowercase letters\n    joined by a single underscore. Otherwise, returns False.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string consists of lowercase letters\n    separated by underscores, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Returns True if the input string consists of sequences of lowercase letters\n    joined by single underscores, and False otherwise.\n    \"\"\"\n    pattern = re.compile(r'^[a-z]+(?:_[a-z]+)*$')\n    return bool(pattern.match(s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string consists of sequences of lowercase letters\n    joined by a single underscore. Otherwise, returns False.\n    \n    Parameters:\n    s (str): The input string to be evaluated.\n    \n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = re.compile(r'^[a-z]+(?:_[a-z]+)*$')\n    return bool(pattern.fullmatch(s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string consists of lowercase letters separated by single underscores.\n    Otherwise, returns False.\n    \"\"\"\n    pattern = re.compile(r'^[a-z]+(?:_[a-z]+)*$')\n    return bool(pattern.fullmatch(s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string consists of lowercase letters separated by underscores.\n    Otherwise, returns False.\n    \"\"\"\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    return bool(pattern.match(s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore and False otherwise.\n    \n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"Aab_cbbbc\")\n    False\n    >>> text_lowercase_underscore(\"aab__cbbbc\")\n    False\n    >>> text_lowercase_underscore(\"aab_cbbbc_\")\n    False\n    \"\"\"\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    return bool(pattern.match(s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"abc_DEF\")\n    False\n    >>> text_lowercase_underscore(\"abc_def_ghi\")\n    True\n    >>> text_lowercase_underscore(\"ABC_def\")\n    False\n    >>> text_lowercase_underscore(\"abc__def\")\n    False\n    \"\"\"\n    # The pattern matches the entire string from start (^) to end ($)\n    # consisting of lowercase letters separated by single underscores.\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}]}, "Mbpp/19": {"dps": 89.39393939393939, "dps_norm": 94.0, "pass@1": 92.0, "profiled": [{"solution": "def test_duplicate(nums):\n    \"\"\"\n    Determines if there are any duplicate elements in the array.\n\n    Args:\n        nums (list of int): The array of integers to check.\n\n    Returns:\n        bool: True if any duplicate element is found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Determines if the given list of integers contains any duplicate elements.\n\n    Args:\n        nums (List[int]): The list of integers to check.\n\n    Returns:\n        bool: True if any duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Check if the list `nums` contains any duplicate elements.\n\n    Args:\n        nums (list of int): The list of integers to check.\n\n    Returns:\n        bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Determines if there are any duplicate elements in the array.\n\n    :param nums: List of integers\n    :return: True if duplicates exist, False otherwise\n    \"\"\"\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if the input list contains any duplicate elements.\n\n    Args:\n        arr (list of int): The list of integers to check.\n\n    Returns:\n        bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Determines if the list 'nums' contains any duplicate elements.\n\n    Parameters:\n    nums (list of int): The list of integers to check for duplicates.\n\n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Determines whether the given list of integers contains any duplicate elements.\n\n    Args:\n    nums (List[int]): The list of integers to check for duplicates.\n\n    Returns:\n    bool: True if any duplicates are found, False otherwise.\n    \"\"\"\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Determines if the input list contains any duplicate elements.\n\n    Args:\n        nums (List[int]): The list of integers to check for duplicates.\n\n    Returns:\n        bool: True if any duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if there are any duplicate elements in the array.\n\n    Args:\n        arr (list of int): The array of integers to check.\n\n    Returns:\n        bool: True if duplicates exist, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if the array contains any duplicate elements.\n\n    Parameters:\n    arr (list of int): The array of integers to check.\n\n    Returns:\n    bool: True if any duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if the array contains any duplicate elements.\n\n    Parameters:\n    arr (list of int): The list of integers to check.\n\n    Returns:\n    bool: True if any duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list of int): The array of integers to check.\n\n    Returns:\n    bool: True if any duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines whether the given list of integers contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Determines if the given list of integers contains any duplicate elements.\n\n    Args:\n        nums (List[int]): The list of integers to check for duplicates.\n\n    Returns:\n        bool: True if any duplicate element is found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Returns True if there are any duplicate elements in the array, otherwise False.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if there are any duplicate elements in the array.\n\n    Parameters:\n    arr (list of int): The list of integers to check for duplicates.\n\n    Returns:\n    bool: True if any duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Determines if there are any duplicate elements in the given list of integers.\n\n    Args:\n        nums (List[int]): The list of integers to check for duplicates.\n\n    Returns:\n        bool: True if duplicates exist, False otherwise.\n    \"\"\"\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Determines if there are any duplicate integers in the given list.\n\n    Parameters:\n    nums (List[int]): The list of integers to check for duplicates.\n\n    Returns:\n    bool: True if any duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the array contains any duplicate elements.\n\n    Parameters:\n    arr (list of int): The list of integers to check.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if there are any duplicate elements in the array.\n    \n    Parameters:\n    arr (list of int): The list of integers to check for duplicates.\n    \n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 38.11538461538461, "dps_norm": 66.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in the provided list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    min_num = lst[0]\n    for num in lst[1:]:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 2}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Returns the smallest number in a list.\n\n    Parameters:\n    numbers (list): A list of integers or floats.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty.\")\n\n    min_num = numbers[0]\n    for num in numbers[1:]:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 2}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in the given list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds and returns the smallest number in a list.\n    \n    Args:\n        lst (list): A list of numbers.\n        \n    Returns:\n        The smallest number in the list.\n        \n    Raises:\n        ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds and returns the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Returns the smallest number in a list.\n\n    Parameters:\n    numbers (list): A list of numerical values.\n\n    Returns:\n    int or float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n\n    min_num = numbers[0]\n    for num in numbers[1:]:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 2}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    min_num = lst[0]\n    for num in lst[1:]:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 2}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Returns the smallest number in a list.\n\n    Parameters:\n    numbers (list): A list of numerical values.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty.\")\n    smallest = numbers[0]\n    for num in numbers[1:]:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 2}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int or float: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"List is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numerical values.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in the provided list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n\n    Raises:\n        ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    smallest = lst[0]\n    for num in lst[1:]:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 2}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds and returns the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    min_num = lst[0]\n    for num in lst[1:]:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 2}, {"solution": "def smallest_num(lst):\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    min_num = lst[0]\n    for num in lst[1:]:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 2}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find and return the smallest number in a list.\n\n    Args:\n        numbers (list): A list of numerical values.\n\n    Returns:\n        int or float: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty.\")\n    \n    min_num = numbers[0]\n    for num in numbers[1:]:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 2}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in a list.\n    \n    Parameters:\n    lst (list): A list of numbers.\n    \n    Returns:\n    int or float: The smallest number in the list.\n    \n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    min_num = lst[0]\n    for num in lst[1:]:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 2}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in the provided list.\n\n    Parameters:\n    lst (list): A list of integers or floats.\n\n    Returns:\n    The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    TypeError: If the list contains non-numeric elements.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    min_num = lst[0]\n    for num in lst:\n        if not isinstance(num, (int, float)):\n            raise TypeError(\"All elements in the list must be integers or floats.\")\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": -1}, {"solution": "def smallest_num(lst):\n    if not lst:\n        raise ValueError(\"List is empty\")\n    smallest = lst[0]\n    for num in lst[1:]:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 2}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in the provided list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    min_num = lst[0]\n    for num in lst[1:]:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 2}, {"solution": "def smallest_num(lst):\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in a list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find and return all tuples from the given list where every element is divisible by k.\n\n    Parameters:\n    tuples_list (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples in tuple_list where all elements are divisible by k.\n\n    Args:\n        tuple_list (list of tuples): The list of tuples to check.\n        k (int): The divisor.\n\n    Returns:\n        list of tuples: Tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds and returns tuples where all elements are divisible by k.\n\n    Parameters:\n    tuples_list (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n    \n    Parameters:\n    lst (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n    \n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [tpl for tpl in lst if all(x % k == 0 for x in tpl)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    tuple_list (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    tuple_list (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    list_of_tuples (list of tuples): The input list containing tuples of integers.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [tup for tup in list_of_tuples if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Find tuples where all elements are divisible by k.\n\n    Parameters:\n    lst (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples where all elements are divisible by k.\n    \n    Args:\n        tuple_list (list of tuples): The list of tuples to check.\n        k (int): The divisor.\n    \n    Returns:\n        list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor.\n    :return: List of tuples with all elements divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n    \n    Parameters:\n    tuple_list (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    tuple_list (list of tuples): The list of tuples to be checked.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds and returns tuples from the given list where all elements are divisible by k.\n\n    Parameters:\n    tuples_list (list of tuples): The list of tuples to be checked.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: A list containing tuples where every element is divisible by k.\n    \n    Example:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    tuples_list (list of tuples): The list of tuples to filter.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Find tuples where all elements are divisible by k.\n\n    Args:\n        lst (list of tuples): The list of tuples to check.\n        k (int): The divisor.\n\n    Returns:\n        list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds and returns a list of tuples where every element in each tuple is divisible by k.\n\n    Parameters:\n    list_of_tuples (list of tuples): The list of tuples to evaluate.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: A list containing tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in list_of_tuples if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    tuple_list (list of tuples): The list of tuples to be checked.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    result = []\n    for tpl in tuple_list:\n        if all(element % k == 0 for element in tpl):\n            result.append(tpl)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    tuple_list (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    :param tuple_list: List of tuples to be checked.\n    :param k: The divisor.\n    :return: List of tuples with all elements divisible by k.\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    tuples_list (List[Tuple[int]]): The list of tuples to filter.\n    k (int): The divisor to check against each element.\n\n    Returns:\n    List[Tuple[int]]: A list containing tuples with all elements divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 45.931372549019606, "dps_norm": 75.71428571428572, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n\n    Args:\n        lst (list): The list of elements to count.\n\n    Returns:\n        dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Parameters:\n    lst (list): The list of elements to count.\n    \n    Returns:\n    dict: A dictionary where keys are list elements and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    return freq", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Parameters:\n    lst (list): The list of elements to count.\n    \n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Parameters:\n    lst (list): The list of elements to count.\n    \n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    :param lst: List of elements to count\n    :return: Dictionary with element frequencies\n    \"\"\"\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    return freq", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the input list.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Parameters:\n    lst (list): The list of elements to count.\n    \n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n\n    Args:\n        lst (list): The list of elements to count.\n\n    Returns:\n        dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Parameters:\n    lst (list): The list of elements to count.\n    \n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n\n    Parameters:\n    lst (list): The list of elements to count.\n\n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \"\"\"\n    from collections import Counter\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Example:\n    >>> freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    from collections import Counter\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n\n    Parameters:\n    lst (list): The list of elements to count.\n\n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n\n    Parameters:\n    lst (list): The list of elements to count.\n\n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    return freq", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Parameters:\n    lst (list): The list of elements to count.\n    \n    Returns:\n    dict: A dictionary where keys are the elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Parameters:\n    lst (list): The list of elements to count.\n    \n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their counts.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n\n    Parameters:\n    lst (list): The list of elements to count.\n\n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}]}, "Mbpp/90": {"dps": 79.51219512195122, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the provided list.\n\n    Parameters:\n    words (list of str): A list containing words as strings.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the provided list.\n\n    Parameters:\n    words (list of str): A list containing words as strings.\n\n    Returns:\n    int: The length of the longest word.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not words:\n        raise ValueError(\"The list of words is empty.\")\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Parameters:\n    words (list of str): List containing words as strings.\n\n    Returns:\n    int: Length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the given list.\n\n    Parameters:\n    words (list of str): A list containing words as strings.\n\n    Returns:\n    int: The length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Args:\n        words (list of str): List of words to evaluate.\n\n    Returns:\n        int: Length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n    \n    Parameters:\n    words (list of str): A list containing words as strings.\n    \n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n    \n    Parameters:\n        words (list of str): List of words to evaluate.\n        \n    Returns:\n        int: Length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Parameters:\n    words (list of str): A list containing words as strings.\n\n    Returns:\n    int: The length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the provided list.\n\n    Parameters:\n    words (list of str): A list of words to evaluate.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Parameters:\n    words (list of str): List containing words as strings.\n\n    Returns:\n    int: Length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Parameters:\n    words (list of str): List of words to evaluate.\n\n    Returns:\n    int: Length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Parameters:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Args:\n        words (list of str): List of words.\n\n    Returns:\n        int: Length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words (list of str): The list of words to evaluate.\n\n    Returns:\n        int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0  # Return 0 if the list is empty\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Args:\n        words (list of str): The list of words to evaluate.\n\n    Returns:\n        int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the provided list.\n    \n    Parameters:\n    words (list of str): A list of words to evaluate.\n    \n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n    \n    Parameters:\n    words (list of str): List containing words as strings.\n    \n    Returns:\n    int: Length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Parameters:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the provided list.\n\n    Parameters:\n    words (list of str): A list of words to evaluate.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Parameters:\n    words (list of str): The list of words to evaluate.\n\n    Returns:\n    int: The length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 78.04878048780488, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    lst (list of tuples): List containing tuples with at least two elements.\n    \n    Returns:\n    The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    # Find the tuple with the smallest second element\n    min_tuple = min(lst, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    for tup in tuples_list[1:]:\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second value.\n    \n    Parameters:\n    tuples_list (list of tuples): List containing tuples with at least two elements.\n    \n    Returns:\n    The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list is empty.\")\n    \n    # Use the min function with a key to find the tuple with the smallest second value\n    smallest_tuple = min(tuples_list, key=lambda x: x[1])\n    return smallest_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    Example:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second value.\n\n    Parameters:\n    lst (list of tuples): A list where each tuple contains two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    # Initialize with the first tuple\n    min_tuple = lst[0]\n    for item in lst[1:]:\n        if item[1] < min_tuple[1]:\n            min_tuple = item\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Parameters:\n    lst (list of tuples): A list where each tuple contains two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value in the list.\n\n    :param lst: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second value.\n    \n    Parameters:\n    tuple_list (list of tuples): A list where each tuple contains two elements.\n    \n    Returns:\n    The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:\n        raise ValueError(\"The input list is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuple_list[0]\n    \n    for current in tuple_list[1:]:\n        if current[1] < min_tuple[1]:\n            min_tuple = current\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    # Find the tuple with the smallest second value\n    min_tuple = min(lst, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    lst (list of tuples): Each tuple contains two elements, where the second element is used for comparison.\n    \n    Returns:\n    The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second value.\n\n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list is empty.\")\n    \n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second value in the list.\n\n    Parameters:\n    lst (list of tuples): A list where each tuple contains two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Parameters:\n    lst (list of tuples): Each tuple contains two elements, where the second element is used for comparison.\n\n    Returns:\n    The first element of the tuple with the smallest second element.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Args:\n        lst (list of tuples): A list where each tuple contains at least two elements.\n        \n    Returns:\n        The first element of the tuple with the smallest second element.\n        \n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    # Use the min function with a key that extracts the second element of each tuple\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    lst (list of tuples): A list where each tuple contains at least two elements.\n    \n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The input list is empty.\")\n    \n    min_tuple = lst[0]\n    for item in lst[1:]:\n        if item[1] < min_tuple[1]:\n            min_tuple = item\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value in the list.\n\n    Args:\n        lst (list of tuples): Each tuple contains two elements where the second element is comparable.\n\n    Returns:\n        The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n\n    # Initialize with the first tuple\n    min_tuple = lst[0]\n    for current in lst[1:]:\n        if current[1] < min_tuple[1]:\n            min_tuple = current\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second value.\n\n    Parameters:\n    lst (list of tuples): A list where each tuple contains two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples_list (list of tuples): A list where each tuple contains two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The input list is empty.\")\n\n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    for current in tuples_list[1:]:\n        if current[1] < min_tuple[1]:\n            min_tuple = current\n            \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    tuple_list (list of tuples): A list where each tuple contains two elements.\n    \n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuple_list:\n        raise ValueError(\"The list is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuple_list[0]\n    \n    for current in tuple_list[1:]:\n        if current[1] < min_tuple[1]:\n            min_tuple = current\n            \n    return min_tuple[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 83.74999999999999, "dps_norm": 84.28571428571428, "pass@1": 100.0, "profiled": [{"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of the given integer n.\n\n    Parameters:\n    n (int): The integer to find the number of divisors for.\n\n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"Zero has an infinite number of divisors.\")\n    \n    count = 0\n    abs_n = abs(n)  # Handle negative integers\n\n    for i in range(1, int(abs_n**0.5) + 1):\n        if abs_n % i == 0:\n            count += 2 if i != abs_n // i else 1\n\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find divisors for.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n == 0:\n        return 0  # Undefined number of divisors for zero\n    n = abs(n)\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n        i += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def divisor(n):\n    if n == 0:\n        return 0  # Zero has an infinite number of divisors, returning 0 as undefined\n    n = abs(n)\n    count = 0\n    sqrt_n = int(n**0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of a given integer n.\n\n    Parameters:\n    n (int): The integer to find the number of divisors for.\n\n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"Zero has an infinite number of divisors.\")\n    n = abs(n)\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "matching_cluster_idx": 5}, {"solution": "import math\ndef divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find divisors for.\n    \n    Returns:\n    int: The number of positive divisors of n.\n    \"\"\"\n    if n < 1:\n        return 0  # No positive divisors for non-positive integers\n    count = 0\n    sqrt_n = math.isqrt(n)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of a given positive integer n.\n    \n    Parameters:\n    n (int): The integer to find divisors for. Must be a positive integer.\n    \n    Returns:\n    int: Number of divisors of n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    sqrt_n = int(n**0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2  # i and n//i are both divisors\n    if sqrt_n * sqrt_n == n:\n        count -= 1  # Correct the count if n is a perfect square\n    \n    return count", "matching_cluster_idx": 5}, {"solution": "import math\ndef divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find the number of divisors for. Must be positive.\n    \n    Returns:\n    int: The number of divisors of n.\n    \n    Raises:\n    ValueError: If n is not a positive integer.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    count = 0\n    sqrt_n = math.isqrt(n)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    \n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find the number of divisors for.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    sqrt_n = int(n**0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer to find divisors for.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"Zero has an infinite number of divisors.\")\n    \n    n = abs(n)\n    count = 0\n    sqrt_n = int(n**0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "matching_cluster_idx": 5}, {"solution": "import math\ndef divisor(n):\n    \"\"\"\n    Write a python function to find the number of divisors of a given integer.\n    assert divisor(15) == 4\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    sqrt_n = int(math.isqrt(n))\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "import math\ndef divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the given integer n.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of the given integer n.\n\n    Parameters:\n    n (int): The integer to find divisors for.\n\n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    sqrt_n = int(n ** 0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2  # i and n//i are both divisors\n    \n    if sqrt_n * sqrt_n == n:\n        count -= 1  # Correct the count if n is a perfect square\n    \n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    if n < 1:\n        return 0\n    count = 0\n    sqrt_n = int(n**0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    if n < 1:\n        return 0\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n        i += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer to find divisors for.\n    \n    Returns:\n    int: The count of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n        i += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def divisor(n):\n    if n == 0:\n        return 0  # Zero has an infinite number of divisors, but we'll return 0 for practicality\n    n = abs(n)\n    count = 0\n    sqrt_n = int(n ** 0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find the number of divisors for. Must be a positive integer.\n    \n    Returns:\n    int: The number of positive divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    sqrt_n = int(n**0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "import math\ndef divisor(n):\n    \"\"\"\n    Returns the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer to find the divisors of.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n == 0:\n        return float('inf')  # Zero has infinitely many divisors\n    n = abs(n)\n    count = 0\n    sqrt_n = int(math.isqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    if n == 0:\n        raise ValueError(\"Zero has an infinite number of divisors.\")\n    n = abs(n)\n    count = 0\n    sqrt_n = int(n**0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "matching_cluster_idx": 5}]}, "Mbpp/97": {"dps": 99.6923076923077, "dps_norm": 88.75, "pass@1": 100.0, "profiled": [{"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n    \n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n        \n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [element for sublist in list_of_lists for element in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency = dict(Counter(flattened))\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Use a generator expression to iterate through all elements efficiently\n    return dict(Counter(item for sublist in list_of_lists for item in sublist))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    freq = {}\n    for sublist in lists:\n        for item in sublist:\n            freq[item] = freq.get(item, 0) + 1\n    return freq", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n    assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (List[List[Any]]): A list containing sublists of elements.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Find frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [element for sublist in list_of_lists for element in sublist]\n    # Use Counter to count frequencies\n    freq_dict = dict(Counter(flattened))\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Parameters:\n    lists (list of lists): The input list containing sublists of elements.\n\n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists and count the frequency of each element\n    flat_list = (item for sublist in lists for item in sublist)\n    frequency = Counter(flat_list)\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        lists (List[List[Any]]): A list of lists containing hashable elements.\n\n    Returns:\n        Dict[Any, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        lists (List[List[Any]]): A list of lists containing hashable elements.\n\n    Returns:\n        Dict[Any, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists and count frequencies using Counter\n    return dict(Counter(item for sublist in lists for item in sublist))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom itertools import chain\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in a flattened list of lists.\n    \n    Parameters:\n    list_of_lists (list of lists): The input list containing sublists with elements.\n    \n    Returns:\n    dict: A dictionary where keys are elements from the sublists and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists using itertools.chain and count frequencies using Counter\n    return dict(Counter(chain.from_iterable(list_of_lists)))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists and count the frequencies\n    flattened = (item for sublist in list_of_lists for item in sublist)\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (List[List[Any]]): A list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists and count the frequencies\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in a flattened list of lists.\n    \n    :param list_of_lists: List[List[Any]]\n    :return: Dict[Any, int]\n    \"\"\"\n    # Flatten the list of lists\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Count the frequency of each element\n    frequency = Counter(flat_list)\n    \n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    freq = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            freq[item] = freq.get(item, 0) + 1\n    return freq", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom itertools import chain\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (List[List[Any]]): A list containing sublists of elements.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = chain.from_iterable(list_of_lists)\n    \n    # Count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(lists):\n    \"\"\"\n    Find frequency of each element in a flattened list of lists, returned in a dictionary.\n    \n    Args:\n        lists (List[List[Any]]): A list of lists containing hashable elements.\n    \n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    # Count the frequency of each element\n    return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 93.96103896103897, "dps_norm": 98.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple and returns the new tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list elements will be appended.\n\n    Returns:\n    tuple: A new tuple containing the original tuple elements followed by the list elements.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the elements of the list to the tuple and returns a new tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to append to.\n\n    Returns:\n    tuple: A new tuple containing the original tuple elements followed by the list elements.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the elements of a list to a tuple and returns the new tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing elements of the original tuple followed by the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends a list to a tuple and returns the resulting tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing elements of the original tuple followed by the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple and returns a new tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing elements from the original tuple followed by the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the elements of a list to a tuple.\n\n    Args:\n        lst (list): The list of elements to append.\n        tup (tuple): The original tuple.\n\n    Returns:\n        tuple: A new tuple containing the original elements followed by the list elements.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the elements of a list to a tuple and returns the new tuple.\n\n    Parameters:\n    lst (list): The list of elements to append.\n    tup (tuple): The original tuple.\n\n    Returns:\n    tuple: A new tuple with the list elements appended.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple and returns the new tuple.\n\n    Parameters:\n    lst (list): The list of elements to append.\n    tpl (tuple): The original tuple.\n\n    Returns:\n    tuple: A new tuple containing elements of the original tuple followed by the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple and returns the new tuple.\n\n    Args:\n        lst (list): The list of elements to append.\n        tpl (tuple): The original tuple.\n\n    Returns:\n        tuple: A new tuple with elements of lst appended to tpl.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns a new tuple.\n    \n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list is appended.\n    \n    Returns:\n    tuple: A new tuple with elements of lst appended to tpl.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends a list to a tuple and returns a new tuple.\n\n    Args:\n        lst (list): The list to append.\n        tpl (tuple): The tuple to append the list to.\n\n    Returns:\n        tuple: The resulting tuple after appending.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(a_list, a_tuple):\n    \"\"\"\n    Appends the elements of a_list to a_tuple and returns a new tuple.\n\n    Parameters:\n    a_list (list): The list to append.\n    a_tuple (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing elements of a_tuple followed by elements of a_list.\n    \"\"\"\n    return a_tuple + tuple(a_list)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple and returns the new tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list elements will be appended.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the list elements.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple and returns the new tuple.\n\n    Args:\n        lst (list): The list of elements to append.\n        tpl (tuple): The tuple to append elements to.\n\n    Returns:\n        tuple: A new tuple with the list elements appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Args:\n        lst (list): The list to append.\n        tpl (tuple): The tuple to append to.\n\n    Returns:\n        tuple: A new tuple with the list elements appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Args:\n        lst (list): The list to append.\n        tpl (tuple): The tuple to which the list is appended.\n\n    Returns:\n        tuple: A new tuple with the list elements appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple.\n\n    Parameters:\n    lst (list): The list of elements to append.\n    tpl (tuple): The original tuple.\n\n    Returns:\n    tuple: A new tuple with the list elements appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple and returns a new tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing elements of the original tuple followed by the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple and returns the new tuple.\n\n    Parameters:\n    lst (list): The list of elements to append.\n    tpl (tuple): The original tuple.\n\n    Returns:\n    tuple: A new tuple with the list elements appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": 95.36144578313252, "dps_norm": 97.72727272727273, "pass@1": 100.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n\n    Returns:\n        list: A single sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all three lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    combined.sort()\n    return combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Parameters:\n    - list1, list2, list3: Lists of integers.\n\n    Returns:\n    - A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Parameters:\n    - list1, list2, list3: Lists of integers.\n\n    Returns:\n    - A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    # Concatenate all lists\n    combined = list1 + list2 + list3\n    # Return the sorted combined list\n    return sorted(combined)", "matching_cluster_idx": 10}, {"solution": "import heapq\ndef merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n\n    Returns:\n        list: A single sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Sort each individual list\n    sorted1 = sorted(list1)\n    sorted2 = sorted(list2)\n    sorted3 = sorted(list3)\n    \n    # Merge the sorted lists efficiently using heapq.merge\n    merged = list(heapq.merge(sorted1, sorted2, sorted3))\n    \n    return merged", "matching_cluster_idx": 5}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n    \n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n    \n    Returns:\n        list: A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    # Combine all lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n    \n    Args:\n        list1 (list): The first list of integers.\n        list2 (list): The second list of integers.\n        list3 (list): The third list of integers.\n    \n    Returns:\n        list: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    merged = list1 + list2 + list3\n    return sorted(merged)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Parameters:\n    - list1, list2, list3: Lists of integers.\n\n    Returns:\n    - A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    # Combine all three lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    return sorted(combined)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n        list1 (List[int]): First list of integers.\n        list2 (List[int]): Second list of integers.\n        list3 (List[int]): Third list of integers.\n        \n    Returns:\n        List[int]: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n        \n    Returns:\n        list: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n        list1, list2, list3: Lists of integers.\n    \n    Returns:\n        A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    merged = list1 + list2 + list3\n    return sorted(merged)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n\n    Returns:\n        list: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all three lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n    \n    Parameters:\n    - list1, list2, list3: Lists of integers.\n    \n    Returns:\n    - A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    combined = list1 + list2 + list3\n    return sorted(combined)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Args:\n        list1 (list): The first list of integers.\n        list2 (list): The second list of integers.\n        list3 (list): The third list of integers.\n\n    Returns:\n        list: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all three lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n    \n    Parameters:\n    - list1, list2, list3: Lists of integers.\n    \n    Returns:\n    - A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    # Combine all three lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Parameters:\n    list1 (list): The first list of integers.\n    list2 (list): The second list of integers.\n    list3 (list): The third list of integers.\n\n    Returns:\n    list: A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    merged = list1 + list2 + list3\n    return sorted(merged)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Example:\n    >>> merge_sorted_list([25, 24, 15, 4, 5, 29, 110],\n    ...                   [19, 20, 11, 56, 25, 233, 154],\n    ...                   [24, 26, 54, 48])\n    [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]\n    \"\"\"\n    # Combine all lists into one\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n\n    Returns:\n        list: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n\n    Returns:\n        list: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n\n    Returns:\n        list: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all three lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Parameters:\n    - list1, list2, list3: Lists of integers.\n\n    Returns:\n    - A sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 95.49230769230769, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds common elements in all nested lists.\n\n    Args:\n        nested_lists (List[List[Any]]): A list of lists containing elements.\n\n    Returns:\n        List[Any]: A list of common elements present in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Initialize the common set with the first list\n    common_set = set(nested_lists[0])\n\n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_set &= set(lst)\n        # Early exit if no common elements\n        if not common_set:\n            break\n\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Args:\n        nested_lists (List[List[Any]]): A list of lists containing elements.\n\n    Returns:\n        List[Any]: A list of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Initialize the common elements set with the first list\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        # Early exit if no common elements\n        if not common_elements:\n            break\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds common elements in the given nested lists.\n\n    Args:\n        nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n        List[int]: A list of integers that are common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        if not common_elements:\n            break  # Early exit if no common elements\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Args:\n        nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n        List[int]: A list of common elements present in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the common set with the first list\n    common_set = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and compute the intersection\n    for lst in nested_lists[1:]:\n        common_set &= set(lst)\n        if not common_set:\n            break  # Early exit if no common elements\n    \n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    # Initialize the common set with the first list\n    common = set(nested_lists[0])\n    # Intersect with each subsequent list\n    for lst in nested_lists[1:]:\n        common &= set(lst)\n    return list(common)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds common elements in all nested lists.\n\n    Parameters:\n    nested_lists (list of lists): A list containing multiple lists.\n\n    Returns:\n    list: A list of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the common set with the first list\n    common_set = set(nested_lists[0])\n    \n    # Intersect with each subsequent list\n    for lst in nested_lists[1:]:\n        common_set &= set(lst)\n        if not common_set:\n            break  # Early exit if no common elements\n\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    # Initialize the common set with the first list\n    common_set = set(nested_lists[0])\n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_set &= set(lst)\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Args:\n        nested_lists (list of lists): A list containing multiple lists to find common elements.\n\n    Returns:\n        set: A set of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n    \n    # Initialize the common elements with the first list converted to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        # Early exit if no common elements\n        if not common_elements:\n            break\n    \n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Parameters:\n    nested_lists (list of lists): A list containing multiple lists.\n\n    Returns:\n    list: A list of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Initialize the common set with the first list\n    common_set = set(nested_lists[0])\n\n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_set.intersection_update(lst)\n        if not common_set:\n            break  # Early exit if no common elements\n\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find common elements in given nested lists.\n\n    Args:\n        nested_lists (List[List[Any]]): A list of lists.\n\n    Returns:\n        List[Any]: A list of elements common to all inner lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the common set with the first sublist\n    common_set = set(nested_lists[0])\n    \n    # Iterate through the remaining sublists and perform intersection\n    for lst in nested_lists[1:]:\n        common_set.intersection_update(lst)\n        if not common_set:\n            break  # Early exit if no common elements\n    \n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds common elements in the given nested lists.\n\n    Args:\n        nested_lists (List[List[Any]]): A list of lists containing elements.\n\n    Returns:\n        List[Any]: A list of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the common elements set with the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        # Early exit if no common elements\n        if not common_elements:\n            break\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n        List[int]: A list of common integers present in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Convert each sublist to a set for efficient intersection\n    sets = map(set, nested_lists)\n    \n    # Find the intersection of all sets\n    common_elements = set.intersection(*sets)\n    \n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of nested lists.\n\n    Args:\n        nested_lists (List[List[Any]]): A list containing multiple lists.\n\n    Returns:\n        List[Any]: A list of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Initialize the common set with the first list\n    common_set = set(nested_lists[0])\n\n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_set &= set(lst)\n        if not common_set:\n            break  # Early exit if no common elements\n\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds common elements in the given nested lists.\n\n    Parameters:\n    nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    List[int]: A list of integers common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the common elements with the first list converted to a set\n    common_elements = set(nested_lists[0])\n    \n    # Intersect with each subsequent list\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        if not common_elements:\n            break  # Early exit if there are no common elements\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Args:\n        nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n        List[int]: A list of common integers present in all nested lists.\n    \n    Example:\n        >>> common_in_nested_lists([[12, 18, 23, 25, 45], \n        ...                         [7, 12, 18, 24, 28], \n        ...                         [1, 5, 8, 12, 15, 16, 18]])\n        [18, 12]\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the common elements with the first list converted to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        if not common_elements:\n            break  # Early exit if no common elements\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find common elements in the given nested lists.\n\n    Args:\n        nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n        List[int]: A list of common elements present in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        if not common_elements:\n            break  # Early exit if no common elements\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Parameters:\n    nested_lists (List[List[Any]]): A list of lists to find common elements in.\n\n    Returns:\n    List[Any]: A list of common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the intersection with the first list as a set\n    common_set = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_set.intersection_update(lst)\n        # Early exit if no common elements\n        if not common_set:\n            break\n    \n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Parameters:\n    nested_lists (List[List[Any]]): A list containing nested lists.\n\n    Returns:\n    List[Any]: A list of common elements present in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Initialize the common elements set with the first list\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        if not common_elements:\n            break  # Early exit if no common elements\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Parameters:\n    nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    List[int]: A list of common integers found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the intersection with the first list converted to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        # Early exit if no common elements\n        if not common_elements:\n            break\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find common elements in given nested lists.\n    \n    Args:\n        nested_lists (list of lists): A list containing multiple lists.\n    \n    Returns:\n        list: A list of common elements across all nested lists.\n    \n    Example:\n        >>> common_in_nested_lists([[12, 18, 23, 25, 45], \n        ...                         [7, 12, 18, 24, 28], \n        ...                         [1, 5, 8, 12, 15, 16, 18]])\n        [12, 18]\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the intersection set with the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        if not common_elements:\n            break  # Early exit if no common elements\n    \n    return list(common_elements)", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.88805970149254, "dps_norm": 95.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Sums all amicable numbers from 1 to the specified limit.\n\n    An amicable pair consists of two different numbers where the sum of the proper divisors\n    of each number equals the other number.\n\n    :param limit: The upper bound of the range to search for amicable numbers.\n    :return: The sum of all amicable numbers within the range.\n    \"\"\"\n    # Initialize a list to hold the sum of proper divisors for each number\n    sum_divisors = [0] * (limit + 1)\n\n    # Calculate sum of proper divisors for each number using a sieve-like approach\n    for i in range(1, limit // 2 + 1):\n        for j in range(2 * i, limit + 1, i):\n            sum_divisors[j] += i\n\n    amicable_sum = 0\n    amicable_set = set()\n\n    for a in range(2, limit + 1):\n        b = sum_divisors[a]\n        if b != a and b <= limit:\n            if sum_divisors[b] == a:\n                amicable_set.add(a)\n                amicable_set.add(b)\n\n    amicable_sum = sum(amicable_set)\n    return amicable_sum", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    # Initialize a list to store sum of proper divisors for each number\n    sum_divisors = [0] * (n + 1)\n    \n    # Calculate sum of proper divisors for each number using a sieve-like approach\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_divisors[j] += i\n    \n    # Find and sum all amicable numbers\n    amicable_sum = 0\n    for a in range(1, n + 1):\n        b = sum_divisors[a]\n        if b != a and b <= n and sum_divisors[b] == a:\n            amicable_sum += a\n    \n    return amicable_sum", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(limit):\n    # Initialize a list to store sum of proper divisors for each number\n    sum_divisors = [0] * (limit + 1)\n    \n    # Calculate sum of proper divisors for each number\n    for i in range(1, limit // 2 + 1):\n        for j in range(2 * i, limit + 1, i):\n            sum_divisors[j] += i\n    \n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_divisors[a]\n        if b != a and b <= limit and sum_divisors[b] == a:\n            amicable_sum += a\n    \n    return amicable_sum", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(limit):\n    def sum_proper_divisors(n):\n        if n < 2:\n            return 0\n        total = 1\n        sqrt_n = int(n**0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                complement = n // i\n                if complement != i:\n                    total += complement\n        return total\n\n    sum_divisors = [0] * (limit + 1)\n    for i in range(1, limit + 1):\n        sum_divisors[i] = sum_proper_divisors(i)\n\n    amicable = set()\n    for a in range(2, limit + 1):\n        b = sum_divisors[a]\n        if b != a and b <= limit and sum_divisors[b] == a:\n            amicable.add(a)\n            amicable.add(b)\n\n    return sum(amicable)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n    assert amicable_numbers_sum(999)==504\n    \"\"\"\n    # Initialize a list to hold sum of proper divisors for each number\n    sum_divisors = [0] * (limit + 1)\n    \n    # Calculate sum of proper divisors for each number using a sieve approach\n    for i in range(1, limit // 2 + 1):\n        for j in range(2 * i, limit + 1, i):\n            sum_divisors[j] += i\n    \n    # Set to store amicable numbers to avoid duplicates\n    amicable = set()\n    \n    for a in range(1, limit + 1):\n        b = sum_divisors[a]\n        if b != a and b <= limit and sum_divisors[b] == a:\n            amicable.add(a)\n            amicable.add(b)\n    \n    return sum(amicable)", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 up to the specified limit.\n\n    An amicable pair consists of two different numbers where the sum of the proper divisors\n    of each number is equal to the other number.\n\n    Args:\n        limit (int): The upper bound of the range to search for amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers within the range.\n    \"\"\"\n    # Initialize a list to store the sum of proper divisors for each number\n    sum_divisors = [0] * (limit + 1)\n    \n    # Calculate sum of proper divisors for each number using the sieve method\n    for i in range(1, limit // 2 + 1):\n        for j in range(2 * i, limit + 1, i):\n            sum_divisors[j] += i\n    \n    total = 0\n    # Iterate through each number to identify amicable pairs\n    for n in range(1, limit + 1):\n        m = sum_divisors[n]\n        # Check if the pair (n, m) is amicable\n        if m > n and m <= limit and sum_divisors[m] == n:\n            total += n + m\n    \n    return total", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to the specified limit.\n\n    An amicable pair consists of two different numbers where the sum of the proper \n    divisors of each number equals the other number.\n\n    Args:\n        limit (int): The upper bound of the range to search for amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers within the range.\n    \"\"\"\n    # Initialize a list to store the sum of proper divisors for each number\n    sum_divisors = [0] * (limit + 1)\n\n    # Calculate sum of proper divisors for each number using a sieve-like approach\n    for i in range(1, limit // 2 + 1):\n        for j in range(2 * i, limit + 1, i):\n            sum_divisors[j] += i\n\n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        partner = sum_divisors[num]\n        # Check if the partner is within range, is different, and forms an amicable pair\n        if partner != num and partner <= limit:\n            if sum_divisors[partner] == num:\n                amicable_sum += num\n\n    return amicable_sum", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to the specified limit.\n\n    Amicable numbers are two different numbers so related that the sum of the proper\n    divisors of each is equal to the other number.\n\n    Args:\n        limit (int): The upper bound of the range to search for amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers within the range.\n    \"\"\"\n    def sum_of_proper_divisors(n):\n        if n < 2:\n            return 0\n        total = 1  # 1 is a proper divisor\n        sqrt_n = int(n**0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                complement = n // i\n                if complement != i:\n                    total += complement\n        return total\n\n    sum_divisors = {}\n    for num in range(1, limit + 1):\n        sum_divisors[num] = sum_of_proper_divisors(num)\n\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        partner = sum_divisors[num]\n        if partner != num and partner <= limit:\n            if sum_divisors.get(partner, 0) == num:\n                amicable_sum += num\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_proper_divisors(num):\n        if num < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.add(i)\n                divisors.add(num // i)\n        return sum(divisors)\n\n    # Precompute sum of proper divisors for all numbers up to n\n    divisor_sums = {i: sum_proper_divisors(i) for i in range(1, n + 1)}\n    \n    amicable_sum = 0\n    for a in range(1, n + 1):\n        b = divisor_sums.get(a, 0)\n        if b != a and b <= n:\n            if divisor_sums.get(b, 0) == a:\n                amicable_sum += a\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_proper_divisors(num):\n        if num < 2:\n            return 0\n        total = 1\n        sqrt_n = int(num**0.5)\n        for i in range(2, sqrt_n + 1):\n            if num % i == 0:\n                total += i\n                complement = num // i\n                if complement != i:\n                    total += complement\n        return total\n\n    amicables = set()\n    for num in range(2, n + 1):\n        sum1 = sum_proper_divisors(num)\n        if sum1 != num and sum1 <= n:\n            sum2 = sum_proper_divisors(sum1)\n            if sum2 == num:\n                amicables.add(num)\n                amicables.add(sum1)\n    return sum(amicables)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Sum all amicable numbers from 1 to n.\n\n    Args:\n        n (int): The upper limit to check for amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers within the range.\n    \"\"\"\n    # Initialize a list to store the sum of proper divisors for each number\n    sum_divisors = [0] * (n + 1)\n\n    # Calculate sum of proper divisors for each number using a sieve-like approach\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_divisors[j] += i\n\n    total = 0\n    # To keep track of already added amicable numbers\n    checked = set()\n\n    for a in range(1, n + 1):\n        b = sum_divisors[a]\n        # Check if b is within range, not equal to a, and forms an amicable pair\n        if b > a and b <= n and sum_divisors[b] == a:\n            total += a + b\n\n    return total", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(max_num):\n    \"\"\"\n    Sum all amicable numbers from 1 to max_num.\n\n    An amicable pair consists of two different numbers so that the sum of the proper divisors \n    of each is equal to the other number.\n\n    Args:\n        max_num (int): The upper limit to search for amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers up to max_num.\n    \n    Example:\n        >>> amicable_numbers_sum(999)\n        504\n    \"\"\"\n    # Initialize a list to store the sum of proper divisors for each number\n    sum_divisors = [0] * (max_num + 1)\n    \n    # Calculate sum of proper divisors using sieve-like approach\n    for i in range(1, max_num // 2 + 1):\n        for j in range(2 * i, max_num + 1, i):\n            sum_divisors[j] += i\n    \n    amicable_set = set()\n    \n    for n in range(1, max_num + 1):\n        m = sum_divisors[n]\n        if m != n and m <= max_num:\n            if sum_divisors[m] == n:\n                amicable_set.add(n)\n                amicable_set.add(m)\n    \n    return sum(amicable_set)", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    def sum_of_divisors(num):\n        if num < 1:\n            return 0\n        total = 1\n        sqrt_n = int(num ** 0.5)\n        for i in range(2, sqrt_n + 1):\n            if num % i == 0:\n                total += i\n                complement = num // i\n                if complement != i:\n                    total += complement\n        return total\n\n    amicables = set()\n    for a in range(1, n + 1):\n        b = sum_of_divisors(a)\n        if b != a and b <= n:\n            if sum_of_divisors(b) == a:\n                amicables.add(a)\n                amicables.add(b)\n    return sum(amicables)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    # Initialize a list to store the sum of proper divisors for each number\n    sum_divisors = [0] * (n + 1)\n    \n    # Populate the sum_divisors list\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_divisors[j] += i\n    \n    # Set to store amicable numbers to avoid duplicates\n    amicable = set()\n    \n    # Identify amicable numbers\n    for i in range(1, n + 1):\n        j = sum_divisors[i]\n        if j != i and j <= n and sum_divisors[j] == i:\n            amicable.add(i)\n            amicable.add(j)\n    \n    # Return the sum of all amicable numbers found\n    return sum(amicable)", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Sum all amicable numbers from 1 to n.\n\n    Amicable numbers are pairs where each number is the sum of the proper divisors of the other.\n    \"\"\"\n    # Initialize a list to hold the sum of proper divisors for each number\n    sum_divisors = [0] * (n + 1)\n\n    # Compute sum of proper divisors for each number up to n\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_divisors[j] += i\n\n    # Find and sum all amicable numbers\n    amicables = set()\n    for a in range(1, n + 1):\n        b = sum_divisors[a]\n        if b != a and b <= n and sum_divisors[b] == a:\n            amicables.add(a)\n\n    return sum(amicables)", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to n.\n\n    An amicable pair consists of two different numbers such that the sum of the proper divisors\n    of each is equal to the other number.\n\n    Args:\n        n (int): The upper limit of the range to search for amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers within the range.\n    \"\"\"\n    def sum_proper_divisors(num):\n        if num < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.add(i)\n                divisors.add(num // i)\n        return sum(divisors)\n\n    total = 0\n    for a in range(2, n + 1):\n        b = sum_proper_divisors(a)\n        if b != a and b <= n:\n            if sum_proper_divisors(b) == a:\n                total += a\n    return total", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to n.\n\n    An amicable pair consists of two different numbers where the sum of the proper\n    divisors of each is equal to the other number.\n\n    :param n: The upper limit to calculate amicable numbers.\n    :return: The sum of all amicable numbers up to n.\n    \n    Example:\n    >>> amicable_numbers_sum(999)\n    504\n    \"\"\"\n    # Initialize a list to store the sum of proper divisors for each number\n    sum_divisors = [0] * (n + 1)\n    \n    # Calculate sum of proper divisors for each number\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_divisors[j] += i\n    \n    # Identify and sum amicable numbers\n    total = 0\n    for a in range(1, n + 1):\n        b = sum_divisors[a]\n        if b != a and b <= n and sum_divisors[b] == a:\n            total += a\n    \n    return total", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to n.\n\n    Amicable numbers are two different numbers where the sum of the proper divisors\n    of each is equal to the other number.\n\n    Parameters:\n    n (int): The upper limit to search for amicable numbers.\n\n    Returns:\n    int: The sum of all amicable numbers up to n.\n    \"\"\"\n    # Initialize a list to store the sum of proper divisors for each number\n    sum_divisors = [0] * (n + 1)\n\n    # Calculate the sum of proper divisors for each number using a sieve approach\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_divisors[j] += i\n\n    total_sum = 0\n    for i in range(2, n + 1):\n        j = sum_divisors[i]\n        # Check if the pair (i, j) is amicable\n        if j != i and j <= n and sum_divisors[j] == i:\n            total_sum += i\n\n    return total_sum", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to n.\n    \n    An amicable pair consists of two different numbers where the sum of the proper \n    divisors of each number is equal to the other number.\n    \"\"\"\n    # Initialize a list to hold the sum of proper divisors for each number\n    sum_divisors = [0] * (n + 1)\n\n    # Calculate sum of proper divisors for each number using a sieve approach\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_divisors[j] += i\n\n    amicable_set = set()\n\n    # Identify amicable numbers\n    for number in range(1, n + 1):\n        partner = sum_divisors[number]\n        if partner != number and partner <= n:\n            if sum_divisors[partner] == number:\n                amicable_set.add(number)\n                amicable_set.add(partner)\n\n    return sum(amicable_set)", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Sum all amicable numbers from 1 to n.\n\n    An amicable pair consists of two different numbers where the sum\n    of the proper divisors of each is equal to the other number.\n\n    Parameters:\n    n (int): The upper limit to search for amicable numbers.\n\n    Returns:\n    int: The sum of all amicable numbers up to n.\n    \"\"\"\n    # Initialize a list to store the sum of proper divisors for each number\n    sum_div = [0] * (n + 1)\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_div[j] += i\n\n    # Set to keep track of amicable numbers\n    amicables = set()\n    for a in range(1, n + 1):\n        b = sum_div[a]\n        if b <= n and b != a and sum_div[b] == a:\n            amicables.add(a)\n            amicables.add(b)\n\n    return sum(amicables)", "matching_cluster_idx": 13}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words from the given sentence that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    sentence (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the given text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum length of words to include.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the given text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the given text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    text (str): The string containing words separated by spaces.\n\n    Returns:\n    List[str]: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words longer than n characters from the given text.\n\n    Parameters:\n    n (int): The minimum length of words to include.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words from the sentence that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum length of words to find.\n    sentence (str): The sentence from which to extract words.\n\n    Returns:\n    List[str]: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the input text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the text into words and filter based on length\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words that are longer than n characters from a given string of words.\n\n    Args:\n        n (int): The minimum length of words to find.\n        text (str): A string containing words separated by spaces.\n\n    Returns:\n        list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the input text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum length of words to include.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find and return a list of words longer than n characters from the given text.\n\n    Parameters:\n    n (int): The minimum length of words to be included.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the given text that are longer than n characters.\n    \n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    text (str): A string containing words separated by spaces.\n    \n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the input text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    text (str): The input string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the input text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find and return a list of words from the given text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the given text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    text (str): The string containing words to be evaluated.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words longer than n characters in the given text.\n\n    Args:\n        n (int): The minimum length of words to find.\n        text (str): A string containing words separated by spaces.\n\n    Returns:\n        list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the given text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum length of words to return.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words from the given sentence that are longer than n characters.\n    \n    Args:\n    - n (int): The minimum number of characters a word must have to be included.\n    - sentence (str): The sentence containing words to evaluate.\n    \n    Returns:\n    - List[str]: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Find and return a list of words longer than n characters from the provided string.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    words (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Write a function to find words that are longer than n characters from a given list of words.\n    \n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 61.92602040816327, "dps_norm": 95.0, "pass@1": 58.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if a given square matrix is a magic square.\n    \n    A magic square is a square matrix where the sums of every row, every column, \n    and both main diagonals are all equal.\n\n    Args:\n        matrix (list of lists of int): The square matrix to test.\n\n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False\n    \n    # Check if all rows have the same length\n    if not all(len(row) == n for row in matrix):\n        return False\n    \n    # Calculate the magic constant using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in zip(*matrix):\n        if sum(col) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n-1-i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if a given matrix is a magic square.\n    \n    A magic square is a n x n matrix where the sum of every row, every column, \n    and both main diagonals are all equal.\n    \n    Args:\n        matrix (list of lists of int): The matrix to be tested.\n        \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False  # Empty matrix is not a magic square\n\n    n = len(matrix)\n\n    # Check if the matrix is n x n\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic constant using the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    if diag1_sum != magic_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check if all rows sum to the magic sum\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check if all columns sum to the magic sum\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n    \n    # Check the main diagonal sum\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n    \n    # Check the secondary diagonal sum\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if a given square matrix is a magic square.\n    \n    A magic square is a square matrix where the sum of every row, \n    every column, and both main diagonals are equal.\n    \n    Parameters:\n    matrix (list of lists of int): The square matrix to test.\n    \n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    if not matrix or not isinstance(matrix, list):\n        return False\n    \n    n = len(matrix)\n    \n    # Check if matrix is square\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != n:\n            return False\n    \n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        current_sum = sum(row)\n        if current_sum != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        current_sum = sum(matrix[row][col] for row in range(n))\n        if current_sum != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    if diag1_sum != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag2_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    if n == 0:\n        return False\n    \n    # Check if the matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n-1-i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if the given matrix is a magic square.\n    \n    A magic square is a square matrix where the sum of every row,\n    every column, and both main diagonals are equal.\n    \n    Args:\n        matrix (list of list of int): The square matrix to test.\n        \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False\n\n    n = len(matrix)\n\n    # Ensure all rows have the same length\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the target sum using the first row\n    target_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix[1:]:\n        if sum(row) != target_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != target_sum:\n        return False\n\n    # Check sum of the anti-diagonal\n    anti_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if anti_diagonal_sum != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        return False  # Not a square matrix\n\n    # Calculate the sum of the first row as the reference\n    target_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determine if a matrix is a magic square.\n    \n    A magic square is a square matrix where the sum of every row, every column,\n    and both main diagonals are equal.\n    \n    Args:\n        matrix (list of list of int): The square matrix to test.\n    \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    \n    # Check if matrix is empty or not square\n    if n == 0:\n        return False\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Calculate the magic constant\n    magic_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Check if a given square matrix is a magic square.\n    \n    A magic square is a square matrix where the sums of each row, each column,\n    and both main diagonals are all equal.\n    \n    Args:\n        matrix (list of lists of int): The square matrix to check.\n        \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n    assert magic_square_test([[7, 12, 1, 14], \n                             [2, 13, 8, 11], \n                             [16, 3, 10, 5], \n                             [9, 6, 15, 4]]) == True\n    \"\"\"\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        return False\n\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if the given matrix is a magic square.\n    \n    A magic square is a square matrix where the sums of every row, \n    every column, and both main diagonals are all equal.\n    \n    Args:\n        matrix (list of lists of int): The matrix to be tested.\n        \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    if not matrix or not isinstance(matrix, list):\n        return False\n\n    n = len(matrix)\n\n    # Check if matrix is square\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != n:\n            return False\n\n    # Calculate the sum of the first row as reference\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    main_diag_sum = sum(matrix[i][i] for i in range(n))\n    if main_diag_sum != magic_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    secondary_diag_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diag_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Calculate the sum of the first row as the expected sum\n    expected_sum = sum(matrix[0])\n    \n    # Check if all rows sum to the expected sum\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check if all columns sum to the expected sum\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check the secondary diagonal\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        return False  # Not a square matrix\n\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in zip(*matrix):\n        if sum(col) != magic_sum:\n            return False\n\n    # Check the primary diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Check if a given square matrix is a magic square.\n    A magic square has equal sums for all rows, columns, and both main diagonals.\n    \"\"\"\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        return False  # Not a square matrix\n\n    n = len(matrix)\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determine whether a given matrix is a magic square.\n\n    A magic square is a square matrix in which the sum of every row,\n    every column, and both main diagonals are all equal.\n\n    Args:\n        matrix (list of lists of int): The square matrix to test.\n\n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    \n    if n == 0:\n        return False\n\n    # Ensure all rows have the same length\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the target sum using the first row\n    target_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check sums of all columns\n    for col in zip(*matrix):\n        if sum(col) != target_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    main_diag = sum(matrix[i][i] for i in range(n))\n    if main_diag != target_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    secondary_diag = sum(matrix[i][n - i - 1] for i in range(n))\n    if secondary_diag != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determine if the provided matrix is a magic square.\n    \n    A magic square is a square matrix where the sum of every row, every column,\n    and both main diagonals are equal.\n    \n    Args:\n        matrix (list of list of int): The square matrix to check.\n        \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        return False  # Not a square matrix\n    \n    n = len(matrix)\n    magic_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n    \n    # Check main diagonal\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    if diag1_sum != magic_sum:\n        return False\n    \n    # Check secondary diagonal\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag2_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Check if matrix is square\n    if any(len(row) != n for row in matrix):\n        return False\n    \n    # Calculate the magic constant using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    if not matrix:\n        return False\n\n    n = len(matrix)\n    \n    # Check if all rows have the same length\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    main_diag_sum = sum(matrix[i][i] for i in range(n))\n    if main_diag_sum != magic_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    secondary_diag_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diag_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if n == 0:\n        return False\n    # Calculate the magic constant\n    magic_sum = sum(matrix[0])\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    # Check diagonals\n    diag1 = sum(matrix[i][i] for i in range(n))\n    diag2 = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag1 != magic_sum or diag2 != magic_sum:\n        return False\n    return True", "matching_cluster_idx": 14}]}, "Mbpp/130": {"dps": 99.19282511210763, "dps_norm": 85.0, "pass@1": 58.0, "profiled": [{"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Returns the item with the highest frequency in the list.\n    If multiple items have the same maximum frequency, returns one of them.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    count = Counter(lst)\n    # most_common returns a list of tuples sorted by frequency\n    most_common_item, _ = count.most_common(1)[0]\n    return most_common_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    \n    :param lst: List of items\n    :return: Item with the highest frequency\n    \"\"\"\n    if not lst:\n        return None  # Handle empty list case\n    \n    counts = Counter(lst)\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Write a function to find the item with maximum frequency in a given list.\n    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2]) == 2\n    \"\"\"\n    from collections import Counter\n    count = Counter(lst)\n    max_freq = max(count.values())\n    # Return the first item with the maximum frequency\n    for item in lst:\n        if count[item] == max_freq:\n            return item", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    return Counter(lst).most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n\n    Args:\n        lst (list): The list of items.\n\n    Returns:\n        The item with the highest frequency.\n    \"\"\"\n    from collections import Counter\n\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n\n    counts = Counter(lst)\n    max_item, _ = counts.most_common(1)[0]\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    \n    Parameters:\n    lst (list): The list of items to evaluate.\n    \n    Returns:\n    The item with the highest frequency. If the list is empty, returns None.\n    \"\"\"\n    if not lst:\n        return None\n    counter = Counter(lst)\n    max_item = max(counter, key=counter.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Returns the item with the maximum frequency in the given list.\n\n    :param lst: List of elements\n    :return: Element with the highest frequency\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n    count = Counter(lst)\n    most_common_item, _ = count.most_common(1)[0]\n    return most_common_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    \n    Parameters:\n    lst (list): The list of items to analyze.\n    \n    Returns:\n    The item with the highest frequency.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    count = Counter(lst)\n    # most_common returns a list of tuples sorted by frequency\n    return count.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n\n    Parameters:\n    lst (list): The list of elements to analyze.\n\n    Returns:\n    The element with the highest frequency. If multiple elements have the same\n    maximum frequency, the first encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Handle empty list case\n\n    counts = Counter(lst)\n    max_freq = max(counts.values())\n    for item in lst:\n        if counts[item] == max_freq:\n            return item", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    \n    Parameters:\n    lst (list): The list of items to analyze.\n    \n    Returns:\n    The item with the highest frequency. If multiple items have the same highest frequency,\n    the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Return None for empty lists\n\n    count = Counter(lst)\n    max_item, _ = count.most_common(1)[0]\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the highest frequency in the given list.\n    If multiple items have the same maximum frequency, the first encountered is returned.\n    \n    Parameters:\n    lst (list): The list of items to analyze.\n    \n    Returns:\n    The item with the highest frequency.\n    \"\"\"\n    if not lst:\n        return None  # Return None for empty lists\n    \n    frequency = Counter(lst)\n    most_common_item, _ = frequency.most_common(1)[0]\n    return most_common_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the highest frequency in the given list.\n    \n    Args:\n    lst (list): The list of items to evaluate.\n    \n    Returns:\n    The item with the maximum frequency. If multiple items have the same\n    highest frequency, the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    count = Counter(lst)\n    max_item, _ = count.most_common(1)[0]\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    counts = Counter(lst)\n    # most_common returns list of (elem, count) sorted by count descending\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    \n    Parameters:\n    lst (list): The list of items to evaluate.\n    \n    Returns:\n    The item with the highest frequency. If the list is empty, returns None.\n    \"\"\"\n    if not lst:\n        return None\n    count = Counter(lst)\n    return max(count, key=count.get)", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    If multiple items have the same maximum frequency, the first one encountered is returned.\n    \n    Parameters:\n    lst (list): The list of items to analyze.\n    \n    Returns:\n    The item with the highest frequency, or None if the list is empty.\n    \"\"\"\n    from collections import Counter\n    \n    if not lst:\n        return None  # Return None for empty list\n    \n    frequency = Counter(lst)\n    # Get the item with the highest frequency. In case of ties, Counter.most_common returns the first encountered.\n    most_common_item, _ = frequency.most_common(1)[0]\n    return most_common_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n    \n    Args:\n        lst (list): The list of items to evaluate.\n        \n    Returns:\n        The item with the highest frequency.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    count = Counter(lst)\n    max_item, _ = count.most_common(1)[0]\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    \n    Parameters:\n    lst (list): The list of items to evaluate.\n    \n    Returns:\n    The item with the highest frequency.\n    \"\"\"\n    if not lst:\n        return None  # Return None for empty lists\n    \n    count = Counter(lst)\n    # In case of a tie, max returns the first encountered item with the highest count\n    max_item = max(count, key=count.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    if not lst:\n        return None\n    counter = Counter(lst)\n    # Get the item with the highest frequency\n    return counter.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    \n    Parameters:\n    lst (list): The list of items to evaluate.\n    \n    Returns:\n    The item with the highest frequency.\n    If multiple items have the same maximum frequency, one of them is returned.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    counts = Counter(lst)\n    max_item = max(counts, key=counts.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Returns the item with the highest frequency in the list.\n    If multiple items have the same highest frequency, the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    counts = Counter(lst)\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}]}, "Mbpp/137": {"dps": 67.74193548387096, "dps_norm": 73.75, "pass@1": 68.0, "profiled": [{"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The list of integers to evaluate.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n    if non_zeroes == 0:\n        return float('inf')  # or handle as appropriate\n    return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeros to non-zeros in the given array.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n           Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = sum(1 for num in arr if num == 0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / non_zeros", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n    \n    Parameters:\n    arr (list of int): The input array of integers.\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    count_zero = arr.count(0)\n    count_non_zero = len(arr) - count_zero\n    if count_non_zero == 0:\n        return float('inf')  # Avoid division by zero\n    return count_zero / count_non_zero", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    Parameters:\n    arr (list): List of integers.\n\n    Returns:\n    float: Ratio of zero elements to non-zero elements.\n           Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Returns the ratio of zeroes to non-zeroes in the given array.\n    \n    Parameters:\n    arr (list of int): The input array of integers.\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n           Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = 0\n    non_zeros = 0\n    for num in arr:\n        if num == 0:\n            zeros += 1\n        else:\n            non_zeros += 1\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / non_zeros", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The array of integers.\n\n    Returns:\n    float: The ratio of zero elements to non-zero elements.\n           Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n    if non_zeroes == 0:\n        return float('inf')  # or raise an exception if preferred\n    return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of number of zeroes to number of non-zeroes.\n           Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n    if non_zeroes == 0:\n        return float('inf')  # Define behavior when no non-zero elements\n    return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Finds the ratio of zeroes to non-zeroes in an array of integers.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Handle division by zero if no non-zero elements\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n\n    if non_zeroes == 0:\n        return float('inf')  # Handle division by zero if there are no non-zero elements\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    zero = 0\n    non_zero = 0\n    for num in arr:\n        if num == 0:\n            zero += 1\n        else:\n            non_zero += 1\n    if non_zero == 0:\n        return float('inf')  # Avoid division by zero\n    return zero / non_zero", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Define behavior when no non-zero elements\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Finds the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n        arr (list of int): The input array.\n\n    Returns:\n        float: The ratio of zeroes to non-zeroes. Returns infinity if there are no non-zero elements.\n    \"\"\"\n    zeros = 0\n    non_zeros = 0\n    for num in arr:\n        if num == 0:\n            zeros += 1\n        else:\n            non_zeros += 1\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / non_zeros", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Returns the ratio of zeroes to non-zeroes in the provided array.\n    \n    Parameters:\n    arr (list of int): The list of integers to evaluate.\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zero elements to non-zero elements.\n           Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n    if non_zeroes == 0:\n        return float('inf')  # Avoid division by zero\n    return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n\n    if non_zeroes == 0:\n        return float('inf')  # or raise an exception if preferred\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zero elements in the array.\n\n    Args:\n        arr (list of int): The input array of integers.\n\n    Returns:\n        float: The ratio of zeroes to non-zero elements.\n               Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zero = 0\n    non_zero = 0\n    for num in arr:\n        if num == 0:\n            zero += 1\n        else:\n            non_zero += 1\n    if non_zero == 0:\n        return float('inf')  # Alternatively, you could return 0 or raise an exception\n    return zero / non_zero", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    zero = arr.count(0)\n    non_zero = len(arr) - zero\n    if non_zero == 0:\n        return float('inf')  # Handle case with no non-zero elements\n    return zero / non_zero", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n           Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n\n    if non_zeroes == 0:\n        return float('inf')  # or raise an exception if preferred\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Handle case with no non-zero elements\n    return zeros / non_zeros", "matching_cluster_idx": 7}]}, "Mbpp/140": {"dps": 73.16770186335404, "dps_norm": 79.375, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a set of unique numbers.\n\n    Args:\n        list_of_lists (list of iterables): The list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of iterables): The input list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return {num for sublist in list_of_lists for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of iterables): A list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \n    Example:\n        >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n        {1, 3, 4, 5, 7}\n    \"\"\"\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of unique numbers.\n\n    Args:\n        list_of_lists (list of iterables): The list containing sublists/tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return set().union(*list_of_lists)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"Flatten a list of lists into a single list of unique numbers.\"\"\"\n    flattened = []\n    for sublist in list_of_lists:\n        flattened.extend(sublist)\n    return flattened", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \n    Args:\n        list_of_lists (list of iterables): The list containing sublists or tuples of numbers.\n        \n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return set().union(*list_of_lists)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single list of unique numbers.\n\n    Args:\n        list_of_lists (list of iterables): The input list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the input.\n    \"\"\"\n    return set(item for sublist in list_of_lists for item in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \"\"\"\n    return set().union(*list_of_lists)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of iterables into a single set of unique numbers.\n\n    Args:\n        list_of_lists (list of iterables): The list containing tuples or lists of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the input.\n    \"\"\"\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of iterables): The input list containing lists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the input lists.\n    \"\"\"\n    return {num for sublist in list_of_lists for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of iterables into a set of unique numbers.\n\n    Args:\n        list_of_lists (list of iterables): The input list containing iterables of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the input.\n    \"\"\"\n    return set().union(*list_of_lists)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of iterables): The list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \n    Example:\n        >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n        {1, 3, 4, 5, 7}\n    \"\"\"\n    return set(item for sublist in list_of_lists for item in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single list of numbers.\n    \n    Args:\n        list_of_lists (list of iterables): The input list containing sublists or tuples.\n    \n    Returns:\n        list: A flattened list containing all the numbers from the sublists.\n    \"\"\"\n    return [item for sublist in list_of_lists for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of iterables): The list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return set().union(*list_of_lists)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of unique numbers.\n\n    Args:\n        list_of_lists (list of iterables): The list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return set(item for sublist in list_of_lists for item in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of unique numbers.\n\n    Args:\n        list_of_lists (list of iterables): The input list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the input.\n    \"\"\"\n    return set().union(*list_of_lists)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n    \n    Args:\n        list_of_lists (list of iterables): The list containing sublists or tuples.\n        \n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return set(number for sublist in list_of_lists for number in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of unique numbers.\n\n    Args:\n        list_of_lists (list of iterables): The input list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the input.\n    \"\"\"\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of iterables): The list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    \n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 4}]}, "Mbpp/141": {"dps": 80.09070294784581, "dps_norm": 45.0, "pass@1": 100.0, "profiled": [{"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n\n    Args:\n        arr (list): The list of elements to sort.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:size]\n        max_idx = arr.index(max(arr[:size]))\n        \n        # If the maximum is not at its correct position\n        if max_idx != size - 1:\n            # If the maximum is not at the first position, bring it to the front\n            if max_idx != 0:\n                arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            # Now bring the maximum to its correct position\n            arr[:size] = arr[:size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        start = 0\n        while start < k:\n            sub_arr[start], sub_arr[k] = sub_arr[k], sub_arr[start]\n            start += 1\n            k -= 1\n\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_idx = arr.index(max(arr[:current_size]))\n        \n        if max_idx != current_size - 1:\n            # Bring the maximum element to the front if it's not already there\n            flip(arr, max_idx)\n            # Now move the maximum element to its correct position\n            flip(arr, current_size - 1)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n    \n    :param arr: List of comparable elements.\n    :return: A new list containing the sorted elements.\n    \"\"\"\n    def flip(sublist, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        return sublist[:k][::-1] + sublist[k:]\n    \n    n = len(arr)\n    lst = arr.copy()\n    \n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the current unsorted portion\n        max_index = lst.index(max(lst[:size]))\n        \n        if max_index != size - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                lst = flip(lst, max_index + 1)\n            # Flip it to its correct position\n            lst = flip(lst, size)\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    def flip(sublist, k):\n        return sublist[:k][::-1] + sublist[k:]\n\n    n = len(lst)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in lst[0..current_size-1]\n        max_index = lst.index(max(lst[0:current_size]))\n        if max_index != current_size - 1:\n            # Bring the maximum to the front if it's not already there\n            if max_index != 0:\n                # Flip the maximum number to the front\n                lst = flip(lst, max_index + 1)\n            # Now flip it to its correct position\n            lst = flip(lst, current_size)\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the Pancake Sort algorithm.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Helper function to reverse the first k elements of the list.\"\"\"\n        start = 0\n        while start < k:\n            sub_arr[start], sub_arr[k] = sub_arr[k], sub_arr[start]\n            start += 1\n            k -= 1\n\n    n = len(arr)\n    # Traverse through all elements\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..size-1]\n        max_idx = arr.index(max(arr[:size]))\n        \n        if max_idx != size - 1:\n            # Move the maximum element to the front if it's not already there\n            flip(arr, max_idx)\n            # Move the maximum element to its correct position\n            flip(arr, size - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n\n    Args:\n        arr (list): The list of elements to sort.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[:current_size]))\n\n        # If the maximum is not at its correct position, move it\n        if max_index != current_size - 1:\n            # If the maximum is not at the first position, flip it to the front\n            if max_index != 0:\n                arr[:max_index + 1] = arr[:max_index + 1][::-1]\n            # Now flip it to its correct position\n            arr[:current_size] = arr[:current_size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        \"\"\"Helper function to reverse the first k elements of the array.\"\"\"\n        start = 0\n        end = k - 1\n        while start < end:\n            sub_arr[start], sub_arr[end] = sub_arr[end], sub_arr[start]\n            start += 1\n            end -= 1\n\n    n = len(arr)\n    # Traverse through all array elements\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[:current_size]))\n        \n        # Move the maximum element to the end if it's not already at the correct position\n        if max_index != current_size - 1:\n            # Flip the maximum number to the front if it's not already there\n            if max_index != 0:\n                flip(arr, max_index + 1)\n            # Now flip it to the correct position\n            flip(arr, current_size)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n\n    Args:\n        arr (list): The list of elements to sort.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Reverse the first k elements of the list.\"\"\"\n        left = 0\n        right = k - 1\n        while left < right:\n            sub_arr[left], sub_arr[right] = sub_arr[right], sub_arr[left]\n            left += 1\n            right -= 1\n\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_index = arr.index(max(arr[:size]))\n        if max_index != size - 1:\n            # Bring the maximum element to the front if it's not already there\n            if max_index != 0:\n                flip(arr, max_index + 1)\n            # Move the maximum element to its correct position\n            flip(arr, size)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the pancake sort algorithm.\n\n    Args:\n        arr (list): The list of integers to sort.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[:current_size]))\n        \n        # If the maximum is not at its correct position, perform flips\n        if max_index != current_size - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                arr[:max_index + 1] = reversed(arr[:max_index + 1])\n            # Flip it to its correct position at the end of the current array\n            arr[:current_size] = reversed(arr[:current_size])\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the pancake sort algorithm.\n\n    Args:\n        arr (list): The list of integers to sort.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Helper function to reverse the first k+1 elements of the array.\"\"\"\n        start = 0\n        end = k\n        while start < end:\n            sub_arr[start], sub_arr[end] = sub_arr[end], sub_arr[start]\n            start += 1\n            end -= 1\n\n    n = len(arr)\n    # Iterate from the end of the array to the beginning\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[:current_size]))\n\n        if max_index != current_size - 1:\n            # Flip the maximum element to the beginning if it's not already there\n            flip(arr, max_index)\n            # Now flip it to its correct position\n            flip(arr, current_size - 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Helper function to reverse the first k elements of the array.\"\"\"\n        left = 0\n        while left < k:\n            sub_arr[left], sub_arr[k] = sub_arr[k], sub_arr[left]\n            left += 1\n            k -= 1\n\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[0:current_size]))\n        \n        if max_index != current_size - 1:\n            # Move the maximum element to the front if it's not already there\n            if max_index != 0:\n                flip(arr, max_index)\n            # Move the maximum element to its correct position\n            flip(arr, current_size - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to sort.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Helper function to reverse the first k elements of the array.\"\"\"\n        sub_arr[:k] = sub_arr[:k][::-1]\n\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[:current_size]))\n        \n        # If the maximum is not at its correct position, move it\n        if max_index != current_size - 1:\n            # Move the maximum to the front if it's not already there\n            if max_index != 0:\n                flip(arr, max_index + 1)\n            # Move the maximum to its correct position\n            flip(arr, current_size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n\n    Args:\n        arr (list): The list of elements to sort.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Reverses the order of the first k elements in sub_arr.\"\"\"\n        return sub_arr[:k][::-1] + sub_arr[k:]\n\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[:current_size]))\n        \n        if max_index != current_size - 1:\n            # Bring the maximum element to the front if it's not already there\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Move the maximum element to its correct position\n            arr = flip(arr, current_size)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Reverses the order of the first k elements in sub_arr.\"\"\"\n        sub_arr[:k] = sub_arr[:k][::-1]\n\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[:current_size]))\n        \n        # If the maximum is not at its correct position, perform flips\n        if max_index != current_size - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                flip(arr, max_index + 1)\n            # Now flip it to its correct position\n            flip(arr, current_size)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the Pancake Sort algorithm.\n    \n    Args:\n        arr (list): The list of elements to sort.\n    \n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:size]\n        max_idx = arr.index(max(arr[:size]))\n        \n        if max_idx != size - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_idx != 0:\n                arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            # Flip it to its correct position\n            arr[:size] = arr[:size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the Pancake Sort algorithm.\n    \n    Args:\n        arr (list): The list of integers to sort.\n        \n    Returns:\n        list: The sorted list.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        sub_arr[:k] = sub_arr[:k][::-1]\n    \n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_num = max(arr[:current_size])\n        max_idx = arr.index(max_num)\n        \n        # If the maximum is not at its correct position, move it\n        if max_idx != current_size - 1:\n            # Flip the maximum number to the front if it's not already there\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Now flip it to its correct position\n            flip(arr, current_size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(sublist, end):\n        start = 0\n        while start < end:\n            sublist[start], sublist[end] = sublist[end], sublist[start]\n            start += 1\n            end -= 1\n\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in the current range\n        max_index = arr.index(max(arr[:current_size]))\n        \n        # If the maximum is not at its correct position, move it\n        if max_index != current_size - 1:\n            # If the maximum is not at the start, flip it to the front\n            if max_index != 0:\n                flip(arr, max_index)\n            # Then flip it to its correct position\n            flip(arr, current_size - 1)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Helper function to reverse the first k elements of the list.\"\"\"\n        left = 0\n        right = k - 1\n        while left < right:\n            sub_arr[left], sub_arr[right] = sub_arr[right], sub_arr[left]\n            left += 1\n            right -= 1\n\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[:current_size]))\n        \n        if max_index != current_size - 1:\n            # Move the maximum element to the front if it's not already there\n            flip(arr, max_index + 1)\n            # Move the maximum element to its correct position\n            flip(arr, current_size)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n\n    Args:\n        arr (list): The list of elements to sort.\n\n    Returns:\n        list: A new sorted list.\n    \n    Example:\n        >>> pancake_sort([15, 79, 25, 38, 69])\n        [15, 25, 38, 69, 79]\n    \"\"\"\n    def flip(lst, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        return lst[:k][::-1] + lst[k:]\n\n    sorted_arr = arr.copy()\n    n = len(sorted_arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in the current unsorted portion\n        max_idx = sorted_arr.index(max(sorted_arr[:current_size]))\n        \n        # If the maximum is not at its correct position, move it\n        if max_idx != current_size - 1:\n            # Move the maximum element to the front if it's not already there\n            if max_idx != 0:\n                sorted_arr = flip(sorted_arr, max_idx + 1)\n            # Move the maximum element to its correct position\n            sorted_arr = flip(sorted_arr, current_size)\n    return sorted_arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        sub_arr[:k] = sub_arr[:k][::-1]\n\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_idx = arr.index(max(arr[:current_size]))\n        \n        if max_idx != current_size - 1:\n            # If the maximum is not at the first position, flip it to the front\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Now flip it to its correct position\n            flip(arr, current_size)\n    \n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 97.39999999999999, "dps_norm": 83.75, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list that xor to an even number.\n    Two integers xor to an even number if they have the same parity.\n    \n    Parameters:\n    nums (list of int): The list of integers.\n    \n    Returns:\n    int: The count of valid pairs.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n            \n    # Number of ways to choose 2 even numbers\n    even_pairs = even_count * (even_count - 1) // 2\n    \n    # Number of ways to choose 2 odd numbers\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs in the list that XOR to an even number.\n\n    Since the XOR of two numbers is even if both numbers have the same parity \n    (both even or both odd), we can count the number of even and odd numbers \n    and calculate the combinations accordingly.\n    \"\"\"\n    even = 0\n    odd = 0\n    for num in lst:\n        if num % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    # Calculate combinations of even pairs and odd pairs\n    return (even * (even - 1)) // 2 + (odd * (odd - 1)) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        lst (list): List of integers.\n\n    Returns:\n        int: Number of valid pairs.\n    \"\"\"\n    # Count the number of even and odd integers in the list\n    even_count = sum(1 for num in lst if num % 2 == 0)\n    odd_count = len(lst) - even_count\n\n    # The XOR of two numbers is even if both are even or both are odd\n    # Calculate the number of such pairs using combination formula C(n, 2) = n * (n - 1) / 2\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n\n    # Total valid pairs is the sum of even_pairs and odd_pairs\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    Parameters:\n    lst (List[int]): The list of integers.\n    \n    Returns:\n    int: The number of valid pairs.\n    \"\"\"\n    evens = 0\n    odds = 0\n    for num in lst:\n        if num % 2 == 0:\n            evens += 1\n        else:\n            odds += 1\n    # Number of even pairs: C(evens, 2)\n    even_pairs = evens * (evens - 1) // 2\n    # Number of odd pairs: C(odds, 2)\n    odd_pairs = odds * (odds - 1) // 2\n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n\n    Parameters:\n    nums (list of int): The list of integers.\n\n    Returns:\n    int: The count of valid pairs.\n    \"\"\"\n    count_even = 0\n    count_odd = 0\n\n    # Count the number of even and odd numbers in the list\n    for num in nums:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n\n    # Number of valid pairs is combination of even numbers taken 2 at a time\n    # plus combination of odd numbers taken 2 at a time\n    even_pairs = count_even * (count_even - 1) // 2\n    odd_pairs = count_odd * (count_odd - 1) // 2\n\n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    odd_count = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count * (even_count - 1) // 2) + (odd_count * (odd_count - 1) // 2)", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    \n    :param nums: List of integers\n    :return: Integer count of valid pairs\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Count the number of even and odd numbers in the list\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate the number of valid pairs\n    # Pairs of even numbers\n    even_pairs = even_count * (even_count - 1) // 2\n    # Pairs of odd numbers\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    Args:\n    nums (List[int]): List of integers.\n\n    Returns:\n    int: Number of valid pairs.\n    \n    Example:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Count the number of even and odd integers in the list\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Number of valid pairs is C(even_count, 2) + C(odd_count, 2)\n    pairs = (even_count * (even_count - 1)) // 2 + (odd_count * (odd_count - 1)) // 2\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(arr):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        arr (List[int]): The list of integers.\n\n    Returns:\n        int: The count of valid pairs.\n    \"\"\"\n    count_even = 0\n    count_odd = 0\n\n    for num in arr:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n\n    # Number of even pairs: C(count_even, 2)\n    even_pairs = count_even * (count_even - 1) // 2\n\n    # Number of odd pairs: C(count_odd, 2)\n    odd_pairs = count_odd * (count_odd - 1) // 2\n\n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    Parameters:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The count of valid pairs.\n    \n    Example:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    # Count the number of even and odd numbers in the list\n    even_count = 0\n    odd_count = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The number of valid pairs is the combination of even numbers choose 2 plus\n    # the combination of odd numbers choose 2\n    pairs = (even_count * (even_count - 1)) // 2\n    pairs += (odd_count * (odd_count - 1)) // 2\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    Parameters:\n    nums (list): List of integers.\n    \n    Returns:\n    int: Number of valid pairs.\n    \"\"\"\n    count_even = 0\n    count_odd = 0\n    \n    # Count the number of even and odd numbers\n    for num in nums:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n    \n    # Pairs where both numbers are even or both are odd will have even XOR\n    even_pairs = count_even * (count_even - 1) // 2\n    odd_pairs = count_odd * (count_odd - 1) // 2\n    \n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs in the list where the XOR of the pair is even.\n    \n    Parameters:\n    nums (List[int]): List of integers.\n    \n    Returns:\n    int: Number of valid pairs.\n    \"\"\"\n    from math import comb\n\n    count_even = 0\n    count_odd = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n\n    # Number of even pairs: C(count_even, 2) + C(count_odd, 2)\n    return comb(count_even, 2) + comb(count_odd, 2)", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The number of valid pairs.\n    \n    Example:\n        >>> find_even_pair([5, 4, 7, 2, 1])\n        4\n    \"\"\"\n    n_even = sum(1 for num in lst if num % 2 == 0)\n    n_odd = len(lst) - n_even\n    return (n_even * (n_even - 1) // 2) + (n_odd * (n_odd - 1) // 2)", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    even = odd = 0\n    for num in nums:\n        if num % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    # Number of pairs with both even numbers\n    even_pairs = even * (even - 1) // 2\n    # Number of pairs with both odd numbers\n    odd_pairs = odd * (odd - 1) // 2\n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n\n    Two numbers XOR to an even number if both are even or both are odd.\n\n    Args:\n        lst (list): List of integers.\n\n    Returns:\n        int: Number of valid pairs.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n\n    for num in lst:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    # Number of even pairs: C(even_count, 2)\n    even_pairs = even_count * (even_count - 1) // 2\n    # Number of odd pairs: C(odd_count, 2)\n    odd_pairs = odd_count * (odd_count - 1) // 2\n\n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    Parameters:\n    nums (List[int]): List of integers.\n    \n    Returns:\n    int: Number of valid pairs.\n    \"\"\"\n    even_count = sum(1 for num in nums if num % 2 == 0)\n    odd_count = len(nums) - even_count\n    return (even_count * (even_count - 1) // 2) + (odd_count * (odd_count - 1) // 2)", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    An XOR of two numbers is even if both numbers are even or both are odd.\n\n    :param lst: List of integers\n    :return: Number of valid pairs\n    \"\"\"\n    count_even = 0\n    count_odd = 0\n\n    # Count the number of even and odd integers in the list\n    for num in lst:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n\n    # Calculate the number of valid pairs\n    even_pairs = count_even * (count_even - 1) // 2\n    odd_pairs = count_odd * (count_odd - 1) // 2\n\n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs in the list that XOR to an even number.\n    \n    Parameters:\n    nums (List[int]): List of integers.\n\n    Returns:\n    int: Number of valid pairs.\n    \"\"\"\n    count_evens = sum(1 for num in nums if num % 2 == 0)\n    count_odds = len(nums) - count_evens\n    # Number of ways to choose 2 evens plus number of ways to choose 2 odds\n    return (count_evens * (count_evens - 1) // 2) + (count_odds * (count_odds - 1) // 2)", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n\n    Parameters:\n    lst (list of int): The list of integers.\n\n    Returns:\n    int: The number of pairs whose XOR is even.\n    \"\"\"\n    even_count = sum(1 for num in lst if num % 2 == 0)\n    odd_count = len(lst) - even_count\n    # Number of even pairs: C(even_count, 2)\n    # Number of odd pairs: C(odd_count, 2)\n    return (even_count * (even_count - 1)) // 2 + (odd_count * (odd_count - 1)) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of unique pairs in the list where the XOR of the pair is even.\n\n    Parameters:\n    nums (list of int): The list of integers to evaluate.\n\n    Returns:\n    int: The count of pairs with an even XOR result.\n    \"\"\"\n    count_even = sum(1 for num in nums if num % 2 == 0)\n    count_odd = len(nums) - count_even\n    # Number of ways to choose 2 even numbers\n    even_pairs = count_even * (count_even - 1) // 2\n    # Number of ways to choose 2 odd numbers\n    odd_pairs = count_odd * (count_odd - 1) // 2\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}]}, "Mbpp/170": {"dps": null, "dps_norm": null, "pass@1": 12.0, "profiled": []}, "Mbpp/226": {"dps": 86.82170542635659, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters with odd index values from the input string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A string containing characters from even indices of the input string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the string that have odd index values.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the string that are at odd index positions.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string containing characters from even indices of the input string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the input string that have odd index values.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string containing only the characters at even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the string that have odd index values.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove the characters which have odd index values of a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string with characters at odd indices removed.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove the characters which have odd index values from the given string.\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        str: The string with characters at odd indices removed.\n    \n    Examples:\n        >>> odd_values_string('abcdef')\n        'ace'\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters with odd index values from the string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: A new string with characters at even indices.\n        \n    Example:\n        >>> odd_values_string('abcdef')\n        'ace'\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters at even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the string that have odd index values.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove the characters which have odd index values of a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string with characters at odd indices removed.\n    \n    Example:\n        >>> odd_values_string('abcdef')\n        'ace'\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the string that have odd index values.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters with odd index values from the string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: A string containing characters from even indices of the input string.\n        \n    Example:\n        >>> odd_values_string('abcdef')\n        'ace'\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters at odd index positions from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters with odd index values from the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from even indices of the input string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters with odd index values from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from even indices of the input string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters at odd index positions from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string containing characters from even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters with odd index values from the input string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters with odd index values from the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters from even indices of the original string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}]}, "Mbpp/230": {"dps": 96.58730158730158, "dps_norm": 99.375, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the string 's' with the specified character 'char'.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by 'char'.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the specified character `char`.\n\n    Args:\n        s (str): The input string.\n        char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, c: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the character `c`.\n\n    Parameters:\n    - s (str): The original string.\n    - c (str): The character to replace blank spaces with.\n\n    Returns:\n    - str: The modified string with blank spaces replaced by `c`.\n    \"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the given string with the specified character.\n\n    Args:\n        s (str): The input string.\n        char (str): The character to replace spaces with.\n\n    Returns:\n        str: The modified string with spaces replaced by the specified character.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the specified character `char`.\n\n    Args:\n        s (str): The original string containing spaces.\n        char (str): The character to replace spaces with.\n\n    Returns:\n        str: The modified string with spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the specified `char`.\n\n    Parameters:\n    s (str): The input string containing blank spaces.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the specified character `char`.\n\n    Parameters:\n    - s (str): The original string.\n    - char (str): The character to replace blank spaces with.\n\n    Returns:\n    - str: The modified string with blank spaces replaced.\n    \"\"\"\n    return char.join(s.split(' '))", "matching_cluster_idx": 6}, {"solution": "def replace_blank(s, c):\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the character `c`.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by `c`.\n    \"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    Args:\n        s (str): The original string.\n        char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replace blank spaces in the string with the specified character.\n\n    Args:\n        s (str): The input string.\n        char (str): The character to replace spaces with.\n\n    Returns:\n        str: The modified string with spaces replaced.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, replacement_char):\n    \"\"\"\n    Replace all blank spaces in the string 's' with 'replacement_char'.\n\n    Parameters:\n    s (str): The input string.\n    replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced.\n    \"\"\"\n    return s.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the specified `char`.\n\n    Parameters:\n    - s (str): The original string.\n    - char (str): The character to replace blank spaces with.\n\n    Returns:\n    - str: The modified string with blank spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, c: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the character `c`.\n\n    Args:\n    - s (str): The original string.\n    - c (str): The character to replace blank spaces with.\n\n    Returns:\n    - str: The modified string with blank spaces replaced by `c`.\n    \"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    Args:\n        s (str): The original string.\n        char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replace blank spaces in the string `s` with the character `char`.\n\n    Args:\n        s (str): The input string.\n        char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced by `char`.\n\n    Example:\n        >>> replace_blank(\"hello people\", '@')\n        'hello@people'\n    \"\"\"\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the specified character `char`.\n\n    Args:\n        s (str): The original string.\n        char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the specified character `char`.\n\n    Args:\n        s (str): The original string.\n        char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces blank spaces in the string s with the specified character char.\n\n    Args:\n        s (str): The input string.\n        char (str): The character to replace spaces with.\n\n    Returns:\n        str: The modified string with spaces replaced by char.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replace all blank spaces in the given string with the specified character.\n\n    Args:\n        s (str): The input string.\n        char (str): The character to replace spaces with.\n\n    Returns:\n        str: The modified string with spaces replaced by the specified character.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the string `s` with the specified `char`.\n\n    Args:\n        s (str): The input string.\n        char (str): The character to replace spaces with.\n\n    Returns:\n        str: The modified string with spaces replaced by `char`.\n    \"\"\"\n    # Using str.replace for efficient replacement\n    return s.replace(' ', char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 95.0, "dps_norm": 89.5, "pass@1": 96.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def helper(pos, prev):\n        if pos > n:\n            return 1\n        if pos == 1:\n            lower = 1\n            upper = m // (1 << (n - 1))\n        else:\n            lower = 2 * prev\n            upper = m // (1 << (n - pos))\n        \n        if lower > upper:\n            return 0\n        \n        total = 0\n        for x in range(lower, upper + 1):\n            total += helper(pos + 1, x)\n        return total\n\n    return helper(1, 0)", "matching_cluster_idx": 9}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of possible sequences of length n where each element\n    is a positive integer <= m and is at least twice the previous element.\n    \n    Parameters:\n    m (int): The maximum allowed value in the sequence.\n    n (int): The length of the sequence.\n    \n    Returns:\n    int: The total number of valid sequences.\n    \"\"\"\n    if n == 0:\n        return 0\n    # Initialize the previous DP array: for sequences of length 1, there's 1 way for each x\n    prev = [1] * (m + 1)\n    \n    for length in range(2, n + 1):\n        current = [0] * (m + 1)\n        # Compute prefix sums for the previous DP to optimize the range sum queries\n        prefix_sum = [0] * (m + 1)\n        for x in range(1, m + 1):\n            prefix_sum[x] = prefix_sum[x - 1] + prev[x]\n        # Update the current DP based on the prefix sums\n        for x in range(1, m + 1):\n            half = x // 2\n            current[x] = prefix_sum[half]\n        prev = current  # Update prev for the next iteration\n    \n    # The total number of sequences is the sum of all possible ending values\n    total_sequences = sum(prev)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    if m < 1 or n < 1:\n        return 0\n\n    # Initialize the previous step with 1 sequence for each number\n    prev = [0] * (m + 1)\n    for x in range(1, m + 1):\n        prev[x] = 1\n\n    # Iterate through sequence lengths from 2 to n\n    for _ in range(2, n + 1):\n        # Compute prefix sums for the previous step\n        prefix = [0] * (m + 1)\n        for x in range(1, m + 1):\n            prefix[x] = prefix[x - 1] + prev[x]\n        \n        # Calculate current step based on prefix sums\n        current = [0] * (m + 1)\n        for x in range(1, m + 1):\n            current[x] = prefix[x // 2]\n        \n        # Update prev for the next iteration\n        prev = current\n\n    # The total number of sequences is the sum of all possibilities in the last step\n    return sum(prev[1:])", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of possible sequences of length n where each element is a positive integer\n    less than or equal to m and each element is at least twice the previous element.\n    \n    Parameters:\n    m (int): The maximum possible integer in the sequence.\n    n (int): The length of the sequence.\n    \n    Returns:\n    int: The total number of valid sequences.\n    \"\"\"\n    if n == 0:\n        return 0\n    if m < 1:\n        return 0\n\n    # Initialize DP for sequences of length 1\n    dp_prev = [0] * (m + 1)\n    for k in range(1, m + 1):\n        dp_prev[k] = 1\n\n    for length in range(2, n + 1):\n        # Compute prefix sums for dp_prev\n        prefix_sums = [0] * (m + 2)  # Extra element to avoid index issues\n        for k in range(1, m + 1):\n            prefix_sums[k] = prefix_sums[k - 1] + dp_prev[k]\n        \n        # Compute current dp based on prefix sums\n        dp_current = [0] * (m + 1)\n        for k in range(1, m + 1):\n            max_prev = k // 2\n            if max_prev >= 1:\n                dp_current[k] = prefix_sums[max_prev]\n            else:\n                dp_current[k] = 0\n        dp_prev = dp_current\n\n    return sum(dp_prev)", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n    - m (int): The upper bound for the elements in the sequence.\n    - n (int): The length of the sequence.\n\n    Returns:\n    - int: The total number of valid sequences.\n    \"\"\"\n    if n == 0:\n        return 0\n    # Initialize dp_prev where dp_prev[x] represents the number of sequences of length 1 ending with x\n    dp_prev = [0] * (m + 1)\n    for x in range(1, m + 1):\n        dp_prev[x] = 1\n\n    for _ in range(1, n):\n        # Compute prefix sums for dp_prev to enable efficient range queries\n        prefix_sum = [0] * (m + 1)\n        s = 0\n        for x in range(1, m + 1):\n            s += dp_prev[x]\n            prefix_sum[x] = s\n\n        # Compute dp_current based on dp_prev and the prefix sums\n        dp_current = [0] * (m + 1)\n        for x in range(1, m + 1):\n            dp_current[x] = prefix_sum[x // 2]\n\n        dp_prev = dp_current\n\n    # The total number of sequences of length n is the sum of all sequences ending with any x\n    return sum(dp_prev)", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(prev, steps_left):\n        if steps_left == 1:\n            return 1\n        total = 0\n        start = 2 * prev\n        if start > m:\n            return 0\n        # Iterate through all possible next values\n        for next_val in range(start, m + 1):\n            total += count_sequences(next_val, steps_left - 1)\n        return total\n\n    total_sequences = 0\n    # Iterate through all possible starting values\n    for first in range(1, m + 1):\n        total_sequences += count_sequences(first, n)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    if n == 1:\n        return m\n\n    previous = [0] * (m + 1)\n    # Base case: sequences of length 1\n    for v in range(1, m + 1):\n        previous[v] = 1\n\n    for _ in range(2, n + 1):\n        current = [0] * (m + 1)\n        prefix_sum = [0] * (m + 1)\n        # Compute prefix sums for previous\n        for v in range(1, m + 1):\n            prefix_sum[v] = prefix_sum[v - 1] + previous[v]\n        # Calculate current dp values using prefix sums\n        for v in range(1, m + 1):\n            max_prev = v // 2\n            current[v] = prefix_sum[max_prev]\n        previous = current\n\n    return sum(previous)", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(current, remaining):\n        if remaining == 0:\n            return 1\n        total = 0\n        next_min = 2 * current\n        next_max = m\n        for next_num in range(next_min, next_max + 1):\n            total += count_sequences(next_num, remaining - 1)\n        return total\n\n    total_sequences = 0\n    for first in range(1, m + 1):\n        total_sequences += count_sequences(first, n - 1)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(prev, remaining_length):\n        if remaining_length == 1:\n            return 1  # Only one element needed, which is already counted\n        total = 0\n        # Next element must be at least twice the previous and <= m\n        next_min = 2 * prev\n        if next_min > m:\n            return 0  # No valid next elements\n        for next_elem in range(next_min, m + 1):\n            total += count_sequences(next_elem, remaining_length - 1)\n        return total\n\n    total_sequences = 0\n    # Start with any integer from 1 to m\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize the previous DP array with 1s for sequences of length 1\n    dp_prev = [0] * (m + 2)  # Using m+2 to avoid index issues\n    for x in range(1, m + 1):\n        dp_prev[x] = 1\n\n    for _ in range(2, n + 1):\n        # Compute prefix sums for efficient range queries\n        prefix_sum = [0] * (m + 2)\n        for x in range(1, m + 1):\n            prefix_sum[x] = prefix_sum[x - 1] + dp_prev[x]\n\n        # Initialize the current DP array\n        dp_current = [0] * (m + 2)\n        for x in range(1, m + 1):\n            min_val = 2 * x\n            if min_val > m:\n                dp_current[x] = 0\n            else:\n                dp_current[x] = prefix_sum[m] - prefix_sum[min_val - 1]\n\n        # Update dp_prev for the next iteration\n        dp_prev = dp_current\n\n    # The total number of sequences is the sum of all possibilities for the last element\n    return sum(dp_prev[1:m + 1])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(prev, remaining):\n        if remaining == 0:\n            return 1\n        start = 2 * prev\n        if start > m:\n            return 0\n        total = 0\n        for next_val in range(start, m + 1):\n            total += count_sequences(next_val, remaining - 1)\n        return total\n\n    total_sequences = 0\n    for first in range(1, m + 1):\n        total_sequences += count_sequences(first, n - 1)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of possible sequences of length n where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n    \"\"\"\n    if n == 0:\n        return 0\n    # Initialize dp where dp[k][x] represents number of sequences of length k ending with x\n    dp_prev = [1] * (m + 1)  # Base case: sequences of length 1\n    for length in range(2, n + 1):\n        # Compute prefix sums for dp_prev to enable O(1) range queries\n        prefix_sum = [0] * (m + 1)\n        for x in range(1, m + 1):\n            prefix_sum[x] = prefix_sum[x - 1] + dp_prev[x]\n        # Compute dp for current length\n        dp_curr = [0] * (m + 1)\n        for x in range(1, m + 1):\n            y_max = x // 2\n            if y_max >=1:\n                dp_curr[x] = prefix_sum[y_max]\n            else:\n                dp_curr[x] = 0\n        dp_prev = dp_curr\n    # Total sequences of length n is the sum of sequences ending with any x\n    return sum(dp_prev)", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(length, prev):\n        if length == 0:\n            return 1\n        total = 0\n        # Start from max(2*prev, 1) to m for the next element\n        start = 2 * prev if prev > 0 else 1\n        for next_num in range(start, m + 1):\n            total += count_sequences(length - 1, next_num)\n        return total\n\n    return count_sequences(n, 0)", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of possible sequences of length n where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n    \"\"\"\n    if n == 0:\n        return 0\n    # Initialize dp_prev where dp_prev[v] represents the number of sequences of length 1 ending with v\n    dp_prev = [0] * (m + 2)  # 1-based indexing\n    for v in range(1, m + 1):\n        dp_prev[v] = 1\n\n    for step in range(2, n + 1):\n        # Compute suffix sums where suff_sum[v] = sum of dp_prev[u] for u >= v\n        suff_sum = [0] * (m + 2)\n        for v in range(m, 0, -1):\n            suff_sum[v] = suff_sum[v + 1] + dp_prev[v]\n\n        # Update dp_current based on suff_sum\n        dp_current = [0] * (m + 2)\n        for v in range(1, m + 1):\n            if 2 * v <= m:\n                dp_current[v] = suff_sum[2 * v]\n            else:\n                dp_current[v] = 0\n        dp_prev = dp_current\n\n    return sum(dp_prev[1:m + 1])", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of possible sequences of length n where each element\n    is a positive integer, greater than or equal to twice the previous element,\n    and less than or equal to m.\n\n    Args:\n    - m (int): The maximum allowable value for elements in the sequence.\n    - n (int): The length of the sequences.\n\n    Returns:\n    - int: The total number of valid sequences.\n    \"\"\"\n    if n == 0:\n        return 0\n\n    # Initialize dp_prev where dp_prev[k] represents the number of sequences of length 1 ending with k\n    dp_prev = [0] * (m + 1)\n    for k in range(1, m + 1):\n        dp_prev[k] = 1\n\n    for length in range(2, n + 1):\n        # Compute prefix sums for efficient range queries\n        prefix_sum = [0] * (m + 2)  # Extra element to handle prefix_sum[m]\n        for k in range(1, m + 1):\n            prefix_sum[k] = prefix_sum[k - 1] + dp_prev[k]\n\n        dp_current = [0] * (m + 1)\n        for k in range(1, m + 1):\n            lower = 2 * k\n            if lower > m:\n                dp_current[k] = 0\n            else:\n                # Total sequences where next number is from 2*k to m\n                dp_current[k] = prefix_sum[m] - prefix_sum[lower - 1]\n\n        dp_prev = dp_current\n\n    # The total number of sequences is the sum of all sequences of length n ending with any k\n    total_sequences = sum(dp_prev[1:m + 1])\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of possible sequences of length n where each element \n    is a positive integer less than or equal to m and each element is \n    greater than or equal to twice the previous element.\n    \"\"\"\n    if n == 1:\n        return m\n\n    # Initialize DP for sequences of length 1\n    prev = [0] * (m + 1)\n    for x in range(1, m + 1):\n        prev[x] = 1\n\n    for _ in range(2, n + 1):\n        # Compute prefix sums for the previous DP state\n        prefix_sum = [0] * (m + 2)\n        for x in range(1, m + 1):\n            prefix_sum[x] = prefix_sum[x - 1] + prev[x]\n\n        # Compute current DP state\n        current = [0] * (m + 1)\n        for x in range(1, m + 1):\n            half = x // 2\n            current[x] = prefix_sum[half]\n\n        # Update previous DP state\n        prev = current\n\n    return sum(prev)", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n where each element\n    is a positive integer, each element is at least twice the previous element,\n    and all elements are less than or equal to m.\n    \n    Parameters:\n    m (int): The maximum value an element in the sequence can take.\n    n (int): The length of the sequence.\n    \n    Returns:\n    int: The total number of valid sequences.\n    \"\"\"\n    if n == 0:\n        return 0\n    # Initialize dp for sequences of length 1\n    previous_dp = [1] * (m + 1)  # dp[1][x] = 1 for all x\n\n    for length in range(2, n + 1):\n        current_dp = [0] * (m + 1)\n        # Compute prefix sums for previous_dp\n        prefix_sum = [0] * (m + 2)  # Extra element for easier calculation\n        for x in range(1, m + 1):\n            prefix_sum[x] = prefix_sum[x - 1] + previous_dp[x]\n        # Calculate current_dp using prefix sums\n        for x in range(1, m + 1):\n            y_max = x // 2\n            if y_max >=1:\n                current_dp[x] = prefix_sum[y_max]\n            else:\n                current_dp[x] = 0\n        previous_dp = current_dp\n\n    # Total number of sequences is the sum of dp[n][x] for all x\n    total_sequences = sum(previous_dp[1:m+1])\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of possible sequences of length n where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n    \n    Args:\n    - m (int): The maximum value an element in the sequence can take.\n    - n (int): The length of the sequence.\n    \n    Returns:\n    - int: The total number of valid sequences.\n    \n    Example:\n    >>> get_total_number_of_sequences(10, 4)\n    4\n    \"\"\"\n    if n == 1:\n        return m\n\n    # Initialize the previous state with 1s for sequences of length 1\n    prev = [1] * (m + 1)\n\n    for _ in range(2, n + 1):\n        # Compute prefix sums to efficiently calculate the number of valid predecessors\n        prefix_sum = [0] * (m + 1)\n        for x in range(1, m + 1):\n            prefix_sum[x] = prefix_sum[x - 1] + prev[x]\n        \n        # Calculate the current state based on the prefix sums\n        current = [0] * (m + 1)\n        for x in range(1, m + 1):\n            current[x] = prefix_sum[x // 2]\n        \n        # Update the previous state for the next iteration\n        prev = current\n\n    # The total number of valid sequences is the sum of all possibilities for the last element\n    return sum(prev)", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of possible sequences of length n where each element is a positive integer\n    less than or equal to m, and each element is at least twice the previous element.\n\n    Parameters:\n    m (int): The maximum value an element in the sequence can take.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of valid sequences.\n    \"\"\"\n    if n == 0:\n        return 0\n    if m == 0:\n        return 0\n\n    # Initialize DP for sequences of length 1\n    dp = [1] * (m + 1)  # dp[x] represents number of sequences ending with x\n\n    for length in range(2, n + 1):\n        # Compute prefix sums for current dp\n        prefix_sum = [0] * (m + 1)\n        for x in range(1, m + 1):\n            prefix_sum[x] = prefix_sum[x - 1] + dp[x]\n\n        # Compute new_dp based on prefix sums\n        new_dp = [0] * (m + 1)\n        for x in range(1, m + 1):\n            half = x // 2\n            new_dp[x] = prefix_sum[half]\n\n        dp = new_dp\n\n    # Total sequences of length n\n    total_sequences = sum(dp[1:m+1])\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of possible sequences of length n where each element\n    is a positive integer, greater than or equal to twice the previous element,\n    and less than or equal to m.\n    \n    Parameters:\n    - m (int): The upper bound for the elements in the sequence.\n    - n (int): The length of the sequence.\n    \n    Returns:\n    - int: The total number of valid sequences.\n    \n    Example:\n    >>> get_total_number_of_sequences(10, 4)\n    4\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return m\n\n    # Initialize previous DP array: for sequences of length 1\n    prev = [0] * (m + 1)\n    for x in range(1, m + 1):\n        prev[x] = 1\n\n    # Iterate from sequence length 2 to n\n    for _ in range(2, n + 1):\n        # Compute prefix sums of the previous DP array\n        prefix_sum = [0] * (m + 1)\n        for x in range(1, m + 1):\n            prefix_sum[x] = prefix_sum[x - 1] + prev[x]\n        \n        # Compute current DP array based on prefix sums\n        curr = [0] * (m + 1)\n        for x in range(1, m + 1):\n            limit = x // 2\n            if limit >= 1:\n                curr[x] = prefix_sum[limit]\n            else:\n                curr[x] = 0\n        # Update prev for the next iteration\n        prev = curr\n\n    # The total number of sequences is the sum of the last DP array\n    total_sequences = sum(prev)\n    return total_sequences", "matching_cluster_idx": 8}]}, "Mbpp/240": {"dps": 44.146341463414636, "dps_norm": 64.44444444444444, "pass@1": 100.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    Parameters:\n    list1 (list): The original list.\n    list2 (list): The list to insert into list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by list2.\n    \"\"\"\n    if not list1:\n        # If list1 is empty, simply return list2\n        return list2\n    # Replace the last element with list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1 (list): The original list.\n        list2 (list): The list to replace the last element with.\n\n    Returns:\n        list: The modified list with the last element of list1 replaced by list2.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list is empty and has no elements to replace.\")\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    Args:\n        list1 (list): The original list.\n        list2 (list): The list of elements to insert.\n\n    Returns:\n        list: A new list with the last element of list1 replaced by list2.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list is empty and has no elements to replace.\")\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    Args:\n        list1 (list): The original list whose last element is to be replaced.\n        list2 (list): The list of elements to insert in place of the last element of list1.\n\n    Returns:\n        list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list must contain at least one element.\")\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of lst1 with the elements of lst2.\n\n    Parameters:\n    lst1 (list): The first list whose last element is to be replaced.\n    lst2 (list): The second list whose elements will replace the last element of lst1.\n\n    Returns:\n    list: A new list with the last element of lst1 replaced by lst2.\n    \"\"\"\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1 (list): The original list.\n        list2 (list): The list to insert in place of the last element of list1.\n\n    Returns:\n        list: The modified list with the last element replaced by list2.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list cannot be empty.\")\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list.\n\n    Returns:\n    list: The modified list1 with the last element replaced by list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list whose elements will replace the last element of list1.\n\n    Returns:\n        list: The modified list with the last element of list1 replaced by list2's elements.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n    \n    Parameters:\n    list1 (list): The first list where the last element will be replaced.\n    list2 (list): The list of elements to insert into the first list.\n    \n    Returns:\n    list: The modified list with the last element replaced by list2.\n    \"\"\"\n    if not list1:\n        return list2\n    return list1[:-1] + list2", "matching_cluster_idx": 4}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The original list.\n    list2 (list): The list to insert.\n\n    Returns:\n    list: The modified list.\n    \"\"\"\n    if not isinstance(list1, list) or not isinstance(list2, list):\n        raise TypeError(\"Both arguments must be lists.\")\n    if not list1:\n        return list2.copy()\n    \n    # Replace the last element with the elements of list2\n    return list1[:-1] + list2", "matching_cluster_idx": 4}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    \n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The list to replace the last element of list1.\n    \n    Returns:\n    list: The updated list.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list is empty and has no elements to replace.\")\n    return list1[:-1] + list2", "matching_cluster_idx": 4}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    Parameters:\n    list1 (list): The original list whose last element will be replaced.\n    list2 (list): The list of elements to insert in place of the last element of list1.\n\n    Returns:\n    list: The modified list with the last element replaced by list2's elements.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Parameters:\n    list1 (list): The original list where the last element will be replaced.\n    list2 (list): The list of elements to insert into the first list.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list is empty and has no elements to replace.\")\n    \n    return list1[:-1] + list2", "matching_cluster_idx": 4}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The original list.\n    list2 (list): The list of elements to insert.\n\n    Returns:\n    list: The modified list with the last element replaced by list2.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list cannot be empty.\")\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of lst1 with all elements from lst2.\n\n    Parameters:\n    lst1 (list): The original list whose last element will be replaced.\n    lst2 (list): The list of elements to insert in place of the last element of lst1.\n\n    Returns:\n    list: A new list with the last element of lst1 replaced by lst2.\n    \"\"\"\n    if not lst1:\n        raise ValueError(\"The first list cannot be empty.\")\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The original list.\n    list2 (list): The list to insert in place of the last element of list1.\n\n    Returns:\n    list: The modified list.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list cannot be empty.\")\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The original list.\n    list2 (list): The list of elements to insert.\n\n    Returns:\n    list: The modified list with the last element replaced by list2's elements.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list cannot be empty.\")\n    \n    # Create a copy to avoid modifying the original list\n    modified_list = list1[:-1] + list2\n    return modified_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of lst1 with the elements of lst2.\n\n    Args:\n        lst1 (list): The first list whose last element will be replaced.\n        lst2 (list): The list of elements to insert in place of the last element of lst1.\n\n    Returns:\n        list: A new list with the last element of lst1 replaced by lst2.\n    \"\"\"\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Parameters:\n    - list1 (list): The original list.\n    - list2 (list): The list of elements to insert.\n\n    Returns:\n    - list: The modified list with the last element replaced by list2's elements.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}]}, "Mbpp/251": {"dps": 64.36781609195403, "dps_norm": 73.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the provided list.\n\n    Parameters:\n    lst (list): The original list of elements.\n    elem: The element to insert before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Args:\n        lst (list): The original list.\n        element: The element to insert.\n\n    Returns:\n        list: A new list with the element inserted before each original element.\n    \"\"\"\n    return [e for item in lst for e in (element, item)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the list.\n\n    Parameters:\n    lst (list): The original list.\n    elem: The element to insert before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the input list.\n\n    Args:\n        lst (list): The original list of elements.\n        element: The element to insert before each element of lst.\n\n    Returns:\n        list: A new list with the element inserted before each original element.\n    \"\"\"\n    return [item for pair in zip([element]*len(lst), lst) for item in pair]", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the provided list.\n\n    Parameters:\n    lst (list): The original list of elements.\n    elem: The element to insert before each element in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    return [item for pair in lst for item in (elem, pair)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the given list.\n\n    Parameters:\n    lst (list): The original list.\n    elem: The element to insert before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the given list.\n\n    Parameters:\n    lst (list): The list to process.\n    elem: The element to insert.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    # Using list comprehension for an efficient and concise implementation\n    return [item for pair in lst for item in (elem, pair)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the input list.\n\n    Args:\n        lst (list): The original list of elements.\n        element: The element to be inserted before each item in the list.\n\n    Returns:\n        list: A new list with the element inserted before each original item.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Parameters:\n    lst (list): The original list.\n    element: The element to insert before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original item.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Args:\n        lst (list): The original list.\n        element: The element to insert before each item in the list.\n\n    Returns:\n        list: A new list with the element inserted before each original item.\n    \"\"\"\n    return [val for pair in zip([element]*len(lst), lst) for val in pair]", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the provided list.\n\n    Args:\n        lst (list): The original list of elements.\n        elem: The element to insert before each element in the list.\n\n    Returns:\n        list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Args:\n        lst (list): The original list.\n        elem: The element to insert before each item in the list.\n\n    Returns:\n        list: A new list with the element inserted before each original item.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the provided list.\n\n    Args:\n        lst (list): The original list of elements.\n        elem: The element to insert before each element of the list.\n\n    Returns:\n        list: A new list with the element inserted before each original element.\n    \"\"\"\n    return [item for pair in lst for item in (elem, pair)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts `elem` before each element in the list `lst` and returns the resulting list.\n\n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Using list comprehension to interleave `elem` before each item in `lst`\n    return [item for pair in lst for item in (elem, pair)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Args:\n        lst (list): The original list.\n        element: The element to insert before each element in the list.\n\n    Returns:\n        list: The resulting list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Parameters:\n    lst (list): The original list.\n    elem: The element to insert.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    return [x for item in lst for x in (elem, item)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, el):\n    \"\"\"\n    Inserts the element `el` before each element in the list `lst`.\n\n    Args:\n        lst (list): The original list.\n        el (any): The element to insert.\n\n    Returns:\n        list: The new list with `el` inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(el)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the input list.\n\n    Args:\n    lst (list): The list of elements.\n    element: The element to insert before each element in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    return [val for item in lst for val in (element, item)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the element before each element in the list and returns the resulting list.\n    \"\"\"\n    return [elem for item in lst for elem in (element, item)]", "matching_cluster_idx": 5}]}, "Mbpp/256": {"dps": 99.52054794520548, "dps_norm": 94.70588235294117, "pass@1": 98.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Parameters:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The count of prime numbers less than n.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    # Initialize a sieve list where index represents the number.\n    # True means the number is assumed to be prime initially.\n    sieve = [True] * n\n    sieve[0], sieve[1] = False, False  # 0 and 1 are not prime numbers.\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            # Mark multiples of current as non-prime.\n            sieve[current*current : n : current] = [False] * len(range(current*current, n, current))\n    \n    # The number of primes is the sum of True values in the sieve.\n    return sum(sieve)", "matching_cluster_idx": 16}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Parameters:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: Number of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0:2] = [False, False]  # 0 and 1 are not primes\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(range(current*current, n, current))\n\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(num):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number.\n\n    Parameters:\n    num (int): A non-negative integer.\n\n    Returns:\n    int: The count of prime numbers less than num.\n    \"\"\"\n    if num < 2:\n        return 0\n\n    sieve = [True] * num\n    sieve[0:2] = [False, False]  # 0 and 1 are not primes\n\n    for current in range(2, int(num ** 0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:num:current] = [False] * len(sieve[current*current:num:current])\n\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Args:\n    - n (int): A non-negative integer.\n    \n    Returns:\n    - int: Number of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    # Initialize a list to track prime status for each number\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            # Mark multiples of current as non-prime\n            sieve[current*current:n:current] = [False] * len(range(current*current, n, current))\n    \n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less\n    than the given non-negative number.\n    \n    assert count_Primes_nums(5) == 2\n    \"\"\"\n    if n < 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0], sieve[1] = False, False\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(range(current*current, n, current))\n\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    sieve = [True] * n\n    sieve[0], sieve[1] = False, False\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(range(current*current, n, current))\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Args:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The count of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    # Initialize a sieve with True values\n    sieve = [True] * n\n    sieve[0], sieve[1] = False, False  # 0 and 1 are not primes\n\n    for current in range(2, int(n ** 0.5) + 1):\n        if sieve[current]:\n            # Mark multiples of current as non-prime\n            sieve[current * current:n:current] = [False] * len(range(current * current, n, current))\n    \n    return sum(sieve)", "matching_cluster_idx": 16}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(sieve[current*current:n:current])\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Parameters:\n    n (int): A non-negative integer\n    \n    Returns:\n    int: Number of prime numbers less than n\n    \"\"\"\n    if n < 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(range(current*current, n, current))\n\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Parameters:\n    n (int): A non-negative integer\n    \n    Returns:\n    int: The count of prime numbers less than n\n    \"\"\"\n    if n < 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n\n    for current in range(2, int(n ** 0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(sieve[current*current:n:current])\n\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Args:\n        n (int): A non-negative integer.\n        \n    Returns:\n        int: The count of prime numbers less than n.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    # Initialize a boolean array where index represents the number\n    is_prime = [True] * n\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n\n    for current in range(2, int(n**0.5) + 1):\n        if is_prime[current]:\n            # Mark multiples of current as non-prime\n            for multiple in range(current*current, n, current):\n                is_prime[multiple] = False\n\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0], sieve[1] = False, False\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(sieve[current*current:n:current])\n\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(range(current*current, n, current))\n    return sum(sieve)", "matching_cluster_idx": 16}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Args:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The count of prime numbers less than n.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0], sieve[1] = False, False\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(range(current*current, n, current))\n\n    return sum(sieve)", "matching_cluster_idx": 16}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than a non-negative number n.\n    \n    Args:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The count of prime numbers less than n.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0:2] = [False, False]  # 0 and 1 are not primes\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(range(current*current, n, current))\n    \n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            sieve[i*i:n:i] = [False] * len(range(i*i, n, i))\n    return sum(sieve)", "matching_cluster_idx": 16}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    sieve = [True] * n\n    sieve[0:2] = [False, False]  # 0 and 1 are not primes\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(range(current*current, n, current))\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number 'n'.\n    \n    Parameters:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The count of prime numbers less than 'n'.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Initialize a sieve list where index represents the number and value represents primality\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n    \n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            # Mark multiples of current as non-prime\n            sieve[current*current:n:current] = [False] * len(sieve[current*current:n:current])\n    \n    return sum(sieve)", "matching_cluster_idx": 15}]}, "Mbpp/265": {"dps": 68.83720930232559, "dps_norm": 82.5, "pass@1": 98.0, "profiled": [{"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists by taking every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list of lists: A list containing n sublists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Split the input list into n lists, where each list contains every nth element from the original list.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of splits.\n\n    Returns:\n    list of lists: A list containing n sublists.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The number of sublists to create.\n\n    Returns:\n        list: A list of n sublists.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list of lists: A list containing n sublists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n    \n    Args:\n        lst (list): The list to be split.\n        n (int): The number of sublists to create.\n    \n    Returns:\n        list of lists: A list containing n sublists with every nth element.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the list into n lists, each containing every nth element starting from different indices.\n\n    Args:\n        lst (list): The list to split.\n        n (int): The number of splits.\n\n    Returns:\n        list: A list containing n lists with split elements.\n\n    Example:\n        >>> list_split(['a','b','c','d','e','f','g','h','i','j','k','l','m','n'], 3)\n        [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n lists, each containing every nth element.\n    \n    Args:\n    lst (list): The list to be split.\n    n (int): The interval for splitting.\n    \n    Returns:\n    list of lists: A list containing n sublists.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n    \n    Args:\n        lst (list): The list to be split.\n        n (int): The number of sublists to create.\n        \n    Returns:\n        list: A list containing n sublists.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists by distributing elements\n    based on their index modulo n.\n\n    Parameters:\n    lst (list): The list to split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list of lists: A list containing n sublists with the split elements.\n    \"\"\"\n    # Initialize n empty sublists\n    result = [[] for _ in range(n)]\n    \n    # Distribute each element to the appropriate sublist\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list of lists: A list containing n sublists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    :param lst: The list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists with the split elements.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists by selecting every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list of lists: A list containing n sublists with every nth element.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the list into n sublists, collecting every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list: A list containing n sublists.\n    \"\"\"\n    return [lst[k::n] for k in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The number of sublists to create.\n\n    Returns:\n        list: A list containing n sublists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n lists, each containing every nth element from the original list.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of splits.\n\n    Returns:\n    list of lists: A list containing the split lists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n lists, each containing every nth element starting from their respective positions.\n\n    Args:\n        lst (list): The list to split.\n        n (int): The number of splits.\n\n    Returns:\n        list: A list containing n lists, each split according to the pattern.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists by selecting every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list of lists: A list containing n sublists.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, where each sublist contains every nth element from the original list.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The number of sublists to create.\n\n    Returns:\n        list of lists: A list containing n sublists with the split elements.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    # Use list slicing to create each sublist\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists by selecting every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list: A list containing n sublists with every nth element.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list: A list containing n sublists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check for uniqueness.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check for uniqueness.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check for uniqueness.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \n    Examples:\n        >>> all_unique([1, 2, 3])\n        True\n        >>> all_unique([1, 2, 2])\n        False\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check for uniqueness.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Example:\n    >>> all_unique([1, 2, 3])\n    True\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check for uniqueness.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array of integers.\n    \n    Returns:\n    int: The total number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n        # Append any remaining elements\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The list of integers to count inversions in.\n    \n    Returns:\n    int: The total number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # All remaining elements in left are inversions\n                j += 1\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, count = merge_sort(arr)\n    return count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array.\n    \n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        \n        while i < len_left and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i  # Count inversions\n                j += 1\n        # Append remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array.\n    \n    Returns:\n    int: The number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        return merged, inv_left + inv_right + inv_split\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        len_right = len(right)\n        \n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inv = merge_sort(arr)\n    return total_inv", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array.\n    \n    Returns:\n    int: The total number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        else:\n            mid = len(arr) // 2\n            left, inv_left = merge_sort(arr[:mid])\n            right, inv_right = merge_sort(arr[mid:])\n            merged, inv_split = merge(left, right)\n            total_inv = inv_left + inv_right + inv_split\n            return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        \n        while i < len_left and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i  # Count inversions\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array.\n    \n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    Args:\n        arr (list): The input array.\n        \n    Returns:\n        int: The total number of inversions.\n    \"\"\"\n    \n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # All remaining elements in left are inversions\n                j += 1\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array of integers.\n    \n    Returns:\n    int: The total number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        else:\n            mid = len(arr) // 2\n            left, inv_left = merge_sort(arr[:mid])\n            right, inv_right = merge_sort(arr[mid:])\n            merged, inv_split = merge(left, right)\n            total_inv = inv_left + inv_right + inv_split\n            return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        len_right = len(right)\n        \n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i\n                j += 1\n        \n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array of integers.\n    \n    Returns:\n    int: The total number of inversions in the array.\n    \"\"\"\n    \n    def merge_sort(arr):\n        # Base case: a single element has no inversions\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Split the array into two halves\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        \n        # Merge the sorted halves and count split inversions\n        merged, inv_split = merge(left, right)\n        \n        # Total inversions is sum of left, right, and split inversions\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        \n        # Merge the two sorted arrays and count inversions\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # All remaining elements in left are inversions\n                j += 1\n        \n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, inv_count\n\n    # Start the merge sort and inversion count\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        len_right = len(right)\n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i\n                j += 1\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array of integers.\n    \n    Returns:\n    int: The total number of inversions in the array.\n    \"\"\"\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums, 0\n        mid = len(nums) // 2\n        left, inv_left = merge_sort(nums[:mid])\n        right, inv_right = merge_sort(nums[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        len_right = len(right)\n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array using a modified Merge Sort algorithm.\n    \n    Args:\n    arr (list): The input array/list of integers.\n    \n    Returns:\n    int: The total number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in the array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i\n                j += 1\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n\n        # Append remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        return merged, inv_left + inv_right + inv_split\n\n    def merge(left, right):\n        merged = []\n        i = j = inv = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv += len(left) - i\n                j += 1\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv\n\n    _, total_inv = merge_sort(arr)\n    return total_inv", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array of integers.\n    \n    Returns:\n    int: The total number of inversions.\n    \"\"\"\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums, 0\n        mid = len(nums) // 2\n        left, inv_left = merge_sort(nums[:mid])\n        right, inv_right = merge_sort(nums[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        len_right = len(right)\n        \n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i  # Count inversions\n                j += 1\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        return merged, inv_left + inv_right + inv_split\n\n    def merge(left, right):\n        merged = []\n        inv_count = 0\n        i = j = 0\n        len_left = len(left)\n        len_right = len(right)\n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i\n                j += 1\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Helper function to perform merge sort and count inversions\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        return merged, inv_left + inv_right + inv_split\n\n    # Helper function to merge two sorted arrays and count split inversions\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inv = merge_sort(arr)\n    return total_inv", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The total number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inversions = inv_left + inv_right + inv_split\n        return merged, total_inversions\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # All remaining elements in left > right[j]\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array of integers.\n    \n    Returns:\n    int: The total number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        len_right = len(right)\n        \n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i  # All remaining elements in left are inversions\n                j += 1\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}]}, "Mbpp/308": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/392": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 62.0, "profiled": [{"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    # Compute the sum of f(n//2), f(n//3), f(n//4), f(n//5)\n    sum_parts = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    # Take the maximum of the sum and n itself\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    # Recursive calls with integer division\n    sum_parts = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        memo[n] = 0\n        return 0\n    # Compute the sum of f(n//2) + f(n//3) + f(n//4) + f(n//5)\n    sum_children = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    # Take the maximum between the sum of children and n itself\n    memo[n] = max(sum_children, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    \"\"\"\n    Calculate the maximum sum using the equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n    \n    Parameters:\n    n (int): The input integer.\n    memo (dict): A dictionary to memoize previously computed results.\n    \n    Returns:\n    int: The maximum sum possible.\n    \"\"\"\n    if memo is None:\n        memo = {}\n    \n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Recursively compute the sum of f(n//2), f(n//3), f(n//4), and f(n//5)\n    sum_parts = (get_max_sum(n // 2, memo) +\n                 get_max_sum(n // 3, memo) +\n                 get_max_sum(n // 4, memo) +\n                 get_max_sum(n // 5, memo))\n    \n    # The maximum of the computed sum and the current number n\n    memo[n] = max(sum_parts, n)\n    \n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def helper(x):\n        if x == 0:\n            return 0\n        return max(helper(x // 2) + helper(x // 3) + helper(x // 4) + helper(x // 5), x)\n    \n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    \"\"\"\n    Computes the maximum sum using the equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n    \n    Args:\n        n (int): The input integer.\n        memo (dict, optional): A dictionary to store computed results for memoization.\n        \n    Returns:\n        int: The maximum sum computed.\n    \"\"\"\n    if memo is None:\n        memo = {}\n    \n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        memo[n] = 0\n        return 0\n    \n    # Recursively compute the sum of f(n//2), f(n//3), f(n//4), f(n//5)\n    sum_parts = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    \n    # The maximum of the sum of parts and the number itself\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    \"\"\"\n    Recursively computes the maximum sum using the equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n    \n    Args:\n        n (int): The input integer.\n        memo (dict, optional): A dictionary for memoization. Defaults to None.\n\n    Returns:\n        int: The maximum sum possible.\n    \"\"\"\n    if memo is None:\n        memo = {}\n        \n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        memo[n] = 0\n        return 0\n    \n    # Recursively compute the sum of f(n//2), f(n//3), f(n//4), f(n//5)\n    sum_parts = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    \n    # Store the maximum of the computed sum and n itself\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    # Compute the sum of f(n//2), f(n//3), f(n//4), and f(n//5)\n    sum_parts = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    # Take the maximum of the sum and n itself\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n == 0:\n        return 0\n    if n in memo:\n        return memo[n]\n    \n    # Recursively calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n    sum_parts = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Take the maximum between the sum of parts and n itself\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        memo[0] = 0\n        return 0\n    # Compute the sum of f(n//2), f(n//3), f(n//4), and f(n//5)\n    sum_parts = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    # Choose the maximum between the sum of parts and n itself\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    # Calculate the sum of f(n//2), f(n//3), f(n//4), and f(n//5)\n    sum_parts = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    # Take the maximum of the sum or n itself\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n):\n    @lru_cache(maxsize=None)\n    def f(x):\n        if x == 0:\n            return 0\n        return max(f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5), x)\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    \"\"\"\n    Write a function to find the maximum sum possible by using the given equation \n    f(n) = max( (f(n//2) + f(n//3) + f(n//4) + f(n//5)), n).\n    assert get_max_sum(60) == 106\n    \"\"\"\n    if memo is None:\n        memo = {}\n        \n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        memo[n] = 0\n        return 0\n    \n    # Calculate the sum of f(n//2), f(n//3), f(n//4), and f(n//5)\n    sum_children = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    \n    # Determine the maximum between the sum of children and n\n    memo[n] = max(sum_children, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n):\n    @lru_cache(maxsize=None)\n    def f(x):\n        if x == 0:\n            return 0\n        return max(f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5), x)\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    # Recursively compute the sum of parts\n    sum_parts = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    # Store the maximum of the sum of parts or the current number\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n: int) -> int:\n    \"\"\"\n    Calculate the maximum sum based on the given equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n\n    Args:\n        n (int): The input integer.\n\n    Returns:\n        int: The maximum sum calculated.\n    \"\"\"\n    \n    @lru_cache(maxsize=None)\n    def f(x: int) -> int:\n        if x == 0:\n            return 0\n        # Compute the sum of f(x//2), f(x//3), f(x//4), and f(x//5)\n        sum_children = f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5)\n        # Return the maximum between the sum and x itself\n        return max(sum_children, x)\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n):\n    \"\"\"\n    Calculate the maximum sum using the equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n    \n    Args:\n    n (int): The input integer.\n\n    Returns:\n    int: The maximum sum possible.\n    \"\"\"\n    @lru_cache(maxsize=None)\n    def f(m):\n        if m == 0:\n            return 0\n        return max(f(m//2) + f(m//3) + f(m//4) + f(m//5), m)\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        memo[0] = 0\n        return 0\n    # Compute the sum of the function applied to the parts\n    sum_parts = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    # The maximum of the sum of parts and the number itself\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    # Calculate the sum of f(n//2) + f(n//3) + f(n//4) + f(n//5)\n    total = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    # Decide whether to take the total or n itself\n    memo[n] = max(total, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n):\n    @lru_cache(maxsize=None)\n    def f(x):\n        if x == 0:\n            return 0\n        # Compute the sum of f(x//2), f(x//3), f(x//4), and f(x//5)\n        sum_parts = f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5)\n        # Return the maximum between the sum of parts and x itself\n        return max(sum_parts, x)\n    \n    return f(n)", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string to analyze.\n\n    Returns:\n        str or None: The first non-repeated character if found, otherwise None.\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str or None: The first non-repeated character, or None if there isn't one.\n    \"\"\"\n    char_count = {}\n\n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str or None: The first non-repeated character, or None if there is no such character.\n    \"\"\"\n    counts = {}\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n    \n    for char in s:\n        if counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    Parameters:\n    s (str): The input string to search.\n    \n    Returns:\n    str or None: The first non-repeated character if found, otherwise None.\n    \"\"\"\n    from collections import Counter\n\n    # Count the occurrences of each character in the string\n    counts = Counter(s)\n\n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if counts[char] == 1:\n            return char\n\n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n    \n    Parameters:\n    s (str): The input string to be evaluated.\n    \n    Returns:\n    str or None: The first non-repeating character if found, otherwise None.\n    \"\"\"\n    counts = {}\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n\n    for char in s:\n        if counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in the given string.\n    \n    Args:\n        s (str): The input string to search.\n        \n    Returns:\n        str or None: The first non-repeating character if found, otherwise None.\n    \"\"\"\n    from collections import OrderedDict\n\n    # Use OrderedDict to maintain the order of characters\n    character_counts = OrderedDict()\n\n    # Count the occurrences of each character\n    for char in s:\n        character_counts[char] = character_counts.get(char, 0) + 1\n\n    # Iterate through the ordered dictionary to find the first non-repeating character\n    for char, count in character_counts.items():\n        if count == 1:\n            return char\n\n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in the given string.\n    \n    Parameters:\n    s (str): The input string to search.\n    \n    Returns:\n    str or None: The first non-repeating character if found, otherwise None.\n    \"\"\"\n    char_count = {}\n    \n    # First pass: Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Second pass: Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str or None: The first non-repeating character if found, otherwise None.\n    \"\"\"\n    char_counts = {}\n    \n    # First pass: Count the occurrences of each character\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n    \n    # Second pass: Find the first character with a count of 1\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str or None: The first non-repeating character, or None if all characters repeat.\n    \"\"\"\n    # Dictionary to store the count of each character\n    char_count = {}\n\n    # First pass: count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Second pass: find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str or None: The first non-repeating character if found, else None.\n    \"\"\"\n    from collections import OrderedDict\n\n    # OrderedDict preserves the insertion order\n    char_count = OrderedDict()\n\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    for char, count in char_count.items():\n        if count == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str or None: The first non-repeating character, or None if all characters are repeated.\n    \"\"\"\n    char_count = {}\n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Iterate through the string to find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Count frequency of each character\n    counts = {}\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n    \n    # Find the first character with frequency 1\n    for char in s:\n        if counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str or None: The first non-repeating character if exists, otherwise None.\n    \"\"\"\n    counts = {}\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n\n    for char in s:\n        if counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n    Returns the character if found, otherwise returns None.\n    \"\"\"\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n    \n    Parameters:\n    s (str): The input string to search.\n    \n    Returns:\n    str or None: The first non-repeating character if found, otherwise None.\n    \"\"\"\n    char_counts = {}\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n    \n    :param s: The input string.\n    :return: The first non-repeated character or None if there isn't one.\n    \"\"\"\n    counts = {}\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n    for char in s:\n        if counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in the given string.\n    Returns the character if found, otherwise returns None.\n    \"\"\"\n    # Dictionary to store character counts\n    char_count = {}\n    \n    # First pass: count the frequency of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Second pass: find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Parameters:\n    s (str): The input string to search.\n\n    Returns:\n    str or None: The first non-repeated character if found, otherwise None.\n    \"\"\"\n    # Dictionary to store character counts\n    char_counts = {}\n\n    # First pass: Count the occurrences of each character\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Second pass: Find the first character with a count of 1\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    Parameters:\n    s (str): The input string to search.\n    \n    Returns:\n    str or None: The first non-repeated character if found, otherwise None.\n    \"\"\"\n    from collections import OrderedDict\n\n    # Use OrderedDict to maintain the order of characters\n    char_count = OrderedDict()\n\n    # Count occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Find and return the first character with a count of 1\n    for char, count in char_count.items():\n        if count == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n    \n    Args:\n        s (str): The input string to search.\n        \n    Returns:\n        str or None: The first non-repeated character if found, otherwise None.\n    \"\"\"\n    from collections import OrderedDict\n\n    # Create an ordered dictionary to maintain the order of characters\n    char_count = OrderedDict()\n\n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Iterate through the ordered dictionary to find the first non-repeating character\n    for char, count in char_count.items():\n        if count == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is found, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is in tuplex, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tpl, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Args:\n        tpl (tuple): The tuple to search.\n        element: The element to find.\n\n    Returns:\n        bool: True if element is in tpl, False otherwise.\n    \"\"\"\n    return element in tpl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if the element exists within the given tuple.\n\n    Args:\n        tuplex (tuple): The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Args:\n        tup (tuple): The tuple to search.\n        element: The element to find.\n\n    Returns:\n        bool: True if the element exists in the tuple, False otherwise.\n    \n    Example:\n        assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r') == True\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Args:\n        tuplex (tuple): The tuple to search.\n        element: The element to find.\n\n    Returns:\n        bool: True if element is in tuplex, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if the given element exists within the tuple.\n\n    Args:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is in tup, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tpl, element):\n    \"\"\"\n    Check if the element exists within the tuple.\n\n    Parameters:\n    tpl (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if element is found, False otherwise.\n    \"\"\"\n    return element in tpl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if the element exists in the tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if element is found, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is in tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Args:\n        tup (tuple): The tuple to search.\n        element: The element to find.\n\n    Returns:\n        bool: True if element is in tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if the element exists within the tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is in tuplex, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tpl, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tpl (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is in tpl, False otherwise.\n    \"\"\"\n    return element in tpl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is found, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tpl, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tpl (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is in tpl, False otherwise.\n    \"\"\"\n    return element in tpl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is in tup, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if the element exists within the tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is in tup, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if the specified element exists within the tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is found, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tpl, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Args:\n        tpl (tuple): The tuple to search.\n        element: The element to find.\n\n    Returns:\n        bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tpl", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 85.90062111801242, "dps_norm": 86.66666666666666, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): The first sequence.\n        seq2 (iterable): The second sequence.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set_seq1 = set(seq1)\n    for item in seq2:\n        if item in set_seq1:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any element in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): First sequence.\n        seq2 (iterable): Second sequence.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (iterable): First sequence.\n    seq2 (iterable): Second sequence.\n\n    Returns:\n    bool: True if any element in seq1 is also in seq2, False otherwise.\n    \"\"\"\n    set_seq1 = set(seq1)\n    for item in seq2:\n        if item in set_seq1:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n\n    Args:\n        seq1 (iterable): The first sequence.\n        seq2 (iterable): The second sequence.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): First sequence.\n        seq2 (iterable): Second sequence.\n\n    Returns:\n        bool: True if any element of seq1 is in seq2, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): The first sequence.\n        seq2 (iterable): The second sequence.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    - seq1: first sequence\n    - seq2: second sequence\n\n    Returns:\n    - True if any element of seq1 is in seq2, False otherwise\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any element in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): First sequence.\n        seq2 (iterable): Second sequence.\n\n    Returns:\n        bool: True if any common element exists, False otherwise.\n    \"\"\"\n    return not set(seq1).isdisjoint(seq2)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): The first sequence.\n        seq2 (iterable): The second sequence.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    # Convert one sequence to a set for O(1) lookups\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any element in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): First sequence.\n        seq2 (iterable): Second sequence.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set_seq1 = set(seq1)\n    for item in seq2:\n        if item in set_seq1:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): First sequence of elements.\n        seq2 (iterable): Second sequence of elements.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): First sequence.\n        seq2 (iterable): Second sequence.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set_seq1 = set(seq1)\n    for item in seq2:\n        if item in set_seq1:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (Iterable): First sequence of elements.\n    seq2 (Iterable): Second sequence of elements.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for efficient lookups\n    set_seq2 = set(seq2)\n    \n    # Iterate through the first sequence and check for common elements\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any element in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): First sequence.\n        seq2 (iterable): Second sequence.\n\n    Returns:\n        bool: True if any common element exists, False otherwise.\n    \"\"\"\n    # Convert the smaller sequence to a set for efficient look-up\n    if len(seq1) < len(seq2):\n        smaller, larger = seq1, seq2\n    else:\n        smaller, larger = seq2, seq1\n\n    seen = set(smaller)\n    for item in larger:\n        if item in seen:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): First sequence.\n        seq2 (iterable): Second sequence.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    # Convert the first sequence to a set for O(1) lookups\n    set_seq1 = set(seq1)\n    \n    # Iterate through the second sequence and check for common elements\n    for item in seq2:\n        if item in set_seq1:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n\n    Args:\n        seq1 (iterable): The first sequence to check.\n        seq2 (iterable): The second sequence to check against.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n\n    Args:\n        seq1 (iterable): The first sequence of elements.\n        seq2 (iterable): The second sequence of elements.\n\n    Returns:\n        bool: True if any element of seq1 is in seq2, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)  # Convert second sequence to a set for O(1) lookups\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (Iterable): First sequence.\n        seq2 (Iterable): Second sequence.\n\n    Returns:\n        bool: True if any element of seq1 is in seq2, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (iterable): First sequence of elements.\n    seq2 (iterable): Second sequence of elements.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    return not set(seq1).isdisjoint(seq2)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): The first sequence.\n        seq2 (iterable): The second sequence.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 40.65843621399177, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple into a string separated by the given delimiter.\n    \n    Parameters:\n    tup (tuple): The tuple containing elements to concatenate.\n    delimiter (str): The delimiter to separate the elements. Default is '-'.\n    \n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple into a string separated by the given delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by the specified delimiter.\n    \n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n    \n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(item) for item in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple using the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a single string separated by the given delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The string used to separate elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by '-'.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return '-'.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a single string separated by the given delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a string separated by the delimiter.\n    \n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Defaults to '-'.\n        \n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by the given delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The string delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    \"\"\"\n    Concatenates each element of the tuple using a hyphen as the delimiter.\n\n    Args:\n        t (tuple): A tuple containing elements to concatenate.\n\n    Returns:\n        str: A string with tuple elements concatenated by hyphens.\n    \"\"\"\n    return '-'.join(str(element) for element in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    \"\"\"\n    Concatenates each element of the tuple using a hyphen '-' as the delimiter.\n\n    Parameters:\n    t (tuple): A tuple containing elements to concatenate.\n\n    Returns:\n    str: A string with all tuple elements concatenated by '-'.\n    \"\"\"\n    return '-'.join(str(item) for item in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to separate the elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(item) for item in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tpl, delimiter='-'):\n    return delimiter.join(str(item) for item in tpl)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a single string separated by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple using the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The delimiter to use. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by the given delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The string delimiter to use. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to separate elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use for concatenation. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(item) for item in tup)", "matching_cluster_idx": 4}]}, "Mbpp/424": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the last character of each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n\n    Example:\n        >>> extract_rear(('Mers', 'for', 'Vers'))\n        ['s', 'r', 's']\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the last character of each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the provided tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \n    Example:\n        >>> extract_rear(('Mers', 'for', 'Vers'))\n        ['s', 'r', 's']\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists in `lst` that contain the specified `element`.\n\n    Parameters:\n    lst (list of lists): The list containing sublists to be checked.\n    element (any): The element to look for within the sublists.\n\n    Returns:\n    int: The count of sublists that contain the `element`.\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, target):\n    \"\"\"\n    Counts the number of sublists that contain the target element.\n\n    Parameters:\n    - list_of_sublists (list of lists): The list containing sublists to be searched.\n    - target: The element to search for within the sublists.\n\n    Returns:\n    - int: The count of sublists containing the target element.\n    \"\"\"\n    return sum(target in sublist for sublist in list_of_sublists)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    - list_of_sublists (list of lists): The list containing sublists to be searched.\n    - element: The element to search for within the sublists.\n\n    Returns:\n    - int: The count of sublists containing the specified element.\n    \"\"\"\n    return sum(element in sublist for sublist in list_of_sublists)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    :param list_of_lists: List[List[Any]] - A list of sublists to search through.\n    :param element: Any - The element to count occurrences of in the sublists.\n    :return: int - The count of sublists containing the element.\n    \"\"\"\n    return sum(element in sublist for sublist in list_of_lists)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    lst (list of lists): The list containing sublists to be searched.\n    element: The element to search for within the sublists.\n\n    Returns:\n    int: The count of sublists that contain the element.\n    \"\"\"\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    list_of_lists (list of lists): The main list containing sublists.\n    element: The element to count within the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n    \n    :param list_of_lists: List of lists to search through.\n    :param element: The element to search for.\n    :return: The count of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Args:\n        list_of_sublists (List[List[Any]]): A list of sublists to search through.\n        element (Any): The element to count within the sublists.\n\n    Returns:\n        int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists in lst that contain the specified element.\n    \n    Args:\n        lst (list of lists): The list containing sublists.\n        element: The element to count in the sublists.\n    \n    Returns:\n        int: The number of sublists containing the element.\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Args:\n        list_of_sublists (list of lists): The list containing sublists to search.\n        element: The element to search for within the sublists.\n\n    Returns:\n        int: The count of sublists containing the element.\n    \"\"\"\n    return sum(element in sublist for sublist in list_of_sublists)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Args:\n        list_of_lists (list of lists): The list containing sublists to search.\n        element: The element to count within the sublists.\n\n    Returns:\n        int: The count of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    \"\"\"\n    Counts the number of sublists in 'lst' that contain the element 'elem'.\n    \n    Parameters:\n    lst (list of lists): The list containing sublists to search.\n    elem: The element to count within the sublists.\n    \n    Returns:\n    int: The count of sublists containing 'elem'.\n    \n    Example:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    return sum(1 for sublist in lst if elem in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain a particular element.\n\n    Parameters:\n    list_of_lists (list of lists): The list containing sublists to be searched.\n    element (any): The element to count within the sublists.\n\n    Returns:\n    int: The count of sublists containing the specified element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists in `lst` that contain the specified `element`.\n\n    Args:\n        lst (list of lists): The list of sublists to search.\n        element: The element to count in the sublists.\n\n    Returns:\n        int: The number of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    - list_of_lists (List[List[Any]]): A list of sublists to search through.\n    - element (Any): The element to count within the sublists.\n\n    Returns:\n    - int: The count of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists within 'lst' that contain the specified 'element'.\n\n    Args:\n        lst (list of lists): The list containing sublists to be searched.\n        element: The element to search for within the sublists.\n\n    Returns:\n        int: The count of sublists containing the element.\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    list_of_lists (list of lists): The list containing sublists to search.\n    element: The element to count within the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    list_of_sublists (list of lists): The list containing sublists to be searched.\n    element (any): The element to search for within the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    return sum(element in sublist for sublist in list_of_sublists)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    list_of_lists (list of lists): The list of sublists to check.\n    element: The element to count in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    list_of_lists (list of lists): The list containing sublists to be searched.\n    element (any): The element to count within the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.9586776859504, "dps_norm": 56.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Args:\n        arr (list): The list of elements to sort.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap.\n\n    # Start with a big gap, then reduce the gap until it becomes 0.\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location.\n            arr[j] = temp\n        gap = gap // 2  # Reduce the gap for the next step.\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements that are gap apart and greater than temp\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Insert the temp element at its correct position\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift elements of the array that are greater than temp\n            # to one position ahead of their current position\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Place temp in its correct location\n            arr[j] = temp\n\n        gap //= 2  # Reduce the gap for the next iteration\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a large gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Insert the current element into its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = 1\n    # Initialize the gap using Knuth's sequence\n    while gap < n // 3:\n        gap = 3 * gap + 1\n\n    # Start with the largest gap and reduce it\n    while gap >= 1:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements that are gap apart and greater than temp\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 3  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 6}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Reduce the gap until it becomes zero.\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements of the array that are gap apart.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration.\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap = gap // 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements of arr[0..i-gap] that are greater than temp\n            # to one position ahead of their current position\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap = gap // 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a large gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Start with a big gap, then reduce the gap until it becomes 0.\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift elements of the array that are gap apart.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location.\n            arr[j] = temp\n\n        gap //= 2  # Reduce the gap for the next iteration.\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap = gap // 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Start with a big gap, then reduce the gap until it becomes 0.\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location.\n            arr[j] = temp\n        gap = gap // 2  # Reduce the gap for the next iteration.\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a large gap, then reduce the gap\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Perform a gapped insertion sort\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap.\n\n    # Start with a big gap, then reduce the gap until it becomes 0.\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element.\n\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 74.68085106382978, "dps_norm": 72.0, "pass@1": 80.0, "profiled": [{"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if the entered number is greater than all elements in the given array.\n\n    Args:\n        arr (list of numbers): The array of numbers to compare against.\n        num (number): The number to check.\n\n    Returns:\n        bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    # Use the built-in all() function for efficiency\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int/float): The array of numbers to compare.\n    num (int/float): The number to compare against the array elements.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if 'num' is greater than all elements in 'arr'.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare.\n\n    Returns:\n    bool: True if 'num' is greater than all elements in 'arr', False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the array elements.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the array elements.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n\n    Example:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int): The array of integers to compare against.\n    num (int): The number to compare.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int/float): The array of numbers to compare against.\n    num (int/float): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    Parameters:\n    arr (list): List of numbers.\n    num (int or float): The number to compare.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    Args:\n        arr (list of int): The array of integers to compare against.\n        num (int): The number to check.\n\n    Returns:\n        bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    Args:\n        arr (list): List of numbers.\n        num (int or float): Number to compare.\n\n    Returns:\n        bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the array elements.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n        arr (list of int/float): The list of numbers to compare.\n        num (int/float): The number to check against the array elements.\n\n    Returns:\n        bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    if not arr:  # If the array is empty, decide how to handle\n        return True  # Assuming True, as there are no elements to compare\n\n    return num > max(arr)", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if 'num' is greater than all elements in 'arr'.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the list elements.\n\n    Returns:\n    bool: True if 'num' is greater than all elements in 'arr', False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    Parameters:\n    arr (list of int/float): The array of numbers to compare against.\n    num (int/float): The number to compare.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the array elements.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    Parameters:\n    arr (list of int/float): The array of numbers to compare against.\n    num (int/float): The number to compare.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if `num` is greater than all elements in `arr`.\n\n    Parameters:\n    arr (list): List of integers.\n    num (int): The number to compare.\n\n    Returns:\n    bool: True if `num` is greater than all elements in `arr`, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    :param arr: List of integers.\n    :param num: Integer to compare.\n    :return: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if 'num' is greater than all elements in 'arr'.\n\n    Parameters:\n    arr (list of numbers): The array to compare against.\n    num (number): The number to compare.\n\n    Returns:\n    bool: True if 'num' is greater than all elements in 'arr', False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    :param arr: List of numbers\n    :param num: Number to compare\n    :return: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": 98.52941176470588, "dps_norm": 96.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters at odd indices.\n    \"\"\"\n    return ''.join([char for idx, char in enumerate(s) if idx % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A string containing characters from even indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at odd positions in a string.\n    Positions are 1-based.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The string with characters at odd positions removed.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at odd indices from the input string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A string containing characters from the odd indices of the input.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string containing characters from even indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"Remove characters at even indices, keeping characters at odd indices.\"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at even indices (0-based) from the string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from odd indices of the input.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at even indices (0-based) from the string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from odd indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string containing only the characters from odd indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters from the string that are at odd indices.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string with characters at odd positions removed.\n    \"\"\"\n    # Slicing the string to get characters at odd indices (1, 3, 5, ...)\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at even indices, keeping characters at odd indices.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: A string containing only the characters at odd indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at odd positions from the string.\n    Positions are 1-based, so character at position 1 is the first character.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: A new string with characters at odd positions removed.\n    \"\"\"\n    # Slice the string starting from index 1, taking every second character\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd positions in the string (1-based indexing).\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        str: A new string with characters at odd positions removed.\n    \n    Example:\n        remove_odd(\"python\")  # Returns \"yhn\"\n    \"\"\"\n    # In 0-based indexing, odd positions are at even indices.\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at even indices (0, 2, 4, ...) from the string s.\n    Keeps characters at odd indices (1, 3, 5, ...).\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing only the characters at odd indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string containing characters from even indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Remove characters at odd positions (1-based indexing) from the string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd positions removed.\n    \"\"\"\n    # Using list slicing to get characters at odd indices (0-based)\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from odd indices of the input.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"Remove characters at odd indices from the input string.\"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd positions from the input string.\n    Positions are considered starting from 1.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: A new string with characters at odd positions removed.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at even indices from the input string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: A string containing characters from odd indices of the input string.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 99.60591133004927, "dps_norm": 96.0, "pass@1": 44.0, "profiled": [{"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in `lst` within the tuple `tup`.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    count = Counter(tup)\n    return sum(count[element] for element in lst)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Count the total number of occurrences of all elements in lst within the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search in.\n    lst (list): The list of elements to count.\n\n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    element_counts = Counter(tup)\n    return sum(element_counts[element] for element in lst)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Count the total number of occurrences of elements in lst within the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    counter = Counter(tup)\n    return sum(counter[element] for element in lst if element in counter)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in `lst` within the tuple `tup`.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    return sum(tup.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the total number of occurrences of all elements in `lst` within the tuple `tup`.\n\n    Parameters:\n    tup (tuple): The tuple to search through.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of all specified elements in the tuple.\n    \"\"\"\n    from collections import Counter\n    counter = Counter(tup)\n    return sum(counter[element] for element in lst if element in counter)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements in `lst` within the tuple `tup`.\n    \n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n    \n    Returns:\n    int: The total number of occurrences of elements from `lst` in `tup`.\n    \n    Example:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n    3\n    \"\"\"\n    count = 0\n    counter = Counter(tup)\n    for item in lst:\n        count += counter.get(item, 0)\n    return count", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tpl, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in `lst` within the tuple `tpl`.\n\n    Args:\n        tpl (tuple): The tuple to search within.\n        lst (list): The list of elements to count in the tuple.\n\n    Returns:\n        int: The total number of occurrences of the specified elements.\n    \"\"\"\n    element_counts = Counter(tpl)\n    return sum(element_counts[element] for element in lst if element in element_counts)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total occurrences of all elements in lst within the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of all specified elements in the tuple.\n    \"\"\"\n    counter = Counter(tup)\n    return sum(counter[element] for element in lst if element in counter)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of elements in lst within the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of all specified elements in the tuple.\n    \"\"\"\n    counter = Counter(tup)\n    return sum(counter[element] for element in lst)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(data_tuple, elements_list):\n    \"\"\"\n    Counts the total occurrences of specified elements in a tuple.\n\n    Parameters:\n    data_tuple (tuple): The tuple to search within.\n    elements_list (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total number of occurrences of the specified elements.\n    \"\"\"\n    # Create a Counter object to count occurrences of each element in the tuple\n    counts = Counter(data_tuple)\n    \n    # Sum the counts for each element in the list\n    total = sum(counts[element] for element in elements_list)\n    \n    return total", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(data_tuple, elements_list):\n    \"\"\"\n    Counts the total occurrences of specified elements in a tuple.\n\n    Parameters:\n    data_tuple (tuple): The tuple to search within.\n    elements_list (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: Total number of occurrences of the specified elements.\n    \"\"\"\n    counts = Counter(data_tuple)\n    return sum(counts[element] for element in elements_list if element in counts)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in lst within the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of all specified elements in the tuple.\n    \"\"\"\n    counts = Counter(tup)\n    return sum(counts[element] for element in lst)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total occurrences of all elements in lst within the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of all specified elements in the tuple.\n    \"\"\"\n    counts = Counter(tup)\n    return sum(counts[element] for element in lst)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total occurrences of all elements in `lst` within the tuple `tup`.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of all specified elements.\n    \"\"\"\n    counts = Counter(tup)\n    return sum(counts[element] for element in lst)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Count the total number of occurrences of all elements in lst within the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple containing elements to be counted.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of all specified elements in the tuple.\n    \"\"\"\n    counter = Counter(tup)\n    return sum(counter.get(item, 0) for item in lst)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tpl, lst):\n    \"\"\"\n    Count the occurrence of all elements in lst within the tuple tpl.\n\n    Args:\n        tpl (tuple): The tuple to search within.\n        lst (list): The list of elements to count in the tuple.\n\n    Returns:\n        int: The total count of all specified elements in the tuple.\n    \"\"\"\n    element_counts = Counter(tpl)\n    return sum(element_counts[element] for element in lst)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    count = Counter(tup)\n    return sum(count.get(item, 0) for item in lst)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tpl, lst):\n    \"\"\"\n    Counts the total occurrences of all elements in lst within the tuple tpl.\n\n    Parameters:\n    tpl (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of all specified elements in the tuple.\n    \"\"\"\n    counts = Counter(tpl)\n    return sum(counts[element] for element in lst)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tpl, lst):\n    \"\"\"\n    Count the total number of occurrences of all elements in lst within the tuple tpl.\n\n    Parameters:\n    tpl (tuple): The tuple containing elements.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    return sum(tpl.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in 'lst' within 'tup'.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of all specified elements in the tuple.\n    \"\"\"\n    counter = Counter(tup)\n    return sum(counter[element] for element in lst)", "matching_cluster_idx": 4}]}, "Mbpp/451": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        string_list (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Parameters:\n    string_list (list of str): The list of strings to reverse.\n\n    Returns:\n    list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        str_list (list of str): The list of strings to be reversed.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n\n    Args:\n        string_list (list of str): The list of strings to be reversed.\n\n    Returns:\n        list of str: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    Reverse each string in the given list.\n\n    Parameters:\n    lst (list of str): The list of strings to reverse.\n\n    Returns:\n    list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list.\n\n    Parameters:\n    strings (list of str): The list of strings to reverse.\n\n    Returns:\n    list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        strings (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Parameters:\n    strings (list of str): The list of strings to reverse.\n\n    Returns:\n    list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n        strings (list of str): The list of strings to be reversed.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list.\n\n    Args:\n        strings (list of str): List of strings to be reversed.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    Reverses each string in the given list.\n\n    :param lst: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n        strings (list of str): The list of strings to be reversed.\n\n    Returns:\n        list of str: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        strings (list of str): The list of strings to be reversed.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        strings (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        string_list (list of str): The list of strings to be reversed.\n\n    Returns:\n        list of str: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        string_list (list of str): The list of strings to be reversed.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        strings (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        string_list (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n    \n    Args:\n        strings (list of str): The list of strings to reverse.\n        \n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        strings (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 45.96153846153846, "dps_norm": 79.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): A list containing sublists.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Returns a list containing the first element of each sublist.\n\n    Parameters:\n    list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n    list: A list of the first elements from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns the first element of each sublist in the given list of lists.\n\n    Parameters:\n    lst (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    \"\"\"\n    Returns the first element of each sublist in the given list of lists.\n\n    Parameters:\n    lists (List[List[Any]]): A list containing sublists.\n\n    Returns:\n    List[Any]: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_sublists):\n    \"\"\"\n    Extracts the first element from each sublist in the given list of sublists.\n\n    Parameters:\n    list_of_sublists (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \n    Raises:\n    ValueError: If any sublist is empty.\n    \"\"\"\n    first_elements = []\n    for index, sublist in enumerate(list_of_sublists):\n        if not sublist:\n            raise ValueError(f\"Sublist at index {index} is empty.\")\n        first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 2}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns a list containing the first element of each sublist in the input list.\n    \n    Parameters:\n    lst (List[List[Any]]): A list of sublists.\n    \n    Returns:\n    List[Any]: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns a list containing the first element of each sublist in the input list.\n\n    Parameters:\n    lst (list of lists): The input list containing sublists.\n\n    Returns:\n    list: A list containing the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist in the given list of lists.\n\n    Parameters:\n    lst (list of lists): The list containing sublists from which to extract elements.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns the first element of each sublist in the given list.\n\n    Args:\n        lst (list of lists): A list where each element is a sublist.\n\n    Returns:\n        list: A list containing the first element from each sublist.\n\n    Example:\n        >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n        [1, 3, 6]\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns the first element of each sublist in the provided list.\n    \n    Args:\n        lst (List[List[Any]]): A list of sublists.\n        \n    Returns:\n        List[Any]: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns the first element of each sublist in the provided list.\n\n    Args:\n        lst (List[List[Any]]): A list of sublists.\n\n    Returns:\n        List[Any]: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns a list containing the first element of each sublist in the input list.\n\n    Parameters:\n    lst (List[List[Any]]): A list of sublists.\n\n    Returns:\n    List[Any]: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    \"\"\"\n    Returns a list containing the first element of each sublist in `lists`.\n\n    Args:\n        lists (List[List[Any]]): A list of sublists.\n\n    Returns:\n        List[Any]: A list of the first elements from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Return a list containing the first element of each sublist.\n    \n    Parameters:\n    list_of_lists (list of lists): A list where each element is a sublist.\n    \n    Returns:\n    list: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns a list containing the first element of each sublist in the input list.\n    \n    Parameters:\n    lst (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns the first element of each sublist in the given list of lists.\n    \n    Args:\n    lst (List[List[Any]]): A list of sublists.\n    \n    Returns:\n    List[Any]: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Returns a list containing the first element of each sublist.\n    \n    Parameters:\n    list_of_lists (List[List[Any]]): A list of sublists.\n    \n    Returns:\n    List[Any]: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns a list containing the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    \"\"\"\n    Returns the first element of each sublist in the given list of lists.\n\n    Parameters:\n    lists (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def replace_char(s: str, old: str, new: str) -> str:\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n\n    :param s: The original string.\n    :param old: The character to be replaced.\n    :param new: The character to replace with.\n    :return: A new string with the replacements made.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n    \n    Args:\n        s (str): The original string.\n        old (str): The character to replace.\n        new (str): The character to replace with.\n        \n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old: str, new: str) -> str:\n    \"\"\"\n    Replace all occurrences of `old` character with `new` character in the string `s`.\n    \n    Args:\n    - s (str): The original string.\n    - old (str): The character to be replaced.\n    - new (str): The character to replace with.\n    \n    Returns:\n    - str: The modified string with characters replaced.\n    \n    Examples:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old_char: str, new_char: str) -> str:\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n\n    Args:\n        s (str): The original string.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n\n    Args:\n        s (str): The original string.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n    \n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n        \n    Returns:\n        str: The modified string with 'old' characters replaced by 'new' characters.\n    \n    Example:\n        replace_char(\"polygon\", 'y', 'l')  # returns \"pollgon\"\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the string s.\n\n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with replacements.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old: str, new: str) -> str:\n    \"\"\"\n    Replace all occurrences of `old` character with `new` character in the string `s`.\n\n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n\n    Parameters:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n\n    Parameters:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old: str, new: str) -> str:\n    \"\"\"\n    Replaces all occurrences of `old` character with `new` character in the string `s`.\n\n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The replacement character.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of the 'old' character with the 'new' character in the string 's'.\n\n    Parameters:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of a character in a string with a new character.\n\n    Parameters:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string.\")\n    if not isinstance(old, str) or not isinstance(new, str):\n        raise ValueError(\"The 'old' and 'new' parameters must be single characters.\")\n    if len(old) != 1 or len(new) != 1:\n        raise ValueError(\"The 'old' and 'new' parameters must be single characters.\")\n\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replaces all occurrences of the character 'old' with the character 'new' in the string 's'.\n    \n    Parameters:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n    \n    Returns:\n    str: The modified string with replacements.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old: str, new: str) -> str:\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n\n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n\n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"The first argument must be a string.\")\n    if not isinstance(old_char, str) or not isinstance(new_char, str):\n        raise TypeError(\"The characters to replace must be strings.\")\n    if len(old_char) != 1 or len(new_char) != 1:\n        raise ValueError(\"Both old_char and new_char must be single characters.\")\n\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of a character in a string with a new character.\n\n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old: str, new: str) -> str:\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n\n    Parameters:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n\n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old: str, new: str) -> str:\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n\n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 67.81879194630872, "dps_norm": 82.5, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of numbers): The input array containing numeric values.\n\n    Returns:\n    number: The sum of the smallest and largest numbers in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    \n    smallest = arr[0]\n    largest = arr[0]\n    \n    for num in arr[1:]:\n        if num < smallest:\n            smallest = num\n        if num > largest:\n            largest = num\n            \n    return smallest + largest", "matching_cluster_idx": 2}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list of int/float): The input array containing numeric values.\n\n    Returns:\n    int/float: The sum of the smallest and largest values in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    \n    min_val = max_val = arr[0]\n    for num in arr[1:]:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n    \n    Parameters:\n    arr (list of int/float): The input array of numbers.\n    \n    Returns:\n    int/float: Sum of the largest and smallest numbers in the array.\n    \n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array must not be empty\")\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        raise ValueError(\"Array must not be empty\")\n    min_val = max_val = arr[0]\n    for num in arr[1:]:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of int): The list of integers.\n\n    Returns:\n    int: Sum of the smallest and largest integers in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array must not be empty\")\n\n    smallest = arr[0]\n    largest = arr[0]\n\n    for num in arr[1:]:\n        if num < smallest:\n            smallest = num\n        if num > largest:\n            largest = num\n\n    return smallest + largest", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n    \n    Parameters:\n    arr (list of numbers): The list of numbers to evaluate.\n    \n    Returns:\n    int or float: Sum of the smallest and largest numbers in the array.\n    \n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array is empty.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of int/float): The input array containing numerical values.\n\n    Returns:\n    int/float: Sum of the smallest and largest values in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n\n    # Initialize min and max with the first element\n    min_val = max_val = arr[0]\n\n    # Iterate through the array to find min and max\n    for num in arr[1:]:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the smallest and largest numbers in the array.\n\n    Args:\n        arr (list of int/float): The input array.\n\n    Returns:\n        int/float: Sum of the smallest and largest numbers.\n\n    Raises:\n        ValueError: If the array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of int/float): The input array containing numeric values.\n\n    Returns:\n    int/float: The sum of the largest and smallest values in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of int/float): The input array containing numerical values.\n\n    Returns:\n    int/float: Sum of the largest and smallest values in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array must contain at least one element.\")\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the smallest and largest values in the array.\n    \n    Parameters:\n    arr (list of int/float): The input array.\n\n    Returns:\n    int/float: The sum of the smallest and largest values.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array must not be empty.\")\n    \n    min_val = max_val = arr[0]\n    for num in arr[1:]:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the smallest and largest numbers in the array.\n\n    Parameters:\n    arr (list of int/float): The input array containing numerical values.\n\n    Returns:\n    int/float: Sum of the smallest and largest numbers in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array cannot be empty.\")\n    \n    smallest = arr[0]\n    largest = arr[0]\n    \n    for num in arr[1:]:\n        if num < smallest:\n            smallest = num\n        if num > largest:\n            largest = num\n    \n    return smallest + largest", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the smallest and largest numbers in the given array.\n\n    Parameters:\n    arr (list of numbers): The input array containing numeric values.\n\n    Returns:\n    int or float: The sum of the smallest and largest numbers.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the smallest and largest numbers in the array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: Sum of the smallest and largest integers in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array must not be empty.\")\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the smallest and largest values in the given array.\n\n    Parameters:\n    arr (list of int/float): The input array containing numerical values.\n\n    Returns:\n    int/float: Sum of the smallest and largest values.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array must not be empty\")\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of int/float): The input array.\n\n    Returns:\n    int/float: Sum of the largest and smallest values.\n\n    Raises:\n    ValueError: If the array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array is empty\")\n    largest = smallest = arr[0]\n    for num in arr[1:]:\n        if num > largest:\n            largest = num\n        if num < smallest:\n            smallest = num\n    return largest + smallest", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest numbers in the array.\n    \n    Parameters:\n    arr (list): A list of numbers.\n    \n    Returns:\n    int/float: Sum of the largest and smallest numbers.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of int/float): The input array containing numerical values.\n\n    Returns:\n    int/float: Sum of the largest and smallest values.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array must not be empty\")\n\n    min_val = max_val = arr[0]\n    for num in arr[1:]:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of numbers): The input list of numbers.\n\n    Returns:\n    int or float: The sum of the largest and smallest number in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array must not be empty.\")\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of int/float): The input array containing numeric values.\n\n    Returns:\n    int/float: Sum of the smallest and largest values in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    \n    min_val = max_val = arr[0]\n    for num in arr[1:]:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    return min_val + max_val", "matching_cluster_idx": 3}]}, "Mbpp/477": {"dps": 95.74626865671642, "dps_norm": 97.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(s):\n    \"\"\"\n    Converts the input string to lowercase.\n\n    Args:\n        s (str): The string to convert.\n\n    Returns:\n        str: The lowercase version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        s (str): The string to convert.\n\n    Returns:\n        str: The converted lower case string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The string to convert.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lowercase.\n\n    Args:\n        s (str): The input string to convert.\n\n    Returns:\n        str: The lowercase version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Converts the input string to lowercase.\n\n    Args:\n        s (str): The string to convert.\n\n    Returns:\n        str: The lowercase version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        s (str): The input string to convert.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Args:\n        s (str): The input string to be converted.\n        \n    Returns:\n        str: The lowercased version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Args:\n    s (str): The input string to be converted.\n    \n    Returns:\n    str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the input string to lower case.\n\n    Parameters:\n    s (str): The string to convert.\n\n    Returns:\n    str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"Convert the given string to lower case.\"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case without using the built-in lower() method.\n\n    Args:\n        s (str): The input string to convert.\n\n    Returns:\n        str: The converted lower-case string.\n    \"\"\"\n    result = []\n    for char in s:\n        # Check if character is uppercase ASCII letter\n        if 'A' <= char <= 'Z':\n            # Convert to lowercase by adding the ASCII difference\n            lower_char = chr(ord(char) + 32)\n            result.append(lower_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The lower-cased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 85.24590163934427, "dps_norm": 81.81818181818181, "pass@1": 90.0, "profiled": [{"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing values within double quotes.\n\n    Returns:\n        list: A list of extracted string values without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all substrings within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the surrounding quotes.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n    \n    Args:\n        s (str): The input string containing values within double quotes.\n        \n    Returns:\n        list: A list of extracted string values without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Parameters:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n    \n    Parameters:\n    s (str): The input string containing values enclosed in double quotes.\n    \n    Returns:\n    list: A list of extracted values without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing values enclosed in double quotes.\n\n    Returns:\n        list: A list of extracted values without the quotation marks.\n    \"\"\"\n    # Use regex to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the input string.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of extracted string values without the quotes.\n    \"\"\"\n    # Use regular expressions to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted strings without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of strings extracted from within the quotes.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Parameters:\n    s (str): The input string containing quoted values.\n\n    Returns:\n    list: A list of extracted values without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing values within double quotes.\n\n    Returns:\n        list: A list of extracted string values without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing values within quotes.\n\n    Returns:\n        list: A list of extracted string values without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all substrings within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Parameters:\n    s (str): The string containing quoted values.\n\n    Returns:\n    list: A list of strings extracted from within the quotation marks.\n    \"\"\"\n    # Use regular expression to find all substrings within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing values within quotation marks.\n\n    Returns:\n        list: A list of extracted values without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all substrings within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substring values without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    # Regular expression pattern to match content within double quotes\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a string.\n\n    Args:\n        s (str): The input string containing values in quotation marks.\n\n    Returns:\n        List[str]: A list of extracted values without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 95.55555555555556, "dps_norm": 87.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list and return numbers that appear exactly once.\n    \n    Args:\n        nums (list): The list of numbers to process.\n        \n    Returns:\n        list: A list containing numbers that appear only once in the input list.\n    \"\"\"\n    counts = Counter(nums)\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in the list.\n\n    Parameters:\n    nums (list): The input list of numbers.\n\n    Returns:\n    list: A list containing numbers that appear exactly once.\n    \"\"\"\n    count = Counter(nums)\n    unique_nums = [num for num in nums if count[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list and return numbers that appear only once.\n\n    Args:\n    nums (list): The input list of numbers.\n\n    Returns:\n    list: A list containing numbers that appear exactly once in the input list.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(nums)\n    unique_nums = [num for num, count in counts.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef two_unique_nums(lst):\n    \"\"\"\n    Remove duplicate numbers from the given list and return only the unique numbers.\n    \n    Args:\n        lst (list): A list of integers.\n        \n    Returns:\n        list: A list containing numbers that appear exactly once in the input list.\n    \"\"\"\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the given list and return a list of unique numbers.\n    \n    Args:\n        nums (List[int]): The input list of integers.\n        \n    Returns:\n        List[int]: A list containing numbers that appear exactly once in the input list.\n    \"\"\"\n    from collections import Counter\n    count = Counter(nums)\n    unique_nums = [num for num in nums if count[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list and return numbers that appear exactly once.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list of unique integers that appear only once in the input list.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(nums)\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    \"\"\"\n    Removes duplicate numbers from the given list and returns a list of numbers that appear exactly once.\n    \n    Parameters:\n    lst (list): The input list of numbers.\n    \n    Returns:\n    list: A list containing numbers that appear only once in the input list.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(lst)\n    unique_nums = [num for num in lst if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove numbers that appear more than once in the list.\n\n    Args:\n        nums (list): The input list of numbers.\n\n    Returns:\n        list: A list containing only the numbers that appear exactly once.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(nums)\n    unique = [num for num in nums if counts[num] == 1]\n    return unique", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list and return only the unique numbers.\n\n    Args:\n        nums (List[int]): The input list of integers.\n\n    Returns:\n        List[int]: A list containing only the numbers that appear exactly once in the input list.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(nums)\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(lst):\n    \"\"\"\n    Removes duplicate numbers from the given list and returns numbers that appear exactly once.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        list: A list containing numbers that appear only once in the input list.\n    \"\"\"\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list and return a list of unique numbers.\n\n    Args:\n        nums (list): A list of integers which may contain duplicates.\n\n    Returns:\n        list: A list containing only the numbers that appear exactly once in the input list.\n    \"\"\"\n    from collections import Counter\n\n    # Count the frequency of each number in the list\n    counts = Counter(nums)\n\n    # Extract numbers that appear exactly once, preserving the original order\n    unique_nums = [num for num in nums if counts[num] == 1]\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list and return numbers that appear exactly once.\n\n    Args:\n        nums (List[int]): The input list of numbers.\n\n    Returns:\n        List[int]: A list of unique numbers.\n    \"\"\"\n    count = Counter(nums)\n    return [num for num, cnt in count.items() if cnt == 1]", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list and return the numbers that appear exactly once.\n    \n    Parameters:\n    nums (list): The list of integers to process.\n    \n    Returns:\n    list: A list of integers that appear only once in the input list.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list, returning only numbers that appear exactly once.\n    \n    Parameters:\n    nums (List[int]): The list of integers to process.\n    \n    Returns:\n    List[int]: A list containing only the unique numbers from the input list.\n    \"\"\"\n    count = Counter(nums)\n    return [num for num in nums if count[num] == 1]", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from the list and returns the unique numbers.\n    \n    Args:\n        nums (list): A list of integers.\n        \n    Returns:\n        list: A list containing numbers that appear exactly once in the input list.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(lst):\n    \"\"\"\n    Remove duplicate numbers from the list and return numbers that appear exactly once.\n\n    Args:\n        lst (list): The input list of numbers.\n\n    Returns:\n        list: A list containing numbers that are unique in the input list.\n    \"\"\"\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Remove numbers that appear more than once in the list.\n\n    Args:\n        nums (list): List of integers.\n\n    Returns:\n        list: A list containing only the unique integers.\n    \"\"\"\n    counts = Counter(nums)\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list and return numbers that appear exactly once.\n    \n    Args:\n        nums (list): List of integers.\n\n    Returns:\n        list: A list of integers that appear exactly once in the input list.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove numbers that appear more than once in the list.\n\n    Args:\n        nums (List[int]): The input list of integers.\n\n    Returns:\n        List[int]: A list containing only the numbers that appear exactly once.\n    \"\"\"\n    from collections import Counter\n\n    count = Counter(nums)\n    # Preserve the order of first occurrence\n    unique_nums = [num for num in nums if count[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(lst):\n    \"\"\"\n    Remove duplicate numbers from the given list and return numbers that appear exactly once.\n    \n    Args:\n    lst (list): A list of integers.\n    \n    Returns:\n    list: A list containing numbers that appear only once in the input list.\n    \n    Example:\n    >>> two_unique_nums([1,2,3,2,3,4,5])\n    [1, 4, 5]\n    \"\"\"\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 96.82539682539682, "dps_norm": 72.72727272727273, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): First list to interleave.\n        list2 (list): Second list to interleave.\n        list3 (list): Third list to interleave.\n\n    Returns:\n        list: A new list containing elements from all three lists interleaved.\n    \"\"\"\n    return [element for trio in zip(list1, list2, list3) for element in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: The interleaved flat list.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleave three lists of the same length into a single flat list.\"\"\"\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n    \n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n    \n    Returns:\n        list: The interleaved flat list.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A new list containing elements from list1, list2, and list3 interleaved.\n    \"\"\"\n    return [element for trio in zip(list1, list2, list3) for element in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: The interleaved flat list.\n    \"\"\"\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Write a function to interleave 3 lists of the same length into a single flat list.\n    assert interleave_lists([1,2,3,4,5,6,7],\n                           [10,20,30,40,50,60,70],\n                           [100,200,300,400,500,600,700]) == [\n                               1, 10, 100, 2, 20, 200, 3, 30, 300,\n                               4, 40, 400, 5, 50, 500, 6, 60, 600,\n                               7, 70, 700\n                           ]\n    \"\"\"\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A flat list containing elements from the three lists interleaved.\n    \"\"\"\n    return [element for triplet in zip(list1, list2, list3) for element in triplet]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A new list containing elements from the three lists interleaved.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n    \n    Returns:\n        list: A new list containing elements from all three lists interleaved.\n    \"\"\"\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A flat list containing elements from the three lists interleaved.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): First list.\n        list2 (list): Second list.\n        list3 (list): Third list.\n\n    Returns:\n        list: Interleaved flat list.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A new list containing elements from all three lists interleaved.\n    \"\"\"\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): First list to interleave.\n        list2 (list): Second list to interleave.\n        list3 (list): Third list to interleave.\n\n    Returns:\n        list: A flat list containing elements from the three lists interleaved.\n    \"\"\"\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Write a function to interleave 3 lists of the same length into a single flat list.\n    assert interleave_lists([1,2,3,4,5,6,7],[10,20,30,40,50,60,70],[100,200,300,400,500,600,700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    \"\"\"\n    return [x for trio in zip(list1, list2, list3) for x in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Write a function to interleave 3 lists of the same length into a single flat list.\n    assert interleave_lists([1,2,3,4,5,6,7],\n                           [10,20,30,40,50,60,70],\n                           [100,200,300,400,500,600,700]) == [\n        1, 10, 100, 2, 20, 200, 3, 30, 300, \n        4, 40, 400, 5, 50, 500, 6, 60, 600, \n        7, 70, 700\n    ]\n    \"\"\"\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: The interleaved flat list.\n    \"\"\"\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        lst1 (list): First list.\n        lst2 (list): Second list.\n        lst3 (list): Third list.\n\n    Returns:\n        list: Interleaved flat list.\n    \"\"\"\n    return [item for trio in zip(lst1, lst2, lst3) for item in trio]", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list after splitting and appending.\n    \"\"\"\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the range of the list length.\")\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list with the first part moved to the end.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The split index must be an integer.\")\n    if n < 0 or n > len(lst):\n        raise ValueError(\"The split index must be within the bounds of the list.\")\n\n    # Split the list and rearrange\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and rearranging.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be within the range of the list indices.\")\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and reordering.\n    \"\"\"\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be within the range of the list indices.\")\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The split index must be an integer.\")\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be between 0 and the length of the list.\")\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and rearranging.\n    \"\"\"\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the range of the list indices.\")\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and rearranging.\n    \"\"\"\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the range of the list indices.\")\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list.\n    \"\"\"\n    # Ensure n is within the bounds of the list\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the range of the list length.\")\n    \n    # Split the list and rearrange\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"First argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"Second argument must be an integer.\")\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be within the range of the list indices.\")\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"First argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"Second argument must be an integer.\")\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be between 0 and the length of the list.\")\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list with the first part moved to the end.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be within the range of the list indices.\")\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list `arr` at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"First argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"Second argument must be an integer.\")\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be between 0 and the length of the list.\")\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list after splitting and appending.\n    \"\"\"\n    # Validate the index\n    if not isinstance(n, int):\n        raise TypeError(\"The split index n must be an integer.\")\n    if n < 0 or n > len(lst):\n        raise ValueError(\"The split index n is out of bounds.\")\n    \n    # Perform the split and rearrangement\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and rearranging.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if n < 0 or n > len(lst):\n        raise ValueError(\"The split index n must be within the list bounds.\")\n    \n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list after splitting and appending.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the range of the list indices.\")\n\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list after splitting.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if n < 0 or n > len(lst):\n        raise ValueError(\"The index n must be within the range of the list length.\")\n\n    # Split the list into two parts\n    first_part = lst[:n]\n    second_part = lst[n:]\n    \n    # Concatenate the second part with the first part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list.\n    \"\"\"\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be within the range of the list indices.\")\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and rearrangement.\n    \"\"\"\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the range of the list length.\")\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The index at which to split the list.\n\n    Returns:\n        list: The modified list after splitting and rearranging.\n\n    Example:\n        >>> split_Arr([12, 10, 5, 6, 52, 36], 2)\n        [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be between 0 and the length of the list.\")\n    \n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(a_list):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Parameters:\n    a_list (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(a_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Parameters:\n    lst (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The resulting tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Parameters:\n    input_list (list): The list to be converted.\n    \n    Returns:\n    tuple: The resulting tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The resulting tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The resulting tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a list to a tuple.\n    \n    Parameters:\n    input_list (list): The list to convert.\n    \n    Returns:\n    tuple: The resulting tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 77.06422018348624, "dps_norm": 93.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the given list.\n    \n    Args:\n        lst (list of int/float): The list of numbers.\n        \n    Returns:\n        int/float: The difference between the largest and smallest numbers.\n        \n    Raises:\n        ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"List must not be empty.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list): A list of numerical values.\n    \n    Returns:\n    int or float: The difference between the maximum and minimum values.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        raise ValueError(\"List must contain at least one element.\")\n    \n    min_val = max_val = lst[0]\n    for num in lst[1:]:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    return max_val - min_val", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the given list.\n    \n    Parameters:\n    nums (list of int/float): The list of numbers to evaluate.\n    \n    Returns:\n    int/float: The difference between the maximum and minimum value.\n    \n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list is empty\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest number in the list.\n    \n    Parameters:\n    nums (list): A list of integers or floats.\n    \n    Returns:\n    int or float: The difference between the largest and smallest numbers.\n    \n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list is empty.\")\n    \n    max_num = nums[0]\n    min_num = nums[0]\n    \n    for num in nums[1:]:\n        if num > max_num:\n            max_num = num\n        if num < min_num:\n            min_num = num\n    \n    return max_num - min_num", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest numbers in the list.\n    \n    Parameters:\n    nums (list of int/float): The list of numbers to evaluate.\n    \n    Returns:\n    int/float: The difference between the maximum and minimum values.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list must contain at least one number.\")\n    \n    min_val = max_val = nums[0]\n    \n    for num in nums[1:]:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    \n    return max_val - min_val", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list of numbers): The list of numbers to evaluate.\n    \n    Returns:\n    int or float: The difference between the maximum and minimum values.\n    \n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list must contain at least one element.\")\n    \n    min_val, max_val = lst[0], lst[0]\n    \n    for num in lst[1:]:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    \n    return max_val - min_val", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The difference between the maximum and minimum values.\n    \n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list must contain at least one element.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list of numbers): The list containing numerical values.\n    \n    Returns:\n    int or float: The difference between the maximum and minimum numbers in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list must contain at least one number.\")\n    \n    maximum = lst[0]\n    minimum = lst[0]\n    \n    for number in lst[1:]:\n        if number > maximum:\n            maximum = number\n        if number < minimum:\n            minimum = number\n    \n    return maximum - minimum", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    If the list is empty, returns 0.\n    \"\"\"\n    if not nums:\n        return 0  # You can also choose to raise an exception if preferred\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n\n    Parameters:\n    nums (list of int/float): The list of numbers.\n\n    Returns:\n    int/float: The difference between the maximum and minimum numbers.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list is empty.\")\n    \n    # Initialize max and min with the first element\n    maximum = minimum = nums[0]\n    \n    # Iterate through the list to find the max and min\n    for num in nums[1:]:\n        if num > maximum:\n            maximum = num\n        if num < minimum:\n            minimum = num\n    \n    return maximum - minimum", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest numbers in the list.\n    \n    Parameters:\n    lst (list of int): The list of integers to evaluate.\n    \n    Returns:\n    int: The difference between the maximum and minimum values in the list.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    maximum = lst[0]\n    minimum = lst[0]\n    \n    for num in lst[1:]:\n        if num > maximum:\n            maximum = num\n        if num < minimum:\n            minimum = num\n    \n    return maximum - minimum", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list of int/float): The list of numbers to evaluate.\n    \n    Returns:\n    int/float: The difference between the largest and smallest number.\n    \n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list must contain at least one element.\")\n    \n    maximum = lst[0]\n    minimum = lst[0]\n    \n    for num in lst[1:]:\n        if num > maximum:\n            maximum = num\n        if num < minimum:\n            minimum = num\n    \n    return maximum - minimum", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Find the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list): A list of integers or floats.\n    \n    Returns:\n    int or float: The difference between the largest and smallest value.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the given list.\n\n    Parameters:\n    lst (list of int): The list of integers to evaluate.\n\n    Returns:\n    int: The difference between the maximum and minimum values.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list must contain at least one element.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list of int): The input list of integers.\n\n    Returns:\n    int: The difference between the maximum and minimum values.\n    \n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list): A list of numerical values.\n    \n    Returns:\n    int or float: The difference between the maximum and minimum values.\n    \n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list must contain at least one element.\")\n    \n    maximum = max(lst)\n    minimum = min(lst)\n    return maximum - minimum", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        raise ValueError(\"The list should not be empty.\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest numbers in the list.\n\n    Parameters:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The difference between the largest and smallest integers.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list is empty.\")\n    \n    largest = max(nums)\n    smallest = min(nums)\n    return largest - smallest", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 92.86666666666667, "dps_norm": 91.5, "pass@1": 94.0, "profiled": [{"solution": "def binomial_coefficient(n, k):\n    \"\"\"\n    Efficiently compute the binomial coefficient C(n, k)\n    \"\"\"\n    if k < 0 or k > n:\n        return 0\n    k = min(k, n - k)  # Take advantage of symmetry\n    result = 1\n    for i in range(1, k + 1):\n        result = result * (n - i + 1) // i\n    return result\ndef sum_Of_product(n):\n    \"\"\"\n    Compute the sum of the product of consecutive binomial coefficients:\n    sum_{k=0}^{n-1} C(n, k) * C(n, k+1)\n    This is equal to C(2n, n+1) based on combinatorial identities.\n    \"\"\"\n    return binomial_coefficient(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    This is equivalent to computing the binomial coefficient C(2n, n+1).\n    \n    Parameters:\n    n (int): The non-negative integer to compute the sum for.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    return comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients in the nth row of Pascal's triangle.\n\n    Args:\n    n (int): The row number in Pascal's triangle (0-indexed).\n\n    Returns:\n    int: The sum of the products of consecutive binomial coefficients.\n    \n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n    \n    # Initialize the first binomial coefficient\n    previous = 1\n    total = 0\n    \n    for k in range(1, n + 1):\n        # Calculate the current binomial coefficient based on the previous one\n        current = previous * (n - k + 1) // k\n        # Add the product of consecutive coefficients to the total\n        total += previous * current\n        # Update previous for the next iteration\n        previous = current\n    \n    return total", "matching_cluster_idx": 9}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Find the sum of the product of consecutive binomial coefficients.\n    \n    The sum is calculated as:\n        sum_{k=0}^{n-1} C(n, k) * C(n, k+1)\n    which is equal to C(2n, n+1).\n    \n    Args:\n        n (int): The non-negative integer to calculate the sum for.\n        \n    Returns:\n        int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    return math.comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    The sum is defined as:\n        sum = C(n,0)*C(n,1) + C(n,1)*C(n,2) + ... + C(n,n-1)*C(n,n)\n    \n    where C(n,k) is the binomial coefficient \"n choose k\".\n    \"\"\"\n    total = 0\n    c_k = 1  # C(n, 0)\n    for k in range(n):\n        # Compute C(n, k+1) based on C(n, k)\n        c_k1 = c_k * (n - k) // (k + 1)\n        total += c_k * c_k1\n        c_k = c_k1\n    return total", "matching_cluster_idx": 9}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Finds the sum of the product of consecutive binomial coefficients for a given n.\n    \n    The sum is calculated as:\n        C(n,0)*C(n,1) + C(n,1)*C(n,2) + ... + C(n,n-1)*C(n,n)\n    \n    This is equivalent to C(2n, n+1).\n    \n    Args:\n        n (int): The integer to compute the sum for.\n        \n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    return math.comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n (int): The number to compute binomial coefficients from 0 to n.\n\n    Returns:\n        int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    sum_p = 0\n    Cnk = 1  # C(n, 0)\n\n    for k in range(n):\n        # Compute C(n, k+1) based on C(n, k)\n        Cnk1 = Cnk * (n - k) // (k + 1)\n        # Add the product C(n, k) * C(n, k+1) to the sum\n        sum_p += Cnk * Cnk1\n        # Update C(n, k) for the next iteration\n        Cnk = Cnk1\n\n    return sum_p", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Args:\n    n (int): The non-negative integer to calculate the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total = 0\n    current = 1  # C(n, 0)\n    for k in range(n):\n        next_coeff = current * (n - k) // (k + 1)  # Compute C(n, k+1)\n        total += current * next_coeff               # Add product C(n,k) * C(n,k+1)\n        current = next_coeff                        # Update current to C(n,k+1)\n    return total", "matching_cluster_idx": 9}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n    \n    The sum is defined as:\n        sum_{k=0}^{n-1} C(n, k) * C(n, k+1)\n    \n    This sum is equal to C(2n, n+1) based on combinatorial identities.\n    \n    Parameters:\n    n (int): The non-negative integer for which the sum is calculated.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    return math.comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Args:\n    - n (int): The binomial coefficient parameter.\n    \n    Returns:\n    - int: The computed sum.\n    \n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    return sum(math.comb(n, k) * math.comb(n, k + 1) for k in range(n))", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Finds the sum of the product of consecutive binomial coefficients for a given n.\n\n    For example:\n    sum_Of_product(3) computes C(3,0)*C(3,1) + C(3,1)*C(3,2) + C(3,2)*C(3,3) = 15\n\n    Args:\n        n (int): The non-negative integer to compute the sum for.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    C_k = 1  # C(n, 0)\n    total = 0\n    for k in range(n):\n        C_k_plus1 = C_k * (n - k) // (k + 1)  # Compute C(n, k+1) based on C(n, k)\n        total += C_k * C_k_plus1\n        C_k = C_k_plus1\n    return total", "matching_cluster_idx": 9}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Find the sum of the product of consecutive binomial coefficients.\n    \n    The function calculates the sum of C(n, k) * C(n, k+1) for k from 0 to n-1,\n    which is equal to C(2n, n+1).\n    \n    Parameters:\n    n (int): The binomial coefficient parameter.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    return comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Find the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n (int): The non-negative integer to compute the sum for.\n\n    Returns:\n        int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    total = 0\n    for k in range(n):\n        total += math.comb(n, k) * math.comb(n, k + 1)\n    return total", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n\n    For example, for n=3:\n    binom(3,0)*binom(3,1) + binom(3,1)*binom(3,2) + binom(3,2)*binom(3,3) \n    = 1*3 + 3*3 + 3*1 = 15\n\n    Args:\n        n (int): The number for which to calculate the sum.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    return sum(math.comb(n, k) * math.comb(n, k + 1) for k in range(n))", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Finds the sum of the product of consecutive binomial coefficients.\n\n    sum_Of_product(n) = C(n,0)*C(n,1) + C(n,1)*C(n,2) + ... + C(n,n-1)*C(n,n)\n\n    This sum is equal to C(2n, n+1).\n\n    Args:\n        n (int): The binomial coefficient parameter.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n    return comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Args:\n    n (int): The number to determine the binomial coefficients.\n    \n    Returns:\n    int: The sum of the products of consecutive binomial coefficients.\n    \n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    # Generate all binomial coefficients C(n, k) for k from 0 to n\n    binomials = [math.comb(n, k) for k in range(n + 1)]\n    \n    # Calculate the sum of products of consecutive binomial coefficients\n    total = 0\n    for k in range(n):\n        product = binomials[k] * binomials[k + 1]\n        total += product\n    return total", "matching_cluster_idx": 7}, {"solution": "def sum_Of_product(n):\n    from math import comb\n\n    # Generate all binomial coefficients for given n\n    coefficients = [comb(n, k) for k in range(n + 1)]\n    \n    # Calculate the sum of the product of consecutive coefficients\n    total = sum(coefficients[i] * coefficients[i + 1] for i in range(n))\n    \n    return total", "matching_cluster_idx": 8}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Find the sum of the product of consecutive binomial coefficients for a given n.\n\n    sum_Of_product(n) = C(n,0)*C(n,1) + C(n,1)*C(n,2) + ... + C(n,n-1)*C(n,n)\n                      = C(2n, n+1)\n    \n    Args:\n        n (int): The integer for which the sum is to be calculated.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    return math.comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Finds the sum of the product of consecutive binomial coefficients.\n\n    The sum is calculated as:\n        sum(C(n, k) * C(n, k + 1) for k in range(n))\n    which is equal to C(2n, n + 1).\n\n    Args:\n        n (int): The non-negative integer to compute the sum for.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \n    Example:\n        >>> sum_Of_product(3)\n        15\n    \"\"\"\n    return math.comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    The sum of C(n, k) * C(n, k+1) for k from 0 to n-1 is equal to C(2n, n+1).\n\n    Args:\n        n (int): The integer value to calculate the sum for.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    return math.comb(2 * n, n + 1)", "matching_cluster_idx": 9}]}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string with spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverse the words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string with spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Write a function to reverse words separated by spaces in a given string.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Write a function to reverse words separated by spaces in a given string.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the words in a given string separated by spaces.\n    \n    Args:\n        s (str): The input string containing words separated by spaces.\n        \n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverse the order of words in a given string separated by spaces.\n\n    Parameters:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A string with the words in reversed order.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    # Split the string into words, reverse the list of words, and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in the given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reverse order.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words separated by spaces in a given string.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the order of words reversed.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the words in a given string separated by spaces.\n\n    Parameters:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into words, reverse the list, and join back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The string with words reversed.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n    \n    Parameters:\n    s (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A string with the words in reverse order.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A new string with the words in reverse order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string with words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n\n    Example:\n        >>> reverse_words(\"python program\")\n        \"program python\"\n    \"\"\"\n    # Split the string into words, reverse the list of words, and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string with words separated by spaces.\n\n    Returns:\n        str: A new string with the order of words reversed.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string with spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverse the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the order of words reversed.\n\n    Examples:\n        >>> reverse_words(\"python program\")\n        'program python'\n        >>> reverse_words(\"hello world\")\n        'world hello'\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Parameters:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the string into words, reverse the list of words, and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \n    Example:\n        >>> reverse_words(\"python program\")\n        \"program python\"\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 56.014492753623195, "dps_norm": 56.42857142857143, "pass@1": 98.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based indexing).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is out of the list bounds.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the list bounds.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 2}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list.\n\n    :param lst: List of elements.\n    :param k: 1-based index of the element to remove.\n    :return: New list with the k'th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element (1-based index) from the list and returns the new list.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if not 1 <= k <= len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list (1-based indexing).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if not 1 <= k <= len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based index).\n\n    Parameters:\n        lst (list): The input list.\n        k (int): The 1-based index of the element to remove.\n\n    Returns:\n        list: A new list with the k-th element removed.\n\n    Raises:\n        IndexError: If k is out of bounds.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the bounds of the list.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based indexing).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is out of the valid range.\n    \"\"\"\n    if 1 <= k <= len(lst):\n        return lst[:k-1] + lst[k:]\n    else:\n        raise IndexError(\"k is out of range\")", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the new list.\n    \n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the new list.\n    \n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based index).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove (1-based).\n\n    Returns:\n    list: A new list with the k-th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the bounds of the list\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list. k is 1-based.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Raises:\n    IndexError: If k is out of bounds.\n    \"\"\"\n    if not 1 <= k <= len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list (1-based index).\n\n    Args:\n        lst (list): The original list.\n        k (int): The 1-based position of the element to remove.\n\n    Returns:\n        list: A new list with the k'th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element (1-based index) from the list and returns the new list.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove (1-based).\n\n    Returns:\n    list: A new list with the k-th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the list's bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based index).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the bounds of the list.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based index).\n\n    Args:\n        lst (list): The input list.\n        k (int): The 1-based index of the element to remove.\n\n    Returns:\n        list: A new list with the k-th element removed.\n\n    Raises:\n        IndexError: If k is out of bounds.\n    \"\"\"\n    if not 1 <= k <= len(lst):\n        raise IndexError(\"k is out of the list bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element (1-based index) from the list and returns the new list.\n    \n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n    \n    Returns:\n    list: A new list with the k-th element removed.\n    \n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the bounds of the list\")\n    # Use list slicing to remove the k-th element\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based indexing).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove (1-based).\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based index).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is out of the list's bounds.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the list's bounds.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based index).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n    \n    Raises:\n    IndexError: If k is out of bounds.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element (1-based index) from the list.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 74.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n\n    :param matrix: List of lists representing the matrix.\n    :param n: The column index (0-based).\n    :return: The maximum value in the n-th column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n'th column of the given matrix.\n\n    Args:\n        matrix (list of lists): The input matrix.\n        n (int): The column index.\n\n    Returns:\n        The maximum value in the n'th column.\n\n    Example:\n        >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n        19\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    if not all(len(row) > n for row in matrix):\n        raise IndexError(\"Column index out of range for one or more rows.\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix represented as a list of lists.\n    n (int): The index of the column (0-based).\n\n    Returns:\n    int/float: The maximum value in the n-th column.\n    \"\"\"\n    return max(row[n] for row in matrix if len(row) > n)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    :param matrix: List of lists representing the matrix\n    :param n: Index of the column\n    :return: Maximum value in the nth column\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix represented as a list of lists.\n    n (int): The index of the column (0-based).\n\n    Returns:\n    int or float: The maximum value in the nth column.\n\n    Raises:\n    IndexError: If the column index is out of range for any row.\n    ValueError: If the matrix is empty.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        raise IndexError(f\"Column index {n} is out of range for the given matrix.\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n\n    Args:\n        matrix (list of lists): The matrix to search, where each sublist represents a row.\n        n (int): The index of the column (0-based) to find the maximum value in.\n\n    Returns:\n        The maximum value in the specified column.\n\n    Raises:\n        IndexError: If the specified column index is out of range for any row in the matrix.\n        ValueError: If the matrix is empty.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, return the maximum value in the n-th column.\n\n    Args:\n        matrix (list of lists): The matrix to process.\n        n (int): The index of the column (0-based).\n\n    Returns:\n        The maximum value in the n-th column.\n\n    Example:\n        >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n        19\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    if any(len(row) <= n for row in matrix):\n        raise IndexError(\"Column index out of range for one or more rows.\")\n    \n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Write a function which given a matrix represented as a list of lists returns the max of the n'th column.\n    assert max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        raise IndexError(f\"Column index {n} is out of range for the provided matrix.\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n-th column in the given matrix.\n\n    Parameters:\n    - matrix (List[List[int]]): A list of lists where each sublist represents a row in the matrix.\n    - n (int): The index of the column (0-based) for which to find the maximum value.\n\n    Returns:\n    - int: The maximum value in the n-th column.\n\n    Raises:\n    - IndexError: If the column index n is out of bounds for any row in the matrix.\n    - ValueError: If the matrix is empty.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n\n    max_value = matrix[0][n]\n    for row in matrix:\n        if n >= len(row):\n            raise IndexError(f\"Column index {n} is out of bounds for row {row}.\")\n        if row[n] > max_value:\n            max_value = row[n]\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n\n    :param matrix: List of lists where each sublist represents a row in the matrix.\n    :param n: Integer representing the column index (0-based).\n    :return: Maximum value in the n-th column.\n    :raises ValueError: If the matrix is empty or the column index is out of bounds.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        raise ValueError(f\"Column index {n} is out of bounds for the given matrix.\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n\n    :param matrix: List of lists representing the matrix.\n    :param n: The index of the column (0-based).\n    :return: The maximum value in the n-th column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    - matrix (List[List[Any]]): A list of lists representing the matrix.\n    - n (int): The index of the column (0-based).\n\n    Returns:\n    - The maximum value in the nth column.\n\n    Raises:\n    - IndexError: If the matrix is empty or if any row doesn't have the nth column.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n\n    # Extract the nth column\n    try:\n        nth_column = [row[n] for row in matrix]\n    except IndexError:\n        raise IndexError(f\"Column index {n} is out of bounds for the given matrix.\")\n\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix represented as a list of lists.\n    n (int): The column index (0-based).\n\n    Returns:\n    int/float: The maximum value in the nth column.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        raise ValueError(\"Matrix is empty or malformed.\")\n    \n    return max(row[n] for row in matrix if len(row) > n)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n    \n    Parameters:\n    matrix (list of lists): The matrix to search.\n    n (int): The index of the column (0-based).\n    \n    Returns:\n    The maximum value in the n-th column.\n    \n    Raises:\n    ValueError: If the matrix is empty or the column index is out of range.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    if not all(len(row) > n for row in matrix):\n        raise ValueError(f\"Not all rows have a column index {n}.\")\n    \n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the matrix.\n\n    Args:\n        matrix (list of lists): The matrix to process.\n        n (int): The index of the column (0-based).\n\n    Returns:\n        The maximum value in the n-th column.\n\n    Example:\n        >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n        19\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A list of lists where each sublist represents a row in the matrix.\n    n (int): The column index (0-based) to find the maximum value in.\n\n    Returns:\n    int: The maximum value in the nth column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Args:\n        matrix (list of lists): The matrix to search.\n        n (int): The index of the column.\n\n    Returns:\n        The maximum value in the nth column.\n\n    Raises:\n        ValueError: If the matrix is empty or the column index is out of bounds.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        raise ValueError(f\"Column index {n} is out of bounds for some rows.\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix to search.\n    n (int): The index of the column.\n\n    Returns:\n    The maximum value in the nth column.\n\n    Raises:\n    ValueError: If the matrix is empty or if the column index is out of range.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        raise ValueError(f\"Column index {n} is out of range for the given matrix.\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix represented as a list of lists.\n    n (int): The index of the column (0-based).\n\n    Returns:\n    int/float: The maximum value in the nth column.\n\n    Raises:\n    ValueError: If the matrix is empty or the column index is out of range.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    max_value = None\n    for row in matrix:\n        if n >= len(row):\n            raise ValueError(f\"Column index {n} is out of range for the row {row}.\")\n        if max_value is None or row[n] > max_value:\n            max_value = row[n]\n    \n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n\n    :param matrix: List of lists where each sublist represents a row in the matrix.\n    :param n: The index of the column (0-based) to find the maximum value in.\n    :return: The maximum value in the specified column.\n    :raises IndexError: If the column index is out of range for any row.\n    :raises ValueError: If the matrix is empty.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        raise IndexError(f\"Column index {n} is out of range for the given matrix.\")", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 55.83333333333332, "dps_norm": 77.5, "pass@1": 96.0, "profiled": [{"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    translation_table = str.maketrans(' _', '_ ')\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    # Create a translation table for swapping space and underscore\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    return s.translate(translation_table)", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return s.translate(str.maketrans({' ': '_', '_': ' '}))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return ''.join(['_' if c == ' ' else ' ' if c == '_' else c for c in s])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n\n    Examples:\n        >>> replace_spaces('Jumanji The Jungle')\n        'Jumanji_The_Jungle'\n        >>> replace_spaces('Hello_World')\n        'Hello World'\n        >>> replace_spaces('Space_and_Underscore')\n        'Space and Underscore'\n    \"\"\"\n    return ''.join(['_' if char == ' ' else ' ' if char == '_' else char for char in s])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with spaces in the given string.\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        str: The modified string with spaces and underscores swapped.\n        \n    Examples:\n        >>> replace_spaces('Jumanji The Jungle')\n        'Jumanji_The_Jungle'\n        >>> replace_spaces('Jumanji_The_Jungle')\n        'Jumanji The Jungle'\n    \"\"\"\n    return ''.join(['_' if char.isspace() else ' ' if char == '_' else char for char in s])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n    \n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The transformed string with spaces and underscores swapped.\n    \"\"\"\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The transformed string with spaces and underscores swapped.\n    \"\"\"\n    return s.translate(str.maketrans({' ': '_', '_': ' '}))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return s.translate(str.maketrans({' ': '_', '_': ' '}))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    return ''.join('_' if c == ' ' else ' ' if c == '_' else c for c in s)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s: str) -> str:\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the input string.\n    \n    Args:\n        s (str): The input string containing spaces and/or underscores.\n        \n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    translation_table = str.maketrans(' _', '_ ')\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return s.translate(str.maketrans({' ': '_', '_': ' '}))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    translation_table = str.maketrans(' _', '_ ')\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n    \n    Args:\n        s (str): The input string to be modified.\n        \n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    translation_table = str.maketrans(' _', '_ ')\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    translation_table = str.maketrans(' _', '_ ')\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return ''.join(['_' if c == ' ' else ' ' if c == '_' else c for c in s])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace all whitespace characters with underscores and all underscores with spaces.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return s.translate({ord(' '): '_', ord('_'): ' '})", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s: str) -> str:\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n\n    Args:\n        s (str): The input string to modify.\n\n    Returns:\n        str: A new string with spaces and underscores swapped.\n\n    Example:\n        >>> replace_spaces('Jumanji The Jungle')\n        'Jumanji_The_Jungle'\n        >>> replace_spaces('Jumanji_The_Jungle')\n        'Jumanji The Jungle'\n    \"\"\"\n    # Create a translation table:\n    # Replace space with underscore and underscore with space\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    return s.translate(translation_table)", "matching_cluster_idx": 6}]}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def move_zero(lst):\n    \"\"\"\n    Write a python function to move all zeroes to the end of the given list.\n    assert move_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the input list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        lst (list): The list of integers.\n\n    Returns:\n        list: The modified list with all zeroes moved to the end.\n    \n    Example:\n        >>> move_zero([1, 0, 2, 0, 3, 4])\n        [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    pos = 0  # Position to place the next non-zero element\n\n    # Iterate through the list and move non-zero elements forward\n    for i in range(len(lst)):\n        if lst[i] != 0:\n            lst[pos] = lst[i]\n            pos += 1\n\n    # Fill the remaining positions with zeroes\n    while pos < len(lst):\n        lst[pos] = 0\n        pos += 1\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        lst (List[int]): The input list containing integers.\n\n    Returns:\n        List[int]: The list after moving all zeroes to the end.\n    \"\"\"\n    last_non_zero = 0  # Pointer for the position of the last non-zero element\n\n    # Iterate through the list and move non-zero elements forward\n    for current in range(len(lst)):\n        if lst[current] != 0:\n            lst[last_non_zero] = lst[current]\n            last_non_zero += 1\n\n    # Fill the remaining positions with zeroes\n    for i in range(last_non_zero, len(lst)):\n        lst[i] = 0\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeros in the list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (list): The list of integers to rearrange.\n    \n    Returns:\n    list: The rearranged list with all zeros moved to the end.\n    \"\"\"\n    non_zero = []\n    zero_count = 0\n    for num in lst:\n        if num != 0:\n            non_zero.append(num)\n        else:\n            zero_count += 1\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeros in the list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (list): The input list containing integers.\n    \n    Returns:\n    list: A new list with all zeros moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zeros = [x for x in lst if x == 0]\n    return non_zero + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the list while maintaining the order of non-zero elements.\n\n    Args:\n        lst (list): The input list containing integers.\n\n    Returns:\n        list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeros in the list 'nums' to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    nums (list): The input list containing integers.\n    \n    Returns:\n    list: The list after moving all zeros to the end.\n    \"\"\"\n    last_non_zero = 0  # Pointer for the position of the last non-zero found\n\n    # Iterate through the list\n    for current in range(len(nums)):\n        if nums[current] != 0:\n            nums[last_non_zero], nums[current] = nums[current], nums[last_non_zero]\n            last_non_zero += 1\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the list while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (List[int]): The input list of integers.\n    \n    Returns:\n    List[int]: The list after moving all zeroes to the end.\n    \"\"\"\n    pos = 0  # Position to place the next non-zero element\n    for num in lst:\n        if num != 0:\n            lst[pos] = num\n            pos += 1\n    # Fill the remaining positions with zeroes\n    while pos < len(lst):\n        lst[pos] = 0\n        pos += 1\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeros in the list to the end while maintaining the order of non-zero elements.\n    \n    Args:\n        lst (list): The input list containing integers.\n        \n    Returns:\n        list: The list after moving all zeros to the end.\n    \"\"\"\n    last_non_zero = 0  # Pointer for the position of the last non-zero found\n\n    # Iterate through the list\n    for current in range(len(lst)):\n        if lst[current] != 0:\n            # Swap elements if a non-zero is found\n            lst[last_non_zero], lst[current] = lst[current], lst[last_non_zero]\n            last_non_zero += 1\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n\n    :param lst: List of integers\n    :return: List with all zeroes moved to the end\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [0] * (len(lst) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes in the list 'nums' to the end while maintaining the order of non-zero elements.\n\n    Args:\n        nums (list): The list of integers containing zeroes and non-zeroes.\n\n    Returns:\n        list: The modified list with all zeroes moved to the end.\n    \"\"\"\n    last_non_zero = 0  # Pointer for the position of the last non-zero found\n\n    # Iterate through the list\n    for current in range(len(nums)):\n        if nums[current] != 0:\n            nums[last_non_zero], nums[current] = nums[current], nums[last_non_zero]\n            last_non_zero += 1\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        nums (List[int]): The input list containing integers.\n\n    Returns:\n        List[int]: The list after moving all zeroes to the end.\n    \"\"\"\n    pos = 0  # Position to place the next non-zero element\n\n    # Iterate through the list and move non-zero elements forward\n    for num in nums:\n        if num != 0:\n            nums[pos] = num\n            pos += 1\n\n    # Fill the remaining positions with zeroes\n    for i in range(pos, len(nums)):\n        nums[i] = 0\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n    lst (list): The input list containing integers.\n\n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = []\n    zero_count = 0\n    for num in lst:\n        if num != 0:\n            non_zero.append(num)\n        else:\n            zero_count += 1\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Parameters:\n    lst (list): The input list containing integers.\n\n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes in the list 'nums' to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    nums (list): The input list containing integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = []\n    zero_count = 0\n    \n    for num in nums:\n        if num != 0:\n            non_zero.append(num)\n        else:\n            zero_count += 1\n            \n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        lst (list): The input list containing integers.\n\n    Returns:\n        list: The list after moving all zeroes to the end.\n    \"\"\"\n    pos = 0  # Position to place the next non-zero element\n\n    # Iterate through the list and move non-zero elements forward\n    for num in lst:\n        if num != 0:\n            lst[pos] = num\n            pos += 1\n\n    # Fill the remaining positions with zeroes\n    for i in range(pos, len(lst)):\n        lst[i] = 0\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    write_index = 0  # Pointer for the position of the next non-zero element\n\n    # Iterate through the list and move non-zero elements forward\n    for num in lst:\n        if num != 0:\n            lst[write_index] = num\n            write_index += 1\n\n    # Fill the remaining positions with zeros\n    for i in range(write_index, len(lst)):\n        lst[i] = 0\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Parameters:\n    lst (list): The input list containing integers.\n\n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the list while maintaining the order of non-zero elements.\n\n    Parameters:\n    nums (list): The input list containing integers.\n\n    Returns:\n    list: The list with all zeroes moved to the end.\n    \"\"\"\n    last_non_zero = 0  # Pointer for the position of the last non-zero element\n\n    # Iterate through the list\n    for current in range(len(nums)):\n        if nums[current] != 0:\n            # Swap the current element with the element at last_non_zero pointer\n            nums[last_non_zero], nums[current] = nums[current], nums[last_non_zero]\n            last_non_zero += 1\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeros in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        lst (list): The input list containing integers.\n\n    Returns:\n        list: The list after moving all zeros to the end.\n    \"\"\"\n    index = 0  # Pointer for the position of the next non-zero element\n\n    # Iterate through the list and move non-zero elements forward\n    for num in lst:\n        if num != 0:\n            lst[index] = num\n            index += 1\n\n    # Fill the remaining positions with zeros\n    for i in range(index, len(lst)):\n        lst[i] = 0\n\n    return lst", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/644": {"dps": 68.29787234042553, "dps_norm": 72.66666666666666, "pass@1": 100.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The original array.\n    k (int): The position up to which the array should be reversed (1-based index).\n\n    Returns:\n    list: The array after reversing the first k elements.\n    \n    Raises:\n    ValueError: If k is not within the valid range.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(k, int):\n        raise TypeError(\"The position k must be an integer.\")\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array.\")\n    \n    # Reverse the first k elements and concatenate with the remaining elements\n    reversed_part = arr[:k][::-1]\n    remaining_part = arr[k:]\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"Invalid value for k. It must be between 0 and the length of the array.\")\n    reversed_part = arr[:k][::-1]\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the first k elements of the array.\n\n    Args:\n        arr (list): The input array.\n        k (int): The position up to which to reverse.\n\n    Returns:\n        list: The array after reversing up to position k.\n    \n    Example:\n        reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n    # Reverse the first k elements and concatenate the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be within the array length\")\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n\n    :param arr: List of elements\n    :param k: Position up to which to reverse (1-based)\n    :return: Modified list with first k elements reversed\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be within the range of the array length\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the k-th position (1-based index).\n\n    Parameters:\n    arr (list): The input array to be reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array after reversing up to the k-th position.\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k must be between 1 and the length of the array inclusive.\")\n    \n    # Adjust for zero-based indexing\n    start = 0\n    end = k - 1\n    while start < end:\n        arr[start], arr[end] = arr[end], arr[start]\n        start += 1\n        end -= 1\n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array after reversing up to the k-th position.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n    \n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the array up to the k-th position.\n\n    Args:\n        arr (list): The input array.\n        k (int): The position up to which to reverse the array.\n\n    Returns:\n        list: The array with the first k elements reversed.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position (1-based index).\n\n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array after reversing up to the k-th position.\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k must be between 1 and the length of the array inclusive.\")\n    \n    # Convert k to zero-based index\n    k_index = k\n    # Reverse the sublist up to k\n    reversed_part = arr[:k_index][::-1]\n    # Concatenate the reversed part with the remaining elements\n    return reversed_part + arr[k_index:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The input list of elements.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The modified list with elements reversed up to position k.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n\n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The position up to which the array will be reversed (1-based index).\n\n    Returns:\n    list: The array after reversing up to the k-th position.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be within the range of the array length.\")\n    \n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array after reversing up to position k.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be within the range of the array length.\")\n    \n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n\n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The number of elements from the start of the array to reverse.\n\n    Returns:\n    list: The array after reversing the first k elements.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n\n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be within the range of the array length.\")\n    \n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n\n    Parameters:\n    arr (list): The array to be modified.\n    k (int): The position up to which the array is to be reversed.\n\n    Returns:\n    list: The array with the first k elements reversed.\n\n    Raises:\n    ValueError: If k is negative or exceeds the length of the array.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n    \n    # Reverse the first k elements and concatenate with the remaining elements\n    reversed_part = arr[:k][::-1]\n    remaining_part = arr[k:]\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed (1-based index).\n\n    Returns:\n    list: The array after reversing up to the k-th position.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(k, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be within the range of the array length.\")\n\n    # Slice the array up to k and reverse it\n    reversed_part = arr[:k][::-1]\n    # Concatenate the reversed part with the remaining elements\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The modified list with elements up to position k reversed.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n\n    Parameters:\n    arr (list): The input array to be reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array after reversing up to the k-th position.\n\n    Raises:\n    ValueError: If k is out of the bounds of the array.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be within the bounds of the array.\")\n    \n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n\n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array after reversing up to the k-th position.\n\n    Raises:\n    ValueError: If k is larger than the length of the array or less than 1.\n    \"\"\"\n    if k < 1:\n        raise ValueError(\"k must be at least 1.\")\n    if k > len(arr):\n        raise ValueError(\"k is larger than the length of the array.\")\n    \n    left, right = 0, k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the array up to the given position k.\n\n    Parameters:\n    arr (list): The list to be reversed.\n    k (int): The position up to which the list is to be reversed.\n\n    Returns:\n    list: The list with the first k elements reversed.\n    \"\"\"\n    if k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n    if k > len(arr):\n        k = len(arr)\n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}]}, "Mbpp/720": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(original_tuple, new_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    original_tuple (tuple): The original tuple.\n    new_dict (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return original_tuple + (new_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to the given tuple and returns a new tuple.\n    \n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add.\n    \n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the new tuple.\n\n    Parameters:\n    tpl (tuple): The original tuple.\n    dct (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return tpl + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tpl (tuple): The original tuple.\n    dct (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tpl + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to a tuple and returns a new tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to the given tuple and returns a new tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    tpl (tuple): The original tuple.\n    dct (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tpl + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to a tuple and returns a new tuple.\n\n    Args:\n        t (tuple): The original tuple.\n        d (dict): The dictionary to add.\n\n    Returns:\n        tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(original_tuple, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple and returns a new tuple.\n\n    Args:\n        original_tuple (tuple): The original tuple.\n        dictionary (dict): The dictionary to add.\n\n    Returns:\n        tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return original_tuple + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tpl (tuple): The original tuple.\n    dct (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary added.\n    \"\"\"\n    return tpl + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    tpl (tuple): The original tuple.\n    dct (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tpl + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to the tuple and returns a new tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary added as the last element.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary added.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(original_tuple, new_dict):\n    \"\"\"\n    Adds a dictionary to a tuple and returns a new tuple.\n    \n    Parameters:\n    original_tuple (tuple): The original tuple.\n    new_dict (dict): The dictionary to add.\n    \n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return original_tuple + (new_dict,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 62.73224043715847, "dps_norm": 70.0, "pass@1": 90.0, "profiled": [{"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        list: A list of strings found within double quotes.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found within double quotation marks.\n    \"\"\"\n    # Use regular expression to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed within double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found within double quotes.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        List[str]: A list of substrings found within quotation marks.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the given string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found between double quotes.\n    \n    Example:\n        >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n        ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extract all substrings enclosed in double quotation marks.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        List[str]: A list of extracted substrings without the quotes.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found within double quotes.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of strings found between double quotes.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extract all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found within double quotes.\n    \"\"\"\n    # Use regular expression to find all occurrences between \" \"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the given string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        List[str]: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Parameters:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    # The regex pattern looks for characters between double quotes\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        list: A list of substrings found within double quotes.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of strings found within double quotes.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found between double quotes.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks.\n\n    Parameters:\n    s (str): The input string containing quoted substrings.\n\n    Returns:\n    list: A list of substrings without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    Args:\n        s (str): The input string containing quoted substrings.\n    \n    Returns:\n        List[str]: A list of substrings found within quotation marks.\n    \n    Example:\n        >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n        ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the input string.\n\n    Parameters:\n    s (str): The input string containing quoted substrings.\n\n    Returns:\n    List[str]: A list of strings found within double quotes.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extract values between quotation marks \" \" from the given string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found within quotation marks.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    # Use regular expressions to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}]}, "Mbpp/732": {"dps": 20.01937984496124, "dps_norm": 67.0, "pass@1": 98.0, "profiled": [{"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, and dots in the input string with a colon.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    return s.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The modified string with specified characters replaced by colons.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(s):\n    return s.translate(str.maketrans({' ': ':', ',': ':', '.': ':'}))", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    return s.translate(str.maketrans({' ': ':', ',': ':', '.': ':'}))", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the string with a colon.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    translation_table = str.maketrans(\" ,.\", \":::\")\n    return s.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with replacements.\n    \"\"\"\n    return s.translate(str.maketrans({' ': ':', ',': ':', '.': ':'}))", "matching_cluster_idx": 8}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n    \n    Args:\n        s (str): The input string to be processed.\n        \n    Returns:\n        str: The processed string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the string with a colon.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with specified characters replaced by colons.\n    \"\"\"\n    return s.translate(str.maketrans({' ': ':', ',': ':', '.': ':'}))", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, and dots in the input string with a colon.\n    \n    Parameters:\n    s (str): The input string to be processed.\n    \n    Returns:\n    str: The processed string with specified characters replaced by colons.\n    \"\"\"\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    return s.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the string with a colon.\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    return s.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots with a colon.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Use regular expression to replace spaces, commas, and dots with ':'\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 2}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, and dots in the input string with colons.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Create a translation table where each character to replace is mapped to ':'\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    return s.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    return s.translate(str.maketrans(' ,.', ':::'))", "matching_cluster_idx": 8}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the string with a colon.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \n    Example:\n        >>> replace_specialchar('Python language, Programming language.')\n        'Python:language::Programming:language:'\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n    \n    Args:\n        s (str): The input string to be processed.\n        \n    Returns:\n        str: The modified string with specified characters replaced by colons.\n        \n    Example:\n        >>> replace_specialchar('Python language, Programming language.')\n        'Python:language::Programming:language:'\n    \"\"\"\n    return s.translate(str.maketrans({' ': ':', ',': ':', '.': ':'}))", "matching_cluster_idx": 8}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replaces all spaces, commas, or dots with a colon.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}]}, "Mbpp/740": {"dps": 94.41818181818182, "dps_norm": 89.44444444444444, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    Args:\n        tup (tuple): The input tuple with an even number of elements.\n        \n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \n    Raises:\n        ValueError: If the tuple has an odd number of elements.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    it = iter(tup)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        tup (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        tup (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary using adjacent elements as key-value pairs.\n\n    Parameters:\n    t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n    dict: A dictionary constructed from the tuple.\n\n    Raises:\n    ValueError: If the tuple has an odd number of elements.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    # Using iterator and zip for efficient pairing\n    it = iter(t)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The input tuple containing an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple contains an odd number of elements, cannot form key-value pairs.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple (tuple): The tuple to convert. Must have an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n\n    Raises:\n        ValueError: If the tuple has an odd number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    it = iter(input_tuple)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple's adjacent elements.\n    \n    Example:\n        >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n        {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    it = iter(t)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary by pairing adjacent elements.\n    \n    Args:\n        t (tuple): The input tuple with an even number of elements.\n        \n    Returns:\n        dict: A dictionary with keys and values from adjacent tuple elements.\n        \n    Raises:\n        ValueError: If the tuple has an odd number of elements.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    it = iter(t)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements.\")\n    \n    return {key: value for key, value in zip(t[::2], t[1::2])}", "matching_cluster_idx": 7}, {"solution": "def tuple_to_dict(tpl):\n    \"\"\"\n    Converts a tuple to a dictionary by pairing adjacent elements as key-value pairs.\n\n    Args:\n        tpl (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n\n    Raises:\n        ValueError: If the tuple has an odd number of elements.\n    \"\"\"\n    if len(tpl) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return {tpl[i]: tpl[i + 1] for i in range(0, len(tpl), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tpl):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        tpl (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n\n    Raises:\n        ValueError: If the tuple does not contain an even number of elements.\n    \"\"\"\n    if len(tpl) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n\n    return {tpl[i]: tpl[i + 1] for i in range(0, len(tpl), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary by pairing adjacent elements as key-value pairs.\n    \n    Args:\n        t (tuple): The input tuple with an even number of elements.\n    \n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \"\"\"\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary using adjacent elements as key-value pairs.\n\n    Parameters:\n    t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n    dict: A dictionary constructed from the tuple.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary using adjacent elements as key-value pairs.\n    \n    Parameters:\n    t (tuple): The input tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary constructed from the tuple.\n    \n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \n    Example:\n        >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n        {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a dictionary by pairing adjacent elements as key-value pairs.\n    \n    Args:\n        tup (tuple): The input tuple containing an even number of elements.\n        \n    Returns:\n        dict: A dictionary constructed from the tuple's adjacent elements.\n        \n    Example:\n        >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n        {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    it = iter(tup)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n\n    Args:\n        tup (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from adjacent key-value pairs in the tuple.\n\n    Raises:\n        ValueError: If the tuple does not contain an even number of elements.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n\n    it = iter(tup)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple into a dictionary by pairing adjacent elements as key-value pairs.\n\n    Args:\n        tup (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n\n    Raises:\n        ValueError: If the tuple has an odd number of elements.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tpl):\n    \"\"\"\n    Converts a tuple into a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        tpl (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \"\"\"\n    if len(tpl) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    return dict(zip(tpl[::2], tpl[1::2]))", "matching_cluster_idx": 8}]}, "Mbpp/744": {"dps": 79.45205479452055, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    input_tuple (tuple): The tuple to check.\n\n    Returns:\n    bool: True if None is present, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if None is present, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Checks if the given tuple contains any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The tuple to check.\n\n    Returns:\n        bool: True if None is present in the tuple, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"Check if the tuple contains any None value.\"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    input_tuple (tuple): The tuple to check.\n\n    Returns:\n    bool: True if None is found in the tuple, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        t (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the tuple contains any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Checks if the given tuple contains any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if the given tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if None is present in the tuple, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the tuple contains any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if None is present, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if None is present in the tuple, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    input_tuple (tuple): The tuple to check.\n\n    Returns:\n    bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 2}]}, "Mbpp/750": {"dps": 54.76190476190476, "dps_norm": 52.5, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the tuple to the end of the list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to be added.\n\n    Returns:\n    list: A new list containing elements of both the original list and the tuple.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple containing elements to add.\n\n    Returns:\n    list: A new list containing the elements of the original list followed by the tuple elements.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n    list: The updated list with tuple elements appended.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds elements of a tuple to the end of a list.\n\n    Args:\n        lst (list): The list to which elements will be added.\n        tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n        list: The updated list with tuple elements appended.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the tuple `tpl` to the list `lst` and returns a new list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to be added.\n\n    Returns:\n    list: A new list containing elements of `lst` followed by elements of `tpl`.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Add the elements of the given tuple to the given list.\n\n    Args:\n        lst (list): The list to which elements will be added.\n        tpl (tuple): The tuple containing elements to add.\n\n    Returns:\n        list: The updated list with elements from the tuple appended.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the tuple to the list and returns the new list.\n\n    :param lst: List of integers.\n    :param tpl: Tuple of integers to be added to the list.\n    :return: New list with tuple elements appended.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Args:\n        lst (list): The list to which the tuple will be added.\n        tpl (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n        list: A new list containing the elements of the original list followed by the tuple elements.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The combined list with tuple elements appended.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"First argument must be a list.\")\n    if not isinstance(tpl, tuple):\n        raise TypeError(\"Second argument must be a tuple.\")\n    \n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple whose elements will be added.\n\n    Returns:\n    list: A new list containing the elements of the original list followed by the tuple elements.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple containing elements to add.\n\n    Returns:\n    list: The updated list with tuple elements added.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the elements of the given tuple to the end of the given list.\n\n    Args:\n        lst (list): The original list.\n        tup (tuple): The tuple to be added.\n\n    Returns:\n        list: A new list containing elements from lst followed by elements from tup.\n\n    Example:\n        >>> add_tuple([5, 6, 7], (9, 10))\n        [5, 6, 7, 9, 10]\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds elements of a tuple to a list.\n\n    Parameters:\n    lst (list): The list to be extended.\n    tpl (tuple): The tuple whose elements are to be added.\n\n    Returns:\n    list: The list after adding the tuple elements.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list and returns the new list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to add to the list.\n\n    Returns:\n    list: A new list containing the elements of lst followed by the elements of tpl.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n    list: A new list containing the original list elements followed by the tuple elements.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tup (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n    list: A new list containing the elements of the original list followed by the tuple elements.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the tuple to the list and returns the modified list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The list after adding the elements of the tuple.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list and returns the new list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The combined list.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: A new list containing the elements of the original list followed by the tuple elements.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to be added.\n\n    Returns:\n    list: The new list with tuple elements appended.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}]}, "Mbpp/753": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/754": {"dps": 96.37931034482759, "dps_norm": 95.625, "pass@1": 94.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n        l3 (list): Third list of elements.\n\n    Returns:\n        list: A list of elements common to all three lists at the same indices.\n    \"\"\"\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements that appear in all three lists at the same index.\n\n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n    l3 (list): Third list of elements.\n\n    Returns:\n    list: A list of common elements appearing at the same indices in all three lists.\n    \"\"\"\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n        l3 (list): Third list of elements.\n\n    Returns:\n        list: A list of common elements found at the same indices in all three lists.\n    \"\"\"\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n    l3 (list): Third list of elements.\n\n    Returns:\n    list: A list of elements that are common at the same indices in all three lists.\n    \"\"\"\n    # Determine the minimum length among the three lists to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to collect elements that are the same across all lists at each index\n    common_elements = [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Args:\n        l1 (list): First list.\n        l2 (list): Second list.\n        l3 (list): Third list.\n\n    Returns:\n        list: A list of common elements appearing at the same indices in all three lists.\n    \"\"\"\n    return [a for a, b, c in zip(l1, l2, l3) if a == b == c]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Extracts elements that are common across three lists at the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements found at the same indices in all three lists.\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    common_elements = [a for a, b, c in zip(l1, l2, l3) if a == b == c]\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements that appear in all three lists at the same index.\n\n    Args:\n        l1, l2, l3 (list): Three lists to compare.\n\n    Returns:\n        list: List of common elements.\n    \"\"\"\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists that appear at the same index.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n        l3 (list): Third list of elements.\n\n    Returns:\n        list: A list of common elements appearing at the same index in all three lists.\n    \"\"\"\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists that appear at the same index.\n\n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n    l3 (list): Third list of elements.\n\n    Returns:\n    list: A list of elements common to all three lists at the same indices.\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    common_elements = [x for x, y, z in zip(l1, l2, l3) if x == y == z]\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists that appear at the same index.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n        l3 (list): Third list of elements.\n\n    Returns:\n        list: A list containing elements common to all three lists at the same index.\n    \"\"\"\n    # Determine the minimum length among the three lists to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to collect elements where all three lists have the same element at index i\n    common_elements = [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists where the elements are the same at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Three lists to compare.\n    \n    Returns:\n    list: A list of common elements that appear in all three lists at the same index.\n    \n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7],\n    ...                   [0, 1, 2, 3, 4, 5, 7],\n    ...                   [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    return [a for a, b, c in zip(l1, l2, l3) if a == b == c]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Returns a list of elements that are common to l1, l2, and l3 at the same index.\n\n    Parameters:\n    l1 (list): First list.\n    l2 (list): Second list.\n    l3 (list): Third list.\n\n    Returns:\n    list: List of common elements found at the same indices in all three lists.\n    \"\"\"\n    # Determine the minimum length to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = []\n\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common across three lists at the same index.\n\n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n    l3 (list): Third list of elements.\n\n    Returns:\n    list: A list of elements that are the same in all three lists at the same index.\n    \"\"\"\n    # Determine the minimum length among the three lists to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through each index up to the minimum length\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements at the same index across three lists.\n\n    Parameters:\n    l1, l2, l3 (list): Three lists to compare.\n\n    Returns:\n    list: A list of elements common to all three lists at the same indices.\n    \"\"\"\n    # Use zip to iterate over all lists simultaneously and compare elements\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    This function finds and returns a list of such common elements.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list containing elements common to all three lists at the same index.\n    \n    Example:\n        >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n        [1, 7]\n    \"\"\"\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements that appear at the same index in all three lists.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n        l3 (list): Third list of elements.\n\n    Returns:\n        list: A list of common elements appearing at the same index in all three lists.\n    \"\"\"\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Returns a list of elements that are common to l1, l2, and l3 at the same index.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n        l3 (list): Third list of elements.\n\n    Returns:\n        list: A list containing elements common to all three lists at the same index.\n    \"\"\"\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists at the same index.\n    \n    Parameters:\n    l1, l2, l3 (list): Three lists to compare.\n    \n    Returns:\n    list: A list of elements common to all three lists at the same index.\n    \"\"\"\n    common_elements = []\n    # Iterate over the minimum length to avoid IndexError\n    for a, b, c in zip(l1, l2, l3):\n        if a == b == c:\n            common_elements.append(a)\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Args:\n        l1, l2, l3 (list): Three lists to compare.\n\n    Returns:\n        list: A list of common elements.\n    \"\"\"\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements common to l1, l2, and l3 at the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of elements that are the same in all three lists at the same index.\n    \"\"\"\n    # Use zip to iterate over the lists in parallel and collect elements that are equal\n    return [a for a, b, c in zip(l1, l2, l3) if a == b == c]", "matching_cluster_idx": 7}]}, "Mbpp/755": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/757": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/758": {"dps": 99.82625482625481, "dps_norm": 98.75, "pass@1": 100.0, "profiled": [{"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within the input list.\n\n    Args:\n        lst (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary where each key is a tuple representing a sublist,\n              and the value is the count of its occurrences in the input list.\n    \"\"\"\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst_of_lsts):\n    \"\"\"\n    Counts the occurrences of each sublist within the provided list of lists.\n    Converts each sublist to a tuple to make it hashable for dictionary keys.\n\n    Args:\n        lst_of_lsts (List[List[Any]]): A list containing sublists.\n\n    Returns:\n        Dict[Tuple[Any, ...], int]: A dictionary with tuples as keys and their counts as values.\n    \"\"\"\n    # Convert each sublist to a tuple and count their occurrences\n    return dict(Counter(tuple(sublist) for sublist in lst_of_lsts))", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Count the occurrences of each sublist within a list of lists.\n    \n    Args:\n        lst (list of lists): The input list containing sublists to be counted.\n    \n    Returns:\n        dict: A dictionary where each key is a tuple representing a unique sublist,\n              and the corresponding value is the number of times that sublist appears.\n              \n    Example:\n        >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n        {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        if key in counts:\n            counts[key] += 1\n        else:\n            counts[key] = 1\n    return counts", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within the given list.\n    Converts each sublist to a tuple and returns a dictionary\n    with tuples as keys and their counts as values.\n    \n    Args:\n        lst (list of lists): The input list containing sublists.\n        \n    Returns:\n        dict: A dictionary with tuple keys and integer counts.\n    \"\"\"\n    from collections import Counter\n    tupled = (tuple(sublist) for sublist in lst)\n    return dict(Counter(tupled))", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    from collections import Counter\n    # Convert each sublist to a tuple and count occurrences\n    counts = Counter(tuple(sublist) for sublist in lst)\n    return dict(counts)", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts occurrences of each sublist within the given list.\n    Converts each sublist to a tuple and returns a dictionary\n    with tuples as keys and their counts as values.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Counts the occurrences of each sublist within a list.\n    Each sublist is converted to a tuple to be used as a dictionary key.\n\n    Args:\n        lists (List[List[Any]]): A list of lists to be counted.\n\n    Returns:\n        Dict[Tuple[Any, ...], int]: A dictionary with tuple keys and their counts.\n    \n    Example:\n        >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n        {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    counts = {}\n    for sublist in lists:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Count the occurrences of sublists within a list.\n\n    Args:\n        lst (List[List[Any]]): A list of lists.\n\n    Returns:\n        Dict[Tuple[Any, ...], int]: A dictionary with each sublist converted to a tuple as keys\n                                    and their occurrence counts as values.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within the input list.\n    \n    Args:\n        lst (list of lists): The list containing sublists to be counted.\n        \n    Returns:\n        dict: A dictionary with each unique sublist converted to a tuple as keys and their counts as values.\n    \"\"\"\n    # Convert each sublist to a tuple to make them hashable\n    tuple_sublists = (tuple(sublist) for sublist in lst)\n    \n    # Use Counter to count occurrences of each tuple\n    counts = Counter(tuple_sublists)\n    \n    # Convert Counter object to a regular dictionary\n    return dict(counts)", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list.\n    \n    Args:\n        lst (List[List[Any]]): A list of lists to be counted.\n        \n    Returns:\n        Dict[Tuple[Any, ...], int]: A dictionary with each unique sublist converted to a tuple as keys and their counts as values.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist in the given list.\n    \n    Args:\n        lst (list of lists): The list containing sublists to be counted.\n        \n    Returns:\n        dict: A dictionary with each sublist converted to a tuple as keys and their counts as values.\n    \"\"\"\n    from collections import Counter\n    # Convert each sublist to a tuple to make it hashable\n    tuple_sublists = map(tuple, lst)\n    # Count the occurrences of each tuple sublist\n    return dict(Counter(tuple_sublists))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list.\n    \n    Args:\n        lst (list of lists): The list containing sublists to be counted.\n        \n    Returns:\n        dict: A dictionary where each key is a tuple converted from a sublist,\n              and the value is the number of times that sublist appears in the original list.\n    \"\"\"\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Counts the occurrences of each sublist within a list of lists.\n    Converts each sublist to a tuple to use as dictionary keys.\n\n    Args:\n        lists (List[List[Any]]): The list containing sublists to count.\n\n    Returns:\n        Dict[Tuple[Any, ...], int]: A dictionary with tupleified sublists as keys and their counts as values.\n    \"\"\"\n    from collections import Counter\n\n    # Convert each sublist to a tuple to make them hashable\n    tupled_lists = map(tuple, lists)\n    \n    # Count the occurrences of each tuple\n    counts = Counter(tupled_lists)\n    \n    return dict(counts)", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within the given list.\n    Converts each sublist to a tuple to make it hashable.\n    \n    Parameters:\n    lst (list of lists): The list containing sublists to be counted.\n\n    Returns:\n    dict: A dictionary with tuple representations of sublists as keys and their counts as values.\n    \"\"\"\n    from collections import Counter\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Count occurrences of each sublist within a list.\n\n    Args:\n        lst (list of lists): The list containing sublists to be counted.\n\n    Returns:\n        dict: A dictionary with tuples as keys representing the sublists,\n              and integers as values representing their counts.\n    \"\"\"\n    counts = {}\n    for sublst in lst:\n        key = tuple(sublst)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of each sublist within the given list of lists.\n    Returns a dictionary with tuples as keys and their counts as values.\n    \n    Args:\n        list_of_lists (List[List[Any]]): A list containing sublists.\n        \n    Returns:\n        Dict[Tuple[Any, ...], int]: A dictionary mapping each unique sublist (as a tuple) to its count.\n    \"\"\"\n    counts = {}\n    for sublist in list_of_lists:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list of lists.\n    Converts each sublist to a tuple to use as a dictionary key.\n\n    Args:\n        lst (list of lists): The list containing sublists to count.\n\n    Returns:\n        dict: A dictionary with tuples as keys and their occurrence counts as values.\n    \"\"\"\n    from collections import Counter\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of each sublist within a list of lists.\n\n    Args:\n        list_of_lists (List[List[Any]]): A list containing sublists.\n\n    Returns:\n        Dict[Tuple[Any, ...], int]: A dictionary with tuples as keys and their counts as values.\n    \"\"\"\n    # Convert each sublist to a tuple to make them hashable\n    tuple_sublists = (tuple(sublist) for sublist in list_of_lists)\n    \n    # Use Counter to count occurrences of each tuple\n    counts = Counter(tuple_sublists)\n    \n    return dict(counts)", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within the given list.\n    \n    Args:\n        lst (list of lists): The list containing sublists to be counted.\n        \n    Returns:\n        dict: A dictionary where each key is a tuple representing a unique sublist,\n              and the value is the number of its occurrences in the original list.\n    \"\"\"\n    # Convert each sublist to a tuple since lists are not hashable\n    tuple_sublists = (tuple(sublist) for sublist in lst)\n    # Use Counter to count the occurrences of each tuple\n    return dict(Counter(tuple_sublists))", "matching_cluster_idx": 7}]}, "Mbpp/760": {"dps": 41.824817518248175, "dps_norm": 75.625, "pass@1": 98.0, "profiled": [{"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n        lst (list): The list of elements to check.\n\n    Returns:\n        bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Assuming empty list does not have a unique element\n    return all(element == lst[0] for element in lst)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n        lst (list): The list of numbers to check.\n\n    Returns:\n        bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:\n        # Assuming an empty list does not contain any elements\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether the list contains only one distinct element.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Assuming empty list does not contain any elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if only one distinct element exists, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Assuming empty list does not contain any elements\n\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Parameters:\n    lst (list): The list of elements to check.\n\n    Returns:\n    bool: True if all elements are identical, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Define empty list as not having any distinct elements\n    first = lst[0]\n    for item in lst:\n        if item != first:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Checks whether all elements in the list are identical.\n\n    Args:\n        lst (list): The list of elements to check.\n\n    Returns:\n        bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not numbers:  # Handle empty list if necessary\n        return False\n    first_element = numbers[0]\n    for element in numbers:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are identical.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Assuming empty list does not have a unique element\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are identical.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Assuming empty list does not contain any elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are identical.\n\n    Args:\n        lst (list): List of numbers.\n\n    Returns:\n        bool: True if all elements are the same or the list is empty, False otherwise.\n    \"\"\"\n    if not lst:\n        return True  # Assuming an empty list has all elements identical\n    first_element = lst[0]\n    for element in lst[1:]:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n    \n    Parameters:\n    lst (list): The list of numbers to check.\n    \n    Returns:\n    bool: True if all elements are identical, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Assuming empty list does not have any elements\n    \n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are identical, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Define as False for empty lists\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same or the list is empty, False otherwise.\n    \"\"\"\n    return len(set(lst)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Checks whether the list contains only one distinct element.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:  # Handle empty list\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether the list contains only one distinct element.\n\n    Parameters:\n    lst (list): List of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same or the list is empty, False otherwise.\n    \"\"\"\n    if not lst:\n        return True  # Assuming an empty list has only one (zero) distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Parameters:\n    lst (list): List of numbers to check.\n\n    Returns:\n    bool: True if all elements are identical, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Assuming empty list does not contain any elements\n\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Assuming empty list does not contain any distinct element\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list contains only one distinct element.\n\n    Args:\n        lst (list): The list of numbers.\n\n    Returns:\n        bool: True if only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return True  # Define empty list as having one distinct element.\n\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are identical.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:\n        # Depending on the definition, an empty list can be considered to have all identical elements\n        return True\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are identical.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Args:\n        s (str): The input string to evaluate.\n\n    Returns:\n        int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Args:\n        s (str): The input string to be evaluated.\n\n    Returns:\n        int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digit characters in the given string.\n\n    Args:\n        s (str): The input string to be evaluated.\n\n    Returns:\n        int: The count of digit characters in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The input string to be processed.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Args:\n        s (str): The input string to be processed.\n\n    Returns:\n        int: The count of digit characters in the string.\n    \"\"\"\n    return sum(1 for c in s if c.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Parameters:\n    s (str): The input string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Parameters:\n    s (str): The input string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The input string to examine.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digit characters in the given string.\n\n    Args:\n        s (str): The input string to be evaluated.\n\n    Returns:\n        int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Args:\n        s (str): The input string to be evaluated.\n\n    Returns:\n        int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The input string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The input string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The input string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in the given string.\n\n    Parameters:\n    s (str): The input string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The input string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"Counts the number of digit characters in the provided string.\"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The input string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 99.01869158878505, "dps_norm": 98.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: A list where each tuple contains a pair of consecutive items.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: A list where each tuple contains a pair of consecutive items.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: A list where each tuple contains a pair of consecutive items.\n\n    Example:\n        >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n        [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: A list where each tuple contains a pair of consecutive items.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: List containing consecutive pairs as tuples.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    Args:\n        lst (list): The input list.\n        \n    Returns:\n        list of tuples: List containing pairs of consecutive items.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    Args:\n        lst (list): The input list from which to generate pairs.\n        \n    Returns:\n        list of tuples: A list containing tuples of consecutive pairs.\n    \n    Example:\n        >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n        [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: A list containing tuples of consecutive pairs.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: List containing pairs of consecutive items.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of consecutive pairs from the input list.\n\n    Args:\n        lst (list): The input list from which to generate pairs.\n\n    Returns:\n        list of tuples: A list containing tuples of consecutive elements.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: List containing consecutive item pairs.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    Args:\n        lst (list): The input list.\n    \n    Returns:\n        list of tuples: A list where each tuple contains a pair of consecutive items.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    Args:\n    lst (list): The input list.\n\n    Returns:\n    list of tuples: Each tuple contains a pair of consecutive items.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n    lst (list): The input list from which to create pairs.\n\n    Returns:\n    list of tuples: A list containing tuples of consecutive pairs.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: List containing tuples of consecutive pairs.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n    \n    Args:\n    lst (list): The input list.\n\n    Returns:\n    list of tuples: List containing tuples of consecutive pairs.\n    \n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n    lst (list): The input list from which to generate pairs.\n\n    Returns:\n    list of tuples: A list containing tuples of consecutive elements.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: Each tuple contains a pair of consecutive items.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    Args:\n        lst (list): The input list from which to generate consecutive pairs.\n    \n    Returns:\n        list of tuples: A list containing tuples of consecutive elements.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}]}, "Mbpp/775": {"dps": 87.19999999999999, "dps_norm": 64.28571428571429, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index in the list is an odd number.\n\n    Args:\n    lst (list of int): The list of integers to check.\n\n    Returns:\n    bool: True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    return all(x % 2 != 0 for idx, x in enumerate(lst) if idx % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index in the list is an odd number.\n\n    Parameters:\n    lst (list of int): The list to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    # Iterate over odd indices starting from 1\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at odd indices in the list is an odd number.\n\n    Parameters:\n    lst (list of int): The list to check.\n\n    Returns:\n    bool: True if every element at odd indices is odd, False otherwise.\n    \"\"\"\n    # Iterate over the list starting at index 1, stepping by 2 to access odd indices\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n\n    Parameters:\n    lst (list of int): The list to be checked.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    return all(item % 2 != 0 for index, item in enumerate(lst) if index % 2 == 1)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks whether every element at an odd index in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n\n    Parameters:\n    lst (list of int): The list of integers to check.\n\n    Returns:\n    bool: True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    return all(x % 2 != 0 for x in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    # Iterate over elements at odd indices and check if each is odd\n    return all(x % 2 != 0 for x in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index in the list is an odd number.\n\n    Args:\n        lst (list): The list of integers to check.\n\n    Returns:\n        bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd numbers, False otherwise.\n    \"\"\"\n    return all(x % 2 != 0 for i, x in enumerate(lst) if i % 2 == 1)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in the given list.\n\n    Args:\n        lst (list): The list of integers to check.\n\n    Returns:\n        bool: True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    return all(x % 2 != 0 for x in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in the given list.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    return all(x % 2 == 1 for x in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    # Iterate over indices starting from 1 with step of 2 (odd indices)\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n\n    Args:\n        lst (list of int): The list of integers to check.\n\n    Returns:\n        bool: True if every element at an odd index is odd, False otherwise.\n    \n    Examples:\n        >>> odd_position([2, 1, 4, 3, 6, 7, 6, 3])\n        True\n        >>> odd_position([2, 1, 4, 2, 6, 7, 6, 3])\n        False\n    \"\"\"\n    # Iterate over the list starting from index 1, stepping by 2 to access odd indices\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at odd indices in the list is an odd number.\n    \n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    # Iterate over the list starting from index 1, stepping by 2\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at odd indices in the list is an odd number.\n\n    Args:\n        lst (list of int): The list of integers to check.\n\n    Returns:\n        bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    # Slice the list to get elements at odd indices and check each is odd\n    return all(num % 2 != 0 for num in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index in the list is an odd number.\n\n    Args:\n        lst (list of int): The list to check.\n\n    Returns:\n        bool: True if every element at odd indices is odd, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks whether every element at an odd index in the list is an odd number.\n\n    Args:\n        lst (list): The list of integers to check.\n\n    Returns:\n        bool: True if all elements at odd indices are odd numbers, False otherwise.\n    \"\"\"\n    return all(x % 2 != 0 for i, x in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index in the list is an odd number.\n    \n    Parameters:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    return all(element % 2 != 0 for index, element in enumerate(lst) if index % 2 != 0)", "matching_cluster_idx": 2}]}, "Mbpp/777": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 84.0, "profiled": [{"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated (unique) elements in the given list.\n    \n    Parameters:\n    lst (list): The list of integers.\n    \n    Returns:\n    int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated (unique) elements in the given list.\n\n    Parameters:\n    lst (list): The list of integers.\n\n    Returns:\n    int: The sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    total = sum(unique_elements)\n    return total", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of unique (non-repeated) elements in the list.\n    \n    Args:\n        lst (list): The list of integers.\n        \n    Returns:\n        int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of unique elements in the list.\n    \n    Parameters:\n    lst (list): The list of integers.\n    \n    Returns:\n    int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated (unique) elements in the given list.\n\n    Args:\n        lst (list): The list of integers.\n\n    Returns:\n        int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of unique (non-repeated) elements in the list.\n    \n    Parameters:\n    lst (list): The input list of integers.\n    \n    Returns:\n    int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of unique elements in the given list.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated (unique) elements in the given list.\n\n    Args:\n        lst (list): The list of integers.\n\n    Returns:\n        int: The sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of unique elements in the list.\n    \n    Parameters:\n    lst (list): The list of integers.\n    \n    Returns:\n    int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of unique elements in the given list.\n\n    Args:\n        lst (list): The list of integers.\n\n    Returns:\n        int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of unique (distinct) elements in the given list.\n\n    Args:\n    lst (list): The list of integers.\n\n    Returns:\n    int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of non-repeated (unique) elements in the given list.\n    \n    Args:\n        lst (list): A list of integers.\n        \n    Returns:\n        int: Sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    total = sum(unique_elements)\n    return total", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of unique (non-repeated) elements in the given list.\n\n    Args:\n    lst (list): The list of integers.\n\n    Returns:\n    int: Sum of unique elements.\n    \n    Example:\n    >>> find_sum([1,2,3,1,1,4,5,6])\n    21\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of non-repeated (unique) elements in the given list.\n    \n    Parameters:\n    lst (list): The list of integers.\n    \n    Returns:\n    int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of unique elements in the given list.\n    \n    Parameters:\n    lst (list): The list of integers.\n    \n    Returns:\n    int: Sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of unique elements in the given list.\n    \n    Args:\n        lst (list): A list of integers.\n        \n    Returns:\n        int: Sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of unique elements in the given list.\n    \n    Parameters:\n    lst (list): The list of integers.\n    \n    Returns:\n    int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of unique elements in the list.\n    \n    Args:\n        lst (list): The input list of integers.\n    \n    Returns:\n        int: The sum of non-repeated (unique) elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of non-repeated (unique) elements in the given list.\n    \n    Parameters:\n    lst (list): The list of integers to process.\n    \n    Returns:\n    int: Sum of unique elements in the list.\n    \"\"\"\n    # Convert the list to a set to remove duplicates and sum the unique elements\n    return sum(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/781": {"dps": 99.48818897637796, "dps_norm": 99.0, "pass@1": 96.0, "profiled": [{"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    import math\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    sqrt_n = math.isqrt(n)\n    # If n is a perfect square, it has an odd number of divisors\n    is_perfect_square = sqrt_n * sqrt_n == n\n    return not is_perfect_square", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    :param n: Integer to check\n    :return: True if the number of divisors is even, False otherwise\n    \"\"\"\n    sqrt_n = math.isqrt(n)\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    sqrt_n = int(n ** 0.5)\n    # A number has an odd number of divisors only if it's a perfect square\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n    \n    Args:\n        n (int): The number to check.\n        \n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    sqrt_n = math.isqrt(n)\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    sqrt_n = math.isqrt(n)\n    # If n is a perfect square, it has an odd number of divisors\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    sqrt_n = math.isqrt(n)\n    # A number has an odd number of divisors only if it's a perfect square\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    # A number has an odd count of divisors only if it's a perfect square\n    sqrt_n = math.isqrt(n)\n    if sqrt_n * sqrt_n == n:\n        return False  # Odd number of divisors\n    return True        # Even number of divisors", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Returns True if the number of divisors of n is even, False otherwise.\n    \"\"\"\n    sqrt_n = math.isqrt(n)\n    # If n is a perfect square, it has an odd number of divisors\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Returns:\n        True if the number of divisors is even, False otherwise.\n    \"\"\"\n    sqrt_n = math.isqrt(n)\n    # If n is a perfect square, it has an odd number of divisors\n    if sqrt_n * sqrt_n == n:\n        return False\n    else:\n        return True", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check if the number of divisors of n is even.\n    Returns True if even, False otherwise.\n    \"\"\"\n    sqrt_n = int(n ** 0.5)\n    if sqrt_n * sqrt_n == n:\n        return False  # Odd number of divisors (perfect square)\n    else:\n        return True   # Even number of divisors", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n    \n    A number has an odd number of divisors only if it is a perfect square.\n    Therefore, if n is not a perfect square, it has an even number of divisors.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Number must be a positive integer.\")\n    \n    sqrt_n = math.isqrt(n)\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n    \n    Args:\n    - n (int): The number to check.\n    \n    Returns:\n    - bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    sqrt_n = math.isqrt(n)\n    # If n is a perfect square, it has an odd number of divisors\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    sqrt_n = math.isqrt(n)\n    # A number has an odd number of divisors only if it is a perfect square\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False  # Assuming positive integers only\n\n    count = 0\n    sqrt_n = int(n**0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2  # i and n//i are both divisors\n    if sqrt_n * sqrt_n == n:\n        count -= 1  # Correct the count if n is a perfect square\n\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    sqrt_n = int(math.sqrt(n))\n    # If n is a perfect square, it has an odd number of divisors\n    if sqrt_n * sqrt_n == n:\n        return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Returns True if the number of divisors of n is even, otherwise False.\n    A number has an odd number of divisors only if it is a perfect square.\n    \"\"\"\n    import math\n    sqrt_n = math.isqrt(n)\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    # If n is a perfect square, it has an odd number of divisors\n    # Otherwise, it has an even number of divisors\n    sqrt_n = math.isqrt(n)\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Returns True if the number of divisors of n is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    root = int(math.sqrt(n))\n    return root * root != n", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n    \n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    sqrt_n = math.isqrt(n)\n    # A number has an odd number of divisors if and only if it's a perfect square\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of `n` is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    # A number has an odd number of divisors if and only if it is a perfect square\n    root = int(n ** 0.5)\n    is_perfect_square = root * root == n\n    return not is_perfect_square", "matching_cluster_idx": 4}]}, "Mbpp/800": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements from a list of lists.\n\n    Args:\n        list_of_lists (List[List[int]]): A list containing multiple sublists of integers.\n\n    Returns:\n        List[int]: The sublist with the highest sum of its elements.\n\n    Raises:\n        ValueError: If the input list is empty or contains no sublists.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"The input list is empty.\")\n\n    # Initialize with the first sublist and its sum\n    max_sublist = list_of_lists[0]\n    max_sum = sum(max_sublist)\n\n    # Iterate through the remaining sublists\n    for sublist in list_of_lists[1:]:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sublist = sublist\n\n    return max_sublist", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n    \n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n    \n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n    \"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    if not list_of_lists:\n        return []\n    max_list = list_of_lists[0]\n    max_sum = sum(max_list)\n    for current_list in list_of_lists[1:]:\n        current_sum = sum(current_list)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = current_list\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n    \n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n    \n    Returns:\n    List[int]: The sublist with the maximum sum.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n    \n    Parameters:\n    list_of_lists (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    List[int]: The sublist with the highest sum. Returns an empty list if input is empty.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n    \n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n    \n    Returns:\n    List[int]: The sublist with the maximum sum.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    # Using max with key=sum to find the sublist with the highest sum\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements from a list of lists.\n\n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    # Use the built-in max function with sum as the key to find the sublist with the highest sum\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n    \n    Parameters:\n    list_of_lists (list of lists): A list containing sublists of numerical elements.\n    \n    Returns:\n    list: The sublist with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n    \n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n    \n    Returns:\n    List[int]: The sublist with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n    \n    :param list_of_lists: List of lists containing numerical elements\n    :return: The sublist with the highest sum\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"The input list cannot be empty.\")\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n\n    Args:\n        list_of_lists (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n        List[int]: The sublist with the highest sum.\n\n    Example:\n        >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n        [10, 11, 12]\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    # Initialize with the first sublist and its sum\n    max_list = list_of_lists[0]\n    max_sum = sum(max_list)\n\n    for sublist in list_of_lists[1:]:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n\n    Args:\n        list_of_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n        List[int]: The sublist with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"The input list cannot be empty.\")\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n\n    Args:\n        lists (list of lists): A list containing sublists of numbers.\n\n    Returns:\n        list: The sublist with the highest sum.\n    \"\"\"\n    if not lists:\n        return []\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements from a list of lists.\n\n    Parameters:\n    lists (List[List[int]]): A list containing multiple lists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n    \"\"\"\n    if not lists:\n        return []\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of its elements.\n\n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"The input list cannot be empty.\")\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n    \n    Args:\n    list_of_lists (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    List[int]: The sublist with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n\n    Parameters:\n    list_of_lists (List[List[int]]): A list containing multiple lists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"The input list_of_lists is empty.\")\n\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of its elements.\n\n    Args:\n        list_of_lists (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n        List[int]: The sublist with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n    \n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n    \n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n    \n    Parameters:\n    list_of_lists (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    List[int]: The sublist with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the element k is present in the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    k (any): The element to search for.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the value k is present in the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    k (any): The value to find in the tuple.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the tuple contains the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to search.\n    k: The element to find.\n\n    Returns:\n    bool: True if k is in tuples, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the value k is present in the given tuple.\n\n    Parameters:\n    tuples (tuple): The tuple to search.\n    k (any): The value to check for.\n\n    Returns:\n    bool: True if k is in tuples, False otherwise.\n    \"\"\"\n    # Using the 'in' operator for efficient membership testing\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple contains the element k.\n\n    Args:\n        tup (tuple): The tuple to search.\n        k: The element to find.\n\n    Returns:\n        bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple 'tup' contains the element 'k'.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    k (any): The element to find in the tuple.\n\n    Returns:\n    bool: True if 'k' is in 'tup', False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the value k is present in the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    k (any): The value to search for.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Args:\n        tuples (tuple): The tuple to check.\n        k (any): The element to search for.\n\n    Returns:\n        bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to search.\n    k (any): The element to find.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple contains the element k.\n    \n    Parameters:\n    tup (tuple): The tuple to search.\n    k: The element to find.\n    \n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple 'tup' contains the value 'k'.\n\n    Args:\n        tup (tuple): The tuple to check.\n        k: The value to search for in the tuple.\n\n    Returns:\n        bool: True if 'k' is in 'tup', False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the value k is present in the given tuple.\n\n    Args:\n        tuples (tuple): The tuple to search.\n        k: The value to search for.\n\n    Returns:\n        bool: True if k is in tuples, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple contains the element k.\n\n    Args:\n        tup (tuple): The tuple to search within.\n        k: The element to search for.\n\n    Returns:\n        bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if the value k is present in the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    k (any): The value to search for.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the element 'k' is present in the given tuple.\n\n    Parameters:\n    tuples (tuple): The tuple to search.\n    k (any): The element to look for.\n\n    Returns:\n    bool: True if 'k' is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if the element k is present in the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    k: The element to find.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple contains the element k.\n\n    Args:\n        tup (tuple): The tuple to search.\n        k: The element to find.\n\n    Returns:\n        bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    \"\"\"\n    Check if the tuple `tpl` contains the element `k`.\n\n    Parameters:\n    tpl (tuple): The tuple to search.\n    k (any): The element to find in the tuple.\n\n    Returns:\n    bool: True if `k` is in `tpl`, False otherwise.\n    \"\"\"\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the element k is present in the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    k (any): The element to find.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    k (int): The value to find in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}]}}}
