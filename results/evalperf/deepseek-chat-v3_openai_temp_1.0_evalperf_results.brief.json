{"date": "2024-12-26 01:57", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 84.76715801824392, "dps_norm": 79.75493514210092, "pass@1": 88.55932203389831}, "eval": {"HumanEval/9": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        rolling_max_list.append(current_max)\n    \n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/0": {"dps": 52.325581395348834, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no close elements are found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no such pair is found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers_sorted = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    \n    # If no close elements are found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no close elements are found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no such pair is found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no close elements are found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers_sorted = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    \n    # If no close elements are found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no close elements are found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers_sorted = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    \n    # If no such pair is found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no close elements are found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no close elements are found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily check adjacent elements\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no close elements found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no close elements found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no close elements are found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no close elements found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no such pair is found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no close elements found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    \n    # If no such pair is found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no such pair is found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    \n    # If no close elements are found, return False\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 76.26582278481013, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    absolute_differences = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute differences\n    mad = sum(absolute_differences) / len(absolute_differences)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    absolute_differences = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute differences\n    mad = sum(absolute_differences) / len(absolute_differences)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    absolute_differences = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute differences\n    mad = sum(absolute_differences) / len(absolute_differences)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    absolute_differences = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute differences\n    mad = sum(absolute_differences) / len(absolute_differences)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    absolute_differences = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute differences\n    mad = sum(absolute_differences) / len(absolute_differences)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    absolute_differences = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute differences\n    mad = sum(absolute_differences) / len(absolute_differences)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 4}]}, "HumanEval/16": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to make finding the closest pair easier\n    numbers.sort()\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[1] - numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(numbers)):\n        current_diff = abs(numbers[i] - numbers[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (numbers[i - 1], numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i-1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i-1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i+1] - sorted_numbers[i])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to find the closest elements efficiently\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make it easier to find the closest pair\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to find the closest elements efficiently\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to find the closest elements efficiently\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to make finding the closest pair easier\n    numbers_sorted = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (numbers_sorted[0], numbers_sorted[1])\n    min_diff = abs(numbers_sorted[1] - numbers_sorted[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(numbers_sorted)):\n        current_diff = abs(numbers_sorted[i] - numbers_sorted[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (numbers_sorted[i - 1], numbers_sorted[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to easily find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 64.45578231292518, "dps_norm": 23.125, "pass@1": 100.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisors for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisors for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor exists for numbers less than or equal to 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}]}, "HumanEval/26": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if counts[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if counts[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if counts[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if counts[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if counts[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    counts = Counter(numbers)\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if counts[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    counts = Counter(numbers)\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if counts[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = {}\n    for num in numbers:\n        count[num] = count.get(num, 0) + 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if counts[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if counts[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 50.63291139240506, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}]}, "HumanEval/33": {"dps": 97.22222222222223, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[index]\n            index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[index]\n            index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list by replacing the elements at indices divisible by 3 with the sorted ones\n    result = l.copy()\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[index]\n            index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[index]\n            index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[index]\n            index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list by replacing the elements at indices divisible by 3 with the sorted elements\n    result = l.copy()\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list by replacing the elements at indices divisible by 3 with the sorted elements\n    result = l.copy()\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list by replacing the elements at indices divisible by 3 with the sorted ones\n    result = l.copy()\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[index]\n            index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[index]\n            index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    for i, sorted_value in zip(range(0, len(l), 3), sorted_divisible_by_three):\n        result[i] = sorted_value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list with the sorted elements at the correct positions\n    result = l.copy()\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list by replacing the elements at indices divisible by 3 with the sorted elements\n    result = l.copy()\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[index]\n            index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list by replacing the elements at indices divisible by 3 with the sorted elements\n    result = l.copy()\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then back to a list\n    unique_elements = list(set(l))\n    # Sort the list of unique elements\n    unique_elements.sort()\n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then back to a list and sort it\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n        n (int): The upper limit (exclusive) for the range of integers to consider.\n    \n    Returns:\n        int: The count of the digit 7 in numbers less than n that are divisible by 11 or 13.\n    \n    Examples:\n        >>> fizz_buzz(50)\n        0\n        >>> fizz_buzz(78)\n        2\n        >>> fizz_buzz(79)\n        3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n        n (int): The upper limit (exclusive) for the range of integers to consider.\n    \n    Returns:\n        int: The count of the digit 7 in numbers less than n that are divisible by 11 or 13.\n    \n    Examples:\n        >>> fizz_buzz(50)\n        0\n        >>> fizz_buzz(78)\n        2\n        >>> fizz_buzz(79)\n        3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n        n (int): The upper limit (exclusive) for the range of integers to consider.\n    \n    Returns:\n        int: The count of the digit 7 in numbers less than n that are divisible by 11 or 13.\n    \n    Examples:\n        >>> fizz_buzz(50)\n        0\n        >>> fizz_buzz(78)\n        2\n        >>> fizz_buzz(79)\n        3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n        n (int): The upper limit (exclusive) for the range of integers to consider.\n    \n    Returns:\n        int: The count of the digit 7 in numbers less than n that are divisible by 11 or 13.\n    \n    Examples:\n        >>> fizz_buzz(50)\n        0\n        >>> fizz_buzz(78)\n        2\n        >>> fizz_buzz(79)\n        3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n        n (int): The upper limit (exclusive) for the range of numbers to consider.\n    \n    Returns:\n        int: The count of the digit 7 in numbers less than n that are divisible by 11 or 13.\n    \n    Examples:\n        >>> fizz_buzz(50)\n        0\n        >>> fizz_buzz(78)\n        2\n        >>> fizz_buzz(79)\n        3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 94.92635024549918, "dps_norm": 90.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the elements at even indices\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even elements\n    sorted_even_elements = sorted(even_elements)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at even indices with the sorted elements\n    for i, sorted_element in zip(range(0, len(l), 2), sorted_even_elements):\n        result[i] = sorted_element\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract values at even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the values at even indices\n    sorted_even_values = sorted(even_indices_values)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the values at even indices with the sorted values\n    for i, sorted_value in zip(range(0, len(l), 2), sorted_even_values):\n        result[i] = sorted_value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_indices = l[::2]\n    # Sort the even-indexed elements\n    sorted_even = sorted(even_indices)\n    # Create a new list to store the result\n    result = l.copy()\n    # Replace the even-indexed elements with the sorted ones\n    for i, value in enumerate(sorted_even):\n        result[2 * i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the values at even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the values at even indices\n    sorted_even_values = sorted(even_indices_values)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the values at even indices with the sorted values\n    for i, value in enumerate(sorted_even_values):\n        result[i * 2] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_indices = l[::2]\n    # Sort the even-indexed elements\n    sorted_even = sorted(even_indices)\n    # Create a new list to store the result\n    result = l.copy()\n    # Replace the even-indexed elements with the sorted ones\n    for i, value in enumerate(sorted_even):\n        result[2 * i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_indices = l[::2]\n    # Sort the even-indexed elements\n    sorted_even = sorted(even_indices)\n    # Create a copy of the original list to modify\n    result = l.copy()\n    # Replace the even-indexed elements with the sorted ones\n    for i, value in enumerate(sorted_even):\n        result[2 * i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the elements at even indices\n    even_indices = l[::2]\n    \n    # Sort the elements at even indices\n    sorted_even_indices = sorted(even_indices)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the elements at even indices with the sorted ones\n    for i, value in enumerate(sorted_even_indices):\n        result[i * 2] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract values at even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the values at even indices\n    sorted_even_values = sorted(even_indices_values)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the values at even indices with the sorted values\n    for i, sorted_value in zip(range(0, len(l), 2), sorted_even_values):\n        result[i] = sorted_value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_indices = l[::2]\n    # Sort the even-indexed elements\n    sorted_even = sorted(even_indices)\n    # Create a new list to store the result\n    result = l.copy()\n    # Replace the even-indexed elements with the sorted ones\n    for i, value in enumerate(sorted_even):\n        result[2 * i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_indices = l[::2]\n    # Sort the even-indexed elements\n    sorted_even = sorted(even_indices)\n    # Create a new list to store the result\n    result = l.copy()\n    # Replace the even-indexed elements with the sorted ones\n    for i, value in enumerate(sorted_even):\n        result[i * 2] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract values at even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the values at even indices\n    sorted_even_values = sorted(even_indices_values)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the values at even indices with the sorted values\n    for i, sorted_value in zip(range(0, len(l), 2), sorted_even_values):\n        result[i] = sorted_value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_indices = l[::2]\n    # Sort the even-indexed elements\n    sorted_even = sorted(even_indices)\n    # Create a new list to store the result\n    result = l.copy()\n    # Replace the even-indexed elements with the sorted ones\n    for i, value in enumerate(sorted_even):\n        result[2 * i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the values at even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the values at even indices\n    sorted_even_values = sorted(even_indices_values)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the values at even indices with the sorted values\n    for i, value in enumerate(sorted_even_values):\n        result[2 * i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_indices = l[::2]\n    # Sort the even-indexed elements\n    sorted_even = sorted(even_indices)\n    # Create a new list to store the result\n    result = l.copy()\n    # Replace the even-indexed elements with the sorted ones\n    for i, value in enumerate(sorted_even):\n        result[2 * i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the values at even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the values at even indices\n    sorted_even_values = sorted(even_indices_values)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the values at even indices with the sorted values\n    for i, value in enumerate(sorted_even_values):\n        result[2 * i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract values at even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the values at even indices\n    sorted_even_values = sorted(even_indices_values)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the values at even indices with the sorted values\n    for i, sorted_value in zip(range(0, len(l), 2), sorted_even_values):\n        result[i] = sorted_value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_indices = l[::2]\n    # Sort the even-indexed elements\n    sorted_even = sorted(even_indices)\n    # Create a new list to store the result\n    result = l.copy()\n    # Replace the even-indexed elements with the sorted ones\n    for i, value in enumerate(sorted_even):\n        result[2 * i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_indices = l[::2]\n    # Sort the even-indexed elements\n    sorted_even = sorted(even_indices)\n    # Create a new list to store the result\n    result = l.copy()\n    # Replace the even-indexed elements with the sorted ones\n    for i, value in enumerate(sorted_even):\n        result[2 * i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the elements at even indices\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace the even indices in the result with the sorted values\n    for i, value in enumerate(sorted_even):\n        result[i * 2] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_indices = l[::2]\n    # Sort the even-indexed elements\n    sorted_even = sorted(even_indices)\n    # Create a new list to store the result\n    result = l.copy()\n    # Replace the even-indexed elements with the sorted ones\n    for i, value in enumerate(sorted_even):\n        result[i * 2] = value\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 93.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p efficiently using exponentiation by squaring.\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        n = n // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        n = n // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p efficiently using exponentiation by squaring.\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        n = n // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p efficiently using exponentiation by squaring.\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        n = n // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        n = n // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters and compare them\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters and compare them\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters and compare them\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A sorted list of unique common elements.\n    \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Find the intersection of the two lists\n    common_elements = set(l1).intersection(set(l2))\n    \n    # Sort the result and convert it to a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A sorted list of unique common elements.\n    \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Find the intersection of the two lists and convert to a set to remove duplicates\n    common_elements = set(l1).intersection(set(l2))\n    \n    # Sort the result and return as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A sorted list of unique common elements.\n    \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Find the intersection of the two lists\n    common_elements = set(l1).intersection(set(l2))\n    # Sort the result and convert it back to a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A sorted list of unique common elements.\n    \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Find the intersection of the two lists and convert it to a set to remove duplicates\n    common_elements = set(l1).intersection(set(l2))\n    \n    # Sort the result and convert it back to a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Sort the common elements and return as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Sort the common elements and return as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Sort the common elements and return as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Sort the result and return as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Sort the result and return as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A sorted list of unique common elements.\n    \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Find the intersection of the two lists and convert it to a set to remove duplicates\n    common_elements = set(l1).intersection(set(l2))\n    \n    # Sort the result and return it as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A sorted list of unique common elements.\n    \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Find the intersection of the two lists and convert it to a set to remove duplicates\n    common_elements = set(l1).intersection(set(l2))\n    \n    # Sort the common elements and return them as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A sorted list of unique common elements.\n    \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Find the intersection of the two lists and convert it to a set to remove duplicates\n    common_elements = set(l1).intersection(set(l2))\n    \n    # Sort the result and return it as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find the intersection (common elements)\n    common_elements = set(l1).intersection(set(l2))\n    # Sort the result and convert it back to a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A sorted list of unique common elements.\n    \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Sort the common elements and return as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Sort the result and convert it back to a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A sorted list of unique common elements.\n    \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Find the intersection of the two lists\n    common_elements = set(l1).intersection(set(l2))\n    \n    # Sort the common elements and return as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A sorted list of unique common elements.\n    \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Find the intersection of the two lists and convert it to a set to remove duplicates\n    common_elements = set(l1).intersection(set(l2))\n    \n    # Sort the common elements and return them as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A sorted list of unique common elements.\n    \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Sort the common elements and return as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A sorted list of unique common elements.\n    \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Find the intersection of the two lists and convert it to a set to remove duplicates\n    common_elements = set(l1).intersection(set(l2))\n    \n    # Sort the result and convert it back to a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 57.46527777777778, "dps_norm": 94.44444444444444, "pass@1": 100.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(m: int) -> bool:\n        \"\"\"Check if m is a prime number.\"\"\"\n        if m < 2:\n            return False\n        for i in range(2, int(m**0.5) + 1):\n            if m % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check for the smallest prime factors and divide n accordingly\n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    # If n is still greater than 1, it must be a prime factor\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check for the smallest prime factors and divide n by them\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # Check if i is a prime factor\n            if is_prime(i):\n                largest_factor = i\n            # Check if the corresponding factor (n // i) is a prime factor\n            if is_prime(n // i):\n                largest_factor = n // i\n                break  # Since we are iterating from smallest to largest, the first prime factor found is the largest\n\n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check for the smallest prime factors and divide n by them\n    for i in range(2, int(n ** 0.5) + 1):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    # If n is still greater than 1, it is a prime factor\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check divisibility by 2 separately\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    # Check odd factors starting from 3\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n    # If n is still greater than 2, it must be prime\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check for the smallest prime factors and divide n accordingly\n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    # If n is still greater than 1, it must be a prime factor\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(m: int) -> bool:\n        \"\"\"Check if m is a prime number.\"\"\"\n        if m < 2:\n            return False\n        for i in range(2, int(m**0.5) + 1):\n            if m % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check divisibility by 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    # Check divisibility by odd numbers starting from 3\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n    # If n is still greater than 2, it must be prime\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(m: int) -> bool:\n        \"\"\"Check if m is a prime number.\"\"\"\n        if m < 2:\n            return False\n        for i in range(2, int(m**0.5) + 1):\n            if m % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # Check if i is a prime factor\n            if is_prime(i):\n                largest_factor = i\n            # Check if the corresponding factor (n // i) is a prime factor\n            if is_prime(n // i):\n                largest_factor = n // i\n                break  # Since we are iterating from smallest to largest, the first prime factor found here is the largest\n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors and divide n accordingly\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # Check if i is a prime factor\n            if is_prime(i):\n                largest_factor = max(largest_factor, i)\n            # Check if the corresponding factor (n // i) is a prime factor\n            if is_prime(n // i):\n                largest_factor = max(largest_factor, n // i)\n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check for the smallest prime factors and divide n accordingly\n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    # If n is still greater than 1, it must be a prime factor\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(m: int) -> bool:\n        \"\"\"Check if m is a prime number.\"\"\"\n        if m < 2:\n            return False\n        for i in range(2, int(m**0.5) + 1):\n            if m % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a factor, check if it's prime\n            if is_prime(i):\n                largest_factor = i\n            # Check if the corresponding factor is prime\n            if is_prime(n // i):\n                largest_factor = n // i\n                break  # Since we're iterating from smallest to largest, the last prime factor found is the largest\n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a factor, check if it's prime\n            if is_prime(i):\n                largest_factor = i\n            # Check the corresponding factor (n // i)\n            if is_prime(n // i):\n                largest_factor = n // i\n                break  # Since we're iterating from smallest to largest, this is the largest prime factor\n\n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = i\n            if is_prime(n // i):\n                largest_factor = n // i\n                break\n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(m: int) -> bool:\n        \"\"\"Check if m is a prime number.\"\"\"\n        if m < 2:\n            return False\n        for i in range(2, int(m**0.5) + 1):\n            if m % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check divisibility by 2 separately\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    # Check odd factors from 3 to sqrt(n)\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n    # If n is still greater than 2, it must be prime\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(m: int) -> bool:\n        \"\"\"Check if m is a prime number.\"\"\"\n        if m < 2:\n            return False\n        for i in range(2, int(m**0.5) + 1):\n            if m % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # Check if i is a prime factor\n            if is_prime(i):\n                largest_factor = i\n            # Check if the corresponding factor (n // i) is a prime factor\n            if is_prime(n // i):\n                largest_factor = n // i\n                break  # Since we are iterating from smallest to largest, the first prime factor found here is the largest\n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors and divide n accordingly\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = i\n            # Check if the corresponding factor is prime\n            if is_prime(n // i):\n                largest_factor = n // i\n                break  # Since we are iterating from smallest to largest, the largest prime factor is found\n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = i\n            if is_prime(n // i):\n                largest_factor = n // i\n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = i\n            if is_prime(n // i):\n                largest_factor = n // i\n                break\n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check divisibility by 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    # Check divisibility by odd numbers starting from 3\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n    # If n is still greater than 2, it must be prime\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(m: int) -> bool:\n        \"\"\"Check if m is a prime number.\"\"\"\n        if m < 2:\n            return False\n        for i in range(2, int(m**0.5) + 1):\n            if m % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check divisibility by 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    # Check divisibility by odd numbers starting from 3\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n    # If n is still greater than 2, it must be prime\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(m: int) -> bool:\n        \"\"\"Check if m is a prime number.\"\"\"\n        if m < 2:\n            return False\n        for i in range(2, int(m**0.5) + 1):\n            if m % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check divisibility by 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    # Check divisibility by odd numbers starting from 3\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n    # If n is still greater than 2, it must be prime\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 67.66233766233766, "dps_norm": 55.0, "pass@1": 100.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    \n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()  # Convert to lowercase to handle uppercase vowels\n    \n    # Count vowels in the string\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the string\n    if len(s_lower) > 0 and s_lower[-1] == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    \n    # Count vowels in the string\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the string\n    if s_lower.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    \n    # Count vowels in the string\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the string\n    if len(s_lower) > 0 and s_lower[-1] == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()  # Convert to lowercase to handle both uppercase and lowercase vowels\n    \n    # Count vowels in the string\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y' and count it as a vowel\n    if len(s_lower) > 0 and s_lower[-1] == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()  # Convert to lowercase to handle uppercase vowels\n    \n    # Count vowels in the string\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the word\n    if len(s_lower) > 0 and s_lower[-1] == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    \n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()  # Convert to lowercase to handle uppercase vowels\n    \n    # Count vowels in the string\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the string\n    if len(s_lower) > 0 and s_lower[-1] == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    \n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()  # Convert to lowercase to handle uppercase vowels\n    \n    # Count vowels in the string\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the string\n    if len(s_lower) > 0 and s_lower[-1] == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()  # Convert to lowercase to handle uppercase vowels\n    \n    # Count vowels in the string\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the string\n    if s_lower.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    \n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    \n    # Count vowels in the string\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y'\n    if len(s_lower) > 0 and s_lower[-1] == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    \n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        if char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        if char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()  # Convert to lowercase to handle both uppercase and lowercase vowels\n    \n    # Count vowels in the string\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the string\n    if len(s_lower) > 0 and s_lower[-1] == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()  # Convert to lowercase to handle both uppercase and lowercase vowels\n    \n    # Count vowels in the string\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the string\n    if s_lower.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()  # Convert to lowercase to handle both uppercase and lowercase vowels\n    \n    # Count vowels in the string\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the string\n    if len(s_lower) > 0 and s_lower[-1] == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    \n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 3}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 83.66336633663366, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:  # Check if index is odd and value is even\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:  # Check if index is odd and value is even\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:  # Check if index is odd and value is even\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:  # Check if index is odd and value is even\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:  # Check if index is odd and value is even\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:  # Check if index is odd and value is even\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    # Sort each word's characters based on ASCII value\n    sorted_words = [''.join(sorted(word)) for word in words]\n    # Join the sorted words back into a single string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    words = s.split(' ')\n    \n    # Process each word\n    ordered_words = []\n    for word in words:\n        # Sort the characters in the word based on ASCII value\n        sorted_word = ''.join(sorted(word))\n        ordered_words.append(sorted_word)\n    \n    # Join the words back together with spaces\n    ordered_sentence = ' '.join(ordered_words)\n    \n    return ordered_sentence", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort the characters in each word based on ASCII value\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort each word's characters based on ASCII value\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    parts = s.split(' ')\n    \n    # Process each word\n    ordered_parts = []\n    for part in parts:\n        # Sort the characters in the word based on ASCII value\n        sorted_part = ''.join(sorted(part))\n        ordered_parts.append(sorted_part)\n    \n    # Join the processed words with spaces\n    ordered_string = ' '.join(ordered_parts)\n    \n    return ordered_string", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: The order of words and blank spaces in the sentence is preserved.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort the characters in each word based on ASCII value\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    parts = s.split(' ')\n    # Process each word\n    ordered_parts = []\n    for part in parts:\n        # Sort the characters in the word based on ASCII value\n        sorted_part = ''.join(sorted(part))\n        ordered_parts.append(sorted_part)\n    # Join the processed words with spaces\n    return ' '.join(ordered_parts)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort the characters in each word based on ASCII value\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort the characters in each word based on ASCII value\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Reorders the characters of each word in the string in ascending order based on ASCII value,\n    while preserving the original order of words and spaces.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string with each word's characters sorted in ascending order.\n    \"\"\"\n    words = s.split(' ')  # Split the string into words based on spaces\n    ordered_words = []\n    \n    for word in words:\n        # Sort the characters of the word based on their ASCII value\n        sorted_word = ''.join(sorted(word))\n        ordered_words.append(sorted_word)\n    \n    # Join the ordered words with spaces in between\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    parts = s.split(' ')\n    # Process each word\n    ordered_parts = []\n    for part in parts:\n        # Sort the characters in the word based on ASCII value\n        sorted_part = ''.join(sorted(part))\n        ordered_parts.append(sorted_part)\n    # Join the processed words with spaces\n    return ' '.join(ordered_parts)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    words = s.split(' ')\n    # Sort each word based on ASCII value\n    sorted_words = [''.join(sorted(word)) for word in words]\n    # Join the sorted words with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort each word's characters based on ASCII value\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort the characters in each word based on ASCII value\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    parts = s.split(' ')\n    # Process each word\n    ordered_parts = []\n    for part in parts:\n        # Sort the characters in the word based on ASCII value\n        sorted_part = ''.join(sorted(part))\n        ordered_parts.append(sorted_part)\n    # Join the processed words with spaces\n    return ' '.join(ordered_parts)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort the characters in each word based on ASCII value\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort the characters in each word based on ASCII value\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort the characters in each word based on ASCII value\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort each word's characters based on ASCII value\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    words = s.split(' ')\n    \n    # Process each word\n    ordered_words = []\n    for word in words:\n        # Sort the characters in the word based on ASCII value\n        sorted_word = ''.join(sorted(word))\n        ordered_words.append(sorted_word)\n    \n    # Join the processed words with spaces\n    ordered_sentence = ' '.join(ordered_words)\n    \n    return ordered_sentence", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 93.94812680115274, "dps_norm": 57.142857142857146, "pass@1": 99.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    The coordinates are sorted first by row in ascending order, and then by column in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    The coordinates are sorted first by row in ascending order, and then by column in descending order.\n    \n    Examples:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    >>> get_row([], 1)\n    []\n    \n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    Coordinates are sorted first by row in ascending order, and then by column in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    The coordinates are sorted first by row in ascending order, and then by column in descending order.\n    \n    Examples:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    >>> get_row([], 1)\n    []\n    \n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    The coordinates are sorted first by row in ascending order, and then by column in descending order.\n    \n    Examples:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    >>> get_row([], 1)\n    []\n    \n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all columns in the current row where the value is x\n        cols = [col_idx for col_idx, val in enumerate(row) if val == x]\n        # Sort columns in descending order\n        cols.sort(reverse=True)\n        # Append the coordinates to the result\n        for col_idx in cols:\n            result.append((row_idx, col_idx))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    The coordinates are sorted first by row in ascending order, and then by column in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    Coordinates are sorted first by row in ascending order, and then by column in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    The coordinates are sorted first by row in ascending order, and then by column in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    Coordinates are sorted first by row in ascending order, and then by column in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    The coordinates are sorted first by row in ascending order, and then by column in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    The coordinates are sorted first by row in ascending order, and then by column in descending order.\n\n    Examples:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    Coordinates are sorted first by row in ascending order, and then by column in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    Coordinates are sorted first by row in ascending order, and then by column in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list `lst` and an integer `x`, find all occurrences of `x` in the list.\n    Return a list of tuples representing the coordinates (row, column) of each occurrence.\n    Coordinates are sorted first by row in ascending order, and then by column in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2-dimensional nested list `lst` and an integer `x`, \n    find all occurrences of `x` in the list and return their coordinates \n    as a list of tuples. The coordinates are sorted first by row in ascending \n    order, and then by column in descending order.\n\n    Args:\n    lst (list of list of int): The 2-dimensional nested list.\n    x (int): The integer to search for.\n\n    Returns:\n    list of tuple: List of coordinates (row, column) where `x` is found.\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer x in the nested list lst and returns their coordinates.\n    Coordinates are sorted by rows in ascending order and by columns in descending order.\n    \n    Args:\n    lst (list of list of int): The nested list to search.\n    x (int): The integer to find in the nested list.\n    \n    Returns:\n    list of tuple: A list of coordinates (row, column) where x is found.\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.64948453608248, "dps_norm": 28.571428571428573, "pass@1": 100.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each letter in the alphabet by 4 positions.\n    \n    Args:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions within the lowercase alphabet\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift character by 4 positions within the uppercase alphabet\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    The rotation is equivalent to shifting down by two multiplied by two places (2 * 2 = 4).\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':  # Handle lowercase letters\n            # Shift character by 4 positions, wrapping around if necessary\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':  # Handle uppercase letters\n            # Shift character by 4 positions, wrapping around if necessary\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    \n    Args:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift the character by 4 positions within the lowercase alphabet\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift the character by 4 positions within the uppercase alphabet\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    The rotation is equivalent to shifting each character down by two multiplied by two places.\n    For example:\n    'a' -> 'e', 'b' -> 'f', ..., 'z' -> 'd'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift lowercase letters\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase letters\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    \n    Args:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift the character by 4 positions within the lowercase alphabet\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift the character by 4 positions within the uppercase alphabet\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each letter in the alphabet by 4 positions.\n    For example, 'a' becomes 'e', 'b' becomes 'f', etc.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':  # Handle lowercase letters\n            # Shift the character by 4 positions, wrapping around if necessary\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':  # Handle uppercase letters\n            # Shift the character by 4 positions, wrapping around if necessary\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    The rotation is equivalent to shifting each character down by two multiplied by two places.\n    For example:\n    'a' -> 'e', 'b' -> 'f', ..., 'z' -> 'd'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift lowercase letters\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(shifted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase letters\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(shifted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    \n    Args:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift the character by 4 positions within the lowercase alphabet\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift the character by 4 positions within the uppercase alphabet\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    \n    Args:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift the character by 4 positions within the lowercase alphabet\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift the character by 4 positions within the uppercase alphabet\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each letter in the alphabet by 4 positions.\n    For example, 'a' becomes 'e', 'b' becomes 'f', etc.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift lowercase letters by 4 positions\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase letters by 4 positions\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    \n    Args:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions within the lowercase alphabet\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift character by 4 positions within the uppercase alphabet\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    \n    Args:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift the character by 4 positions within the lowercase alphabet\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift the character by 4 positions within the uppercase alphabet\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    The rotation is equivalent to shifting each character down by two multiplied by two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift the character by 4 positions within the lowercase alphabet\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(shifted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift the character by 4 positions within the uppercase alphabet\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(shifted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    \n    Args:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift the character by 4 positions within the lowercase alphabet\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift the character by 4 positions within the uppercase alphabet\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    \n    Args:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions within the lowercase alphabet\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift character by 4 positions within the uppercase alphabet\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    For example, 'a' becomes 'e', 'b' becomes 'f', etc.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift lowercase letters\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(shifted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase letters\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(shifted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each letter in the alphabet by 4 positions.\n    \n    Args:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions within the lowercase alphabet\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift character by 4 positions within the uppercase alphabet\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each letter in the alphabet by 4 positions.\n    \n    Args:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions within the lowercase alphabet\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(shifted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift character by 4 positions within the uppercase alphabet\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(shifted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each character in the alphabet by 4 positions.\n    The rotation is equivalent to shifting each character down by two multiplied by two places.\n    \n    Args:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift the character by 4 positions within the lowercase alphabet\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift the character by 4 positions within the uppercase alphabet\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating each letter in the alphabet by 4 positions.\n    For example, 'a' becomes 'e', 'b' becomes 'f', etc.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift lowercase letters by 4 positions\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase letters by 4 positions\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Leave non-alphabet characters unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 87.54863813229572, "dps_norm": 58.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the 2nd smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the 2nd smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the 2nd smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the 2nd smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the 2nd smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the 2nd smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the 2nd smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the 2nd smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 98.98580121703854, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's in the template with the count\n        sentence = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(sentence)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace 'i' with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace 'i' with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace 'i' with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's in the template with the count\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace 'i' with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all 'i's with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace 'i' with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace 'i' with the count in the template string\n        output = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s):\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    s1, s2 = lst\n    # Try concatenating s1 + s2\n    combined1 = s1 + s2\n    if is_balanced(combined1):\n        return 'Yes'\n    # Try concatenating s2 + s1\n    combined2 = s2 + s1\n    if is_balanced(combined2):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s):\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    s1, s2 = lst\n    # Try concatenating s1 + s2\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    # Try concatenating s2 + s1\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s):\n    '''\n    Helper function to check if a string of parentheses is balanced.\n    '''\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    '''\n    Check if it is possible to concatenate the two strings in some order\n    to form a balanced string of parentheses.\n    '''\n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s):\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    s1, s2 = lst\n    # Try concatenating s1 + s2\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    # Try concatenating s2 + s1\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s):\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s):\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s):\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s):\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    s1, s2 = lst\n    # Try concatenating s1 + s2\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    # Try concatenating s2 + s1\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s):\n    '''\n    Helper function to check if a string of parentheses is balanced.\n    '''\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    '''\n    Check if it is possible to concatenate the two strings in some order\n    to form a balanced string of parentheses.\n    '''\n    s1, s2 = lst\n    # Try both possible concatenations\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Get the last k elements (the largest k elements)\n    max_k_elements = sorted_arr[-k:]\n    # Return the sorted list of the maximum k elements\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Select the last k elements (the largest k elements)\n    max_k = sorted_arr[-k:]\n    # Return the sorted list of the largest k elements\n    return sorted(max_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    arr_sorted = sorted(arr)\n    # Select the last k elements (the largest k elements)\n    max_k = arr_sorted[-k:]\n    # Return the sorted list of the maximum k numbers\n    return sorted(max_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Select the last k elements (the largest k elements)\n    max_k = sorted_arr[-k:]\n    # Return the sorted list of the largest k elements\n    return sorted(max_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    arr_sorted = sorted(arr)\n    # Get the last k elements (the largest k elements)\n    max_k = arr_sorted[-k:]\n    return max_k", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Get the last k elements (the largest k elements)\n    max_k_elements = sorted_arr[-k:]\n    \n    return max_k_elements", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Get the last k elements (the largest k elements)\n    max_k = sorted_arr[-k:]\n    # Return the sorted list of the largest k elements\n    return sorted(max_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Get the last k elements (the largest k elements)\n    max_k_elements = sorted_arr[-k:]\n    return max_k_elements", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Select the last k elements (the largest k elements)\n    max_k = sorted_arr[-k:]\n    # Return the sorted list of the largest k elements\n    return sorted(max_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Select the last k elements (the largest k elements)\n    max_k = sorted_arr[-k:]\n    # Return the sorted list of the largest k elements\n    return sorted(max_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Get the last k elements (the largest k elements)\n    max_k = sorted_arr[-k:]\n    # Return the sorted list of the largest k elements\n    return sorted(max_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Get the last k elements (the largest k elements)\n    max_k_elements = sorted_arr[-k:]\n    # Return the sorted list of the largest k elements\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    arr_sorted = sorted(arr)\n    # Select the last k elements (the largest k elements)\n    max_k = arr_sorted[-k:]\n    # Return the sorted list of the largest k elements\n    return sorted(max_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    arr_sorted = sorted(arr)\n    # Select the last k elements (the largest k elements)\n    max_k = arr_sorted[-k:]\n    # Return the sorted list of the largest k elements\n    return sorted(max_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Get the last k elements (the largest k elements)\n    max_k = sorted_arr[-k:]\n    # Return the sorted list of the largest k elements\n    return sorted(max_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Select the last k elements (the largest k elements)\n    max_k_elements = sorted_arr[-k:]\n    # Return the sorted list of the maximum k elements\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Get the last k elements (the largest k elements)\n    max_k = sorted_arr[-k:]\n    # Return the sorted list of the largest k elements\n    return sorted(max_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Get the last k elements (the largest k elements)\n    max_k_elements = sorted_arr[-k:]\n    return max_k_elements", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    arr_sorted = sorted(arr)\n    # Select the last k elements (the largest k elements)\n    max_k = arr_sorted[-k:]\n    return max_k", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    arr_sorted = sorted(arr)\n    # Get the last k elements (the largest k elements)\n    max_k = arr_sorted[-k:]\n    return max_k", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 87.17488789237669, "dps_norm": 65.71428571428572, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:  # Check if position is even and value is odd\n            total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths and sorts the remaining strings first by length,\n    then alphabetically if lengths are equal.\n\n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A list of strings with even lengths, sorted first by length\n                     and then alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    \n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths and sorts the remaining strings first by length,\n    then alphabetically if lengths are equal.\n    \n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A list of strings with even lengths, sorted by length and alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A list of strings with even lengths, sorted by length and alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A list of strings with even lengths, sorted first by length\n                     and then alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A list of strings with even lengths, sorted first by length\n                     and then alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A list of strings with even lengths, sorted first by length\n                     and then alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths and sorts the remaining strings.\n    The sorting is first by length in ascending order, then alphabetically.\n    \n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths and sorts the remaining strings first by length,\n    then alphabetically if lengths are equal.\n    \n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths and sorts the remaining strings.\n    The sorting is first by length in ascending order, then alphabetically.\n    \n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A list of strings with even lengths, sorted first by length\n                     and then alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths and sorts the remaining strings first by length,\n    then alphabetically if lengths are equal.\n\n    Args:\n        lst (list of str): The list of strings to process.\n\n    Returns:\n        list of str: The filtered and sorted list of strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A list of strings with even lengths, sorted by length and alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths and sorts the remaining strings\n    first by length and then alphabetically.\n\n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A list of strings with even lengths, sorted first by length\n                     and then alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A list of strings with even lengths, sorted first by length\n                     and then alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A list of strings with even lengths, sorted first by length\n                     and then alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A list of strings with even lengths, sorted by length and alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A list of strings with even lengths, sorted first by length\n                     and then alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 86.77966101694915, "dps_norm": 92.5, "pass@1": 100.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if not numbers or n <= 0:\n        return []\n    \n    # Use heapq's nlargest function to get the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    \n    # Return the result in descending order\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    # Use heapq's nlargest function to get the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    \n    # Return the result in descending order\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if not numbers or n <= 0:\n        return []\n    \n    # Use heapq to find the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    \n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    # Use heapq to find the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    \n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use heapq's nlargest function to get the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use heapq's nlargest function to get the n largest elements\n    largest = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    # Use heapq to find the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    \n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use heapq's nlargest function to get the n largest elements\n    largest = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use heapq's nlargest function to get the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use heapq's nlargest function to get the n largest elements\n    largest = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use heapq's nlargest function to get the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use heapq's nlargest function to get the n largest elements\n    largest = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use heapq's nlargest function to get the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    # Use heapq's nlargest function to get the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    \n    # Return the result in descending order\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use heapq's nlargest function to get the n largest elements\n    largest = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    # Use heapq's nlargest function to get the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    \n    # Return the result in descending order\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    # Use heapq's nlargest function to get the n largest elements\n    largest = heapq.nlargest(n, numbers)\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use heapq's nlargest function to get the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use heapq's nlargest function to get the n largest elements\n    largest = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use heapq's nlargest function to get the n largest elements\n    largest = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return largest", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 50.34013605442177, "dps_norm": 50.0, "pass@1": 33.0, "profiled": [{"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    # Check for all possible rotations\n    for i in range(1, n + 1):\n        # Rotate the string by i positions\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n  # If no rotation found, return the length of the string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    # Check for all possible rotations\n    for i in range(1, n + 1):\n        # Rotate the string by i positions\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n  # If no rotation found, return the length of the string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    :param s: The input string\n    :return: The minimum number of rotations required\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Check for all possible rotations\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    :param s: The input string\n    :return: The minimum number of rotations required\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    # Check for all possible rotations\n    for i in range(1, n + 1):\n        # Rotate the string by i positions\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    :param s: The input string\n    :return: The minimum number of rotations required\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    # Iterate over all possible rotation lengths\n    for i in range(1, n + 1):\n        # Check if the string is the same after rotation\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    # Check for all possible rotations\n    for i in range(1, n + 1):\n        # Rotate the string by i positions\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n  # If no rotation found, return the length of the string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    # Check for all possible rotations\n    for i in range(1, n + 1):\n        # Rotate the string by i positions\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    :param s: Input string\n    :return: Minimum number of rotations\n    \"\"\"\n    n = len(s)\n    # Check if the string is empty or has only one character\n    if n == 0 or n == 1:\n        return 1\n    # Iterate through possible rotation lengths\n    for i in range(1, n + 1):\n        # Check if rotating the string by i positions results in the same string\n        if s == s[i:] + s[:i]:\n            return i\n    # If no rotation (other than full rotation) results in the same string, return n\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    :param s: The input string\n    :return: The minimum number of rotations required\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    # If the string is empty or has only one character, return 1\n    if n == 0 or n == 1:\n        return 1\n    # Iterate over possible rotation lengths\n    for i in range(1, n + 1):\n        # Check if the string is the same after i rotations\n        if s == s[i:] + s[:i]:\n            return i\n    # If no rotation (other than full rotation) results in the same string, return n\n    return n", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": 51.541218637992834, "dps_norm": 92.77777777777777, "pass@1": 20.0, "profiled": [{"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    \n    # Remove the last occurrence (note: the string has already been modified)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    \n    # Remove the last occurrence (note: the string has already been modified)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first and last occurrence of the character\n    # by slicing the string\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    \n    # Remove the last occurrence (note: the string has already been modified)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    :param s: The input string.\n    :param char: The character to remove.\n    :return: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = s.find(char)\n    if first_index == -1:\n        return s  # Character not found, return the original string\n    \n    # Find the index of the last occurrence\n    last_index = s.rfind(char)\n    if last_index == first_index:\n        # Only one occurrence, remove it\n        return s[:first_index] + s[first_index+1:]\n    \n    # Remove both first and last occurrence\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    \n    # Remove the last occurrence (note: the string has already been modified)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first and last occurrence of the character\n    # by slicing the string\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    \n    # Remove the last occurrence (note: the string has already been modified)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    \n    # Remove the last occurrence (note that the string has already been modified)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    \n    # Remove the last occurrence (note that the string has already been modified)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first and last occurrence of the character\n    # by slicing the string\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    \n    # Remove the last occurrence (note that the string has already been modified)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = s.find(char)\n    # Find the index of the last occurrence\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    # Remove the last occurrence (note: the string is now shorter)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    # Remove the last occurrence (note: the string has already been modified)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    :param s: The input string.\n    :param char: The character to remove.\n    :return: The string with the first and last occurrence of the character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = s.find(char)\n    # Find the index of the last occurrence\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    # Remove the last occurrence (note: the string has already been modified)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    \n    # Remove the last occurrence (note: the string has already been modified)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    :param s: The input string.\n    :param char: The character to remove.\n    :return: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = s.find(char)\n    if first_index == -1:\n        return s  # Character not found, return the original string\n\n    # Find the index of the last occurrence\n    last_index = s.rfind(char)\n    if last_index == first_index:\n        # Only one occurrence, remove it\n        return s[:first_index] + s[first_index + 1:]\n\n    # Remove the first and last occurrence\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    :param s: The input string.\n    :param char: The character to remove.\n    :return: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = s.find(char)\n    if first_index == -1:\n        return s  # Character not found, return the original string\n\n    # Find the index of the last occurrence\n    last_index = s.rfind(char)\n    if last_index == first_index:\n        # Only one occurrence, remove it\n        return s[:first_index] + s[first_index + 1:]\n\n    # Remove both first and last occurrence\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    \n    # Remove the last occurrence (note: the string has already been modified)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Remove the first and last occurrence of the character\n    # by slicing the string\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: List of lists representing the matrix\n    :return: List of lists representing the sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists representing the matrix\n    :return: Sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists representing the matrix\n    :return: List of lists representing the sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists representing the matrix\n    :return: Sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]\nsorted_matrix = sort_matrix(matrix)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists representing the matrix\n    :return: List of lists representing the sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists representing the matrix\n    :return: Sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: List of lists representing the matrix\n    :return: List of lists representing the sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists representing the matrix\n    :return: Sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: List of lists representing the matrix\n    :return: List of lists representing the sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists representing the matrix\n    :return: Sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and store it with the row\n    rows_with_sum = [(sum(row), row) for row in matrix]\n    \n    # Sort the rows based on the sum\n    rows_with_sum.sort(key=lambda x: x[0])\n    \n    # Extract the sorted rows\n    sorted_matrix = [row for (_, row) in rows_with_sum]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists representing the matrix\n    :return: List of lists representing the sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: List of lists representing the matrix\n    :return: List of lists representing the sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists representing the matrix\n    :return: List of lists representing the sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: List of lists representing the matrix\n    :return: List of lists representing the sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: List of lists representing the matrix\n    :return: Sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists representing the matrix\n    :return: List of lists representing the sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists representing the matrix\n    :return: List of lists representing the sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists representing the matrix\n    :return: List of lists representing the sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists representing the matrix\n    :return: List of lists representing the sorted matrix\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/19": {"dps": 69.94949494949495, "dps_norm": 83.0, "pass@1": 100.0, "profiled": [{"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set with the original list\n    if len(unique_elements) == len(arr):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate elements.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set to the original list\n    if len(unique_elements) == len(arr):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set to the original list\n    if len(unique_elements) == len(arr):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # If the length of the set is less than the length of the list, there are duplicates\n    return len(unique_elements) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set to the original list\n    if len(unique_elements) == len(arr):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set to the original list\n    if len(unique_elements) == len(arr):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set to the original list\n    if len(unique_elements) == len(arr):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set with the original list\n    if len(unique_elements) == len(arr):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list): The list of integers to check.\n\n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # If the length of the set is less than the length of the list, there are duplicates\n    return len(unique_elements) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list): The list of integers to check.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set to the original list\n    if len(unique_elements) == len(arr):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate element.\n\n    Parameters:\n    arr (list): List of integers to check for duplicates.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # If the length of the set is less than the length of the list, duplicates exist\n    return len(unique_elements) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate element.\n\n    Parameters:\n    arr (list): List of integers to check for duplicates.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set with the original list\n    if len(unique_elements) == len(arr):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list): The list of integers to check.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Use a set to store unique elements\n    unique_elements = set()\n    \n    for num in arr:\n        if num in unique_elements:\n            return True\n        unique_elements.add(num)\n    \n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate element.\n\n    Parameters:\n    arr (list): List of integers to check for duplicates.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # If the length of the set is less than the length of the list, duplicates exist\n    if len(unique_elements) < len(arr):\n        return True\n    else:\n        return False", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list): The list of integers to check.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Use a set to store unique elements\n    unique_elements = set()\n    \n    for num in arr:\n        if num in unique_elements:\n            return True\n        unique_elements.add(num)\n    \n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set to the original list\n    if len(unique_elements) == len(arr):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list): The list of integers to check.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # If the length of the set is less than the length of the list, duplicates exist\n    return len(unique_elements) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set to the original list\n    if len(unique_elements) == len(arr):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set with the original list\n    if len(unique_elements) == len(arr):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list): The list of integers to check.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Use a set to store unique elements\n    unique_elements = set()\n    \n    for num in arr:\n        if num in unique_elements:\n            return True\n        unique_elements.add(num)\n    \n    return False", "matching_cluster_idx": 14}]}, "Mbpp/62": {"dps": 70.0, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int/float: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Function to find the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    :param lst: List of numbers\n    :return: The smallest number in the list\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int/float: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    min_num = lst[0]\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    :param lst: List of numbers\n    :return: The smallest number in the list\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    :param lst: List of numbers\n    :return: The smallest number in the list\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    min_num = lst[0]\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    :param lst: List of numbers\n    :return: The smallest number in the list\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to check.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check for.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to check\n    :param k: The divisor to check against\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.56862745098039, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the given list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the given list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the given list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the given list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 79.51219512195122, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words\n    :return: Length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list of words.\n\n    :param words: List of words\n    :return: Length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list of words.\n\n    :param words: List of words\n    :return: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    Parameters:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words\n    :return: Length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words\n    :return: Length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 79.28353658536585, "dps_norm": 63.0, "pass@1": 99.0, "profiled": [{"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param lst: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = lst[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in lst:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param lst: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = lst[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in lst[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The input list is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param lst: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = lst[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in lst:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param lst: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = lst[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in lst:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The input list is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param lst: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = lst[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in lst[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 15.833333333333332, "dps_norm": 34.285714285714285, "pass@1": 100.0, "profiled": [{"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n\n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n\n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    if n < 1:\n        return 0  # Return 0 for non-positive integers\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n\n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n\n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the integer n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n\n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n\n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n\n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n\n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    if n < 1:\n        return 0  # Return 0 for non-positive integers\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        return 0  # 0 and negative numbers have no positive divisors\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n\n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n\n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n\n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n\n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    if n < 1:\n        return 0  # Return 0 for non-positive integers\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        return 0  # 0 and negative numbers have no positive divisors\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/97": {"dps": 99.65811965811966, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Initialize an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate over each element in the flattened list\n    for element in flattened_list:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            frequency_dict[element] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    :param lst: The list to append.\n    :param tpl: The tuple to which the list is appended.\n    :return: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    Parameters:\n    lst (list): The list to be appended.\n    tpl (tuple): The tuple to which the list is appended.\n\n    Returns:\n    tuple: The resulting tuple after appending the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    Parameters:\n    lst (list): The list to be appended.\n    tpl (tuple): The tuple to which the list is appended.\n\n    Returns:\n    tuple: The resulting tuple after appending the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    Parameters:\n    lst (list): The list to be appended.\n    tpl (tuple): The tuple to which the list is appended.\n\n    Returns:\n    tuple: The resulting tuple after appending the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    :param lst: The list to append.\n    :param tpl: The tuple to which the list is appended.\n    :return: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    :param lst: The list to append.\n    :param tpl: The tuple to which the list is appended.\n    :return: A new tuple with the list elements appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    :param lst: The list to append.\n    :param tpl: The tuple to which the list is appended.\n    :return: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    Parameters:\n    lst (list): The list to be appended.\n    tpl (tuple): The tuple to which the list is appended.\n\n    Returns:\n    tuple: The resulting tuple after appending the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    Parameters:\n    lst (list): The list to be appended.\n    tpl (tuple): The tuple to which the list is appended.\n\n    Returns:\n    tuple: The resulting tuple after appending the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    :param lst: The list to append.\n    :param tpl: The tuple to which the list is appended.\n    :return: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    Parameters:\n    lst (list): The list to be appended.\n    tpl (tuple): The tuple to which the list is appended.\n\n    Returns:\n    tuple: The resulting tuple after appending the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    Parameters:\n    lst (list): The list to be appended.\n    tpl (tuple): The tuple to which the list is appended.\n\n    Returns:\n    tuple: The resulting tuple after appending the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    Parameters:\n    lst (list): The list to be appended.\n    tpl (tuple): The tuple to which the list is appended.\n\n    Returns:\n    tuple: The resulting tuple after appending the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    Parameters:\n    lst (list): The list to be appended.\n    tpl (tuple): The tuple to which the list is appended.\n\n    Returns:\n    tuple: The resulting tuple after appending the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    :param lst: The list to be appended.\n    :param tpl: The tuple to which the list is appended.\n    :return: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    :param lst: The list to append.\n    :param tpl: The tuple to which the list is appended.\n    :return: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    :param lst: The list to append.\n    :param tpl: The tuple to which the list is appended.\n    :return: A new tuple with the list elements appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    :param lst: The list to append.\n    :param tpl: The tuple to which the list is appended.\n    :return: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    :param lst: The list to append.\n    :param tpl: The tuple to which the list is appended.\n    :return: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a tuple.\n\n    :param lst: The list to append.\n    :param tpl: The tuple to which the list is appended.\n    :return: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 99.38461538461539, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    :param nested_lists: A list of lists containing integers.\n    :return: A set of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n    \n    # Start with the first list as the initial set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    :param nested_lists: A list of lists containing integers.\n    :return: A set of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n    \n    # Start with the first list as the initial set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return common_elements\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    :param nested_lists: A list of lists containing integers.\n    :return: A set of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n    \n    # Start with the first list as the initial set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    :param nested_lists: List of lists containing integers.\n    :return: List of common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Start with the first list as the set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Check if the input is empty\n    if not nested_lists:\n        return []\n    \n    # Initialize the common elements with the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    :param nested_lists: List of lists containing integers.\n    :return: List of common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Start with the first list as the initial set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    :param nested_lists: List of lists containing integers\n    :return: List of common elements\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    :param nested_lists: A list of lists containing integers.\n    :return: A set of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n    \n    # Start with the first list as the initial set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return common_elements\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    :param nested_lists: A list of lists containing integers.\n    :return: A set of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n    \n    # Start with the first list as the base set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    :param nested_lists: A list of lists containing integers.\n    :return: A set of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n    \n    # Start with the first list as the initial set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return common_elements\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Check if the input is empty\n    if not nested_lists:\n        return []\n    \n    # Initialize the common elements with the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    :param nested_lists: List of lists containing elements to find common elements from.\n    :return: A set of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n    \n    # Start with the first list as the initial set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return common_elements\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    :param nested_lists: A list of lists containing integers.\n    :return: A set of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n    \n    # Start with the first list as the initial set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return common_elements\nnested_lists = [\n    [12, 18, 23, 25, 45],\n    [7, 12, 18, 24, 28],\n    [1, 5, 8, 12, 15, 16, 18]\n]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Check if the input is empty\n    if not nested_lists:\n        return []\n    \n    # Initialize the common elements with the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    :param nested_lists: A list of lists containing integers.\n    :return: A set of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n    \n    # Start with the first list as the initial set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    :param nested_lists: List of lists containing integers.\n    :return: List of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Start with the first list as the set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    :param nested_lists: A list of lists containing integers.\n    :return: A set of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n    \n    # Start with the first list as the set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return common_elements\nnested_lists = [\n    [12, 18, 23, 25, 45],\n    [7, 12, 18, 24, 28],\n    [1, 5, 8, 12, 15, 16, 18]\n]", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of a number n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of all proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of all proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of all proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of all proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of a number n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of a number n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Returns the sum of all proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of all proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if a != b and sum_of_proper_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of all proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of a number n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of all proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of all proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if a != b and sum_of_proper_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if a != b and sum_of_proper_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of a number n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The sentence from which to extract the words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    :param n: The minimum length of the words to be returned.\n    :param sentence: The input sentence as a string.\n    :return: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The input sentence as a string.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into individual words\n    words = sentence.split()\n    \n    # Filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The sentence from which to extract words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The input sentence from which to extract words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into individual words\n    words = sentence.split()\n    \n    # Filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The input sentence from which to extract words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    :param n: The minimum length of the words to be returned.\n    :param sentence: The input sentence as a string.\n    :return: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The input sentence from which to extract words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The sentence from which to extract the words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    :param n: The minimum length of the words to be returned.\n    :param sentence: The input sentence as a string.\n    :return: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be found.\n    sentence (str): The sentence from which to find the words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The input sentence from which to extract words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The input sentence from which to extract words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The input sentence from which to extract words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The input sentence from which to extract words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The input sentence from which to extract words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The input sentence from which to extract words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be found.\n    sentence (str): The input sentence to search for words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The input sentence from which to extract words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to be returned.\n    sentence (str): The sentence from which to extract the words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 49.234693877551024, "dps_norm": 93.33333333333333, "pass@1": 25.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the magic constant\n    magic_constant = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the magic constant\n    magic_constant = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the magic constant\n    magic_constant = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check first diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check second diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}]}, "Mbpp/130": {"dps": 95.4372197309417, "dps_norm": 80.83333333333333, "pass@1": 100.0, "profiled": [{"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n    \n    Parameters:\n    lst (list): The list of items to analyze.\n    \n    Returns:\n    The item with the highest frequency. If multiple items have the same frequency,\n    the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    # Use Counter to count the frequency of each item in the list\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n    \n    Parameters:\n    lst (list): The list of items to analyze.\n    \n    Returns:\n    The item with the highest frequency. If multiple items have the same frequency, \n    the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    # Use Counter to count the frequency of each item\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    :param lst: List of items\n    :return: The item with the maximum frequency\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n\n    # Create a frequency dictionary\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n\n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    :param lst: List of items\n    :return: The item with the maximum frequency\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n\n    # Use Counter to count the frequency of each item\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n\n    Parameters:\n    lst (list): The list of items to analyze.\n\n    Returns:\n    The item with the highest frequency. If multiple items have the same frequency, \n    the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    # Use Counter to count the frequency of each item in the list\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n    \n    Parameters:\n    lst (list): The list of items to analyze.\n    \n    Returns:\n    The item with the highest frequency. If multiple items have the same frequency, \n    the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    # Use Counter to count the frequency of each item in the list\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n    \n    :param lst: List of items\n    :return: The item with the maximum frequency\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    # Use Counter to count the frequency of each item\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    Parameters:\n    lst (list): The list of items to analyze.\n\n    Returns:\n    The item with the maximum frequency. If multiple items have the same frequency, \n    the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n\n    # Count the frequency of each item in the list\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item with maximum frequency in a given list.\n    \n    :param lst: List of items\n    :return: The item with the maximum frequency\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    # Count the frequency of each item in the list\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    Parameters:\n    lst (list): The list of items to analyze.\n\n    Returns:\n    The item with the highest frequency. If multiple items have the same frequency,\n    the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n\n    # Use Counter to count the frequency of each item in the list\n    frequency = Counter(lst)\n\n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item with maximum frequency in a given list.\n\n    Parameters:\n    lst (list): The input list of items.\n\n    Returns:\n    The item with the maximum frequency.\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n\n    # Use Counter to count the frequency of each item\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    Parameters:\n    lst (list): The list of items to analyze.\n\n    Returns:\n    The item with the highest frequency. If multiple items have the same frequency,\n    the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n\n    # Use Counter to count the frequency of each item\n    frequency = Counter(lst)\n\n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n\n    Parameters:\n    lst (list): The list of items to analyze.\n\n    Returns:\n    The item with the highest frequency. If multiple items have the same frequency, \n    the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n\n    # Count the frequency of each item in the list\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n\n    Parameters:\n    lst (list): The input list of items.\n\n    Returns:\n    The item with the highest frequency. If multiple items have the same frequency,\n    the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n\n    # Use Counter to count the frequency of each item in the list\n    frequency = Counter(lst)\n\n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n    \n    :param lst: List of items\n    :return: The item with the maximum frequency\n    \"\"\"\n    if not lst:\n        return None\n    \n    # Count the frequency of each item in the list\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate through the list and count the occurrences of each item\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_item = item\n            max_count = count\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n    \n    Parameters:\n    lst (list): The list of items to analyze.\n    \n    Returns:\n    The item with the highest frequency. If multiple items have the same frequency,\n    the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    # Use Counter to count the frequency of each item in the list\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    Parameters:\n    lst (list): The list of items to analyze.\n\n    Returns:\n    The item with the maximum frequency.\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    # Use Counter to count the frequency of each item\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n\n    Parameters:\n    lst (list): The list of items to analyze.\n\n    Returns:\n    The item with the highest frequency. If multiple items have the same frequency, \n    the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    # Use Counter to count the frequency of each item in the list\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n\n    :param lst: List of items\n    :return: The item with the maximum frequency\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n\n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/140": {"dps": 93.027950310559, "dps_norm": 91.875, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n\n    Args:\n    list_of_lists (list of tuples or lists): A list containing tuples or lists of numbers.\n\n    Returns:\n    set: A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    # Use a set comprehension to flatten the list of lists and remove duplicates\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list of tuples or lists): A list containing tuples or lists of numbers.\n    \n    Returns:\n    set: A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    :param list_of_lists: List of tuples or lists containing numbers.\n    :return: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n\n    Args:\n    list_of_lists (list of tuples or lists): A list containing tuples or lists of numbers.\n\n    Returns:\n    set: A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    :param list_of_lists: List of tuples or lists containing numbers.\n    :return: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    :param list_of_lists: List of tuples or lists containing numbers.\n    :return: A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    :param list_of_lists: List of tuples or lists containing numbers.\n    :return: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list of tuples or lists): A list containing tuples or lists of numbers.\n    \n    Returns:\n    set: A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list of tuples or lists): The input list containing tuples or lists of numbers.\n    \n    Returns:\n    set: A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    # Use a set comprehension to flatten the list of lists and remove duplicates\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    :param list_of_lists: List of tuples or lists containing numbers.\n    :return: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    return set(item for sublist in list_of_lists for item in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    :param list_of_lists: List of tuples or lists containing numbers.\n    :return: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    :param list_of_lists: List of tuples or lists containing numbers.\n    :return: A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    # Use a set comprehension to flatten the list of lists and remove duplicates\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n\n    Args:\n    list_of_lists (list of tuples or lists): A list containing tuples or lists of numbers.\n\n    Returns:\n    set: A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    :param list_of_lists: List of tuples or lists containing numbers.\n    :return: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    :param list_of_lists: List of tuples or lists containing numbers.\n    :return: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    :param list_of_lists: List of tuples or lists containing numbers.\n    :return: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of tuples or lists): A list containing tuples or lists of numbers.\n\n    Returns:\n        set: A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n\n    Args:\n    list_of_lists (list of tuples or lists): A list containing tuples or lists of numbers.\n\n    Returns:\n    set: A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    :param list_of_lists: List of tuples or lists containing numbers.\n    :return: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list of tuples or lists): The input list containing tuples or lists of numbers.\n    \n    Returns:\n    set: A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}]}, "Mbpp/141": {"dps": 98.41269841269842, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part of the array\n        max_idx = arr.index(max(arr[:curr_size]))\n        \n        # If the maximum element is not at the current position, flip the array to bring it to the front\n        if max_idx != curr_size - 1:\n            # Flip the array from the start to the maximum element's index\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            # Flip the array from the start to the current size to move the maximum element to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted\n    :return: Sorted list of elements\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"Flips the first k elements of the array.\"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_idx = arr.index(max(arr[:size]))\n        \n        # If the maximum element is not at the end, flip it to the beginning\n        if max_idx != size - 1:\n            flip(arr, max_idx + 1)\n            # Flip the maximum element to its correct position\n            flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part of the array\n        max_idx = arr.index(max(arr[:curr_size]))\n        \n        # If the maximum element is not at the end, flip the array to bring it to the beginning\n        if max_idx != curr_size - 1:\n            # Flip the array from the start to the max_idx to bring the max element to the front\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            # Flip the entire unsorted part to bring the max element to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Flips the first k elements of the array.\n        \n        :param arr: List of elements.\n        :param k: Number of elements to flip.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_idx = arr.index(max(arr[:size]))\n        \n        # If the maximum element is not at the end, flip it to the beginning\n        if max_idx != size - 1:\n            flip(arr, max_idx + 1)\n            # Flip the maximum element to its correct position\n            flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_idx = arr.index(max(arr[:curr_size]))\n        \n        # If the maximum element is not at the end, flip it to the beginning\n        if max_idx != curr_size - 1:\n            # Flip the array from the start to the max index\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            # Flip the entire unsorted part to move the max element to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part of the array\n        max_idx = arr.index(max(arr[:curr_size]))\n        \n        # If the maximum element is not already at the end, flip the array to bring it to the beginning\n        if max_idx != curr_size - 1:\n            # Flip the array from the start to the maximum element index\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            # Flip the array from the start to the current size to move the maximum element to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Reverses the first k elements of the array.\n        \n        :param arr: The array to be flipped.\n        :param k: The number of elements to flip.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_idx = arr.index(max(arr[:size]))\n        \n        # Move the maximum element to the beginning\n        if max_idx != 0:\n            flip(arr, max_idx + 1)\n        \n        # Move the maximum element to its correct position\n        flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted\n    :return: Sorted list of elements\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Reverses the first k elements of the array.\n        \n        :param arr: List of elements\n        :param k: Number of elements to reverse\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_idx = arr.index(max(arr[:size]))\n        \n        # If the maximum element is not at the end, flip it to the beginning\n        if max_idx != size - 1:\n            flip(arr, max_idx + 1)\n            # Flip the maximum element to its correct position\n            flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted\n    :return: Sorted list\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"Flips the first k elements of the array.\"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_idx = arr.index(max(arr[:size]))\n        \n        # If the maximum element is not at the end, flip it to the beginning\n        if max_idx != size - 1:\n            flip(arr, max_idx + 1)\n            # Flip the maximum element to its correct position\n            flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part of the array\n        max_idx = arr.index(max(arr[:curr_size]))\n        \n        # If the maximum element is not at the current position, flip the array to bring it to the front\n        if max_idx != curr_size - 1:\n            # Flip the array from the start to the maximum element's index\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            # Flip the entire unsorted part of the array to move the maximum element to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part of the array\n        max_idx = arr.index(max(arr[:curr_size]))\n        \n        # If the maximum element is not at the end of the unsorted part, flip it to the beginning\n        if max_idx != curr_size - 1:\n            # Flip the array from the start to the max_idx to bring the max element to the front\n            arr = arr[:max_idx+1][::-1] + arr[max_idx+1:]\n            # Flip the entire unsorted part to bring the max element to its correct position\n            arr = arr[:curr_size][::-1] + arr[curr_size:]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part of the array\n        max_idx = arr.index(max(arr[:curr_size]))\n        \n        # If the maximum element is not at the end, flip the array to bring it to the front\n        if max_idx != curr_size - 1:\n            # Flip the array from the start to the max_idx to bring the max element to the front\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            # Flip the entire unsorted part to bring the max element to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"Flips the first k elements of the array.\"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_idx = arr.index(max(arr[:size]))\n        \n        # If the maximum element is not at the end, flip it to the beginning\n        if max_idx != size - 1:\n            flip(arr, max_idx + 1)\n            # Flip the maximum element to its correct position\n            flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:curr_size]))\n        \n        # If the maximum element is not at the end, flip it to the beginning\n        if max_idx != curr_size - 1:\n            # Flip the maximum element to the beginning\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            # Flip the maximum element to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Flips the first k elements of the array.\n        \n        :param arr: List of elements.\n        :param k: Number of elements to flip.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_idx = arr.index(max(arr[:size]))\n        \n        # If the maximum element is not at the end, flip it to the beginning\n        if max_idx != size - 1:\n            flip(arr, max_idx + 1)\n            # Flip the maximum element to its correct position\n            flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"Flips the first k elements of the array.\"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:size]))\n        \n        # If the maximum element is not at the end, flip it to the beginning\n        if max_idx != size - 1:\n            flip(arr, max_idx + 1)\n            # Flip the maximum element to its correct position\n            flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"Flips the first k elements of the array.\"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_idx = arr.index(max(arr[:size]))\n        \n        # If the maximum element is not at the end, flip it to the beginning\n        if max_idx != size - 1:\n            flip(arr, max_idx + 1)\n            # Flip the maximum element to its correct position\n            flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"Flips the first k elements of the array.\"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_idx = arr.index(max(arr[:size]))\n        \n        # If the maximum element is not at the end, flip it to the beginning\n        if max_idx != size - 1:\n            flip(arr, max_idx + 1)\n            # Flip the maximum element to its correct position\n            flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:curr_size]))\n        \n        # If the maximum element is not at the end, flip the array to bring it to the beginning\n        if max_idx != curr_size - 1:\n            # Flip the array from the start to the max_idx to bring the max element to the front\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            # Flip the array from the start to the current size to bring the max element to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part of the array\n        max_idx = arr.index(max(arr[:curr_size]))\n        \n        # If the maximum element is not at the end of the unsorted part, flip it to the beginning\n        if max_idx != curr_size - 1:\n            # Flip the array from the start to the maximum element index\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            # Flip the entire unsorted part to move the maximum element to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n    \n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The number of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The number of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The number of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    \n    # Iterate through all possible pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the XOR of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The number of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    \n    # Iterate through all possible pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the XOR of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The number of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The number of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The number of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    :param nums: List of integers\n    :return: Number of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    \n    # Iterate through all possible pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the XOR of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a range specified by two indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a range specified by two indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index (inclusive).\n    end_idx (int): The ending index (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a range specified by two indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a range specified by two indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a range specified by two indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range (inclusive).\n    end_idx (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 96.70542635658914, "dps_norm": 96.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes the characters which have odd index values of a given string.\n\n    :param input_string: The input string from which to remove odd-indexed characters.\n    :return: A new string with only the characters at even indices.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes the characters which have odd index values of a given string.\n\n    :param input_string: The input string from which to remove odd-indexed characters.\n    :return: A new string with only the characters at even indices.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters with odd index values from the given string.\n\n    :param input_string: The input string to process\n    :return: A new string with characters at odd indices removed\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes the characters which have odd index values of a given string.\n\n    :param input_string: The input string from which to remove odd-indexed characters.\n    :return: A new string with only the even-indexed characters from the input string.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters with odd index values from the given string.\n\n    :param input_string: The input string to process.\n    :return: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters with odd index values from the given string.\n\n    :param input_string: The input string to process\n    :return: A new string with characters at odd indices removed\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes the characters which have odd index values of a given string.\n\n    :param input_string: The input string from which to remove odd-indexed characters.\n    :return: A new string with only the even-indexed characters from the input string.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters with odd index values from the given string.\n    \n    :param input_string: The input string from which to remove characters with odd indices.\n    :return: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes the characters which have odd index values of a given string.\n\n    :param input_string: The input string from which to remove odd-indexed characters.\n    :return: A new string with only the characters at even indices.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters which have odd index values from the given string.\n\n    :param input_string: The input string from which to remove odd-indexed characters.\n    :return: A new string with only the characters at even indices.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes the characters which have odd index values of a given string.\n    \n    :param input_string: The input string from which to remove odd-indexed characters.\n    :return: A new string with only the characters at even indices.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters which have odd index values from the given string.\n\n    :param input_string: The input string from which to remove odd-indexed characters.\n    :return: A new string with only the characters at even indices.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters with odd index values from the given string.\n    \n    :param input_string: The input string from which to remove characters with odd indices.\n    :return: A new string containing only characters with even indices.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes the characters which have odd index values of a given string.\n\n    :param input_string: The input string from which to remove odd-indexed characters.\n    :return: A new string with only the characters at even indices.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters with odd index values from the given string.\n\n    :param input_string: The input string to process\n    :return: A new string with characters at odd indices removed\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters with odd index values from the given string.\n\n    :param input_string: The input string from which to remove characters.\n    :return: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes the characters which have odd index values of a given string.\n    \n    :param input_string: The input string from which to remove odd-indexed characters.\n    :return: A new string with only the even-indexed characters from the input string.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes the characters which have odd index values of a given string.\n\n    :param input_string: The input string from which to remove odd-indexed characters.\n    :return: A new string with only the characters at even indices.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes the characters which have odd index values of a given string.\n\n    :param input_string: The input string to process\n    :return: A new string with characters at odd indices removed\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes the characters which have odd index values of a given string.\n\n    :param input_string: The input string from which to remove odd-indexed characters.\n    :return: A new string with only the even-indexed characters from the input string.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    Args:\n        input_string (str): The string to process.\n        replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    Args:\n        input_string (str): The string to process.\n        replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param replacement_char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 51.72413793103448, "dps_norm": 60.0, "pass@1": 10.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Function to find the number of possible sequences of length n, such that each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n\n    :param m: The maximum value any element in the sequence can take.\n    :param n: The length of the sequence.\n    :return: The total number of valid sequences.\n    \"\"\"\n    def count_sequences(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_element, m + 1):\n            total += count_sequences(current_length + 1, i)\n        return total\n\n    if n == 0:\n        return 0\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(1, i)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of possible sequences of length n, where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n    \n    :param m: The maximum value any element in the sequence can take.\n    :param n: The length of the sequence.\n    :return: The total number of valid sequences.\n    \"\"\"\n    def count_sequences(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_element, m + 1):\n            total += count_sequences(current_length + 1, i)\n        return total\n    \n    if n == 0:\n        return 0\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(1, i)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n, where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n\n    Args:\n    m (int): The maximum value any element in the sequence can take.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of valid sequences.\n    \"\"\"\n    def count_sequences(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for next_element in range(2 * last_element, m + 1):\n            total += count_sequences(current_length + 1, next_element)\n        return total\n\n    if n == 0:\n        return 0\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(1, first_element)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of sequences of length n where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n\n    :param m: The maximum value any element in the sequence can take.\n    :param n: The length of the sequence.\n    :return: The total number of valid sequences.\n    \"\"\"\n    def count_sequences(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_element, m + 1):\n            total += count_sequences(current_length + 1, i)\n        return total\n\n    if n == 0:\n        return 0\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(1, i)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of possible sequences of length n, where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n    \n    :param m: The maximum value any element in the sequence can take.\n    :param n: The length of the sequence.\n    :return: The total number of valid sequences.\n    \"\"\"\n    def count_sequences(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for next_element in range(2 * last_element, m + 1):\n            total += count_sequences(current_length + 1, next_element)\n        return total\n    \n    if n == 0:\n        return 0\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(1, first_element)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n, where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n\n    :param m: The maximum value any element in the sequence can take.\n    :param n: The length of the sequence.\n    :return: The total number of valid sequences.\n    \"\"\"\n    def count_sequences(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_element, m + 1):\n            total += count_sequences(current_length + 1, i)\n        return total\n\n    if n == 0:\n        return 0\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(1, i)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n, where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n\n    Args:\n    m (int): The maximum value any element in the sequence can take.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of valid sequences.\n    \"\"\"\n    def count_sequences(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_element, m + 1):\n            total += count_sequences(current_length + 1, i)\n        return total\n\n    if n == 0:\n        return 0\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(1, i)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of possible sequences of length n, where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n    \n    :param m: The maximum value any element in the sequence can take.\n    :param n: The length of the sequence.\n    :return: The total number of valid sequences.\n    \"\"\"\n    def count_sequences(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for next_element in range(2 * last_element, m + 1):\n            total += count_sequences(current_length + 1, next_element)\n        return total\n    \n    if n == 0:\n        return 0\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(1, first_element)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n, where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n\n    :param m: The maximum value any element in the sequence can take.\n    :param n: The length of the sequence.\n    :return: The total number of valid sequences.\n    \"\"\"\n    def count_sequences(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_element, m + 1):\n            total += count_sequences(current_length + 1, i)\n        return total\n\n    if n == 0:\n        return 0\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(1, i)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n, where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n\n    Args:\n    m (int): The maximum value any element in the sequence can take.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of valid sequences.\n    \"\"\"\n    def count_sequences(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_element, m + 1):\n            total += count_sequences(current_length + 1, i)\n        return total\n\n    if n == 0:\n        return 0\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(1, i)\n    return total_sequences", "matching_cluster_idx": 5}]}, "Mbpp/240": {"dps": 54.26829268292683, "dps_norm": 69.44444444444444, "pass@1": 100.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list whose last element will be replaced.\n    :param list2: The second list whose elements will replace the last element of the first list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1\n    list1_without_last = list1[:-1]\n    # Concatenate the modified list1 with list2\n    result_list = list1_without_last + list2\n    return result_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list.\n    :param list2: The second list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    if not list1:\n        return list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    :param list1: The first list.\n    :param list2: The second list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1\n    list1 = list1[:-1]\n    # Extend list1 with the elements of list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list.\n    :param list2: The second list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    if not list1:\n        return list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list whose last element will be replaced.\n    :param list2: The second list whose elements will replace the last element of the first list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1\n    list1_without_last = list1[:-1]\n    # Concatenate the modified list1 with list2\n    result = list1_without_last + list2\n    return result", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list.\n    :param list2: The second list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1\n    list1 = list1[:-1]\n    # Extend list1 with the elements of list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list whose last element will be replaced.\n    :param list2: The second list whose elements will replace the last element of the first list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1\n    list1 = list1[:-1]\n    # Concatenate list1 with list2\n    return list1 + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list.\n    :param list2: The second list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1\n    list1 = list1[:-1]\n    # Extend list1 with the elements of list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list.\n    :param list2: The second list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1\n    list1 = list1[:-1]\n    # Concatenate list1 with list2\n    return list1 + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param lst1: The first list.\n    :param lst2: The second list.\n    :return: The modified first list with the last element replaced by the elements of the second list.\n    \"\"\"\n    if not lst1:\n        return lst2\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list.\n    :param list2: The second list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of the first list\n    list1_without_last = list1[:-1]\n    # Concatenate the modified first list with the second list\n    result = list1_without_last + list2\n    return result", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list.\n    :param list2: The second list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    if not list1:\n        return list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param lst1: The first list.\n    :param lst2: The second list.\n    :return: A new list with the last element of lst1 replaced by the elements of lst2.\n    \"\"\"\n    if not lst1:\n        return lst2\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list.\n    :param list2: The second list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1\n    list1 = list1[:-1]\n    # Concatenate list1 with list2\n    return list1 + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list.\n    :param list2: The second list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1\n    list1 = list1[:-1]\n    # Concatenate list1 and list2\n    return list1 + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list.\n    :param list2: The second list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1\n    list1 = list1[:-1]\n    # Extend list1 with the elements of list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    :param lst1: The first list whose last element will be replaced.\n    :param lst2: The second list whose elements will replace the last element of the first list.\n    :return: A new list with the last element of lst1 replaced by the elements of lst2.\n    \"\"\"\n    if not lst1:\n        return lst2\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    :param lst1: The first list.\n    :param lst2: The second list.\n    :return: A new list with the last element of lst1 replaced by the elements of lst2.\n    \"\"\"\n    # Remove the last element of the first list\n    lst1 = lst1[:-1]\n    # Extend the first list with the elements of the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    :param list1: The first list whose last element will be replaced.\n    :param list2: The second list whose elements will replace the last element of the first list.\n    :return: A new list with the last element of the first list replaced by the elements of the second list.\n    \"\"\"\n    if not list1:\n        return list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    :param list1: The first list.\n    :param list2: The second list.\n    :return: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1\n    list1_without_last = list1[:-1]\n    # Concatenate the modified list1 with list2\n    result = list1_without_last + list2\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/251": {"dps": 91.95402298850576, "dps_norm": 77.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list.\n    :param element: The element to be inserted before each element in the list.\n    :return: The new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list\n    :param element: The element to insert before each element in the list\n    :return: The new list with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list.\n    :param element: The element to insert before each element in the list.\n    :return: The new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list\n    :param element: The element to insert before each element in the list\n    :return: A new list with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list.\n    :param element: The element to be inserted before each element in the list.\n    :return: The new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list.\n    :param element: The element to be inserted before each element in the list.\n    :return: The new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list\n    :param element: The element to insert before each element in the list\n    :return: The new list with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list.\n    :param element: The element to insert before each element in the list.\n    :return: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: List of elements\n    :param element: Element to insert before each element in the list\n    :return: New list with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list\n    :param element: The element to insert before each element in the list\n    :return: The new list with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list\n    :param element: The element to insert before each element in the list\n    :return: The new list with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list.\n    :param element: The element to insert before each element in the list.\n    :return: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list.\n    :param element: The element to insert before each element in the list.\n    :return: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list\n    :param element: The element to insert before each element in the list\n    :return: A new list with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: List of elements\n    :param element: Element to insert before each element in the list\n    :return: List with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list\n    :param element: The element to insert before each element in the list\n    :return: A new list with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: List of elements\n    :param element: Element to insert before each element in the list\n    :return: List with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list.\n    :param element: The element to insert before each element in the list.\n    :return: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: The original list.\n    :param element: The element to insert before each element in the list.\n    :return: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n\n    :param lst: The original list.\n    :param element: The element to insert before each element in the list.\n    :return: The new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 97.92237442922374, "dps_norm": 88.82352941176471, "pass@1": 100.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to track prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm to find all primes less than n\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of True values in the is_prime list\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not prime numbers\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            # Mark multiples of i as non-prime\n            sieve[i*i : n : i] = [False] * len(sieve[i*i : n : i])\n    \n    # Count the number of True values in the sieve\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to track prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm to find all primes less than n\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            sieve[i*i : n : i] = [False] * len(sieve[i*i : n : i])\n    \n    # Count the number of primes\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to track prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm to find all primes less than n\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of True values in the list\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Use the Sieve of Eratosthenes algorithm to mark non-prime numbers\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of True values in the is_prime list\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of True values in the list\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm to mark non-prime numbers\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm to mark non-prime numbers\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Use the Sieve of Eratosthenes algorithm to mark non-prime numbers\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Sieve of Eratosthenes algorithm\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}]}, "Mbpp/265": {"dps": 64.65116279069768, "dps_norm": 80.83333333333333, "pass@1": 100.0, "profiled": [{"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements to the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n\n    :param lst: The input list to be split.\n    :param n: The interval at which to split the list.\n    :return: A list of lists, where each sublist contains elements spaced by n.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 3}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n\n    :param lst: The input list to be split.\n    :param n: The interval at which to split the list.\n    :return: A list of lists, where each sublist contains every nth element.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n\n    :param lst: The input list to be split.\n    :param n: The interval at which to split the list.\n    :return: A list of lists, where each sublist contains every nth element.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n\n    :param lst: The input list to be split.\n    :param n: The interval at which to split the list.\n    :return: A list of lists, where each sublist contains elements spaced by n.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 3}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n    \n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements to the sublists\n    for i, element in enumerate(lst):\n        result[i % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements to the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements to the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each sublist contains every nth element.\n\n    :param lst: The input list to be split.\n    :param n: The number of sublists to create.\n    :return: A list of n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    :param lst: List of elements to check for uniqueness.\n    :return: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    :param lst: List of elements to check for uniqueness.\n    :return: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    :param lst: List of elements to check\n    :return: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    :param lst: List of elements to check\n    :return: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array using a modified merge sort approach.\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv_count\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array using a modified merge sort algorithm.\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, inv_count\n    \n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv_count\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Count the number of inversions in the given array.\n    \n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array.\n    \n    Returns:\n    int: The number of inversions in the array.\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total_inversions = inv_left + inv_right + inv_merge\n        return merged, total_inversions\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inversions = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inversions += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, inversions\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array using a modified merge sort approach.\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, inv_count\n    \n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Count the number of inversions in an array using a modified merge sort approach.\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, inv_count\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, inv_count\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Count the number of inversions in the given array.\n    \n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array of integers.\n    \n    Returns:\n    int: The number of inversions in the array.\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, inv_count\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Count the number of inversions in the given array using a modified merge sort approach.\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, inv_count\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array using a modified merge sort approach.\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, inv_count\n    \n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, inv_count\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array using a modified merge sort approach.\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv_count\n    \n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array using a modified merge sort approach.\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv_count\n    \n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv_count\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array using a modified merge sort approach.\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv_count\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array using a modified merge sort approach.\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, inv_count\n    \n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv_count\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv_count\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total = inv_left + inv_right + inv_merge\n        return merged, total\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv_count\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        total_inversions = inv_left + inv_right + inv_merge\n        return merged, total_inversions\n    \n    def merge_and_count(left, right):\n        result = []\n        i = j = 0\n        inv_count = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv_count\n    \n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions", "matching_cluster_idx": 5}]}, "Mbpp/308": {"dps": 97.58620689655173, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def large_product(list1, list2, k):\n    # Generate all possible products by multiplying each element from list1 with each element from list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top k products\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    # Generate all possible products by multiplying each element from list1 with each element from list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top k largest products\n    return products_sorted[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists, selecting one factor from each list.\n\n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param n: Number of largest products to return\n    :return: List of the n largest products\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top n products\n    return products_sorted[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    \"\"\"\n    Finds the k largest products from two given lists, selecting one factor from each list.\n\n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param k: Number of largest products to return\n    :return: List of the k largest products\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top k products\n    return products_sorted[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    \"\"\"\n    Finds the k largest products from two given lists, selecting one factor from each list.\n\n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param k: Number of largest products to find\n    :return: List of the k largest products\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top k products\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products by multiplying each element from list1 with each element from list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    # Generate all possible products by multiplying each element from list1 with each element from list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top k products\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    # Generate all possible products by multiplying each element from list1 with each element from list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top k products\n    return products_sorted[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists, selecting one factor from each list.\n\n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param n: Number of largest products to return\n    :return: List of the n largest products\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top n products\n    return products_sorted[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products by multiplying each element from list1 with each element from list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top n products\n    return products_sorted[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    \"\"\"\n    Finds the k largest products from two given lists, selecting one factor from each list.\n\n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param k: Number of largest products to find\n    :return: List of the k largest products\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top k products\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists, selecting one factor from each list.\n\n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param n: Number of largest products to return\n    :return: List of the n largest products\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    # Generate all possible products by multiplying each element from list1 with each element from list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top k products\n    return products_sorted[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    \"\"\"\n    Finds the k largest products from two given lists, selecting one factor from each list.\n\n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param k: Number of largest products to find\n    :return: List of the k largest products\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top k products\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists, selecting one factor from each list.\n\n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param n: Number of largest products to return\n    :return: List of the n largest products\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top n products\n    return products_sorted[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    \"\"\"\n    Find the specified number of largest products from two given lists, selecting one factor from each list.\n\n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param k: Number of largest products to return\n    :return: List of the k largest products\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top k products\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists, selecting one factor from each list.\n\n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param n: Number of largest products to return\n    :return: List of the n largest products\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top n products\n    return products_sorted[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists, selecting one factor from each list.\n\n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param n: Number of largest products to return\n    :return: List of the n largest products\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    # Generate all possible products by multiplying each element from list1 with each element from list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top k products\n    return products_sorted[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    \"\"\"\n    Finds the k largest products from two given lists, selecting one factor from each list.\n\n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param k: Number of largest products to find\n    :return: List of the k largest products\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top k products\n    return products_sorted[:k]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def get_max_sum(n):\n    # Create a dictionary to store the results of subproblems\n    memo = {}\n\n    def helper(n):\n        # Base case: if n is 0, the sum is 0\n        if n == 0:\n            return 0\n        # If the result for n is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(\n            helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5),\n            n\n        )\n        # Store the result in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    # Call the helper function with the given n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Base case: if n is 0 or 1, the maximum sum is n itself\n    if n <= 1:\n        return n\n    \n    # If the result for n is already computed, return it from the memo\n    if n in memo:\n        return memo[n]\n    \n    # Compute the maximum sum using the given equation\n    max_sum = max(\n        get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + \n        get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo),\n        n\n    )\n    \n    # Store the result in the memo for future use\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store the maximum sum for each value of n\n    memo = {}\n\n    def dp(n):\n        # Base case: if n is 0, the sum is 0\n        if n == 0:\n            return 0\n        # If the result is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(dp(n // 2) + dp(n // 3) + dp(n // 4) + dp(n // 5), n)\n        # Store the result in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    return dp(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Function to find the maximum sum possible by using the given equation:\n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \n    Parameters:\n    n (int): The input number.\n    memo (dict): A dictionary to store already computed values for optimization.\n    \n    Returns:\n    int: The maximum sum possible.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Calculate the sum of f(n/2) + f(n/3) + f(n/4) + f(n/5)\n    sum_f = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Return the maximum between the sum and n\n    memo[n] = max(sum_f, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Args:\n    n (int): The input number.\n    memo (dict): A dictionary to store already computed results for optimization.\n    \n    Returns:\n    int: The maximum sum.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Calculate the sum of f(n/2) + f(n/3) + f(n/4) + f(n/5)\n    sum_f = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Take the maximum between the sum and n\n    result = max(sum_f, n)\n    \n    # Store the result in memo for future reference\n    memo[n] = result\n    \n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Function to find the maximum sum possible by using the given equation:\n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \n    Parameters:\n    n (int): The input number.\n    memo (dict): A dictionary to store already computed values for optimization.\n    \n    Returns:\n    int: The maximum sum possible.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Calculate the sum of f(n/2) + f(n/3) + f(n/4) + f(n/5)\n    sum_f = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Return the maximum between the sum and n\n    memo[n] = max(sum_f, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a dictionary to store the results of subproblems\n    memo = {}\n\n    def dp(n):\n        # Base case: if n is 0, the sum is 0\n        if n == 0:\n            return 0\n        # If the result for n is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(dp(n // 2) + dp(n // 3) + dp(n // 4) + dp(n // 5), n)\n        # Store the result in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    return dp(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a dictionary to store the results of subproblems\n    memo = {}\n\n    def dp(n):\n        # Base case: if n is 0, the sum is 0\n        if n == 0:\n            return 0\n        # If the result is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(dp(n // 2) + dp(n // 3) + dp(n // 4) + dp(n // 5), n)\n        # Store the result in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    return dp(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a dictionary to store the results of subproblems\n    memo = {}\n\n    def dp(n):\n        # Base case: if n is 0, the sum is 0\n        if n == 0:\n            return 0\n        # If the result is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(dp(n // 2) + dp(n // 3) + dp(n // 4) + dp(n // 5), n)\n        # Store the result in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    return dp(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n        n (int): The input number.\n        memo (dict): A dictionary to store already computed values for optimization.\n\n    Returns:\n        int: The maximum sum.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n    sum_f = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Choose the maximum between the sum and n itself\n    memo[n] = max(sum_f, n)\n    \n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum possible using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Parameters:\n    n (int): The input number.\n    memo (dict): A dictionary to store already computed values for optimization.\n\n    Returns:\n    int: The maximum sum possible.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Calculate the sum of f(n/2) + f(n/3) + f(n/4) + f(n/5)\n    sum_f = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Return the maximum between the sum and n\n    memo[n] = max(sum_f, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Parameters:\n    n (int): The input number.\n    memo (dict): A dictionary to store already computed values for optimization.\n\n    Returns:\n    int: The maximum sum.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Calculate the sum of f(n/2) + f(n/3) + f(n/4) + f(n/5)\n    sum_f = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Take the maximum between the sum and n\n    result = max(sum_f, n)\n    \n    # Store the result in memo for future reference\n    memo[n] = result\n    \n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Parameters:\n    n (int): The input number.\n    memo (dict): A dictionary to store already computed results for optimization.\n    \n    Returns:\n    int: The maximum sum.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n    sum_f = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Take the maximum between the sum and n\n    result = max(sum_f, n)\n    \n    # Store the result in memo for future reference\n    memo[n] = result\n    \n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Parameters:\n    n (int): The input number.\n    memo (dict): A dictionary to store previously computed results for optimization.\n\n    Returns:\n    int: The maximum sum.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n    sum_f = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Take the maximum between the sum and n\n    result = max(sum_f, n)\n    \n    # Store the result in memo for future reference\n    memo[n] = result\n    \n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Parameters:\n    n (int): The input number.\n    memo (dict): A dictionary to store previously computed results for optimization.\n    \n    Returns:\n    int: The maximum sum.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n    sum_f = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Take the maximum between the sum and n\n    result = max(sum_f, n)\n    \n    # Store the result in memo for future reference\n    memo[n] = result\n    \n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Parameters:\n    n (int): The input number.\n    memo (dict): A dictionary to store already computed values for optimization.\n\n    Returns:\n    int: The maximum sum.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Calculate the sum of f(n/2) + f(n/3) + f(n/4) + f(n/5)\n    sum_f = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Take the maximum between the sum and n\n    memo[n] = max(sum_f, n)\n    \n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum possible using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Parameters:\n    n (int): The input number.\n    memo (dict): A dictionary to store already computed values for optimization.\n    \n    Returns:\n    int: The maximum sum possible.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Calculate the sum of f(n/2) + f(n/3) + f(n/4) + f(n/5)\n    sum_f = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Take the maximum between the sum and n\n    result = max(sum_f, n)\n    \n    # Store the result in memo for future reference\n    memo[n] = result\n    \n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a dictionary to store the results of subproblems\n    memo = {}\n\n    def helper(n):\n        # Base case: if n is 0, the sum is 0\n        if n == 0:\n            return 0\n        # If the result is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(\n            helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5),\n            n\n        )\n        # Store the result in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Parameters:\n    n (int): The input number.\n    memo (dict): A dictionary to store already computed values for optimization.\n    \n    Returns:\n    int: The maximum sum.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n    sum_f = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Take the maximum between the sum and n\n    memo[n] = max(sum_f, n)\n    \n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a dictionary to store the results of subproblems\n    memo = {}\n\n    def dp(n):\n        # Base case: if n is 0, the sum is 0\n        if n == 0:\n            return 0\n        # If the result is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(dp(n // 2) + dp(n // 3) + dp(n // 4) + dp(n // 5), n)\n        # Store the result in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    return dp(n)", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str or None: The first non-repeating character, or None if all characters repeat.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str or None: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    frequency = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    \n    # Iterate through the string to find the first character with a frequency of 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str or None: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str or None: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str or None: The first non-repeating character, or None if all characters repeat.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    frequency = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    \n    # Iterate through the string to find the first character with a frequency of 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    :param s: The input string.\n    :return: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Iterate through the string to count occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string again to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str or None: The first non-repeating character, or None if all characters repeat.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Iterate through the string and count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string again to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    frequency = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    \n    # Iterate through the string to find the first character with a frequency of 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The first non-repeating character, or None if all characters repeat.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    frequency = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    \n    # Iterate through the string to find the first character with a frequency of 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    frequency = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    \n    # Iterate through the string to find the first character with a frequency of 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    :param s: The input string.\n    :return: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str or None: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    frequency = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    \n    # Iterate through the string to find the first character with a frequency of 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    frequency = {}\n    \n    # Iterate through the string to populate the frequency dictionary\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    \n    # Iterate through the string again to find the first character with a frequency of 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 91.30434782608695, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check.\n    \n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check against.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check.\n\n    Returns:\n    bool: True if there is any overlapping value, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): The first sequence.\n    seq2 (sequence): The second sequence.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 64.60905349794238, "dps_norm": 82.85714285714285, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    :param tup: The tuple containing elements to be concatenated.\n    :param delimiter: The delimiter to use between elements (default is '-').\n    :return: A string with elements concatenated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use for concatenation. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    :param tup: The tuple containing elements to be concatenated.\n    :param delimiter: The delimiter to use between elements (default is '-').\n    :return: A string with elements concatenated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to be concatenated.\n        delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tuple_data, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tuple_data (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tuple_data))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    :param tup: The tuple containing elements to be concatenated.\n    :param delimiter: The delimiter to use between elements (default is '-').\n    :return: A string with elements concatenated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    :param tup: The tuple containing elements to be concatenated.\n    :param delimiter: The delimiter to use between elements (default is '-').\n    :return: A single string with elements concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    :param tup: The tuple containing elements to be concatenated.\n    :param delimiter: The delimiter to use between elements (default is '-').\n    :return: A string with elements concatenated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to be concatenated.\n        delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    :param tup: The tuple containing elements to be concatenated.\n    :param delimiter: The delimiter to use between elements (default is '-').\n    :return: A string with elements concatenated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to be concatenated.\n        delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}]}, "Mbpp/424": {"dps": 51.624548736462096, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of the last characters from each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of the last characters from each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings_tuple (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n    tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list of the last characters from each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of the last characters from each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings_tuple (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    :param strings_tuple: A tuple of strings\n    :return: A list of the last characters of each string\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list of the last characters from each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of the last characters from each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings_tuple (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n    tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list of the last characters from each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list of the last characters of each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of the last characters from each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list of the last characters from each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst: List of lists to search through.\n    :param element: The element to count in the sublists.\n    :return: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    lst (list of list): The list of sublists to search.\n    element: The element to count in the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst: List of sublists\n    :param element: The element to count in sublists\n    :return: The count of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst: List of sublists\n    :param element: The element to count in sublists\n    :return: Number of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    lst (list of list): The list of sublists to search.\n    element: The element to count in the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst: List of sublists\n    :param element: Element to count in sublists\n    :return: Number of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst: List of sublists\n    :param element: The element to count in sublists\n    :return: The count of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst: List of sublists\n    :param element: The element to count in sublists\n    :return: Number of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    lst (list of list): The list of sublists to search.\n    element: The element to count in the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst: List of sublists\n    :param element: The element to count in sublists\n    :return: Number of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst: List of sublists\n    :param element: The element to count in sublists\n    :return: The count of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst: List of sublists\n    :param element: The element to count in sublists\n    :return: The count of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst: List of sublists\n    :param element: The element to count in sublists\n    :return: The count of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst: List of sublists\n    :param element: The element to count in sublists\n    :return: Number of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    lst (list of list): The list of sublists to search.\n    element: The element to count in the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    lst (list of list): The list of sublists to search.\n    element: The element to count in the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst: List of sublists\n    :param element: The element to count in sublists\n    :return: Number of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    lst (list of list): The list of sublists to search.\n    element: The element to count in the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    lst (list of list): The list of sublists to search.\n    element: The element to count in the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    lst (list of list): The list of sublists to search.\n    element: The element to count in the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 25.619834710743802, "dps_norm": 44.44444444444444, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap and reduce it\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap and reduce it\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap and reduce it\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap and reduce it\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap and reduce it\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap and reduce it\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap and reduce it\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap and reduce it\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap and reduce it\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap and reduce it\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap and reduce it\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap and reduce it\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap and reduce it\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/433": {"dps": 63.93617021276595, "dps_norm": 62.0, "pass@1": 100.0, "profiled": [{"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": 71.61764705882354, "dps_norm": 22.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(input_string):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    :param input_string: The string from which to remove characters.\n    :return: A new string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([input_string[i] for i in range(len(input_string)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n    \n    :param s: Input string\n    :return: String with characters at odd indices removed\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n    \n    :param s: Input string\n    :return: String with characters at odd indices removed\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    :param s: Input string\n    :return: String with characters at odd indices removed\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n    \n    :param input_string: The string from which to remove characters at odd indices.\n    :return: A new string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([input_string[i] for i in range(len(input_string)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 98.0, "profiled": [{"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    :param tuple_data: The tuple in which to count occurrences.\n    :param list_data: The list of elements to count in the tuple.\n    :return: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    :param tuple_data: The tuple in which to count occurrences.\n    :param list_data: The list of elements to count in the tuple.\n    :return: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tuple_data (tuple): The tuple in which to count occurrences.\n    list_data (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count\ntuple_data = ('a', 'a', 'c', 'b', 'd')\nlist_data = ['a', 'b']", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tuple_data (tuple): The tuple in which to count occurrences.\n    list_data (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    :param tuple_data: The tuple in which to count occurrences.\n    :param list_data: The list of elements to count in the tuple.\n    :return: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    :param tuple_data: The tuple in which to count occurrences.\n    :param list_data: The list of elements to count in the tuple.\n    :return: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count\ntuple_data = ('a', 'a', 'c', 'b', 'd')\nlist_data = ['a', 'b']", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tuple_data (tuple): The tuple in which to count occurrences.\n    list_data (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tuple_data (tuple): The tuple in which to count occurrences.\n    list_data (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count\ntuple_data = ('a', 'a', 'c', 'b', 'd')\nlist_data = ['a', 'b']", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    :param tuple_data: The tuple in which to count occurrences.\n    :param list_data: The list of elements to count in the tuple.\n    :return: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tuple_data (tuple): The tuple in which to count occurrences.\n    list_data (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count\ntuple_data = ('a', 'a', 'c', 'b', 'd')\nlist_data = ['a', 'b']", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Counts the occurrence of all elements of a list in a tuple.\n\n    Parameters:\n    tuple_data (tuple): The tuple in which to count occurrences.\n    list_data (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count\ntuple_data = ('a', 'a', 'c', 'b', 'd')\nlist_data = ['a', 'b']", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tuple_data (tuple): The tuple in which to count occurrences.\n    list_data (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    :param tuple_data: The tuple in which to count occurrences.\n    :param list_data: The list of elements to count in the tuple.\n    :return: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count\ntuple_data = ('a', 'a', 'c', 'b', 'd')\nlist_data = ['a', 'b']", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    :param tuple_data: The tuple in which to count occurrences.\n    :param list_data: The list of elements to count in the tuple.\n    :return: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tuple_data (tuple): The tuple in which to count occurrences.\n    list_data (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Counts the occurrence of all elements of a list in a tuple.\n\n    Parameters:\n    tuple_data (tuple): The tuple in which to count occurrences.\n    list_data (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count\ntuple_data = ('a', 'a', 'c', 'b', 'd')\nlist_data = ['a', 'b']", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tuple_data (tuple): The tuple in which to count occurrences.\n    list_data (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    :param tuple_data: The tuple in which to count occurrences.\n    :param list_data: The list of elements to count in the tuple.\n    :return: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tuple_data (tuple): The tuple in which to count occurrences.\n    list_data (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_data):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tuple_data (tuple): The tuple in which to count occurrences.\n    list_data (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_data:\n        count += tuple_data.count(element)\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: A string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    :param string_list: List of strings to be reversed.\n    :return: List of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in the given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    :param string_list: List of strings to be reversed.\n    :return: List of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    :param string_list: List of strings to be reversed.\n    :return: List of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 53.26923076923077, "dps_norm": 82.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): The list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    :param lst: List of sublists\n    :return: List of first elements from each sublist\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): The list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): The list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): The list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    :param lst: List of sublists\n    :return: List of first elements from each sublist\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): The list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): The list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): The list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): The list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): The input list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    :param lst: List of sublists\n    :return: List of first elements of each sublist\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): The list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    :param lst: List of sublists\n    :return: List of first elements from each sublist\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): The list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): The list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): The list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the given list.\n\n    :param lst: List of sublists\n    :return: List of first elements from each sublist\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string\n    :param old_char: The character to be replaced\n    :param new_char: The character to replace with\n    :return: The modified string with characters replaced\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of `old_char` with `new_char` in `input_string`.\n\n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of `old_char` with `new_char` in `input_string`.\n\n    Args:\n        input_string (str): The original string.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string\n    :param old_char: The character to be replaced\n    :param new_char: The character to replace with\n    :return: The modified string with characters replaced\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string\n    :param old_char: The character to be replaced\n    :param new_char: The character to replace with\n    :return: The modified string with characters replaced\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the input_string.\n\n    :param input_string: The original string\n    :param old_char: The character to be replaced\n    :param new_char: The character to replace with\n    :return: The modified string with characters replaced\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of `old_char` with `new_char` in `input_string`.\n\n    Args:\n        input_string (str): The original string.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the input_string.\n\n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string with characters replaced.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of `old_char` with `new_char` in `input_string`.\n\n    Args:\n        input_string (str): The original string.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string\n    :param old_char: The character to be replaced\n    :param new_char: The character to replace with\n    :return: The modified string with characters replaced\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string with characters replaced.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n\n    :param input_string: The original string\n    :param old_char: The character to be replaced\n    :param new_char: The character to replace with\n    :return: The modified string with characters replaced\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string\n    :param old_char: The character to be replaced\n    :param new_char: The character to replace with\n    :return: The modified string with characters replaced\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the input_string.\n\n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string with characters replaced.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the input_string.\n\n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string with characters replaced.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string\n    :param old_char: The character to be replaced\n    :param new_char: The character to replace with\n    :return: The modified string with characters replaced\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string\n    :param old_char: The character to be replaced\n    :param new_char: The character to replace with\n    :return: The modified string with characters replaced\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the input_string.\n\n    :param input_string: The original string\n    :param old_char: The character to be replaced\n    :param new_char: The character to replace with\n    :return: The modified string with characters replaced\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of `old_char` with `new_char` in `input_string`.\n\n    Args:\n        input_string (str): The original string.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace `old_char` with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string\n    :param old_char: The character to be replaced\n    :param new_char: The character to replace with\n    :return: The modified string with characters replaced\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0  # Return 0 if the array is empty\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of numerical values.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of numerical values.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0  # Return 0 if the array is empty\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0  # Return 0 if the array is empty\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of numerical values.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0  # Return 0 if the array is empty\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0  # Return 0 if the array is empty\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of numerical values.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must not be empty.\")\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of numerical values.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0  # Return 0 if the array is empty\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of numerical values.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0  # Return 0 if the array is empty\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0  # Return 0 if the array is empty\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must not be empty.\")\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    :param s: The input string to be converted.\n    :return: The string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    s (str): The input string to be converted.\n\n    Returns:\n    str: The string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    :param s: The input string to be converted.\n    :return: The string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    s (str): The input string to be converted.\n\n    Returns:\n    str: The string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    s (str): The input string to be converted.\n\n    Returns:\n    str: The string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    s (str): The input string to be converted.\n\n    Returns:\n    str: The string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    s (str): The input string to be converted to lower case.\n\n    Returns:\n    str: The string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The string converted to lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    :param s: The input string to be converted.\n    :return: The string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 85.24590163934427, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    :param input_string: The string from which to extract values.\n    :return: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of extracted values.\n    \"\"\"\n    # Use regular expression to find all values between quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string (str): The input string containing values in quotation marks.\n\n    Returns:\n        list: A list of extracted values.\n    \"\"\"\n    # Use regular expression to find all values between quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    :param input_string: The string from which to extract values.\n    :return: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    :param input_string: The string from which to extract values.\n    :return: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    :param s: Input string containing values within quotation marks.\n    :return: List of extracted values.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n        s (str): The input string containing values in quotation marks.\n    \n    Returns:\n        list: A list of extracted values.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of values extracted from between the quotation marks.\n    \"\"\"\n    # Use regular expression to find all values between quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    :param input_string: The input string containing quoted values.\n    :return: A list of values extracted from between the quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string (str): The input string containing values in quotation marks.\n\n    Returns:\n        list: A list of values extracted from the input string.\n    \"\"\"\n    # Use regular expression to find all values between quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    :param input_string: The input string containing quoted values.\n    :return: A list of values extracted from between the quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string (str): The input string containing values in quotation marks.\n\n    Returns:\n        list: A list of extracted values.\n    \"\"\"\n    # Use regular expression to find all values between quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n        input_string (str): The input string containing values in quotation marks.\n    \n    Returns:\n        list: A list of extracted values.\n    \"\"\"\n    # Use regular expression to find all values between quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string (str): The input string containing values in quotation marks.\n\n    Returns:\n        list: A list of extracted values.\n    \"\"\"\n    # Use regular expression to find all values between quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        input_string (str): The input string containing values in quotation marks.\n\n    Returns:\n        list: A list of extracted values.\n    \"\"\"\n    # Use regular expression to find all values between quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    :param input_string: The string from which to extract values.\n    :return: A list of values found between quotation marks.\n    \"\"\"\n    # Use a regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 95.06172839506173, "dps_norm": 85.71428571428571, "pass@1": 62.0, "profiled": [{"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Iterate through the list and count occurrences\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Create a list of numbers that appear only once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Iterate through the list and count occurrences\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from a given list and returns a list of unique numbers.\n\n    Parameters:\n    nums (list): The list of numbers from which duplicates are to be removed.\n\n    Returns:\n    list: A list of unique numbers.\n    \"\"\"\n    # Use a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear only once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear only once\n    unique_nums = [num for num in lists if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Iterate through the list and count occurrences\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Count the occurrences of each number in the list\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear only once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Iterate through the list and count occurrences\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Create a list of numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Iterate through the list and count occurrences\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Iterate through the list and count occurrences\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Iterate through the list and count occurrences\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Create a list of numbers that appear only once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Iterate through the list and count occurrences\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Create a list of numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Count occurrences of each number in the list\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lists):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Iterate through the list and count occurrences\n    for num in lists:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Create a list of numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 94.9047619047619, "dps_norm": 72.27272727272728, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n    \n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    :param list1: First list\n    :param list2: Second list\n    :param list3: Third list\n    :return: Interleaved list\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    :param list1: First list\n    :param list2: Second list\n    :param list3: Third list\n    :return: Interleaved flat list\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    :param list1: First list\n    :param list2: Second list\n    :param list3: Third list\n    :return: Interleaved flat list\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n    \n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    :param list1: First list\n    :param list2: Second list\n    :param list3: Third list\n    :return: Interleaved flat list\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    :param list1: First list of elements\n    :param list2: Second list of elements\n    :param list3: Third list of elements\n    :return: A single flat list with elements interleaved from the three input lists\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All input lists must be of the same length\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n    \n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    :param list1: First list\n    :param list2: Second list\n    :param list3: Third list\n    :return: Interleaved flat list\n    \"\"\"\n    # Ensure all lists are of the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    :param list1: First list\n    :param list2: Second list\n    :param list3: Third list\n    :return: Interleaved flat list\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and adding the first part to the end.\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the original list\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and adding the first part to the end.\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the original list\n    \n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Add the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    :param arr: The list to be split.\n    :param n: The index at which to split the list.\n    :return: The modified list.\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the list as is.\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n    \n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list after splitting and adding the first part to the end.\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the list as is.\n    \n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Add the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n    \n    :param arr: The input list to be split.\n    :param n: The index at which to split the list.\n    :return: The modified list with the first part added to the end.\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the list as is.\n    \n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Add the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and adding the first part to the end.\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the original list\n    \n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Add the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and adding the first part to the end.\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the list as is.\n    \n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Add the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n    \n    :param arr: List to be split\n    :param n: Index at which to split the list\n    :return: List with the first part added to the end\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the original list\n    \n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Add the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n    \n    :param arr: List to be split and rearranged\n    :param n: Index at which to split the list\n    :return: Rearranged list\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the original list\n    \n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the array at the nth element and adds the first part to the end.\n    \n    :param arr: List of elements to be split\n    :param n: Index at which to split the array\n    :return: New list with the first part added to the end\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the array, return the original array\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n    \n    :param arr: List to be split\n    :param n: Index at which to split the list\n    :return: List with the first part added to the end\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the original list\n    \n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Add the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    :param arr: The input list.\n    :param n: The index at which to split the list.\n    :return: The modified list.\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the list as is.\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n    \n    :param arr: List to be split\n    :param n: Index at which to split the list\n    :return: Modified list with the first part added to the end\n    \"\"\"\n    if n >= len(arr) or n < 0:\n        return arr  # Return the original list if n is out of bounds\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and adding the first part to the end.\n    \"\"\"\n    if n >= len(arr) or n < 0:\n        return arr  # Return the original list if n is out of bounds\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the array at the nth element and adds the first part to the end.\n    \n    :param arr: List to be split and rearranged\n    :param n: Index at which to split the list\n    :return: Rearranged list\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the array, return the array as is\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and adding the first part to the end.\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the original list\n    \n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Add the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n    \n    :param arr: List to be split and rearranged\n    :param n: Index at which to split the list\n    :return: Rearranged list\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the original list\n    \n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The input list.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list.\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the list as is.\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and adding the first part to the end.\n    \"\"\"\n    if n >= len(arr) or n < 0:\n        return arr  # Return the original list if n is out of bounds\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    :param arr: The input list.\n    :param n: The index at which to split the list.\n    :return: The modified list.\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the list, return the list as is.\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple converted from the list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple converted from the list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple converted from the list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple converted from the list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple converted from the list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple converted from the list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple converted from the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple converted from the list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple converted from the list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple converted from the list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    :param nums: List of integers\n    :return: Difference between the largest and smallest value\n    \"\"\"\n    if not nums:\n        return 0  # Return 0 if the list is empty\n    \n    min_num = min(nums)\n    max_num = max(nums)\n    \n    return max_num - min_num", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    :param lst: List of integers or floats\n    :return: Difference between the largest and smallest value\n    \"\"\"\n    if not lst:  # Check if the list is empty\n        return 0\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a given list.\n\n    Parameters:\n    lst (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a given list.\n\n    Parameters:\n    lst (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    :param nums: List of integers\n    :return: Difference between the largest and smallest value\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a given list.\n\n    Parameters:\n    lst (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    :param nums: List of integers or floats\n    :return: Difference between the largest and smallest value\n    \"\"\"\n    if not nums:\n        return 0  # Return 0 if the list is empty\n    \n    min_num = min(nums)\n    max_num = max(nums)\n    \n    return max_num - min_num", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    Parameters:\n    lst (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest value in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    Parameters:\n    lst (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest value in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    :param nums: List of integers\n    :return: Difference between the largest and smallest value\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a given list.\n\n    Parameters:\n    lst (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    :param nums: List of integers\n    :return: Difference between the largest and smallest value\n    \"\"\"\n    if not nums:\n        return 0  # Return 0 if the list is empty\n    \n    min_num = min(nums)\n    max_num = max(nums)\n    \n    return max_num - min_num", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a given list.\n\n    :param lst: List of integers or floats\n    :return: Difference between the largest and smallest values\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    :param nums: List of integers\n    :return: Difference between the largest and smallest value\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    Parameters:\n    lst (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest value in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    Parameters:\n    lst (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest value in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a given list.\n\n    Parameters:\n    lst (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a given list.\n\n    Parameters:\n    lst (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a given list.\n\n    :param lst: List of integers or floats\n    :return: Difference between the largest and smallest values\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a given list.\n\n    Parameters:\n    lst (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 57.66666666666667, "dps_norm": 50.0, "pass@1": 76.0, "profiled": [{"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n\n    total = 0\n    for k in range(n):\n        total += comb(n, k) * comb(n, k + 1)\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n\n    total_sum = 0\n    for k in range(n):\n        # Calculate the product of consecutive binomial coefficients\n        product = comb(n, k) * comb(n, k + 1)\n        total_sum += product\n\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient C(n, k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    result = 1\n    for i in range(k):\n        result = result * (n - i) // (i + 1)\n    return result\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients.\"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total += binomial_coefficient(n, i) * binomial_coefficient(n, i - 1)\n    return total", "matching_cluster_idx": 4}, {"solution": "def factorial(n):\n    \"\"\"Helper function to compute the factorial of a number.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\ndef binomial_coefficient(n, k):\n    \"\"\"Helper function to compute the binomial coefficient C(n, k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    return factorial(n) // (factorial(k) * factorial(n - k))\ndef sum_Of_product(n):\n    \"\"\"Function to find the sum of the product of consecutive binomial coefficients.\"\"\"\n    total_sum = 0\n    for i in range(1, n + 1):\n        total_sum += binomial_coefficient(n, i) * binomial_coefficient(n, i - 1)\n    return total_sum", "matching_cluster_idx": 0}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n\n    total_sum = 0\n    for k in range(n):\n        # Calculate the product of consecutive binomial coefficients C(n, k) and C(n, k+1)\n        product = comb(n, k) * comb(n, k + 1)\n        total_sum += product\n\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        # Calculate binomial coefficients C(n, k) and C(n, k+1)\n        binom_k = math.comb(n, k)\n        binom_k_plus_1 = math.comb(n, k + 1)\n        # Add the product of consecutive binomial coefficients to the total sum\n        total_sum += binom_k * binom_k_plus_1\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n\n    total = 0\n    for k in range(n):\n        total += comb(n, k) * comb(n, k + 1)\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n\n    total = 0\n    for k in range(n):\n        total += comb(n, k) * comb(n, k + 1)\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n\n    total_sum = 0\n    for k in range(n):\n        # Calculate the product of consecutive binomial coefficients C(n, k) and C(n, k+1)\n        product = comb(n, k) * comb(n, k + 1)\n        total_sum += product\n\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n\n    total = 0\n    for k in range(n):\n        total += comb(n, k) * comb(n, k + 1)\n    return total", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient C(n, k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    result = 1\n    for i in range(k):\n        result = result * (n - i) // (i + 1)\n    return result\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients.\"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total += binomial_coefficient(n, i) * binomial_coefficient(n, i - 1)\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n\n    total = 0\n    for k in range(n):\n        total += comb(n, k) * comb(n, k + 1)\n    \n    return total", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n\n    total_sum = 0\n    for k in range(n):\n        # Calculate the product of consecutive binomial coefficients C(n, k) * C(n, k+1)\n        product = comb(n, k) * comb(n, k + 1)\n        total_sum += product\n\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n\n    total_sum = 0\n    for k in range(n):\n        # Calculate the product of consecutive binomial coefficients C(n, k) and C(n, k+1)\n        product = comb(n, k) * comb(n, k + 1)\n        total_sum += product\n\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        # Calculate binomial coefficients C(n, k) and C(n, k+1)\n        binom_k = math.comb(n, k)\n        binom_k_plus_1 = math.comb(n, k + 1)\n        \n        # Add the product of consecutive binomial coefficients to the total sum\n        total_sum += binom_k * binom_k_plus_1\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient C(n, k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    result = 1\n    for i in range(k):\n        result = result * (n - i) // (i + 1)\n    return result\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients.\"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total += binomial_coefficient(n, i) * binomial_coefficient(n, i - 1)\n    return total", "matching_cluster_idx": 4}, {"solution": "def factorial(n):\n    \"\"\"Helper function to compute the factorial of a number.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\ndef binomial_coefficient(n, k):\n    \"\"\"Helper function to compute the binomial coefficient C(n, k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    return factorial(n) // (factorial(k) * factorial(n - k))\ndef sum_Of_product(n):\n    \"\"\"Function to find the sum of the product of consecutive binomial coefficients.\"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += binomial_coefficient(n, i) * binomial_coefficient(n, i + 1)\n    return total_sum", "matching_cluster_idx": -1}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb  # comb(n, k) returns the binomial coefficient C(n, k)\n\n    total_sum = 0\n    for k in range(n):\n        # Calculate the product of consecutive binomial coefficients C(n, k) and C(n, k+1)\n        product = comb(n, k) * comb(n, k + 1)\n        total_sum += product\n\n    return total_sum", "matching_cluster_idx": 4}]}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 69.0, "profiled": [{"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: The string with the order of words reversed.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list back into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: The string with words in reversed order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: The string with words in reversed order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: The string with words in reversed order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a single string with spaces\n    reversed_sentence = ' '.join(reversed_words)\n    \n    return reversed_sentence", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: The string with words in reversed order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list back into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string where words are separated by spaces.\n\n    Args:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: The string with words in reversed order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    # Split the input string into a list of words\n    words = input_string.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list of words into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string where words are separated by spaces.\n\n    :param s: The input string containing words separated by spaces.\n    :return: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list back into a single string with spaces\n    reversed_sentence = ' '.join(reversed_words)\n    \n    return reversed_sentence", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: The string with words in reversed order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list of words into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: The string with words in reversed order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a single string with spaces\n    reversed_sentence = ' '.join(reversed_words)\n    \n    return reversed_sentence", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string where words are separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: The string with the words in reversed order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list of words into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: The string with the order of words reversed.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list of words into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: The string with words in reversed order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list of words into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: The string with words in reversed order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    :param s: The input string containing words separated by spaces.\n    :return: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list back into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    :param s: Input string with words separated by spaces\n    :return: String with words in reversed order\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    # Split the input string into a list of words\n    words = input_string.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list of words into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: The string with the order of words reversed.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: The string with words in reversed order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: The string with words in reversed order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list of words into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 58.69565217391305, "dps_norm": 57.142857142857146, "pass@1": 82.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n\n    Parameters:\n    lst (list): The input list.\n    k (int): The index of the element to remove (1-based indexing).\n\n    Returns:\n    list: The list with the k'th element removed.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst  # If k is out of bounds, return the original list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n\n    :param lst: The input list.\n    :param k: The index of the element to remove (1-based index).\n    :return: The list with the k'th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    Parameters:\n    lst (list): The input list.\n    k (int): The index of the element to remove (1-based indexing).\n    \n    Returns:\n    list: The list with the k'th element removed.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based indexing)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    Parameters:\n    lst (list): The input list.\n    k (int): The index of the element to remove (1-based indexing).\n    \n    Returns:\n    list: The list with the k'th element removed.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n\n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n\n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst  # If k is out of bounds, return the original list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 53.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n'th column in the given matrix.\n\n    :param matrix: A list of lists representing the matrix.\n    :param n: The index of the column (0-based).\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure the column index is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix\")\n    \n    # Extract the n'th column and find the maximum value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n'th column in the given matrix.\n    \n    :param matrix: A list of lists representing the matrix.\n    :param n: The index of the column (0-based).\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Extract the n'th column from each row\n    nth_column = [row[n] for row in matrix]\n    \n    # Return the maximum value in the n'th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \n    :param matrix: List of lists representing the matrix.\n    :param n: The column index (0-based) to find the max value of.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure the column index is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix\")\n    \n    # Extract the n'th column and find the max value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n'th column in the given matrix.\n    \n    :param matrix: A list of lists representing the matrix.\n    :param n: The index of the column (0-based).\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Extract the n'th column from each row\n    column = [row[n] for row in matrix]\n    \n    # Return the maximum value in the column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n'th column in the given matrix.\n\n    :param matrix: A list of lists representing the matrix.\n    :param n: The index of the column (0-based).\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Extract the n'th column from each row\n    nth_column = [row[n] for row in matrix]\n    \n    # Return the maximum value in the n'th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n'th column in the given matrix.\n    \n    :param matrix: A list of lists representing the matrix.\n    :param n: The index of the column to find the maximum value of.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure n is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix.\")\n    \n    # Extract the n'th column and find the maximum value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \n    :param matrix: List of lists representing the matrix.\n    :param n: The index of the column to find the max value.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure n is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix\")\n    \n    # Extract the n'th column and find the max value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n'th column in the given matrix.\n\n    :param matrix: A list of lists representing the matrix.\n    :param n: The index of the column (0-based).\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Extract the n'th column from each row\n    column = [row[n] for row in matrix]\n    \n    # Return the maximum value in the column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n'th column in the given matrix.\n\n    :param matrix: A list of lists representing the matrix.\n    :param n: The index of the column (0-based).\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure the column index is within the matrix's column range\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix.\")\n    \n    # Extract the n'th column and find its maximum value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \n    :param matrix: List of lists representing the matrix.\n    :param n: The column index (0-based) to find the max value.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure the column index is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix\")\n    \n    # Extract the n'th column and find the max value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n'th column in the given matrix.\n    \n    :param matrix: List of lists representing the matrix.\n    :param n: The column index (0-based) to find the maximum value of.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure the column index is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix\")\n    \n    # Extract the n'th column and find the maximum value\n    max_value = max(row[n] for row in matrix)\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n'th column in the given matrix.\n\n    :param matrix: A list of lists representing the matrix.\n    :param n: The index of the column to find the maximum value of.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure the column index is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix.\")\n    \n    # Extract the n'th column and find its maximum value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \n    :param matrix: List of lists representing the matrix.\n    :param n: The index of the column to find the max value.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure the column index is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix.\")\n    \n    # Extract the n'th column and find the max value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \n    :param matrix: List of lists representing the matrix.\n    :param n: The column index (0-based) to find the max value of.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure the column index is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix.\")\n    \n    # Extract the n'th column and find the max value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \n    :param matrix: List of lists representing the matrix.\n    :param n: The column index (0-based) to find the max value.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure the column index is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix\")\n    \n    # Extract the n'th column and find the max value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \n    :param matrix: List of lists representing the matrix.\n    :param n: The column index (0-based) to find the max value.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure the column index is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix.\")\n    \n    # Extract the n'th column and find the max value\n    max_value = max(row[n] for row in matrix)\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n'th column in the given matrix.\n\n    :param matrix: A list of lists representing the matrix.\n    :param n: The index of the column (0-based).\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure the column index is within the matrix's column range\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix.\")\n    \n    # Extract the n'th column and find its maximum value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \n    :param matrix: List of lists representing the matrix.\n    :param n: The index of the column to find the max value.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure the column index is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix\")\n    \n    # Extract the n'th column and find the max value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \n    :param matrix: List of lists representing the matrix\n    :param n: Index of the column to find the max value (0-based index)\n    :return: The maximum value in the n'th column\n    \"\"\"\n    # Ensure the column index is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix\")\n    \n    # Extract the n'th column and find the max value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \n    :param matrix: List of lists representing the matrix.\n    :param n: The column index (0-based) to find the max value.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure the column index is within the range of the matrix columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid column index or empty matrix.\")\n    \n    # Extract the n'th column and find the max value\n    column = [row[n] for row in matrix]\n    return max(column)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zero elements\n    non_zero = [x for x in lst if x != 0]\n    zero = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements followed by zero elements\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [0] * (len(lst) - len(non_zero))\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zeroes\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine non-zero elements and zeroes\n    return non_zero + zeroes", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/644": {"dps": 93.82978723404254, "dps_norm": 91.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    # Check if k is within the bounds of the array\n    if k > len(arr) or k < 0:\n        raise ValueError(\"k is out of bounds for the given array.\")\n    \n    # Reverse the array up to the k-th position\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n    \n    :param arr: List of elements to be reversed\n    :param k: Position up to which the array should be reversed\n    :return: List with elements reversed up to position k\n    \"\"\"\n    # Reverse the portion of the array up to the k-th index\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    # Check if k is within the bounds of the array\n    if k > len(arr) or k < 0:\n        raise ValueError(\"k is out of bounds\")\n    \n    # Reverse the array up to the k-th position\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    if k > len(arr):\n        k = len(arr)\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    :param arr: List of elements to be reversed.\n    :param k: Position up to which the array should be reversed.\n    :return: List with elements reversed up to position k.\n    \"\"\"\n    # Reverse the portion of the array up to index k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n    \n    :param arr: List of elements to be reversed\n    :param k: Position up to which the array should be reversed\n    :return: List with elements reversed up to position k\n    \"\"\"\n    # Ensure k is within the bounds of the array\n    if k > len(arr):\n        k = len(arr)\n    \n    # Reverse the array up to the k-th position\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    :param arr: List of elements to be reversed.\n    :param k: Position up to which the array should be reversed.\n    :return: List with elements reversed up to position k.\n    \"\"\"\n    # Ensure k is within the bounds of the array\n    if k > len(arr):\n        k = len(arr)\n    \n    # Reverse the portion of the array up to index k\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    # Check if k is within the bounds of the array\n    if k > len(arr) or k < 0:\n        raise ValueError(\"k is out of bounds\")\n    \n    # Reverse the array up to the k-th position\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    :param arr: List of elements to be reversed.\n    :param k: Position up to which the array should be reversed.\n    :return: List with elements reversed up to position k.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    # Ensure k is within the bounds of the array\n    if k > len(arr):\n        k = len(arr)\n    \n    # Reverse the portion of the array up to index k\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    :param arr: List of elements to be reversed.\n    :param k: Position up to which the array should be reversed.\n    :return: List with elements reversed up to position k.\n    \"\"\"\n    # Reverse the portion of the array up to index k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    if k > len(arr):\n        k = len(arr)\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    :param arr: List of elements to be reversed\n    :param k: Position up to which the array should be reversed\n    :return: List with elements reversed up to position k\n    \"\"\"\n    # Reverse the subarray from index 0 to k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    :param arr: List of elements to be reversed.\n    :param k: Position up to which the array should be reversed.\n    :return: List with elements reversed up to position k.\n    \"\"\"\n    # Check if k is within the bounds of the array\n    if k > len(arr) or k < 0:\n        raise ValueError(\"k is out of bounds\")\n    \n    # Reverse the array up to the k-th position\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n    \n    :param arr: List of elements to be reversed\n    :param k: Position up to which the array should be reversed\n    :return: List with elements reversed up to position k\n    \"\"\"\n    # Reverse the portion of the array up to the k-th element\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with elements reversed up to the k-th position.\n    \"\"\"\n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    # Ensure k is within the bounds of the array\n    if k > len(arr):\n        k = len(arr)\n    \n    # Reverse the array up to the k-th position\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array\")\n    \n    # Reverse the array up to the k-th position\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the elements of the array up to the given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    # Ensure k is within the bounds of the array\n    if k > len(arr):\n        k = len(arr)\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}]}, "Mbpp/720": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary added.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary added.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary added.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary added.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary added.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary added.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    :param input_tuple: The original tuple to which the dictionary will be added.\n    :param input_dict: The dictionary to be added to the tuple.\n    :return: A new tuple containing the elements of the original tuple followed by the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary added.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 67.97814207650272, "dps_norm": 72.5, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    :param text: The input string containing quoted values.\n    :return: A list of values found between the quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    :param text: The input string containing quoted values.\n    :return: A list of values found between the quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    :param text: The input string containing quoted values.\n    :return: A list of values found between the quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n\n    Args:\n        text (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    Args:\n        text (str): The input string containing quoted values.\n    \n    Returns:\n        list: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    :param text: The input string containing quoted values.\n    :return: A list of values found between the quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    :param text: The input string containing quoted values.\n    :return: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n\n    Args:\n        text (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of values extracted from between the quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    Args:\n        text (str): The input string containing quoted values.\n    \n    Returns:\n        list: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    :param text: The input string containing quoted values.\n    :return: A list of values found between the quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    Args:\n        text (str): The input string containing quoted values.\n    \n    Returns:\n        list: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n\n    Args:\n        text (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n\n    Args:\n        text (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    :param text: The input string containing quoted values.\n    :return: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    Args:\n        text (str): The input string containing quoted values.\n    \n    Returns:\n        list: A list of values extracted from between the quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks from the given string.\n    \n    :param text: The input string containing quoted values.\n    :return: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within double quotes\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    Args:\n        text (str): The input string containing quoted values.\n    \n    Returns:\n        list: A list of values extracted from between the quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    :param text: The input string containing quoted values.\n    :return: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    :param text: The input string containing quoted values.\n    :return: A list of values extracted from between the quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n\n    Args:\n        text (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of values found between quotation marks.\n    \"\"\"\n    # Use regular expression to find all text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 4}]}, "Mbpp/732": {"dps": 24.651162790697676, "dps_norm": 52.0, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon in the input string.\n\n    :param input_string: The string to be processed.\n    :return: The processed string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = [' ', ',', '.']\n    \n    # Replace each character with a colon\n    for char in chars_to_replace:\n        input_string = input_string.replace(char, ':')\n    \n    return input_string", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with a colon\n    result = input_string.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return result", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with a colon\n    for char in [' ', ',', '.']:\n        input_string = input_string.replace(char, ':')\n    return input_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with a colon\n    for char in [' ', ',', '.']:\n        input_string = input_string.replace(char, ':')\n    return input_string", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}]}, "Mbpp/740": {"dps": 83.63636363636364, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: Input tuple\n    :return: Dictionary created from adjacent elements of the tuple\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even to form key-value pairs.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: Tuple to be converted\n    :return: Dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements to form key-value pairs.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    :param t: Input tuple\n    :return: Dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n\n    :param t: The input tuple\n    :return: A dictionary where adjacent elements are key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements to form key-value pairs.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    :param t: Input tuple\n    :return: Dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    t (tuple): The input tuple.\n    \n    Returns:\n    dict: A dictionary where each key-value pair is formed from adjacent elements in the tuple.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements to form key-value pairs.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    Args:\n        t (tuple): The input tuple.\n    \n    Returns:\n        dict: A dictionary with adjacent elements as key-value pairs.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: Input tuple\n    :return: Dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: Input tuple\n    :return: Dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even to form key-value pairs.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: Input tuple\n    :return: Dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even to form key-value pairs.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    :param t: Input tuple\n    :return: Dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements to form key-value pairs.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: Input tuple\n    :return: Dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements to form key-value pairs.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: Input tuple\n    :return: Dictionary created from adjacent elements of the tuple\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even to form key-value pairs.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: The input tuple\n    :return: A dictionary where adjacent elements are key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: Input tuple\n    :return: Dictionary created from adjacent elements of the tuple\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even to form key-value pairs.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    t (tuple): The input tuple.\n    \n    Returns:\n    dict: A dictionary where each key-value pair is formed from adjacent elements in the tuple.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements to form key-value pairs.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    :param t: Input tuple\n    :return: Dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements to form key-value pairs.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: Input tuple\n    :return: Dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements to form key-value pairs.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: Input tuple\n    :return: Dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements to form key-value pairs.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    :param t: Input tuple\n    :return: Dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 13.356164383561644, "dps_norm": 40.0, "pass@1": 100.0, "profiled": [{"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    :param tuple_input: The tuple to check\n    :return: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return any(element is None for element in tuple_input)", "matching_cluster_idx": 1}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    tuple_input (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in tuple_input)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n    \n    :param tup: The tuple to check\n    :return: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n    \n    :param tup: The tuple to check\n    :return: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n    \n    :param tup: The tuple to check\n    :return: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n    \n    :param tup: The tuple to check\n    :return: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    :param tuple_input: The tuple to check\n    :return: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return any(element is None for element in tuple_input)", "matching_cluster_idx": 1}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    :param tuple_input: The tuple to be checked\n    :return: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tuple_data):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    :param tuple_data: The tuple to be checked.\n    :return: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tuple_data)", "matching_cluster_idx": 2}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple contains any None value.\n    \n    :param tuple_input: The tuple to check\n    :return: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return any(element is None for element in tuple_input)", "matching_cluster_idx": 2}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple contains any None value.\n    \n    :param tuple_input: The tuple to check\n    :return: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return any(element is None for element in tuple_input)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n    \n    :param tup: The tuple to check\n    :return: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 1}]}, "Mbpp/750": {"dps": 98.5374149659864, "dps_norm": 99.16666666666667, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple to the given list and returns the updated list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The list with the tuple added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The list with the tuple added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple to the given list and returns the updated list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The list with the tuple added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple to the given list and returns the updated list.\n    \n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    # Convert the tuple to a list and extend the original list\n    lst.extend(list(tpl))\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple to the given list and returns the updated list.\n    \n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The list with the tuple added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}]}, "Mbpp/753": {"dps": 97.31543624161074, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list based on the second element of the tuples\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of tuples containing the k minimum records.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where the second element is a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest second element values.\n    \"\"\"\n    # Sort the list based on the second element of the tuples\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuples_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list of tuples based on the second element (numeric value)\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    \n    # Return the first k tuples from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuples_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list of tuples based on the second element (numeric value)\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    \n    # Return the first k tuples from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where the second element is a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of tuples containing the minimum k records.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuples_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list of tuples based on the second element (numeric value)\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where the second element is a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of tuples containing the minimum k records.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuples_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list of tuples based on the second element (numeric value)\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuples_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list of tuples based on the second element (numeric value)\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    \n    # Return the first k tuples from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 89.65517241379311, "dps_norm": 87.5, "pass@1": 99.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n\n    Returns:\n    list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Parameters:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n\n    Returns:\n    list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n    \n    Args:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n    \n    Returns:\n    list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n    \n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Parameters:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n\n    Returns:\n    list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n    \n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    # Iterate through the indices of the lists\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n    \n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear under the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements that appear under the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/757": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/758": {"dps": 98.26254826254825, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts lists within a list and returns a dictionary where every list is converted to a tuple\n    and the value of such tuple is the number of its occurrences in the original list.\n\n    :param lst: List of lists\n    :return: Dictionary with tuples as keys and their counts as values\n    \"\"\"\n    count_dict = {}\n    for sublist in lst:\n        # Convert the list to a tuple to make it hashable\n        tuple_sublist = tuple(sublist)\n        # Update the count in the dictionary\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list and returns a dictionary\n    where each sublist is converted to a tuple, and the value is the count of its occurrences.\n\n    :param lst: List of lists\n    :return: Dictionary with tuples as keys and their counts as values\n    \"\"\"\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n\n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # Update the count in the dictionary\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Convert each sublist to a tuple and count occurrences\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list and returns a dictionary\n    where each key is a tuple representation of the sublist and the value is the count of its occurrences.\n    \n    :param lst: List of lists\n    :return: Dictionary with tuple keys and integer values\n    \"\"\"\n    count_dict = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple to make it hashable\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Convert each sublist to a tuple and count occurrences\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Convert each sublist to a tuple and count occurrences\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # Update the count in the dictionary\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Convert each sublist to a tuple and count occurrences\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # Update the count in the dictionary\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # Update the count in the dictionary\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list and returns a dictionary\n    where each sublist is converted to a tuple and the value is the count of its occurrences.\n    \n    :param lst: List of lists\n    :return: Dictionary with tuples as keys and their counts as values\n    \"\"\"\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # Update the count in the dictionary\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list and returns a dictionary\n    where each sublist is converted to a tuple, and the value is the count of its occurrences.\n    \n    :param lst: List of lists\n    :return: Dictionary with tuples as keys and their counts as values\n    \"\"\"\n    count_dict = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        # Update the count in the dictionary\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # Update the count in the dictionary\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Convert each sublist to a tuple and count occurrences\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 32.846715328467155, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    \n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    \n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Empty list has no distinct elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to search for digits.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to be analyzed.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to be checked for digits.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to search for digits.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to count digits in.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    :param input_string: The string to be analyzed.\n    :return: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 55.14018691588785, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: The input list.\n    :return: A list of tuples, where each tuple contains a pair of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: List of items\n    :return: List of tuples representing consecutive pairs\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples containing consecutive pairs\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: The input list.\n    :return: A list of tuples representing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    :param lst: List of items\n    :return: List of tuples representing consecutive pairs\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    :param lst: List of items\n    :return: List of tuples representing consecutive pairs\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: The input list.\n    :return: A list of tuples representing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: The input list.\n    :return: A list of tuples representing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: The input list.\n    :return: A list of tuples representing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: List of items\n    :return: List of tuples representing consecutive pairs\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: The input list.\n    :return: A list of tuples representing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    :param lst: List of items\n    :return: List of tuples representing consecutive pairs\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    :param lst: List of items\n    :return: List of tuples representing consecutive pairs\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    :param lst: List of items\n    :return: List of tuples representing consecutive pairs\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples representing consecutive pairs\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: The input list.\n    :return: A list of tuples representing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: The input list.\n    :return: A list of tuples representing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: The input list.\n    :return: A list of tuples representing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: The input list.\n    :return: A list of tuples representing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: The input list.\n    :return: A list of tuples representing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}]}, "Mbpp/775": {"dps": 92.96, "dps_norm": 70.0, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    :param nums: List of integers\n    :return: Boolean indicating if every odd index contains an odd number\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    Parameters:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param lst: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n\n    :param lst: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param lst: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for index, value in enumerate(lst):\n        if index % 2 != 0:  # Check only odd indices\n            if value % 2 == 0:  # If the value at odd index is even, return False\n                return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n\n    :param lst: List of integers\n    :return: Boolean indicating if every odd index contains an odd number\n    \"\"\"\n    for i in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    :param nums: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": 60.204081632653065, "dps_norm": 71.11111111111111, "pass@1": 28.0, "profiled": [{"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    # Iterate through the list and add elements to the set\n    for num in lst:\n        unique_elements.add(num)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Use a set to remove duplicates\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Use a set to filter out repeated elements\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Use a set to remove duplicates\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    # Iterate through the list and add elements to the set\n    for num in lst:\n        unique_elements.add(num)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    # Iterate through the list and add elements to the set\n    for num in lst:\n        unique_elements.add(num)\n    # Calculate the sum of unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    # Iterate through the list and add elements to the set\n    for num in lst:\n        unique_elements.add(num)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Use a set to store unique elements\n    unique_elements = set()\n    # Iterate through the list and add elements to the set\n    for num in lst:\n        unique_elements.add(num)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    # Iterate through the list and add elements to the set\n    for num in lst:\n        unique_elements.add(num)\n    # Calculate the sum of unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Use a set to filter out repeated elements\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    # Iterate through the list and add elements to the set\n    for num in lst:\n        unique_elements.add(num)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Use a set to filter out repeated elements\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    # Iterate through the list and add elements to the set\n    for num in lst:\n        unique_elements.add(num)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Use a set to filter out repeated elements\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Use a set to filter out repeated elements\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    # Iterate through the list and add elements to the set\n    for num in lst:\n        unique_elements.add(num)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    # Iterate through the list and add elements to the set\n    for num in lst:\n        unique_elements.add(num)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    # Iterate through the list and add elements to the set\n    for num in lst:\n        unique_elements.add(num)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    # Iterate through the list and add elements to the set\n    for num in lst:\n        unique_elements.add(num)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    # Iterate through the list and add elements to the set\n    for num in lst:\n        unique_elements.add(num)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 4}]}, "Mbpp/781": {"dps": 89.92125984251967, "dps_norm": 52.0, "pass@1": 100.0, "profiled": [{"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a given number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a given number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a given number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a given number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize the count of divisors\n    count = 0\n    \n    # Iterate from 1 to n to find divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    \n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a given number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize the count of divisors\n    count = 0\n    \n    # Iterate from 1 to n and count the divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    \n    # Check if the count is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a given number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a given number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}]}, "Mbpp/800": {"dps": 87.01492537313433, "dps_norm": 94.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: A string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    :param lists: List of lists containing integers\n    :return: The list with the highest sum of elements\n    \"\"\"\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    :param lists: List of lists containing integers\n    :return: The list with the highest sum of elements\n    \"\"\"\n    # Use the max function with a key that calculates the sum of each list\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    :param lists: List of lists containing integers.\n    :return: The list with the highest sum of elements.\n    \"\"\"\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    :param list_of_lists: A list of lists containing integers.\n    :return: The list with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    # Calculate the sum of each list and find the list with the maximum sum\n    max_sum = -float('inf')\n    max_list = None\n    \n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    :param lists: List of lists containing integers\n    :return: The list with the highest sum of elements\n    \"\"\"\n    # Use the max function with a key that calculates the sum of each list\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    :param list_of_lists: List of lists containing integers\n    :return: The list with the highest sum of elements\n    \"\"\"\n    # Use the max function with a key that calculates the sum of each list\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    :param list_of_lists: List of lists containing integers\n    :return: The list with the highest sum of elements\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    # Use the max function with a key that calculates the sum of each list\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    :param list_of_lists: A list of lists containing integers.\n    :return: The list with the highest sum of elements.\n    \"\"\"\n    # Use the max function with a key that calculates the sum of each list\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    :param lists: List of lists containing integers\n    :return: The list with the highest sum of elements\n    \"\"\"\n    # Use the max function with a key that calculates the sum of each list\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    :param lists: List of lists containing integers\n    :return: The list with the highest sum of elements\n    \"\"\"\n    # Use the max function with a key that calculates the sum of each list\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    :param lists: List of lists containing integers\n    :return: The list with the highest sum of elements\n    \"\"\"\n    # Use the max function with a key that calculates the sum of each list\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    :param lists: List of lists containing integers.\n    :return: The list with the highest sum of elements.\n    \"\"\"\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    :param list_of_lists: A list of lists containing integers.\n    :return: The list with the highest sum of elements.\n    \"\"\"\n    # Use the max function with a key that calculates the sum of each list\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    :param list_of_lists: List of lists containing integers\n    :return: The list with the highest sum of elements\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    # Calculate the sum of each list and find the list with the maximum sum\n    max_list = max(list_of_lists, key=sum)\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    :param list_of_lists: List of lists containing integers\n    :return: The list with the highest sum of elements\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    # Find the list with the maximum sum\n    max_list = max(list_of_lists, key=sum)\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    :param list_of_lists: List of lists containing integers\n    :return: List with the highest sum of elements\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    max_sum = float('-inf')\n    max_list = None\n    \n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    :param list_of_lists: List of lists containing integers\n    :return: The list with the highest sum of elements\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    # Calculate the sum of each list and find the list with the maximum sum\n    max_list = max(list_of_lists, key=sum)\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    :param lists: List of lists containing integers\n    :return: The list with the highest sum of elements\n    \"\"\"\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    :param list_of_lists: List of lists containing integers\n    :return: The list with the highest sum of elements\n    \"\"\"\n    # Use the max function with a key that calculates the sum of each list\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    :param list_of_lists: A list of lists containing integers.\n    :return: The list with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    # Calculate the sum of each list and store it with the list\n    sum_list_pairs = [(sum(lst), lst) for lst in list_of_lists]\n    \n    # Find the pair with the maximum sum\n    max_sum_pair = max(sum_list_pairs, key=lambda x: x[0])\n    \n    # Return the list with the highest sum\n    return max_sum_pair[1]", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n    \n    :param tuples: A tuple of integers\n    :param k: An integer to check for in the tuple\n    :return: True if k is in the tuple, False otherwise\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the value k.\n\n    :param tuples: A tuple of integers.\n    :param k: The integer to check for in the tuple.\n    :return: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    :param tuples: A tuple of integers\n    :param k: An integer to check for in the tuple\n    :return: True if k is in the tuple, False otherwise\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuples contain the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to be checked.\n    k (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}]}}}