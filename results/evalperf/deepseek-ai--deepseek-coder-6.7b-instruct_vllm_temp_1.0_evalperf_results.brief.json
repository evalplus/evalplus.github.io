{"date": "2024-10-19 16:28", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 83.55516548026816, "dps_norm": 78.20569308671841, "pass@1": 73.57627118644068}, "eval": {"HumanEval/9": {"dps": 72.98107255520505, "dps_norm": 68.33333333333333, "pass@1": 78.0, "profiled": [{"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_numbers = [numbers[0]]\n    for i in range(1, len(numbers)):\n        max_numbers.append(max(max_numbers[-1], numbers[i]))\n    \n    return max_numbers", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if len(numbers) == 0:\n        return []\n    \n    max_numbers = [numbers[0]]\n    for i in range(1, len(numbers)):\n        max_numbers.append(max(numbers[i], max_numbers[i-1]))\n\n    return max_numbers", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    \n    max_numbers = [numbers[0]] \n    for i in range(1, len(numbers)):\n        max_numbers.append(max(max_numbers[-1], numbers[i]))\n    return max_numbers", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    result = [numbers[0]]\n    for i in range(1, len(numbers)):\n        result.append(max(result[-1], numbers[i]))\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = [numbers[0]]\n    for num in numbers[1:]:\n        rolling_max_list.append(max(rolling_max_list[-1], num))\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    max_values = [numbers[0]]\n    current_max = numbers[0]\n\n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        max_values.append(current_max)\n\n    return max_values", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    rolling_max_list = [numbers[0]]\n    for i in range(1, len(numbers)):\n        rolling_max_list.append(max(rolling_max_list[-1], numbers[i]))\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    # Initialize an empty list to store the rolling maximums\n    rolling_maxes = []\n    \n    # Initialize the maximum to None\n    max_number = None\n\n    # Loop over the numbers in the input list\n    for number in numbers:\n        # If the maximum is None (or if the current number is greater than the maximum),\n        # update the maximum\n        if max_number is None or number > max_number:\n            max_number = number\n        \n        # Append the current maximum to the list of rolling maximums\n        rolling_maxes.append(max_number)\n    \n    return rolling_maxes", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    \n    res = [numbers[0]]\n    max_val = numbers[0]\n    \n    for num in numbers[1:]:\n        if num > max_val:\n            max_val = num\n        res.append(max_val)\n    \n    return res", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    max_list = [numbers[0]]\n    for i in range(1, len(numbers)):\n        max_list.append(max(max_list[-1], numbers[i]))\n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    \n    rolling_max_values = [numbers[0]]\n    for i in range(1, len(numbers)):\n        rolling_max_values.append(max(numbers[i], rolling_max_values[-1]))\n    return rolling_max_values", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum \n    element found until given moment in the sequence.\n    \"\"\"\n    if not numbers: \n        return []\n    \n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.append(max(result[-1], num))\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    max_list = [numbers[0]]\n    for i in range(1, len(numbers)):\n        max_list.append(max(max_list[i-1], numbers[i]))\n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_nums = []\n    max_num = float('-inf')\n\n    for num in numbers:\n        max_num = max(max_num, num)\n        max_nums.append(max_num)\n\n    return max_nums", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    max_num = numbers[0]\n    result = [max_num]\n\n    for num in numbers[1:]:\n        if num > max_num:\n            max_num = num\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_nums = [numbers[0]]\n    for num in numbers[1:]:\n        max_nums.append(max(num, max_nums[-1]))\n\n    return max_nums", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_numbers = []\n    current_max = numbers[0] if numbers else None\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        max_numbers.append(current_max)\n    return max_numbers", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    res = [numbers[0]]\n    for num in numbers[1:]:\n        res.append(max(res[-1], num))\n    return res", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 8}]}, "HumanEval/0": {"dps": 62.67441860465116, "dps_norm": 68.57142857142857, "pass@1": 96.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()  # Sorting the list of numbers\n    for i in range(1, len(numbers)):  # Iterating over the list from 2nd position to the end\n        if abs(numbers[i] - numbers[i - 1]) < threshold:  # If the difference between current number and previous number is smaller than threshold, return True\n            return True\n    return False  # If no such pair found, return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport math\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if math.fabs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers)-1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n\n    for i in range(1, len(numbers)):\n        if abs(numbers[i] - numbers[i - 1]) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    sorted_nums = sorted(numbers)\n    for i in range(len(sorted_nums) - 1):\n        if abs(sorted_nums[i] - sorted_nums[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers = sorted(numbers)\n    for i in range(1, len(numbers)):\n        if abs(numbers[i] - numbers[i-1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers = sorted(numbers)\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list\n    numbers.sort()\n    # Loop through the list comparing each element to its next one\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            # If the difference is smaller than the threshold, return True\n            return True\n    # If no close elements are found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers) - 1):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(1, len(sorted_numbers)):\n        if abs(sorted_numbers[i] - sorted_numbers[i - 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 77.23101265822785, "dps_norm": 82.5, "pass@1": 97.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    abs_diff = [abs(x - mean) for x in numbers]\n    mad = sum(abs_diff) / len(abs_diff)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    differences = [abs(number - mean) for number in numbers]\n    mad = sum(differences) / len(differences)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(num - mean) for num in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    abs_diffs = [abs(x - mean) for x in numbers]\n    mad = sum(abs_diffs) / len(abs_diffs)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n\n    MAD = average | x - x_mean |\n\n    Examples:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([5.0, 10.0, 10.0, 10.0, 15.0])\n    3.0\n    >>> mean_absolute_deviation([-1.0, -1.0, -1.0, 1.0, 1.0])\n    0.6666666666666666\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    abs_diffs = [abs(num - mean) for num in numbers]\n    mad = sum(abs_diffs) / len(abs_diffs)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    abs_diffs = [abs(num - mean) for num in numbers]\n    mad = sum(abs_diffs) / len(abs_diffs)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(num - mean) for num in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = statistics.mean(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    abs_diffs = [abs(x - mean) for x in numbers]\n    mad = sum(abs_diffs) / len(abs_diffs)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    abs_diffs = [abs(x - mean) for x in numbers]\n    mad = sum(abs_diffs) / len(abs_diffs)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    if len(numbers) == 0:\n        raise ValueError(\"Input list should not be empty.\")\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(n - mean) for n in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean_val = statistics.mean(numbers)\n    mad_val = sum(abs(num - mean_val) for num in numbers) / len(numbers)\n    return mad_val", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(num - mean) for num in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(n - mean) for n in numbers) / len(numbers)\nnumbers = [1.0, 2.0, 3.0, 4.0]", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(n - mean) for n in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_deviation = [abs(number - mean) for number in numbers]\n    mad = sum(absolute_deviation) / len(absolute_deviation)\n\n    return mad", "matching_cluster_idx": 4}]}, "HumanEval/16": {"dps": 92.55813953488372, "dps_norm": 93.88888888888889, "pass@1": 72.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Converting the input string to lowercase and converting it to a set to remove duplicates.\n    # Then, returning the length of the set.\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    distinct_characters = set(string.lower())\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \"\"\"\n    distinct_characters = set()\n    for char in string:\n        distinct_characters.add(char.lower())\n\n    return len(distinct_characters)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # convert the string to lower case to ignore case sensitivity\n    string = string.lower()\n    # use a set to get distinct characters in the string\n    distinct_characters = set(string)\n    # return the length of the set (the number of distinct characters)\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_characters = set()\n    for char in string.lower():\n        distinct_characters.add(char)\n    return len(distinct_characters)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    # convert all letters to lower case to handle case-insensitive distinct characters\n    lower_string = string.lower()\n    # convert the string to a set, which removes duplicate letters\n    distinct_letters = set(lower_string)\n    # count the number of letters in the set, these are the distinct characters\n    num_distinct_characters = len(distinct_letters)\n    return num_distinct_characters", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case and then convert it to a set to get distinct characters.\n    # Finally, get the length of the set to get the number of distinct characters.\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must have at least two elements\")\n\n    min_diff = float('inf')\n    result = (0, 0)\n    \n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = ()\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    result = (None, None)\n    for i in range(len(numbers)-1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i+1])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_difference = float('inf')\n    result = ()\n    for i in range(1, len(numbers)):\n        difference = numbers[i] - numbers[i - 1]\n        if difference < min_difference:\n            min_difference = difference\n            result = (numbers[i - 1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List of numbers must contain at least two elements\")\n    \n    numbers.sort()\n    min_diff = float('inf')\n    result = ()\n    \n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i-1], numbers[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers.sort()\n    smallest_difference = float('inf')\n    result = (None, None)\n    for i in range(len(numbers) - 1):\n        difference = numbers[i+1] - numbers[i]\n        if difference < smallest_difference:\n            smallest_difference = difference\n            result = (numbers[i], numbers[i+1])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" \n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    assert len(numbers) >= 2, \"List must contain at least two numbers\"\n    \n    numbers.sort()\n    smallest_diff = float('inf')\n    result = ()\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < smallest_diff:\n            smallest_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements\")\n\n    numbers.sort()\n    min_diff = numbers[1] - numbers[0]\n    result = (numbers[0], numbers[1])\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i+1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    result = ()\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (0, 0)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i-1], numbers[i])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each other\n    and return them in order (smaller number, larger number).\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError('Input list must have at least two elements')\n        \n    numbers.sort()\n    min_diff = numbers[1] - numbers[0]\n    result = (numbers[0], numbers[1])\n    \n    for i in range(2, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i-1], numbers[i])\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers.sort()  # sort the list in ascending order\n    min_diff = float('inf')  # initialize minimum difference as infinity\n    result = (0.0, 0.0)  # initialize result as two zeros\n    for i in range(1, len(numbers)):\n        # calculate the difference between the current pair and the previous minimum difference\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            # if the difference is smaller, update the minimum difference and the result\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    assert len(numbers) >= 2, \"Input list must have at least two numbers\"\n\n    numbers.sort()\n\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list in ascending order\n    numbers.sort()\n\n    # Initialize variables to keep track of the smallest difference and the closest pair\n    smallest_difference = float('inf')\n    closest_pair = (None, None)\n\n    # Loop over the list to find the closest pair\n    for i in range(1, len(numbers)):\n        difference = numbers[i] - numbers[i - 1]\n        if difference < smallest_difference:\n            smallest_difference = difference\n            closest_pair = (numbers[i - 1], numbers[i])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i-1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n    for i in range(1, len(sorted_numbers)):\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i - 1], sorted_numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (None, None)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = ()\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must have at least two numbers.\")\n    \n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i-1], numbers[i])\n    return closest_pair", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 54.25170068027211, "dps_norm": 20.625, "pass@1": 100.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    i = n - 1\n    while i > 0:\n        if n % i == 0:\n            return i\n        i -= 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    For a given number n, find the largest number that divides n evenly, \n    smaller than n\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Initialize the divisor to the largest possible\n    largest_divisor = n - 1\n\n    # Starting from the largest possible divisor, decrement until a divisor is found\n    while n % largest_divisor != 0:\n        largest_divisor -= 1\n\n    return largest_divisor", "matching_cluster_idx": 0}, {"solution": "import doctest\ndef largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n < 2:\n        return None\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    i = n - 1\n    while i > 0:\n        if n % i == 0:\n            return i\n        i -= 1\n    return None", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    if n <= 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    i = n - 1\n    while i > 0:\n        if n % i == 0:\n            return i\n        i -= 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    if n <= 1:\n        raise ValueError(\"Number must be greater than 1\")\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # If the number is less than or equal to 1, it does not have a proper divisor\n    if n <= 1:\n        return None\n    \n    # Start from the number itself and decrease until you find a divisor\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n < 2:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(30)\n    15\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}]}, "HumanEval/26": {"dps": 89.0, "dps_norm": 93.75, "pass@1": 21.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count_dict = {}\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    non_duplicates = [key for key, value in count_dict.items() if value == 1]\n    return non_duplicates", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = dict()\n    result = []\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count_dict = {}\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    counts = dict()\n    result = []\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n            \n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n            counts[num] -= 1\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count = {}\n    result = []\n\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    for num in numbers:\n        if count[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count_dict = {}\n    result = []\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    for num in numbers:\n        if count_dict[num] == 1:\n            result.append(num)\n            count_dict[num] -= 1\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    counts = {}\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 1\n        else:\n            counts[num] += 1\n\n    return [num for num in counts if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    no_duplicates = []\n    counts = {}\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    for num in numbers:\n        if counts[num] == 1:\n            no_duplicates.append(num)\n    return no_duplicates", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    return [num for num in numbers if count_dict[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    unique_numbers = []\n    count_dict = {}\n    \n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    for num in numbers:\n        if count_dict[num] == 1:\n            unique_numbers.append(num)\n    \n    return unique_numbers", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    result = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            result.append(number)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count_dict = {}\n    output = []\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    for num in numbers:\n        if count_dict[num] == 1:\n            output.append(num)\n            count_dict[num] -= 1\n    return output", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count_map = {}\n    result = []\n    for num in numbers:\n        if num in count_map:\n            count_map[num] += 1\n        else:\n            count_map[num] = 1\n\n    for num in numbers:\n        if count_map[num] == 1:\n            result.append(num)\n            count_map[num] -= 1\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count_map = {}\n    res = []\n    for num in numbers:\n        if num in count_map:\n            count_map[num] += 1\n        else:\n            count_map[num] = 1\n    for num in numbers:\n        if count_map[num] == 1:\n            res.append(num)\n            count_map[num] -= 1\n    return res", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import defaultdict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    number_counts = defaultdict(int)\n    output_numbers = []\n\n    for number in numbers:\n        number_counts[number] += 1\n\n    for number in numbers:\n        if number_counts[number] == 1:\n            output_numbers.append(number)\n\n    return output_numbers", "matching_cluster_idx": 2}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count_map = Counter(numbers)\n    non_duplicate_nums = [num for num, count in count_map.items() if count == 1]\n    return non_duplicate_nums", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count_dict = {}\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    result = [num for num in count_dict if count_dict[num] == 1]\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    result = []\n    counts = {}\n\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 2}]}, "HumanEval/31": {"dps": 64.68354430379748, "dps_norm": 78.75, "pass@1": 94.0, "profiled": [{"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number is prime, and False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n < 2:  # 0 and 1 are not prime numbers\n        return False\n    if n == 2:  # 2 is a prime number\n        return True\n    if n % 2 == 0:  # all other even numbers are not prime\n        return False\n    for current in range(3, int(n ** 0.5) + 1, 2):\n        if n % current == 0: \n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    # 0 and 1 are not prime numbers\n    if n < 2:\n        return False\n\n    # 2 is the only even prime number\n    if n == 2: \n        return True\n    \n    # all other even numbers are not primes\n    if n % 2 == 0: \n        return False\n\n    # range starts with 3 and only needs to go up \n    # the square root of n for all odd numbers\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}]}, "HumanEval/33": {"dps": 69.5138888888889, "dps_norm": 76.36363636363636, "pass@1": 41.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \n    Example:\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Create list of elements with indices divisible by three\n    l_div_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort list with elements at indices divisible by three\n    l_div_by_three.sort()\n\n    # Create new list based on original one with sorted values at indices divisible by three\n    l_prime = [l_div_by_three[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Save values at the positions divisible by 3\n    divisible_by_three_values = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these values\n    divisible_by_three_values.sort()\n    \n    # Create an output list with same length as the input\n    l_prime = [None]*len(l)\n    \n    # Put the sorted values in the places divisible by 3 in the output list\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l_prime[i] = divisible_by_three_values.pop(0)\n        else:\n            l_prime[i] = l[i]\n    \n    return l_prime", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    sorted_third = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    l_prime = [sorted_third[i//3] if i % 3 == 0 else l[i] for i in range(len(l))]\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    values_at_indexes_divisible_by_three = sorted(l[i] for i in range(len(l)) if i % 3 == 0)\n    result = l[:]\n    result[::3] = values_at_indexes_divisible_by_three\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    sortable = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    l_prime = [sortable.pop(0) if i % 3 == 0 else l[i] for i in range(len(l))]\n    return l_prime", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    divisible_by_three.sort()\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = divisible_by_three.pop(0)\n    return l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    # get items at indices divisible by 3\n    div_by_3 = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # sort the selected items\n    div_by_3.sort()\n\n    # replace items at indices divisible by 3 with sorted items\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = div_by_3[i // 3]\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    sorted_l = sorted(l[i] for i in range(len(l)) if i % 3 == 0)\n    new_l = [0]*len(l)\n\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            new_l[i] = sorted_l[sorted_index]\n            sorted_index += 1\n        else:\n            new_l[i] = l[i]\n    \n    return new_l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    divisible_by_three = [(i, v) for i, v in enumerate(l) if i % 3 == 0]\n    sorted_values = sorted([v for i, v in divisible_by_three])\n    l_prime = l.copy()\n    for (i, v), sorted_value in zip(divisible_by_three, sorted_values):\n        l_prime[i] = sorted_value\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Extract the values that are at the indices divisible by three\n    values_at_indices_div_by_3 = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these values\n    sorted_values = sorted(values_at_indices_div_by_3)\n    \n    # Initialize the list l'\n    l_prime = l.copy()\n    \n    # Overwrite the values at the indices divisible by three with the sorted values\n    for i in range(len(l_prime)):\n        if i % 3 == 0:\n            l_prime[i] = sorted_values[i // 3]\n            \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    values = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            values.append(l[i])\n    values.sort()\n    j = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = values[j]\n            j += 1\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    sorted_every_third = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    result = [None]*len(l)\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_every_third[i//3]\n        else:\n            result[i] = l[i]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    sorted_values = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    result = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(sorted_values.pop(0))\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    three_index_values = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    three_index_count = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = three_index_values[three_index_count]\n            three_index_count += 1\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    sorted_list = sorted([x for i, x in enumerate(l) if i % 3 == 0])\n    new_list = [sorted_list.pop(0) if i % 3 == 0 else x for i, x in enumerate(l)]\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    divisible_by_three.sort()\n    \n    result = l.copy()\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = divisible_by_three[i // 3]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Create a sorted list of elements at indices divisible by 3.\n    divisible_by_three = sorted(l[i] for i in range(len(l)) if i % 3 == 0)\n\n    l_prime = l.copy()  # Initialize the return list as a copy of l.\n\n    for i in range(len(l)):\n        if i % 3 == 0:\n            # Insert the next element from divisible_by_three into l_prime.\n            l_prime[i] = divisible_by_three.pop(0)\n\n    return l_prime", "matching_cluster_idx": 6}, {"solution": "def sort_third(l):\n    sorted_list = sorted(l[i] for i in range(len(l)) if i % 3 == 0)\n    result = [None]*len(l)\n    counter = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_list[counter]\n            counter += 1\n        else:\n            result[i] = l[i]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    sorted_indices = sorted([i for i, e in enumerate(l) if i % 3 == 0])\n    sorted_values = sorted([e for i, e in enumerate(l) if i % 3 == 0])\n    l_prime = l[:]\n    for i, j in enumerate(sorted_indices):\n        l_prime[j] = sorted_values[i]\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # separate values at the indicies that are divisible by three\n    div_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # sort the list of values\n    div_by_three.sort()\n    # create a copy of the original list\n    l_prime = l[:]\n    # replace elements in the copied list that are divisible by three with sorted values\n    for i in range(len(l_prime)):\n        if i % 3 == 0:\n            l_prime[i] = div_by_three[i // 3]\n    return l_prime", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 97.0, "profiled": [{"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Returns the number of times the digit 7 appears in integers \n    less than n which are divisible by 11 or 13.\n\n    Args:\n        n (int): Upper limit for the search.\n\n    Returns:\n        int: The number of times the digit 7 appears.\n\n    Doctests:\n        >>> fizz_buzz(50)\n        0\n        >>> fizz_buzz(78)\n        2\n        >>> fizz_buzz(79)\n        3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 94.92635024549918, "dps_norm": 90.0, "pass@1": 97.0, "profiled": [{"solution": "def sort_even(l: list):\n    evens = sorted([v for i, v in enumerate(l) if i % 2 == 0])\n    j = 0\n    res = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            res.append(evens[j])\n            j += 1\n        else:\n            res.append(l[i])\n    return res", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_indices_values = sorted([v for i, v in enumerate(l) if i % 2 == 0])\n    result = [even_indices_values.pop(0) if i % 2 == 0 else v for i, v in enumerate(l)]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # get the elements at even positions in l\n    even_positions = [l[i] for i in range(0, len(l), 2)]\n    # sort the list of even positions\n    even_positions.sort()\n    # create a new list\n    new_list = []\n    # iterate through the elements of l\n    for i in range(len(l)):\n        # if the current index is even, append the next element from sorted list of even positions\n        if i % 2 == 0:\n            new_list.append(even_positions.pop(0))\n        # else, append the current element of l\n        else:\n            new_list.append(l[i])\n    return new_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    # extract values at even indices\n    evens = [l[i] for i in range(0, len(l), 2)]\n    # sort these values\n    evens.sort()\n\n    # create a copy of l\n    l_prime = l.copy()\n\n    # replace values at even indices of l_prime with sorted values\n    for i in range(0, len(l_prime), 2):\n        l_prime[i] = evens[i // 2]\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_indices = [i for i in range(0, len(l), 2)] # Indices of even positions\n    even_values = sorted([l[i] for i in even_indices]) # Sorted values at even positions\n    new_l = l.copy() # Create a copy of original list\n    for i, value in zip(even_indices, even_values):\n        new_l[i] = value\n    return new_l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # separate the even and odd indices\n    even_indices = [i for i in range(len(l)) if i % 2 == 0]\n    odd_indices = [i for i in range(len(l)) if i % 2 != 0]\n\n    even_values = [l[i] for i in even_indices]\n    even_values.sort()\n\n    # construct the result\n    res = [None] * len(l)\n    for i in even_indices:\n        res[i] = even_values.pop(0)\n    for i in odd_indices:\n        res[i] = l[i]\n\n    return res", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    even_values = sorted([l[i] for i in range(0, len(l), 2)])\n    j = 0\n    for i in range(0, len(l), 2):\n        l[i] = even_values[j]\n        j += 1\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Store all values at even indices in the original list\n    even_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort those even values\n    even_values.sort()\n    \n    # Create a new list with the same length as original\n    result = [0] * len(l)\n    \n    # Fill the odd indices with the elements of the original list\n    for i in range(1, len(l), 2):\n        result[i] = l[i]\n    \n    # Fill the even indices with the sorted even values\n    for i in range(0, len(l), 2):\n        result[i] = even_values[i // 2]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # separate even and odd indicies\n    evens = [v for i, v in enumerate(l) if i % 2 == 0]\n    odds = [v for i, v in enumerate(l) if i % 2 != 0]\n\n    # sort the even indicies\n    evens.sort()\n\n    # merge the sorted even and unaltered odd indicies\n    l_prime = [None] * len(l)\n    l_prime[::2] = evens\n    l_prime[1::2] = odds\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even-indexed elements and sort them\n    even_indices_sorted = sorted(l[i] for i in range(0, len(l), 2))\n    l_prime = l[:]\n    \n    # Replace the even-indexed elements with the sorted values\n    for i, value in zip(range(0, len(l), 2), even_indices_sorted):\n        l_prime[i] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # list to store even indexed values\n    even_values = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # sort the even_values list\n    even_values.sort()\n\n    # create a new list with the same length as l\n    l_prime = [0] * len(l)\n\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # place the smallest value from even_values at even indexed positions\n            l_prime[i] = even_values[i // 2]\n        else:\n            # place the original value at odd indexed positions\n            l_prime[i] = l[i]\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_indices_values = sorted(l[i] for i in range(0, len(l), 2))\n    l_prime = [even_indices_values.pop(0) if i % 2 == 0 else v for i, v in enumerate(l)]\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Fetch the elements at even indicies\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the even elements\n    even_elements.sort()\n\n    # Combine sorted even elements and odd elements\n    sorted_l = [even_elements.pop(0) if i % 2 == 0 else l[i] for i in range(len(l))]\n    \n    return sorted_l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indicies = [x for x in range(0, len(l), 2)]\n    sorted_even = sorted(l[i] for i in even_indicies)\n    result = l[:]\n    for index, val in zip(even_indicies, sorted_even):\n        result[index] = val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Extracting the values at even indicies and sorting them\n    sorted_even_values = sorted(l[i] for i in range(0, len(l), 2))\n    result = l[:]\n    # Replacing the values at even indicies with the sorted values\n    for i in range(0, len(l), 2):\n        result[i] = sorted_even_values.pop(0)\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    sorted_l = l[::2]\n    sorted_l = [even_elements.pop(0) if i % 2 == 0 else l[i] for i in range(len(l))]\n    return sorted_l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Seperate even indexed and odd indexed elements.\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    odd_elements = [l[i] for i in range(1, len(l), 2)]\n\n    # Sort the even indexed elements.\n    even_elements.sort()\n\n    # Reconstruct the list with even indexed elements in sorted order.\n    result = [None] * len(l)\n    result[::2] = even_elements\n    result[1::2] = odd_elements\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    # Split the list into even-indexed and odd-indexed elements.\n    even_indices = [element for index, element in enumerate(l) if index % 2 == 0]\n    odd_indices = [element for index, element in enumerate(l) if index % 2 == 1]\n\n    # Sort the even-indexed elements.\n    even_indices.sort()\n\n    # Create a new list with the sorted even-indexed elements and original odd-indexed elements.\n    l_prime = [None]*len(l)\n    l_prime[::2] = even_indices\n    l_prime[1::2] = odd_indices\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are \n    equal to the values of the even indicies of l, but sorted.\n    \"\"\"\n    even_indicies = [x for x in range(0, len(l), 2)]  # Extracting even indicies\n    even_values = sorted([l[i] for i in even_indicies])  # Sorting the even values\n    l_prime = l.copy()  # Copying the original list\n    for i, v in zip(even_indicies, even_values):\n        l_prime[i] = v  # Replacing the sorted even values at the corresponding even indicies\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    l_prime = [even_elements.pop(0) if i % 2 == 0 else l[i] for i in range(len(l))]\n    return l_prime", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 70.82352941176471, "dps_norm": 90.0, "pass@1": 80.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    # return 2^n modulo p (be aware of numerics)\n    return (2**n) % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    # Return 2^n modulo p using exponentiation by squaring\n    if p == 1: \n        return 0 \n    elif n == 0: \n        return 1\n    else:\n        partial_result = modp(n//2, p)\n        if n % 2 == 0:\n            return (partial_result ** 2) % p\n        else:\n            return (2 * (partial_result ** 2) % p) % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return (2**n) % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    if p == 1:\n        return 0\n    else:\n        return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    # The property of exponentiation is used to calculate the remainder.\n    # (a * b) % p = ((a % p) * (b % p)) % p\n    # So, we can compute large powers modulo p in logarithmic time.\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return (2 ** n) % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return (2**n) % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    if p == 1:\n        return 0\n    else:\n        return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return (2 ** n) % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int):\n    return (2 ** n) % p", "matching_cluster_idx": 3}, {"solution": "import doctest\ndef modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Calculate 2^n without modulo\n    power_without_modulo = 2**n\n\n    # Return the modulo of power_without_modulo by p\n    return power_without_modulo % p", "matching_cluster_idx": 2}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Python handles overflow automatically when calculating powers of large numbers\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef modp(n: int, p: int):\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1 % p\n    elif n == 1:\n        return 2 % p\n    else:\n        half_pow = modp(n // 2, p)\n        if n % 2 == 0:\n            return (half_pow * half_pow) % p\n        else:\n            return (half_pow * half_pow * 2) % p", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return (2**n) % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    # handle the special case where p is 1\n    if p == 1:\n        return 0\n    else:\n        return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 92.41545893719807, "dps_norm": 73.125, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([c for c in text if c not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    text_without_vowels = ''.join([char for char in text if char not in vowels])\n    return text_without_vowels", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    return \"\".join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    result = [char for char in text if char not in vowels]\n    return ''.join(result)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    result = ''\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([letter for letter in text if letter not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    return ''.join(c for c in text if c.lower() not in 'aeiou')", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([c for c in text if c not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 20.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert the strings to character sets (remove duplicates and maintain order)\n    set0 = sorted(set(s0))\n    set1 = sorted(set(s1))\n\n    # Return if the character sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    # Convert to sets and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert the two strings to sets of characters\n    s0_set = set(s0)\n    s1_set = set(s1)\n\n    # Return True if the two sets are equal, False otherwise\n    return s0_set == s1_set", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 77.08661417322834, "dps_norm": 70.0, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    return sorted(list(set(l1)&set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert the lists to sets and use intersection to find common elements.\n    # Then, sort the resulting list and return it.\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    # Use set to remove duplicates and find intersection\n    common_set = set(l1) & set(l2)\n\n    # Convert back to list and sort\n    return sorted(list(common_set))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert lists to sets to perform set operations\n    s1 = set(l1)\n    s2 = set(l2)\n\n    # Find intersection of sets which gives common elements\n    common_set = s1.intersection(s2)\n\n    # Return sorted list of common elements\n    return sorted(list(common_set))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set([x for x in l1 if x in l2]))", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert both lists to sets\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find common elements and sort them\n    common_elements = sorted(list(set1 & set2))\n\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set([x for x in l1 if x in l2]))", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Set intersection to find common elements and then sort and return them\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    return sorted(list(set(l1)&set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(x for x in l1 if x in l2))", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list) -> list:\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n\n    Returns:\n    list: Sorted unique common elements.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert the lists to sets\n    s1 = set(l1)\n    s2 = set(l2)\n\n    # Return the sorted list of unique common elements\n    return sorted(s1 & s2)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    return sorted(set([item for item in l1 if item in l2]))", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    Args:\n        l1: The first list of integers.\n        l2: The second list of integers.\n\n    Returns:\n        A list of unique common elements sorted in ascending order.\n\n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 91.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return max(factors)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return max(factors)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return max(factors)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n\n    def is_prime(num: int):\n        \"\"\"Helper function to check if num is a prime number.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_prime = None\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            largest_prime = i\n            while n % i == 0:\n                n //= i\n        if n == 1:\n            break\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    def is_prime(num: int):\n        if num == 1:\n            return False\n        elif num == 2:\n            return True\n        else:\n            for i in range(2, num):\n                if num % i == 0:\n                    return False\n            return True\n\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n if is_prime(n) else i", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. \n    Assume n > 1 and is not a prime.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n\n    def is_prime(x):\n        \"\"\"Check if a number is prime.\"\"\"\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    largest_prime_factor = 1\n    # Check dividing by 2\n    while n % 2 == 0:\n        largest_prime_factor = 2\n        n = n / 2\n\n    # Check the odd numbers\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_prime_factor = i\n            n = n / i\n\n    # Check if n itself is a prime\n    if n > 2 and is_prime(n):\n        largest_prime_factor = n\n\n    return largest_prime_factor", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 58.76623376623377, "dps_norm": 45.0, "pass@1": 26.0, "profiled": [{"solution": "def vowels_count(s):\n    count = 0\n    vowels = ['a', 'e', 'i', 'o', 'u']\n\n    for i in range(len(s)):\n        if s[i].lower() in vowels:\n            count += 1\n        # Check for 'y' at the end of the string\n        if s[i].lower() == 'y' and i == len(s) - 1:\n            count += 1\n\n    return count", "matching_cluster_idx": 0}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        if s[i].lower() in 'aeiou':\n            count += 1\n        elif i == len(s)-1 and s[i].lower() == 'y':\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for letter in s:\n        if letter in vowels:\n            count += 1\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = \"aeiou\"\n    count = 0\n    for i in range(len(s)):\n        if s[i].lower() in vowels:\n            count += 1\n        if i == len(s) - 1 and s[i].lower() == \"y\":\n            count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def vowels_count(s):\n    count = 0\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    last_char = s[-1] if s else ''\n\n    for letter in s:\n        if letter in vowels:\n            count += 1\n    if last_char == 'y' or last_char == 'Y':\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    count = sum(1 for char in s.lower() if char in vowels)\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    count = 0\n    for i in range(len(s)):\n        if s[i].lower() in vowels:\n            count += 1\n        if i == len(s) - 1 and s[i].lower() == 'y':\n            count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def vowels_count(s):\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    count = 0\n    s = s.lower()\n    for char in s:\n        if char in 'aeiou':\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    count = 0\n    vowels = \"aeiou\"\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        if i == len(s)-1 and s[i] == 'y':\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def vowels_count(s):\n    # List of vowels\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    \n    # Variable to store count of vowels\n    count = 0\n\n    # Convert input string to lower case for case insensitive comparison\n    s = s.lower()\n\n    # Iterate over the string to count vowels\n    for char in s:\n        if char in vowels:\n            count += 1\n            \n    # If the string ends with 'y', increment count by 1\n    if s.endswith('y'):\n        count += 1\n\n    # Return count of vowels\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    count = 0\n    last_character = s[-1].lower() if s else ''\n    for char in s.lower():\n        if char in vowels:\n            count += 1\n    if last_character == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = 0\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        if i == len(s) - 1 and s[i] == 'y':\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    s = s.lower()\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        if s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    s = s.lower()\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        if s[i] == 'y' and i == len(s)-1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    vowels = \"aeiou\"\n    count = 0\n    for i in range(len(s)):\n        if s[i].lower() in vowels:\n            count += 1\n        if s[i].lower() == 'y' and i == len(s)-1:\n            count += 1\n    return count", "matching_cluster_idx": 0}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 85.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(i) for i in lst1)\n    sum2 = sum(len(i) for i in lst2)\n    if sum1 < sum2:\n        return lst1\n    elif sum2 < sum1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len_lst1 = sum(len(word) for word in lst1)\n    len_lst2 = sum(len(word) for word in lst2)\n    if len_lst1 < len_lst2:\n        return lst1\n    elif len_lst2 < len_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(i) for i in lst1)\n    sum2 = sum(len(i) for i in lst2)\n    if sum1 < sum2:\n        return lst1\n    elif sum2 < sum1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len_lst1 = sum([len(i) for i in lst1])\n    len_lst2 = sum([len(i) for i in lst2])\n    if len_lst1 < len_lst2:\n        return lst1\n    elif len_lst2 < len_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 < len2:\n        return lst1\n    elif len2 < len1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 < len2:\n        return lst1\n    elif len2 < len1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(word) for word in lst1)\n    sum2 = sum(len(word) for word in lst2)\n    if sum1 < sum2:\n        return lst1\n    elif sum2 < sum1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_lst1 = sum([len(word) for word in lst1])\n    sum_lst2 = sum([len(word) for word in lst2])\n\n    if sum_lst1 < sum_lst2:\n        return lst1\n    elif sum_lst2 < sum_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    chars_in_lst1 = sum(len(word) for word in lst1)\n    chars_in_lst2 = sum(len(word) for word in lst2)\n    \n    if chars_in_lst1 < chars_in_lst2:\n        return lst1\n    elif chars_in_lst1 > chars_in_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(word) for word in lst1)\n    sum2 = sum(len(word) for word in lst2)\n    \n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(word) for word in lst1)\n    sum2 = sum(len(word) for word in lst2)\n\n    if sum1 < sum2:\n        return lst1\n    elif sum1 > sum2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(word) for word in lst1)\n    sum2 = sum(len(word) for word in lst2)\n    if sum1 < sum2:\n        return lst1\n    elif sum2 < sum1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len_lst1 = sum(len(word) for word in lst1)\n    len_lst2 = sum(len(word) for word in lst2)\n    if len_lst1 < len_lst2:\n        return lst1\n    elif len_lst2 < len_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    return lst1 if sum(len(word) for word in lst1) <= sum(len(word) for word in lst2) else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len1 = sum(len(word) for word in lst1)\n    len2 = sum(len(word) for word in lst2)\n    if len1 < len2:\n        return lst1\n    elif len1 > len2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars1 = sum([len(word) for word in lst1])\n    total_chars2 = sum([len(word) for word in lst2])\n    \n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(word) for word in lst1)\n    sum2 = sum(len(word) for word in lst2)\n    \n    return lst1 if sum1 <= sum2 else lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 89.15841584158416, "dps_norm": 58.333333333333336, "pass@1": 86.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 != 0 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. \n    Add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # initialize sum to 0\n    s = 0\n    # loop over the lst\n    for i in range(len(lst)):\n        # check if the index is odd and element at that index is even\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            # add the element to the sum\n            s += lst[i]\n    # return the sum\n    return s", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, return the sum of even elements that are at odd indices\"\"\"\n\n    # Slice out every other element starting from index 1 (adjusting for zero-based indexing)\n    odd_indices = lst[1::2]\n\n    # Filter out odd numbers\n    even_numbers = [num for num in odd_indices if num % 2 == 0]\n\n    # Return the sum of the remaining even numbers\n    return sum(even_numbers)", "matching_cluster_idx": 5}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \"\"\"\n    return sum(el for idx, el in enumerate(lst) if idx % 2 != 0 and el % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(num for index, num in enumerate(lst) if index % 2 == 1 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # initial sum is 0\n    total = 0\n\n    # loop through the list and add the element if it is at an odd index and even\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            total += lst[i]\n\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    \n    # Initialize sum to 0\n    sum_even_odd_indices = 0\n    \n    # Iterate over lst from 0 to len(lst)\n    for i in range(len(lst)):\n        # Check if the index is odd and the number at that index is even\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            # Add the number to the sum\n            sum_even_odd_indices += lst[i]\n            \n    return sum_even_odd_indices", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, \n    add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n\n    # initialize sum\n    even_sum = 0\n    \n    # iterate over the list with odd indices\n    for i in range(1, len(lst), 2):\n        # check if the number is even\n        if lst[i] % 2 == 0:\n            # add to sum\n            even_sum += lst[i]\n    \n    return even_sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(v for i, v in enumerate(lst) if i % 2 == 1 and v % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\"\"\"\n\n    # Use list slicing to get odd index elements and filter out odd ones\n    odd_indices_even_nums = [num for index, num in enumerate(lst) if index % 2 != 0 and num % 2 == 0]\n    \n    # Return the sum of the odd index even numbers\n    return sum(odd_indices_even_nums)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # filter for elements at odd indices and even values \n    odd_even_pairs = [n for i, n in enumerate(lst) if i % 2 != 0 and n % 2 == 0]\n    # return the sum of the filtered list\n    return sum(odd_even_pairs)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": 91.22448979591837, "dps_norm": 96.0, "pass@1": 77.0, "profiled": [{"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    return ' '.join([''.join(sorted(word)) for word in words])", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\n    # split the string into words, then sort characters in each word\n    return ' '.join([''.join(sorted(word)) if word != ' ' else ' ' for word in s.split(' ')])", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    ordered_str = ' '.join(ordered_words)\n    return ordered_str", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    result = []\n\n    for word in words:\n        chars = list(word)\n        chars.sort(key=lambda x: ord(x))\n        result.append(''.join(chars))\n\n    return ' '.join(result)", "matching_cluster_idx": 2}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [' '.join([''.join(sorted(w)) for w in words])]\n    return ordered_words[0]", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Split the string into words\n    words = s.split(' ')\n    # For each word, sort its characters based on their ASCII values\n    words = [''.join(sorted(word)) for word in words]\n    # Join the sorted words back together\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    result = []\n    for word in words:\n        chars = list(word)\n        chars.sort(key=lambda x: ord(x))\n        result.append(''.join(chars))\n    return ' '.join(result)", "matching_cluster_idx": 2}, {"solution": "def anti_shuffle(s):\n    words = s.split(\" \")\n    shuffled_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(shuffled_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Split the sentence into words and blank spaces.\n    words = s.split(' ')\n    result = []\n\n    # For each word, sort its characters based on ASCII values.\n    for word in words:\n        new_word = ''.join(sorted(word))\n        # Append the new sorted word to the result list.\n        result.append(new_word)\n\n    # Join the sorted words with blank spaces and return the result.\n    return ' '.join(result)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(\" \")\n    for i in range(len(words)):\n        words[i] = \"\".join(sorted(words[i]))\n    return \" \".join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    return \" \".join(\n        \"\".join(sorted(word)) if word != \" \" else \" \"\n        for word in s.split(\" \")\n    )", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    for i, word in enumerate(words):\n        new_word = ''.join(sorted(word))\n        words[i] = new_word\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    new_words = []\n    for word in words:\n        new_word = \"\".join(sorted(word))\n        new_words.append(new_word)\n    new_s = \" \".join(new_words)\n    return new_s", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    for i in range(len(words)):\n        words[i] = ''.join(sorted(words[i]))\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 64.43804034582132, "dps_norm": 51.42857142857143, "pass@1": 85.0, "profiled": [{"solution": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates\n    coords = []\n    \n    # Iterate over the rows in the list\n    for i in range(len(lst)):\n        # Iterate over the columns in the current row\n        for j in range(len(lst[i])):\n            # If the current element is equal to x, add its coordinates to coords\n            if lst[i][j] == x:\n                coords.append((i, j))\n    \n    # Sort the coordinates first by row number, then by column number in descending order\n    coords.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coords", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coord = []\n    for i, row in enumerate(lst):\n        for j, col in enumerate(row):\n            if col == x:\n                coord.append((i, j))\n    return sorted(coord, key=lambda y: (y[0], -y[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i, row in enumerate(lst):\n        for j, col in enumerate(row):\n            if col == x:\n                coords.append((i, j))\n    return sorted(coords, key=lambda tup: (tup[0], -tup[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]\n    result.sort(key=lambda y: (y[0], -y[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, item in enumerate(row):\n            if item == x:\n                coordinates.append((i, j))\n\n    coordinates.sort(key=lambda y: (y[0], -y[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda y: (y[0], -y[1]))\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i, row in enumerate(lst):\n        for j, elem in enumerate(row):\n            if elem == x:\n                coords.append((i, j))\n    coords.sort(key=lambda y: (y[0], -y[1]))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Initialize an empty list for the coordinates\n    coordinates = []\n    # Loop through the rows\n    for i in range(len(lst)):\n        # Loop through the elements in the row\n        for j in range(len(lst[i])):\n            # If the element is equal to x, append its coordinates to the list\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    # Sort the coordinates first by rows in ascending order, then by columns in descending order\n    coordinates.sort(key = lambda y: (y[0], -y[1]))\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    # Initialize empty list to store tuples\n    tuples = []\n    \n    # Loop through each row\n    for i in range(len(lst)):\n        # Loop through each element in the row\n        for j in range(len(lst[i])):\n            # If element matches x, append tuple (i, j)\n            if lst[i][j] == x:\n                tuples.append((i, j))\n    \n    # Sort tuples first by row and then by column\n    tuples.sort(key=lambda y: (y[0], -y[1]))\n    \n    # Return the list of tuples\n    return tuples", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    if not lst: return []\n    coords = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coords.append((i, j))\n    coords.sort(key = lambda y: (y[0], -y[1]))\n    return coords", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, item in enumerate(row):\n            if item == x:\n                coordinates.append((i, j))\n\n    # Sort by row then by column in descending order\n    coordinates.sort(key=lambda y: (y[0], -y[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    if not lst:\n        return []\n\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n\n    # Sort coordinates first by rows in ascending order,\n    # then by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, element in enumerate(row):\n            if element == x:\n                coordinates.append((i, j))\n\n    coordinates.sort(key=lambda y: (y[0], -y[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    coordinates.sort(key = lambda y: (y[0], -y[1]))\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, num in enumerate(row):\n            if num == x:\n                coordinates.append((i, j))\n    # sort the coordinates first by row and then by column\n    coordinates.sort(key=lambda tup: (tup[0], -tup[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i, row in enumerate(lst):\n        for j, elem in enumerate(row):\n            if elem == x:\n                coords.append((i, j))\n    coords.sort(key = lambda y: (y[0], -y[1]))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                coords.append((i, j))\n    return sorted(coords, key=lambda y: (y[0], -y[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row in range(len(lst)):\n        for col in range(len(lst[row])):\n            if lst[row][col] == x:\n                result.append((row, col))\n    result.sort(key=lambda y: (y[0], -y[1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    result = [(i, j) for i, row in enumerate(lst) for j, col in enumerate(row) if col == x]\n    result.sort(key=lambda y: (y[0], -y[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        for j, elem in enumerate(row):\n            if elem == x:\n                result.append((i, j))\n    result.sort(key=lambda tup: (tup[0], -tup[1]))\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.64948453608248, "dps_norm": 28.571428571428573, "pass@1": 68.0, "profiled": [{"solution": "def encrypt(s):\n    encrypted_string = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            char = char.lower()\n            encrypted_char = chr(((ord(char) - 97 + shift) % 26) + 97)\n            encrypted_string += encrypted_char.upper() if char.isupper() else encrypted_char\n        else:\n            encrypted_string += char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            char_code = ord(char.lower())\n            if char.isupper():\n                result += chr((char_code - 65 + shift) % 26 + 65)\n            else:\n                result += chr((char_code - 97 + shift) % 26 + 97)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_s = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted_s += chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n        else:\n            encrypted_s += char\n    return encrypted_s", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        # handle only alphabets, keep others intact\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for c in s:\n        if 'a' <= c <= 'z':\n            result += chr((ord(c) - ord('a') + 2*2) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            result += chr((ord(c) - ord('A') + 2*2) % 26 + ord('A'))\n        else:\n            result += c\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + 2*2) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_s = \"\"\n    for c in s:\n        if c.isalpha():\n            ascii_offset = 65 if c.isupper() else 97\n            encrypted_s += chr((ord(c) - ascii_offset + 2 * 2) % 26 +  ascii_offset)\n        else:\n            encrypted_s += c\n    return encrypted_s", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_text = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted_text += chr((ord(char) - ascii_offset + 2*2) % 26 + ascii_offset)\n        else:\n            encrypted_text += char\n    return encrypted_text", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = ''\n    for char in s:\n        if char.isalpha():\n            char_code = ord(char.lower())\n            char_code = (char_code - ord('a') + 2*2) % 26 + ord('a')\n            result += chr(char_code) if char.islower() else chr(char_code).upper()\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = ''\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            char = char.lower()\n            if ord(char) + 4 > ord('z'):\n                result += chr(ord('a') + (ord(char) + 4 - ord('z')) - 1)\n            else:\n                result += chr(ord(char) + 4)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = ''\n    for char in s:\n        # handle lowercase characters\n        if char.islower():\n            result += chr(((ord(char) - ord('a') + 2*2) % 26) + ord('a'))\n        # handle uppercase characters\n        elif char.isupper():\n            result += chr(((ord(char) - ord('A') + 2*2) % 26) + ord('A'))\n        # keep non-alphabet characters as is\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_string = \"\"\n\n    for char in s:\n        if char.isalpha():\n            ascii_val = ord(char.lower())\n            new_char = chr(((ascii_val - 97 + 2*2) % 26) + 97)\n            encrypted_string += new_char.upper() if char.isupper() else new_char\n        else:\n            encrypted_string += char\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            char = char.lower()\n            if ord(char) + shift > ord('z'):\n                result += chr(ord('a') + (shift - (ord('z') - ord(char) + 1)))\n            else:\n                result += chr(ord(char) + shift)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_string = \"\"\n    for char in s:\n        if not char.isalpha():\n            encrypted_string += char\n            continue\n        ascii_offset = 65 if char.isupper() else 97\n        encrypted_string += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_s = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted_s += chr((ord(char) - ascii_offset + 2*2) % 26 + ascii_offset)\n        else:\n            encrypted_s += char\n    return encrypted_s", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            result += chr(((ord(char) - ord('a') + 2*2) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            result += chr(((ord(char) - ord('A') + 2*2) % 26) + ord('A'))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for char in s:\n        # Check if character is an uppercase letter\n        if 'A' <= char <= 'Z':\n            encrypted += chr(((ord(char) - 65 + 2*2) % 26) + 65)\n        # Check if character is a lowercase letter\n        elif 'a' <= char <= 'z':\n            encrypted += chr(((ord(char) - 97 + 2*2) % 26) + 97)\n        # If not a letter, add to the encrypted string without change\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_text = \"\"\n    for character in s:\n        if character.isalpha():\n            ascii_offset = 65 if character.isupper() else 97\n            encrypted_character = chr((((ord(character) - ascii_offset) + 2*2) % 26) + ascii_offset)\n            encrypted_text += encrypted_character\n        else:\n            encrypted_text += character\n    return encrypted_text", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for character in s:\n        if character.isalpha():\n            ascii_offset = ord('a') if character.islower() else ord('A')\n            encrypted += chr((ord(character) - ascii_offset + 2*2) % 26 + ascii_offset)\n        else:\n            encrypted += character\n    return encrypted", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 72.06225680933852, "dps_norm": 56.66666666666667, "pass@1": 63.0, "profiled": [{"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = float('inf')\n    second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # sorting the list\n    lst.sort()\n    \n    # finding the second smallest element\n    for i in range(1, len(lst)):\n        if lst[i] != lst[0]:\n            return lst[i]\n    \n    return None", "matching_cluster_idx": 11}, {"solution": "def next_smallest(lst):\n    if not lst or len(lst) < 2:\n        return None\n    first_min = second_min = float('inf')\n    for num in lst:\n        if num < first_min:\n            first_min, second_min = num, first_min\n        elif first_min < num < second_min:\n            second_min = num\n    return None if second_min == float('inf') else second_min", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    first_min = second_min = float('inf')\n    for i in lst:\n        if i < first_min:\n            first_min, second_min = i, first_min\n        elif first_min < i < second_min:\n            second_min = i\n    return second_min if second_min < float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    # Filter out duplicates, sort the list, and check for empty list\n    lst = sorted(list(set(lst)))\n    if len(lst) < 2:\n        return None\n    else:\n        return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    lst = list(set(lst))\n    lst.sort()\n    if len(lst) < 2:\n        return None\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    lst = list(set(lst))  # Remove duplicates\n    lst.sort()  # Sort the list in ascending order\n\n    # Check if the list has at least 2 elements\n    if len(lst) < 2:\n        return None\n    else:\n        return lst[1]  # Return the second smallest element", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = float('inf')\n    second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    lst_set = set(lst)\n    lst_set.remove(min(lst_set))\n    if len(lst_set) < 1:\n        return None\n    return min(lst_set)", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    lst = list(set(lst))\n    lst.sort()\n    if len(lst) < 2:\n        return None\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = float('inf')\n    second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    # Check if the list is empty\n    if len(lst) < 2:\n        return None\n\n    min_val = float('inf')\n    second_min = float('inf')\n    \n    # Go through each element in the list\n    for ele in lst:\n        # If the current element is smaller than the current minimum, update minimum\n        if ele < min_val:\n            second_min = min_val\n            min_val = ele\n        # If the current element is in between the current minimum and second minimum, update second minimum\n        elif min_val < ele < second_min:\n            second_min = ele\n\n    # If there was no second minimum found (in case all elements in the list were equal), return None\n    if second_min == float('inf'):\n        return None\n    \n    return second_min", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    lst = list(set(lst))\n    lst.sort()\n    if len(lst) < 2:\n        return None\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Handle empty list\n    if not lst:\n        return None\n    \n    # Remove duplicate values\n    lst = list(set(lst))\n    \n    # Sort the list\n    lst.sort()\n    \n    # If there are at least 2 elements, return the 2nd smallest one. Else, return None.\n    return lst[1] if len(lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    # Remove duplicate items in the list\n    lst = list(set(lst))\n\n    # Check if there are at least 2 unique elements in the list\n    if len(lst) < 2:\n        return None\n\n    # Sort the list in ascending order\n    lst.sort()\n\n    # Return the 2nd smallest item\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    # First, we will sort the list\n    lst = sorted(list(set(lst)))\n\n    # Next, we'll check if there is at least one element in the list.\n    if len(lst) < 2:\n        return None\n    else:\n        return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    lst = list(set(lst))\n    lst.sort()\n    return lst[1] if len(lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    lst = list(set(lst))  # Remove duplicates\n    lst.sort()\n    if len(lst) < 2:\n        return None\n    return lst[1]", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 80.32454361054766, "dps_norm": 56.66666666666667, "pass@1": 61.0, "profiled": [{"solution": "def odd_count(lst):\n    result = []\n    for idx, val in enumerate(lst):\n        count = sum(1 for char in val if int(char) % 2 != 0)\n        sentence = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        result.append(sentence)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    results = []\n    for index, num_str in enumerate(lst):\n        count = sum(1 for ch in num_str if int(ch) % 2 != 0)\n        result = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        results.append(result)\n    return results", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        odd_num = sum(int(c) % 2 for c in s)\n        str_odd_num = str(odd_num)\n        output = f\"the number of odd elements {str_odd_num}n the str{str_odd_num}ng {str_odd_num} of the {str_odd_num}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    # Initialize an empty list to store the results\n    results = []\n\n    # Loop through the input list\n    for i, s in enumerate(lst):\n        # Initialize a count of odd numbers to 0\n        odd_count = 0\n\n        # Loop through each character in the string\n        for ch in s:\n            # If the character is odd (1, 3, 5, etc.), increment the count\n            if int(ch) % 2 != 0:\n                odd_count += 1\n\n        # Generate the required string and append it to the results list\n        result_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        results.append(result_string)\n\n    # Return the list of results\n    return results", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(string):\n        return sum(1 for char in string if int(char) % 2 != 0)\n    \n    return [\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count_odd_digits(s), count_odd_digits(s), count_odd_digits(s), count_odd_digits(s)) for s in lst]", "matching_cluster_idx": 0}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \n    \"the number of odd elements in the string i of the input.\" \n    where all the i's should be replaced by the number of odd digits in the i'th string of the input.\n    \"\"\"\n    def count_odds(num_str):\n        \"\"\"Count the number of odd digits in a string of digits\"\"\"\n        return sum(int(d) % 2 != 0 for d in num_str)\n\n    return [f\"the number of odd elements {count_odds(s)}n the str{count_odds(s)}ng {count_odds(s)} of the {count_odds(s)}nput.\" for s in lst]", "matching_cluster_idx": 0}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Loop through each string in the input list\n    for i, string in enumerate(lst):\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for char in string if int(char) % 2 != 0)\n\n        # Construct the result string and append it to the result list\n        result_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(result_str)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        count = sum(int(c) % 2 for c in s)\n        element = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(element)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    odd_elements_count = lambda string: sum(1 for char in string if int(char) % 2 != 0)\n    result = [\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n        odd_elements_count(string),\n        odd_elements_count(string),\n        odd_elements_count(string),\n        odd_elements_count(string)\n    ) for string in lst]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        count = sum([1 for c in s if int(c) % 2 != 0])\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(int(c) % 2 for c in s)\n        new_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count)\n        result.append(new_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    # list to store the counts\n    counts = []\n\n    for i, string in enumerate(lst, start=1):\n        # count the odd numbers in the string\n        odd_count = sum(int(c) % 2 != 0 for c in string)\n\n        # generate the required string and append to counts\n        counts.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count))\n\n    return counts", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for idx, string in enumerate(lst):\n        odd_digits_count = sum((int(x) % 2 != 0) for x in string)\n        element = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n            odd_digits_count,\n            odd_digits_count,\n            odd_digits_count,\n            odd_digits_count\n        )\n        result.append(element)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, start=1):\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for index, element in enumerate(lst):\n        odd_digits = sum(int(char) % 2 for char in element)\n        sentence = f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n        result.append(sentence)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for ch in s if int(ch) % 2 != 0)\n\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odd_digits(s)\n        s = s.replace(s, str(odd_count))\n        template = \"the number of odd elements {0}n the str{0}ng {0} of the {0}nput.\"\n        result.append(template.format(s))\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd(num):\n        return sum(int(digit) % 2 for digit in num)\n\n    return [f\"the number of odd elements {count_odd(s)}n the str{count_odd(s)}ng {count_odd(s)} of the {count_odd(s)}nput.\" for s in lst]", "matching_cluster_idx": 0}, {"solution": "def odd_count(lst):\n    output = []\n    for i, string in enumerate(lst):\n        count = sum(int(char) % 2 for char in string)\n        string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        output.append(string)\n    return output", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/120": {"dps": null, "dps_norm": null, "pass@1": 8.0, "profiled": []}, "HumanEval/121": {"dps": 83.2286995515695, "dps_norm": 62.85714285714286, "pass@1": 97.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(x for x in lst[::2] if x % 2 != 0)", "matching_cluster_idx": 5}, {"solution": "def solution(lst):\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    sum = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 == 1:\n            sum += lst[i]\n    return sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    # filter for odd numbers at even positions\n    odd_even_numbers = [num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 == 1]\n    # calculate sum of filtered odd numbers\n    return sum(odd_even_numbers)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize a variable to store the sum\n    sum = 0\n\n    # Iterate through the list\n    for i in range(0, len(lst), 2):\n        # If the element is odd, add it to the sum\n        if lst[i] % 2 != 0:\n            sum += lst[i]\n\n    # Return the sum\n    return sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum([n for i, n in enumerate(lst) if i % 2 == 0 and n % 2 == 1])", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, \n    return the sum of all of the odd elements that are in even positions.\n    \"\"\"\n    return sum(el for idx, el in enumerate(lst) if idx % 2 == 0 and el % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(el for idx, el in enumerate(lst) if idx % 2 == 0 and el % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \"\"\"\n    return sum([v for i, v in enumerate(lst) if i % 2 == 0 and v % 2 != 0])", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(el for i, el in enumerate(lst) if i % 2 == 0 and el % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(elm for i, elm in enumerate(lst) if i % 2 == 0 and elm % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(x for x in lst[::2] if x % 2 != 0)", "matching_cluster_idx": 5}, {"solution": "def solution(lst):\n    sum = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum", "matching_cluster_idx": 4}]}, "HumanEval/149": {"dps": 96.45669291338584, "dps_norm": 89.28571428571429, "pass@1": 90.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    # Delete strings with odd lengths\n    filtered_lst = [x for x in lst if len(x) % 2 == 0]\n    \n    # Sort the list by length of each word, and then alphabetically\n    sorted_lst = sorted(sorted(filtered_lst), key=len)\n    \n    return sorted_lst", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    # Delete the strings of odd lengths\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # Return the list sorted by length and alphabetically\n    return sorted(lst, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filtering the list for even length strings\n    even_lst = [i for i in lst if len(i) % 2 == 0]\n    # Sorting the filtered list first by length and then alphabetically\n    even_lst.sort()\n    even_lst.sort(key=len)\n    return even_lst", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    # Filter list for strings with even length\n    lst = [x for x in lst if len(x) % 2 == 0]\n    # Sort the list by length and then alphabetically\n    lst.sort()\n    lst.sort(key=len)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    even_length_lst = [word for word in lst if len(word) % 2 == 0]\n    even_length_lst.sort()\n    return sorted(even_length_lst, key=len)", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    # deleting strings with odd lengths\n    filtered_list = [string for string in lst if len(string) % 2 == 0]\n    # sorting the list by length of each word, and then alphabetically\n    sorted_list = sorted(sorted(filtered_list), key=len)\n    return sorted_list", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    # Deletes the strings that have odd lengths from list.\n    lst = [i for i in lst if len(i) % 2 == 0]\n\n    # Sorts the list by length of each word and alphabetically.\n    lst = sorted(lst, key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings of odd length\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length first and then alphabetically\n    sorted_list = sorted(sorted(filtered_list), key=len)\n    \n    return sorted_list", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    # delete the strings that have odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # sort the list by length and alphabetically\n    lst.sort()\n    lst.sort(key=len)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort list by length of each word, then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Remove strings with odd lengths\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # Sort by length and then by alphabetical order\n    lst.sort()\n    lst.sort(key=len)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    # Remove strings of odd length\n    lst = [x for x in lst if len(x) % 2 == 0]\n    # Sort the list first by length, then by alphabetical order\n    lst.sort()\n    lst.sort(key=len)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    # Filter out words with odd lengths\n    filtered = [word for word in lst if len(word) % 2 == 0]\n    # Sort by length and then alphabetically\n    return sorted(sorted(filtered), key=len)", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n    sorted_words = sorted(even_length_words, key=lambda word: (len(word), word))\n    return sorted_words", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Remove the strings with odd lengths\n    lst = [x for x in lst if len(x) % 2 == 0]\n\n    # Sort the list by length and then alphabetically\n    lst.sort()\n    lst.sort(key=len)\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    # Filter the list to remove strings of odd length\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort the list by length of each word, and then by alphabetical order\n    sorted_lst = sorted(sorted(filtered_lst), key=len)\n\n    return sorted_lst", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    # delete the strings that have odd lengths\n    lst = [x for x in lst if len(x) % 2 == 0]\n\n    # sort the list first by length and then alphabetically\n    lst.sort()\n    lst.sort(key=len)\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    # Delete the strings that have odd lengths from the list\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # Sort the list first by length of each word and then by alphabetical order\n    lst.sort()\n    lst.sort(key=len)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    even_length_lst = [word for word in lst if len(word) % 2 == 0]\n    even_length_lst.sort(key=lambda x: (len(x), x))\n    return even_length_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Remove the strings that have odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # If two words have the same length, sort the list alphabetically\n    lst.sort()\n\n    # Sort the list by length of each word\n    lst.sort(key=len)\n\n    return lst", "matching_cluster_idx": 6}]}, "Mbpp/3": {"dps": 70.29661016949153, "dps_norm": 76.875, "pass@1": 91.0, "profiled": [{"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    p = 3\n    while p * p <= n:\n        if n % p == 0:\n            return True\n        p += 2\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(num):\n    if num <= 1:\n        return True\n    for i in range(2, num):\n        if num % i == 0:\n            return True\n    return False", "matching_cluster_idx": 1}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(num):\n    if num <= 1:\n        return True\n    if num == 2:\n        return False\n    if num % 2 == 0:\n        return True\n    for i in range(3, int(num**0.5) + 1, 2):\n        if num % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    max_divisor = int(n ** 0.5)\n    for d in range(3, 1 + max_divisor, 2):\n        if n % d == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n == 2:\n        return False\n    else:\n        for i in range(2, n):\n            if n % i == 0:\n                return True\n        return False", "matching_cluster_idx": 0}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n == 2:\n        return False\n    else:\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return True\n        return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    max_div = int(n**0.5) + 1\n    for i in range(3, max_div, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, n):\n        if (n % i) == 0:\n            return True\n    return False", "matching_cluster_idx": 0}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return True\n        i += 2\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(num):\n    \"\"\"\n    A function that returns True if the number is not prime and False otherwise.\n\n    Args:\n    num (int): the number to be evaluated\n\n    Returns:\n    bool: True if the number is not prime, False otherwise\n    \"\"\"\n\n    # Non-prime numbers are numbers less than 2\n    if num < 2:\n        return True\n\n    # Prime numbers are only divisible by 1 and themselves, so loop through 2 to num\n    for i in range(2, num):\n        # If num is divisible by any number in the range, it's not prime\n        if num % i == 0:\n            return True\n\n    # If num has no divisors other than 1 and itself, it is prime\n    return False", "matching_cluster_idx": 0}]}, "Mbpp/4": {"dps": 88.05460750853243, "dps_norm": 83.33333333333333, "pass@1": 90.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Using heapify to convert list into heap\n    heapq.heapify(nums)\n    # Using nlargest to get 'n' largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    # Returning the 'n' largest numbers in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 8}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # heapq module provides an implementation of the heap queue algorithm, \n    # also known as the priority queue algorithm. \n    # We use negative of number to convert max heap to min heap as Python heapq provides min heap by default.\n    max_heap = [-x for x in numbers]\n    heapq.heapify(max_heap)\n    \n    # Extract n largest integers\n    largest_numbers = [-heapq.heappop(max_heap) for _ in range(n)]\n    return largest_numbers\nnumbers = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers_list, n):\n    return heapq.nlargest(n, numbers_list)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # use heapq.nlargest to get the n largest numbers and then reverse the list to get in descending order\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use nlargest from heapq module to find n largest integers\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        raise ValueError('n is larger than the length of numbers')\n    \n    # Use heapq to turn list into a heap, in ascending order\n    # The minus sign is used to make a max-heap as min-heap is default in python\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # The returned values are sorted in descending order, as requested\n    return sorted(largest_numbers, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest() to get the 'n' largest numbers in the list\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the numbers in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Converting to a heap\n    heapq.heapify(numbers)\n    # Extracting largest n elements in descending order\n    largest_numbers = heapq.nlargest(n, numbers)\n    largest_numbers.sort(reverse=True)\n    return largest_numbers", "matching_cluster_idx": 8}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq library's nlargest function\n    largest_nums = heapq.nlargest(n, nums)\n    # Sort the list in descending order\n    largest_nums.sort(reverse=True)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use the heapq module to create a heap, this will convert the iterable into a heap data structure.\n    # The smallest element is at the front.\n    heap = heapq.nlargest(n, numbers)\n    # Use the heapify function to convert an iterable into a heap.\n    # This is efficient because it places the smallest item at the root of the heap.\n    heapq.heapify(heap)\n    # Return the heap in descending order\n    return sorted(heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(num_list, n):\n    # Use heapq to turn list into a max heap\n    heapq._heapify_max(num_list)\n\n    # Pop off and append largest n elements into a new list\n    result = [heapq._heappop_max(num_list) for _ in range(n)]\n\n    return result", "matching_cluster_idx": 11}]}, "Mbpp/9": {"dps": 64.421768707483, "dps_norm": 53.0, "pass@1": 25.0, "profiled": [{"solution": "def find_Rotations(s: str) -> int:\n    n = len(s)\n    temp = s + s\n\n    for i in range(1, n):\n        if temp[i:i+n] == s:\n            return i\n\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        if s[i:] + s[:i] == s:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(string: str) -> int:\n    \"\"\"\n    This function finds the minimum number of rotations required to get the same string.\n    \"\"\"\n\n    # Check if string is not empty\n    if string and len(string) > 1:\n        # Concatenating the string\n        string = string + string\n        # Finding the length of the concatenated string\n        length = len(string)\n\n        # Finding the next character of the prefix\n        failure = [0] * length\n        j = 1\n        i = 0\n        while j < length:\n            if string[i] == string[j]:\n                failure[j] = i + 1\n                i += 1\n                j += 1\n            elif i > 0:\n                i = failure[i - 1]\n            else:\n                j += 1\n\n        # Find minimum rotation\n        min_rotation = len(string) - failure[-1]\n\n        # If length is multiple of min_rotation, then return 1\n        if len(string) % min_rotation == 0:\n            return min_rotation\n\n    return 0  # If string is empty or has only one character", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(str1):\n    # compute temporary string\n    temp = str1 + str1\n\n    # find length of original string\n    n = len(str1)\n    \n    # find minimum rotation by comparing\n    # string with temp string\n    for i in range(1, n+1):\n        if (temp[i:i+n] == str1):\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    n = len(s)\n    temp = s + s\n    # For concatenation, we need to make sure that\n    # there is no rotation of the string which gives us\n    # the original string as a substring.\n    # This means, we are looking for the smallest non-1\n    # factor of length of the string.\n    for i in range(1, n):\n        if temp[i:i+n] == s:\n            return i\n    return n  # In case of no rotation", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(string):\n    length = len(string)\n    if length <= 1:\n        return 0\n    for rotation in range(1, length):\n        if string[rotation:] + string[:rotation] == string:\n            return rotation\n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    temp = s + s\n    for i in range(1, n):\n        if temp[i:i+n] == s:\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(string):\n    n = len(string)\n    for i in range(1, n):\n        if string[i:] + string[:i] == string:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(str):\n    # Get the length of the string\n    n = len(str)\n    \n    # Create a concatenated string\n    temp = str + str\n    \n    # Set initial minimum rotation as maximum possible value\n    min_rotation = float('inf')\n    \n    # Find the rotation\n    for i in range(1, n+1):\n        # For each i, compare the substring with the original string\n        # If they are the same, get the rotation number\n        if str == temp[i:i+n]:\n            min_rotation = min(min_rotation, i)\n            \n    # Return the minimum rotation\n    return min_rotation", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    This function finds the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    rotation = 1\n    while rotation <= len(s):\n        if s[rotation:] + s[:rotation] == s:\n            return rotation\n        rotation += 1\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(string: str) -> int:\n    if string == \"\":\n        return 0\n    else:\n        # Check how many rotations are needed to get the same string\n        for i in range(1, len(string)):\n            if string[i:] + string[:i] == string:\n                return i\n        # If no rotation was needed, return the length of the string\n        return len(string)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    A function that finds the minimum number of rotations to get the same string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(input_string):\n    length = len(input_string)\n    for i in range(1, length):\n        if input_string[i:] + input_string[:i] == input_string:\n            return i\n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(input_string: str) -> int:\n    # check if input string is empty or contains only one character\n    if len(input_string) <= 1:\n        return 0\n\n    # rotate the string and compare it with the original string\n    for i in range(1, len(input_string)):\n        # if string is same after rotation, return the number of rotations\n        if input_string == input_string[i:] + input_string[:i]:\n            return i\n\n    # if no rotation gives the same string, return the length of the string\n    return len(input_string)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(str_input):\n    str_size = len(str_input)\n    for i in range(1, str_size):\n        # splitting the original string into two parts at ith position\n        split_str = str_input[i:str_size] + str_input[0:i]\n        # checking if it's rotation of original string\n        if split_str == str_input:\n            return i  # Return the rotation count\n    return str_size  # If no rotation found return string size", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Function to find the minimum number of rotations\n    required to get the same string\n    \"\"\"\n    rotation_count = 0\n    original = s\n\n    while True:\n        s = s[1:] + s[0]  # rotate string\n        rotation_count += 1  # increment rotation counter\n\n        if s == original:  # if string is same as original, return rotation count\n            return rotation_count", "matching_cluster_idx": 5}]}, "Mbpp/11": {"dps": 74.05017921146954, "dps_norm": 87.77777777777777, "pass@1": 58.0, "profiled": [{"solution": "def remove_Occ(s, ch):\n    first_idx = s.find(ch)  # find the first occurrence of ch\n    if first_idx != -1:  # if ch is present in s\n        last_idx = s.rfind(ch)  # find the last occurrence of ch\n        # remove the first and last occurrence of ch from s\n        s = s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:]\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, character):\n    first_Occ = input_string.find(character)\n    if first_Occ != -1:\n        input_string = input_string[:first_Occ] + input_string[first_Occ+1:]\n        last_Occ = input_string.rfind(character)\n        if last_Occ != -1:\n            input_string = input_string[:last_Occ] + input_string[last_Occ+1:]\n    return input_string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, ch):\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == ch:\n            s[i] = ''\n            break\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == ch:\n            s[i] = ''\n            break\n    return ''.join(s)", "matching_cluster_idx": 2}, {"solution": "def remove_Occ(str1, char1):\n    # Initialize first and last indexes with -1\n    first_index = last_index = -1\n    \n    # Find first and last occurrences of the given character\n    for i in range(len(str1)):\n        if str1[i] == char1:\n            if first_index == -1:  # For first occurrence\n                first_index = i\n            last_index = i  # For last occurrence\n    \n    # If character is not found in string\n    if first_index == -1:\n        return str1\n\n    # Remove first and last occurrences of the character from string\n    str1 = str1[:first_index] + str1[first_index+1:last_index] + str1[last_index+1:]\n\n    return str1", "matching_cluster_idx": 0}, {"solution": "def remove_Occ(s, c):\n    # finding the first and the last occurrence of a given character in the string\n    first_occurrence = s.find(c)\n    last_occurrence = s.rfind(c)\n\n    # checking if the character exists in the string\n    if first_occurrence != -1 and last_occurrence != -1:\n        # removing first and last occurrence of a character from the string\n        s = s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first_index = s.find(c)\n    if first_index != -1:\n        last_index = s.rfind(c)\n        return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n    else:\n        return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str, ch):\n    first_occurance = str.find(ch)\n    if first_occurance == -1:\n        return str\n    last_occurance = str.rfind(ch)\n    if first_occurance == last_occurance:\n        return str[:first_occurance] + str[first_occurance+1:]\n    else:\n        return str[:first_occurance] + str[first_occurance+1:last_occurance] + str[last_occurance+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str, char):\n    first_Occ = str.find(char)\n    if first_Occ == -1:\n        return str\n    last_Occ = str.rfind(char)\n    return str[:first_Occ] + str[first_Occ+1:last_Occ] + str[last_Occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    first_index = string.find(char)\n    if first_index != -1:  # character is found\n        last_index = string.rfind(char)\n        string = string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]\n    return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    first_occur = s.find(ch)\n    last_occur = s.rfind(ch)\n    \n    if first_occur == -1:\n        return s\n    \n    return s[:first_occur] + s[first_occur+1:last_occur] + s[last_occur+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Removes the first and last occurrence of a given character from a string.\n\n    Parameters:\n    s (str): The string from which to remove the first and last occurrence of a character.\n    c (char): The character to remove from the string.\n\n    Returns:\n    str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    # Finding the first and last occurrence of the character in the string\n    first_occurrence = s.find(c)\n    last_occurrence = s.rfind(c)\n\n    # If the character is not in the string, return the original string\n    if first_occurrence == -1:\n        return s\n\n    # Removing the first and last occurrence of the character from the string\n    s = s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    first_index = string.find(char)\n    if first_index != -1:\n        string = string[:first_index] + string[first_index+1:]\n        last_index = string.rfind(char)\n        if last_index != -1:\n            string = string[:last_index] + string[last_index+1:]\n    return string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(str, char):\n    first_Occ = str.find(char)\n    if first_Occ == -1:\n        return str\n    last_Occ = str.rfind(char)\n    return str[:first_Occ] + str[first_Occ+1:last_Occ] + str[last_Occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    first_Occ = s.find(ch)\n    if first_Occ == -1:\n        return s\n    last_Occ = s.rfind(ch)\n    return s[:first_Occ] + s[first_Occ+1:last_Occ] + s[last_Occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char_to_remove):\n    first_idx = input_string.find(char_to_remove)\n    last_idx = input_string.rfind(char_to_remove)\n\n    if first_idx != -1 and last_idx != -1 and first_idx != last_idx:\n        return input_string[:first_idx] + input_string[first_idx+1:last_idx] + input_string[last_idx+1:]\n    elif first_idx != -1:\n        return input_string[:first_idx] + input_string[first_idx+1:]\n    elif last_idx != -1:\n        return input_string[:last_idx] + input_string[last_idx+1:]\n    else:\n        return input_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    first_index = string.find(char)  # find the first occurrence\n    if first_index != -1:  # if character is found\n        string = string[:first_index] + string[first_index+1:]  # remove first occurrence\n        last_index = string.rfind(char)  # find the last occurrence\n        if last_index != -1:  # if character is found\n            string = string[:last_index] + string[last_index+1:]  # remove last occurrence\n    return string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    first_index = s.find(c)\n    last_index = s.rfind(c)\n    if first_index != -1 and last_index != -1 and first_index != last_index:\n        return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n    elif first_index != -1:\n        return s[:first_index] + s[first_index+1:]\n    elif last_index != -1:\n        return s[:last_index] + s[last_index+1:]\n    else:\n        return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Finding first and last occurrence of the character in the string\n    first_occurrence = s.find(char)\n    last_occurrence = s.rfind(char)\n    \n    # If character is not found in the string, returning original string\n    if first_occurrence == -1:\n        return s\n\n    # If first and last occurrences are the same, removing only one occurrence \n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence+1:]\n    \n    # If first and last occurrences are different, removing both occurrences\n    return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    # Checking if the character is present in the string\n    if ch in s:\n        # Removing first and last occurrence of the character\n        s = s.replace(ch, '', 1)  # Replace first occurrence\n        s = s[::-1]  # Reverse the string\n        s = s.replace(ch, '', 1)  # Remove the last occurrence of the character\n        s = s[::-1]  # Reverse back to original order\n    return s", "matching_cluster_idx": 3}, {"solution": "def remove_Occ(string, char):\n    # getting first and last occurrence of character\n    first_occur = string.find(char)\n    last_occur = string.rfind(char)\n\n    # checking if character is present in string\n    if first_occur == -1 or last_occur == -1:\n        return string  # return string if character is not present\n\n    # removing first and last occurrence of character\n    string = string[:first_occur] + string[first_occur+1:last_occur] + string[last_occur+1:]\n\n    return string", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 95.71428571428571, "dps_norm": 99.6875, "pass@1": 97.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    sum_row = [sum(row) for row in matrix]\n    zipped = list(zip(matrix, sum_row))\n    zipped.sort(key=lambda x: x[1])\n    return [row[0] for row in zipped]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    mat.sort(key=sum)\n    return mat", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    return sorted(mat, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    sum_rows = [sum(row) for row in matrix]\n    sorted_matrix = [x for _,x in sorted(zip(sum_rows, matrix))]\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and store it in a tuple (sum, row)\n    sums = [(sum(row), row) for row in matrix]\n    \n    # Sort the list of tuples by the first element of each tuple (i.e., the sum)\n    sums.sort()\n    \n    # Extract the rows in the correct order\n    sorted_matrix = [row for _, row in sums]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate sums of rows and sort by them\n    sorted_indices = sorted(range(len(matrix)), key=lambda i: sum(matrix[i]))\n    sorted_matrix = [matrix[i] for i in sorted_indices]\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Create a list to hold the sum of each row and the corresponding index\n    sum_list = [(sum(row), i) for i, row in enumerate(matrix)]\n    # Sort the list of sums\n    sum_list.sort()\n    # Create a new sorted matrix by using the indices of the original matrix\n    sorted_matrix = [matrix[i] for _, i in sum_list]\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    This function takes a matrix and returns a new matrix sorted in ascending order of the sums of its rows.\n    \"\"\"\n    # Calculate the sum for each row\n    sums_list = [sum(row) for row in matrix]\n    # Zip together the row sums with the original rows\n    zipped_matrix = list(zip(sums_list, matrix))\n    # Sort the zipped list and get back the rows\n    sorted_matrix = [row for _, row in sorted(zipped_matrix)]\n    return sorted_matrix", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    return sorted(mat, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts the matrix rows based on the sum of their values.\"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 57.4390243902439, "dps_norm": 75.0, "pass@1": 40.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(s: str) -> bool:\n    split_strings = s.split(\"_\")\n    for string in split_strings:\n        if not string.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    if re.fullmatch(pattern, s):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(text):\n    # Split the text into words\n    words = text.split(\"_\")\n    # For each word check if it is all in lower case and consists of letters only.\n    # If all words pass this condition, return True, otherwise False\n    return all(word.islower() and word.isalpha() for word in words)", "matching_cluster_idx": 4}, {"solution": "def text_lowercase_underscore(s):\n    words = s.split(\"_\")\n    for word in words:\n        if not word.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    pattern = \"^[a-z]+(_[a-z]+)*$\"\n    if re.search(pattern, text):\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def text_lowercase_underscore(input_string):\n    split_string = input_string.split('_')\n    for sequence in split_string:\n        if not sequence.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(text):\n    # Split the text into words\n    words = text.split(\"_\")\n    # Check each word if it only contains lowercase letters\n    for word in words:\n        if not word.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    # Split the string into a list of words\n    words = s.split(\"_\")\n    \n    # Check each word in the list\n    for word in words:\n        # If any word is not entirely in lowercase, return False\n        if not word.islower():\n            return False\n    \n    # If no non-lowercase word is found, return True\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    for word in s.split(\"_\"):\n        if not word.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(input_str):\n    # regex check for sequences of lowercase letters joined with an underscore\n    pattern = \"^[a-z]+(_[a-z]+)*$\"\n    if re.match(pattern, input_str):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    This function checks if the input string contains sequences of lowercase letters\n    joined with an underscore.\n    \"\"\"\n    split_text = s.split(\"_\")\n    for text in split_text:\n        if not text.islower() or not text.isalpha():\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = \"^[a-z]+(_[a-z]+)*$\"\n    if(re.search(pattern, s)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def text_lowercase_underscore(s):\n    parts = s.split('_')\n    return all(part.islower() and part.isalpha() for part in parts)", "matching_cluster_idx": 4}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(txt):\n    words = txt.split('_')\n    for word in words:\n        if not word.islower() or not word.isalpha():\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def text_lowercase_underscore(text):\n    # Split the text into segments using '_' as the separator\n    segments = text.split(\"_\")\n\n    # For each segment, check if it consists only of lowercase letters\n    for segment in segments:\n        if not segment.islower():\n            return False\n\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    # split string into words\n    words = s.split(\"_\")\n\n    # check if all words are in lowercase\n    return all(word.islower() for word in words)", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    split_string = s.split(\"_\")\n    for sub_str in split_string:\n        if not sub_str.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(input_string):\n    split_string = input_string.split(\"_\")\n    for word in split_string:\n        if not word.islower():\n            return False\n    return True", "matching_cluster_idx": 5}]}, "Mbpp/19": {"dps": 66.41414141414141, "dps_norm": 81.0, "pass@1": 100.0, "profiled": [{"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(input_list):\n    \"\"\"\n    This function takes a list of integers and checks if there are any duplicates.\n    It returns True if there are duplicates and False if there are no duplicates.\n    \"\"\"\n    if len(input_list) == len(set(input_list)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    if len(array) == len(set(array)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"This function checks for duplicate elements in the given list\"\"\"\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    if len(array) == len(set(array)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Using a set to store the elements of the list.\n    # Set does not allow duplicate elements,\n    # so if the length of the set and the list is not the same, \n    # it means that there are duplicate elements in the list.\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(numbers):\n    if len(numbers) == len(set(numbers)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    if len(nums) == len(set(nums)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(lst):\n    return len(lst) != len(set(lst))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(lst):\n    return len(lst) != len(set(lst))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    seen = set()\n    for num in array:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    if len(nums) == len(set(nums)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(lst):\n    return len(lst) != len(set(lst))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(lst):\n    return len(lst) != len(set(lst))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if a given list of integers contains any duplicate element.\n    If there is a duplicate, it returns True; otherwise, it returns False.\n\n    :param arr: a list of integers\n    :return: a boolean indicating whether there are duplicate elements\n    \"\"\"\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    \"\"\"\n    This function checks if there are any duplicate elements in the given list.\n\n    Parameters:\n    array (list): A list of integers\n\n    Returns:\n    bool: True if there are duplicate elements, False otherwise\n    \"\"\"\n    return len(array) != len(set(array))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    \"\"\"\n    Function to check if any element is repeated in a given array of integers.\n\n    :param array: List of integers.\n    :return: True if any element is repeated, False otherwise.\n    \"\"\"\n    return len(array) != len(set(array))", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 97.0, "dps_norm": 98.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    \"\"\"\n    This function takes a list of numbers as an argument, finds and returns the smallest number in the list.\n    \"\"\"\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    \"\"\"\n    Function to find smallest number in a list.\n    \"\"\"\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    \"\"\"\n    This function takes a list of numbers as input and returns the smallest number in the list.\n    \"\"\"\n\n    # Checking if the list is empty. If so, returning None.\n    if not num_list:\n        return None\n\n    # Initializing the smallest number as the first number in the list.\n    smallest = num_list[0]\n\n    # Going through the rest of the list.\n    for num in num_list:\n\n        # If the current number is smaller than the current smallest, \n        # update the smallest number.\n        if num < smallest:\n            smallest = num\n    \n    # Return the smallest number.\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function finds the smallest number in a list.\n    Args:\n    lst: list of integers\n    \n    Returns:\n    smallest_num: smallest integer in the list\n    \"\"\"\n    smallest_num = min(lst)\n    return smallest_num", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function takes a list of integers as input and returns the smallest number in the list.\n    \"\"\"\n    # Initialize min_num as the first element in the list\n    min_num = lst[0]\n    \n    # Iterate through each element in the list\n    for num in lst:\n        # If the current element is smaller than min_num, update min_num\n        if num < min_num:\n            min_num = num\n            \n    # Return the smallest number\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function takes a list of numbers as input and returns the smallest number in the list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function takes a list of numbers as input and returns the smallest number.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}]}, "Mbpp/75": {"dps": 93.21428571428572, "dps_norm": 68.33333333333334, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(i % k == 0 for i in t):\n            result.append(t)\n    return result\ntuples_list = [(6, 24, 12), (7, 9, 6), (12, 18, 21)]\nk = 6", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(i % k == 0 for i in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    result = []\n    for t in lst:\n        if all(i % k == 0 for i in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tpl in tuples_list:\n        if all(i % k == 0 for i in tpl):\n            result.append(tpl)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        if all(el % k == 0 for el in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    return [t for t in list_of_tuples if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = [t for t in tuples_list if all(e % k == 0 for e in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    def all_divisible(tpl, k):\n        return all(i % k == 0 for i in tpl)\n\n    return [tpl for tpl in lst if all_divisible(tpl, k)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    # Filter the list using a custom function to check if all elements of a tuple are divisible by k\n    result = [t for t in tuples_list if all(x % k == 0 for x in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = [t for t in tuples_list if all(x % k == 0 for x in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the input list of tuples\n    for t in lst:\n        # Iterate over the elements in each tuple\n        for elem in t:\n            # If the element is not divisible by k, break the loop and move on to the next tuple\n            if elem % k != 0:\n                break\n        # If we've gotten this far without breaking, that means all elements in the tuple are divisible by k\n        else:\n            # Add the tuple to the results list\n            result.append(t)\n    \n    # Return the list of results\n    return result", "matching_cluster_idx": 8}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function finds tuples which have all elements divisible by k from the given list of tuples.\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(i % k == 0 for i in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tup_list, k):\n    return [tup for tup in tup_list if all(el % k == 0 for el in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = [t for t in tuples_list if all(x % k == 0 for x in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tpl in tuples_list:\n        if all(el % k == 0 for el in tpl):\n            result.append(tpl)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = [t for t in tuples_list if all(e % k == 0 for e in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = [t for t in tuples_list if all(i % k == 0 for i in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    result = [t for t in tuples if all(x % k == 0 for x in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    result = [t for t in tuples if all(x % k == 0 for x in t)]\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.56862745098039, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    freqs = {}\n    for item in lst:\n        if (item in freqs):\n            freqs[item] += 1\n        else:\n            freqs[item] = 1\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if (item in frequency):\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if (item in frequency):\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # create an empty dictionary\n    count_dict = {}\n    \n    # iterate over each element in the list\n    for elem in lst:\n        if elem in count_dict:\n            # if the element is already in the dictionary, increase its count\n            count_dict[elem] += 1\n        else:\n            # if the element is not in the dictionary, add it with a count of 1\n            count_dict[elem] = 1\n    \n    # return the resulting dictionary\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    count_dict = {}\n    for i in lst:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    freq_dict = {}\n    for item in input_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Function to get the frequency of all the elements in a list\n    \"\"\"\n    # Create an empty dictionary\n    freq_dict = {}\n    # Loop through the list\n    for i in lst:\n        # If the element is in the dictionary, increment the count\n        if i in freq_dict:\n            freq_dict[i] += 1\n        # If the element is not in the dictionary, add it with count 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freqs = {}\n    for item in lst:\n        if item in freqs:\n            freqs[item] += 1\n        else:\n            freqs[item] = 1\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for i in lst:\n        if i in frequency:\n            frequency[i] += 1\n        else:\n            frequency[i] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freqs = {}\n    for el in lst:\n        if el in freqs:\n            freqs[el] += 1\n        else:\n            freqs[el] = 1\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freqs = {}\n    for el in lst:\n        if el in freqs:\n            freqs[el] += 1\n        else:\n            freqs[el] = 1\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freqs = {}\n    for num in lst:\n        if num in freqs:\n            freqs[num] += 1\n        else:\n            freqs[num] = 1\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freqs = {}\n    for item in lst:\n        if item in freqs:\n            freqs[item] += 1\n        else:\n            freqs[item] = 1\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freqs = {}\n    for i in lst:\n        if i in freqs:\n            freqs[i] += 1\n        else:\n            freqs[i] = 1\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freqs = {}\n    for elem in lst:\n        if elem in freqs:\n            freqs[elem] += 1\n        else:\n            freqs[elem] = 1\n    return freqs", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 79.51219512195122, "dps_norm": 85.71428571428571, "pass@1": 26.0, "profiled": [{"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    #initialize maximum length to 0\n    max_len = 0\n\n    #iterate through each word in the list\n    for word in words:\n        #if the length of the current word is greater than max_len, update max_len\n        if len(word) > max_len:\n            max_len = len(word)\n\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    This function takes a list of words and returns the length of the longest word.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    This function takes a list of words and returns the length of the longest word.\n    \"\"\"\n    # Initialize max_length to 0\n    max_length = 0\n\n    # For each word in the list\n    for word in words:\n        # If the length of the current word is greater than max_length\n        if len(word) > max_length:\n            # Update max_length to the length of the current word\n            max_length = len(word)\n\n    # Return the maximum length\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    return max(len(word) for word in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(words_list):\n    # Initialize maximum length to 0\n    max_length = 0\n    # Loop through each word in the list\n    for word in words_list:\n        # If the length of the current word is greater than max_length, update max_length\n        if len(word) > max_length:\n            max_length = len(word)\n    # Return the longest word length\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    return max(len(word) for word in word_list)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    return max(len(word) for word in word_list)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words_list):\n    return max(len(word) for word in words_list)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 78.04878048780488, "dps_norm": 60.0, "pass@1": 91.0, "profiled": [{"solution": "def index_minimum(list_of_tuples):\n    return min(list_of_tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"Given a list of tuples, returns the first value of the tuple with the smallest second value\"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"Return the first value of the tuple with the smallest second value\"\"\"\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    # Initialize the minimum index and value to the first item in the list\n    min_index, min_value = 0, list_of_tuples[0][1]\n\n    # Iterate over the rest of the list\n    for i in range(1, len(list_of_tuples)):\n        # If the item has a smaller second value than the current minimum, update the minimum\n        if list_of_tuples[i][1] < min_value:\n            min_index, min_value = i, list_of_tuples[i][1]\n\n    # Return the first value of the tuple with the smallest second value\n    return list_of_tuples[min_index][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # The 'min' function finds the minimum of a list.\n    # 'key' is used to specify a function of one argument that is used to extract a comparison key from each element.\n    # In this case, it's set to get the second element of each tuple.\n    min_value_tuple = min(lst, key = lambda x:x[1])\n    # Return only the first element of the found tuple (index 0).\n    return min_value_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Finds the tuple with the smallest second value and returns the first value of that tuple.\n    :param lst: a list of tuples\n    :return: the first value of the tuple with the smallest second value\n    \"\"\"\n    # Start by assuming the first tuple's second value is the smallest\n    smallest_second_value = lst[0][1]\n    smallest_second_index = 0\n\n    # Go through each tuple in the list\n    for i in range(len(lst)):\n        # If the current tuple's second value is smaller than the smallest_second_value, update the smallest_second_value and smallest_second_index\n        if lst[i][1] < smallest_second_value:\n            smallest_second_value = lst[i][1]\n            smallest_second_index = i\n\n    # Return the first value of the tuple with the smallest second value\n    return lst[smallest_second_index][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    if lst:\n        return min(lst, key=lambda x: x[1])[0]\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_tuple):\n    return min(list_tuple, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Sort the list of tuples by the second element.\n    lst.sort(key=lambda x: x[1])\n    # Return the first (index 0) element of the sorted list.\n    return lst[0][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, the function returns the first value of the tuple with the smallest second value.\n\n    :param lst: List of tuples\n    :type lst: List[Tuple[Any, int]]\n    :return: First value of the tuple with the smallest second value\n    :rtype: Any\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    lst.sort(key=lambda x: x[1])\n\n    # Return the first value of the first tuple in the sorted list\n    return lst[0][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 77.77777777777777, "dps_norm": 42.857142857142854, "pass@1": 95.0, "profiled": [{"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(num):\n    count = 0\n    for i in range(1, num+1):\n        if num % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize count to 0\n    count = 0\n    for i in range(1, n + 1):\n        # Check if i is a divisor\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(num):\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/97": {"dps": 95.00854700854701, "dps_norm": 84.375, "pass@1": 90.0, "profiled": [{"solution": "def frequency_lists(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    frequency = {}\n    for item in flat_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lst for item in sublist]\n\n    # Create a dictionary to store frequencies\n    freq_dict = {}\n\n    # Iterate through the flattened list\n    for item in flat_list:\n        # If the item is in the dictionary, increase its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[item] = 1\n\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    freqs = {}\n    for sublist in lst:\n        for elem in sublist:\n            if elem in freqs:\n                freqs[elem] += 1\n            else:\n                freqs[elem] = 1\n    return freqs", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    \"\"\"\n    This function finds the frequency of each element in a flattened list of lists\n    \"\"\"\n    frequency = {}\n    for sublist in lst:\n        for element in sublist:\n            if element in frequency:\n                frequency[element] += 1\n            else:\n                frequency[element] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef flatten(lst):\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst_of_lst):\n    flat_list = flatten(lst_of_lst)\n    freq_dict = defaultdict(int)\n    for item in flat_list:\n        freq_dict[item] += 1\n    return dict(freq_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    freqs = {}\n    for sublist in lists:\n        for element in sublist:\n            if element in freqs:\n                freqs[element] += 1\n            else:\n                freqs[element] = 1\n    return freqs", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef frequency_lists(lst):\n    freq_dict = defaultdict(int)\n    for sublist in lst:\n        for item in sublist:\n            freq_dict[item] += 1\n    return dict(freq_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    freq_dict = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def flatten(lst):\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst):\n    flat_list = flatten(lst)\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef flatten(lst):\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst):\n    flattened_list = flatten(lst)\n    return dict(Counter(flattened_list))", "matching_cluster_idx": 6}, {"solution": "def flatten(input_list):\n    output_list = []\n    for i in input_list:\n        output_list.extend(i)\n    return output_list\ndef frequency(input_list):\n    frequency_dict = {}\n    for i in input_list:\n        if i in frequency_dict:\n            frequency_dict[i] += 1\n        else:\n            frequency_dict[i] = 1\n    return frequency_dict\ndef frequency_lists(input_lists):\n    return frequency(flatten(input_lists))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef flatten(input_list):\n    flattened = [item for sublist in input_list for item in sublist]\n    return flattened\ndef frequency_lists(input_list):\n    flattened = flatten(input_list)\n    frequency = dict(Counter(flattened))\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef flatten(lst):\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst):\n    flat_list = flatten(lst)\n    return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "def flatten(lst):\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst):\n    flat_list = flatten(lst)\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def flatten_list(lst):\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst):\n    flat_list = flatten_list(lst)\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef flatten(lst):\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lsts):\n    flat_list = flatten(lsts)\n    return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    freq = {}\n    for sublist in lst:\n        for item in sublist:\n            if item in freq:\n                freq[item] += 1\n            else:\n                freq[item] = 1\n    return freq", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lst for item in sublist]\n\n    # Create an empty dictionary to store frequency counts\n    frequency_count = {}\n\n    # For each item in the flattened list, increase the count in the dictionary\n    for item in flat_list:\n        if item in frequency_count:\n            frequency_count[item] += 1\n        else:\n            frequency_count[item] = 1\n\n    return frequency_count", "matching_cluster_idx": 6}, {"solution": "def flatten(nested_list):\n    # helper function to flatten list\n    result = []\n    for sublist in nested_list:\n        for item in sublist:\n            result.append(item)\n    return result\ndef frequency_lists(nested_list):\n    # function to count frequency of each item in the flattened list\n    flat_list = flatten(nested_list)\n    frequency = {}\n    for item in flat_list:\n        if (item in frequency):\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def flatten(lst):\n    \"\"\"Flattens a list of lists\"\"\"\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst):\n    \"\"\"Returns a dictionary with the frequency of each element in the flattened list of lists\"\"\"\n    flat_list = flatten(lst)\n    return {i: flat_list.count(i) for i in flat_list}", "matching_cluster_idx": 1}]}, "Mbpp/106": {"dps": 66.78571428571429, "dps_norm": 90.83333333333333, "pass@1": 99.0, "profiled": [{"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    # concatenate the tuple and the list using + operator\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    # combine the tuple and list\n    combined = tpl + tuple(lst)\n    return combined", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to list\n    tpl_list = list(tpl)\n    \n    # Add the given list to the list of the tuple\n    tpl_list.extend(lst)\n    \n    # Convert the list back to tuple\n    tpl = tuple(tpl_list)\n    \n    return tpl", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    # Convert tuple to list\n    tup_list = list(tup)\n    # Append the list to the tuple list\n    tup_list.extend(lst)\n    # Convert list back to tuple\n    new_tup = tuple(tup_list)\n    return new_tup", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Append the given list to the given tuples\"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    This function appends a given list to the given tuple and returns the result.\n    \n    Parameters:\n        lst (List): The list to be appended.\n        tpl (Tuple): The tuple to which the list will be appended.\n    \n    Returns:\n        Tuple: A tuple consisting of the elements of the initial tuple followed by the elements of the list.\n    \"\"\"\n    # Convert the tuple to list\n    tpl_list = list(tpl)\n    # Append the list to the list\n    tpl_list.extend(lst)\n    # Convert the list back to tuple\n    result_tpl = tuple(tpl_list)\n    # Return the resulting tuple\n    return result_tpl", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    This function appends a given list to a given tuple and returns the combined object.\n    \n    Parameters:\n    lst (list): The list to be added.\n    tup (tuple): The tuple to which the list is appended.\n    \n    Returns:\n    tuple: The tuple resulting from appending the list to the tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    # Using the + operator to concatenate tuples and lists\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 4}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    merged_list = lst1 + lst2 + lst3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\" Merge three sorted lists into a single sorted list.\n\n    Args:\n        list1 (list): first sorted list\n        list2 (list): second sorted list\n        list3 (list): third sorted list\n\n    Returns:\n        list: A sorted list containing elements from all three input lists.\n    \"\"\"\n\n    # Merge the lists\n    merged_list = list1 + list2 + list3\n\n    # Sort the merged list\n    merged_list.sort()\n\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # concatenate the lists\n    merged_list = list1 + list2 + list3\n    # sort the merged list\n    merged_list.sort()\n    # return the sorted list\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merging the three lists into one\n    merged_list = list1 + list2 + list3\n\n    # Sorting the combined list\n    sorted_list = sorted(merged_list)\n\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Concatenate the lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    merged_list = l1 + l2 + l3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(a, b, c):\n    # merge all three lists into one\n    merged_list = a + b + c\n    # sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    # Merge the three lists\n    merged_list = l1 + l2 + l3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    merged_list = l1 + l2 + l3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    merged_list = l1 + l2 + l3\n    merged_list.sort()\n    return merged_list\nlst1 = [25, 24, 15, 4, 5, 29, 110]\nlst2 = [19, 20, 11, 56, 25, 233, 154]\nlst3 = [24, 26, 54, 48]\nmerged_list = merge_sorted_list(lst1, lst2, lst3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    merged = lst1 + lst2 + lst3\n    return sorted(merged)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    return sorted(merged_list)\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    result = list1 + list2 + list3\n    result.sort()\n    return result", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 52.12307692307692, "dps_norm": 75.625, "pass@1": 94.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    return list(set.intersection(*map(set, nested_lists)))", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_list):\n    return list(set.intersection(*map(set, nested_list)))", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_lists):\n    return list(set.intersection(*map(set, nested_lists)))", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Get the first list in the nested lists as a starting point\n    common_elements = set(nested_lists[0])\n    # Loop over remaining lists\n    for cur_list in nested_lists[1:]:\n        # Intersection of elements in current list with the common elements\n        common_elements = common_elements.intersection(set(cur_list))\n    # Convert to list and return\n    return list(common_elements)\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    if not nested_list:\n        return []\n\n    common_elements = set(nested_list[0])\n    for cur_list in nested_list[1:]:\n        common_elements = common_elements & set(cur_list)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements = common_elements & set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    return list(set.intersection(*map(set, nested_list)))", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_lists):\n    result = set(nested_lists[0])  # start with first list\n    for lst in nested_lists[1:]:  # iterate over the remaining lists\n        result = result & set(lst)  # find common elements with current result and current list\n    return list(result)  # return list of common elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function finds the common elements in given nested lists\n    and returns them as a list.\n    \"\"\"\n    result = set(nested_lists[0])\n    for sub_list in nested_lists[1:]:\n        result = result.intersection(set(sub_list))\n    return list(result)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    return list(set.intersection(*map(set, nested_lists)))", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_lists):\n    # convert the first list to a set\n    common_elements = set(nested_lists[0])\n\n    # iterate over the rest of the lists\n    for current_list in nested_lists[1:]:\n        # keep only elements that are common in the current list and the common_elements set\n        common_elements = common_elements.intersection(current_list)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    return list(set.intersection(*map(set, nested_lists)))", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_list):\n    \"\"\"\n    This function takes a nested list of numbers and returns common elements.\n    \"\"\"\n    result = set(nested_list[0])  # Initial result is the set of first list\n    for each_list in nested_list[1:]:  # Loop over the rest of the lists\n        result = result & set(each_list)  # Take intersection of the current result and current list\n    return list(result)  # Return the result as a list", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    # convert nested list into set of list\n    set_lists = map(set, nested_list)\n    # use python built-in set.intersection method\n    common = set.intersection(*set_lists)\n    return list(common)", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(lst):\n    if len(lst)==0:\n        return []\n    common_set = set(lst[0])\n    for l in lst[1:]:\n        common_set = common_set & set(l)\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # To solve the problem, use the built-in Python function set() \n    # and & operator to find intersection of all elements in each nested list.\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements = common_elements & set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Find common elements in the first list\n    common = set(nested_lists[0])\n    # For each subsequent list, find common elements\n    for lst in nested_lists[1:]:\n        common &= set(lst)  # Intersection of current common elements and new list\n    return list(common)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    return list(set.intersection(*map(set, nested_list)))", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(lists):\n    common = set(lists[0])\n    for lst in lists[1:]:\n        common = common & set(lst)\n    return list(common)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    return list(set.intersection(*map(set, nested_list)))", "matching_cluster_idx": 4}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 49.0, "profiled": [{"solution": "def sum_of_divisors(n):\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if i * (n // i) == n:\n                sum = sum + i + n//i\n            else:\n                sum += i\n            i += 1\n    return sum\ndef amicable_numbers_sum(limit):\n    amicable_sum = 0\n    for i in range(1, limit+1):\n        j = sum_of_divisors(i)\n        if i != j and sum_of_divisors(j) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum += i\n            if n / i != i:\n                sum += n // i\n    return sum\ndef amicable_numbers_sum(n):\n    sum = 0\n    for i in range(1, n):\n        if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i:\n            sum += i\n    return sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n): \n    sum = 1\n    i = 2\n    while i * i <= n: \n        if n % i: \n            i += 1\n        else: \n            if i * (n // i) == n: \n                sum = sum + i + n//i \n            else: \n                sum = sum + i \n            i += 1\n    return sum\ndef amicable_numbers_sum(limit):\n    amicable_numbers_sum = 0\n    for i in range(1, limit+1):\n        sum_of_divisors_i = sum_of_divisors(i)\n        if i != sum_of_divisors_i and sum_of_divisors(sum_of_divisors_i) == i:\n            amicable_numbers_sum += i\n    return amicable_numbers_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_divisors(num):\n        sum = 1\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                if i * (num // i) == num:\n                    sum = sum + i + num//i\n                else:\n                    sum = sum + i\n                i += 1\n        return sum\n\n    amicable_sum = 0\n    for i in range(1, n+1):\n        sum_1 = sum_divisors(i)\n        sum_2 = sum_divisors(sum_1)\n        if sum_2==i and sum_1!=sum_2:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def divisors_sum(n):\n    '''Calculates the sum of divisors excluding the number itself.'''\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    '''Calculates the sum of all amicable numbers up to a specified limit.'''\n    amicable_numbers = set()\n    for i in range(2, limit + 1):\n        if i in amicable_numbers:\n            continue\n        sum_divisors = divisors_sum(i)\n        if (sum_divisors != i) and (divisors_sum(sum_divisors) == i):\n            amicable_numbers.update([i, sum_divisors])\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def d(n):\n    \"\"\"\n    Function to find the sum of proper divisors of a number\n    \"\"\"\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if i * (n // i) == n:\n                sum = sum + i + n//i\n            else:\n                sum += i\n            i += 1\n    return sum\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Function to find sum of amicable numbers in a given limit\n    \"\"\"\n    amicable_sum = 0\n    numbers = [0] * (limit+1)\n\n    for i in range(1, limit+1):\n        numbers[i] = d(i)\n\n    for i in range(1, limit+1):\n        if (numbers[i] != i and numbers[i] <= limit and numbers[numbers[i]] == i):\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n/i:\n                sum += i\n            else:\n                sum += i + n/i\n    return sum\ndef amicable_numbers_sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum_of_i = sum_of_proper_divisors(i)\n        if i != sum_of_i and i == sum_of_proper_divisors(sum_of_i):\n            sum += i\n    return sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def d(n):\n        s = 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                s += i\n                if i * i != n:\n                    s += n // i\n        return s\n\n    amicable_numbers = set()\n    for i in range(1, limit + 1):\n        j = d(i)\n        if j > i and d(j) == i:\n            amicable_numbers.add(i)\n            amicable_numbers.add(j)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i:\n            continue\n        if i * i != n:\n            sum = sum + i + n // i\n        else:\n            sum = sum + i\n    return sum\ndef amicable_numbers_sum(limit):\n    sum = 0\n    for i in range(1, limit):\n        num1 = sum_of_divisors(i)\n        num2 = sum_of_divisors(num1)\n        if num2 == i and num1 != num2:\n            sum += i\n    return sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    # Initialize the sum\n    sum = 0\n\n    for num in range(1, n+1):\n        div_sum = sum_of_factors(num)\n\n        # Check if num is not equal to the sum of factors and if the sum of factors\n        # is less than or equal to n\n        if (num != div_sum and div_sum <= n):\n            second_div_sum = sum_of_factors(div_sum)\n\n            # Check if num is equal to sum of factors of sum of factors\n            if (num == second_div_sum):\n                # Add num to the sum\n                sum += num\n    return sum\ndef sum_of_factors(n):\n    sum = 1\n    i = 2\n    while i <= n // i:\n        if n % i == 0:\n            if i == (n // i):\n                sum = sum + i\n            else:\n                sum = sum + (i + n // i)\n        i += 1\n    return sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def sum_divisors(n):\n        sum = 1\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if i * (n // i) == n:\n                    sum = sum + i + n//i\n                else:\n                    sum = sum + i\n                i += 1\n        return sum\n    amicable_numbers = set()\n    for i in range(1, limit+1):\n        s = sum_divisors(i)\n        if s > i and s <= limit and sum_divisors(s) == i:\n            amicable_numbers.add(i)\n            amicable_numbers.add(s)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if i * (n // i) == n:\n                sum = sum + i + n//i\n            else:\n                sum += i\n            i += 1\n    return sum\ndef amicable_numbers_sum(limit):\n    amicable_numbers = set()\n    for i in range(2, limit+1):\n        sum_i = sum_divisors(i)\n        sum_sum_i = sum_divisors(sum_i)\n        if i != sum_i and sum_i <= limit and i == sum_sum_i:\n            amicable_numbers.add(i)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    sum = 1\n    d = 2\n    while d * d <= n:\n        if n % d:\n            d += 1\n        else:\n            if d * (n // d) == n:\n                sum = sum + d + n//d\n            else:\n                sum = sum + d\n            d += 1\n    return sum\ndef amicable_numbers_sum(limit):\n    sum = 0\n    for i in range(1, limit+1):\n        j = sum_divisors(i)\n        if i != j and sum_divisors(j) == i:\n            sum += i\n    return sum", "matching_cluster_idx": 11}, {"solution": "def d(n):\n    \"\"\"\n    Function to find sum of proper divisors of n.\n    \"\"\"\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if i * (n // i) == n:\n                sum = sum + i + n//i\n            else:\n                sum = sum + i\n            i += 1\n    return sum\ndef amicable_numbers_sum(n):\n    \"\"\"\n    Function to find sum of all amicable numbers from 1 to n.\n    \"\"\"\n    sum = 0\n    for i in range(2,n+1):\n        if d(d(i))==i and d(i)!=i:\n            sum += i\n    return sum", "matching_cluster_idx": 11}, {"solution": "def d(n):\n    \"\"\"\n    Find the sum of proper divisors of the given number.\n    \"\"\"\n    sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if i*i != n:\n                sum = sum + i + n // i\n            else:\n                sum = sum + i\n    return sum\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Find the sum of all amicable numbers from 1 to the specified limit.\n    \"\"\"\n    sum = 0\n    for i in range(1, limit):\n        if i == d(d(i)) and i != d(i):\n            sum += i\n    return sum", "matching_cluster_idx": 11}, {"solution": "def d(n):\n    sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum += i\n            if i * i != n:\n                sum += n // i\n    return sum\ndef amicable_numbers_sum(limit):\n    sum = 0\n    for i in range(1, limit+1):\n        num1 = d(i)\n        num2 = d(num1)\n        if num2 == i and num1 != num2:\n            sum += i\n    return sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"\n    Helper function to compute the sum of divisors of a number excluding itself\n    \"\"\"\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Function to sum all amicable numbers up to the limit\n    \"\"\"\n    amicable_numbers = set()\n    for i in range(2, limit + 1):\n        j = sum_divisors(i)\n        if j != i and j <= limit and sum_divisors(j) == i:\n            amicable_numbers.add(i)\n            amicable_numbers.add(j)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def divisor_sum(n):\n    divisor_list = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i:\n            continue\n        if i == n // i:\n            divisor_list.append(i)\n        else:\n            divisor_list.extend([i, n // i])\n    return sum(divisor_list)\ndef amicable_numbers_sum(limit):\n    amicable_numbers = set()\n    for i in range(1, limit + 1):\n        if i in amicable_numbers:\n            continue\n        sum_div = divisor_sum(i)\n        if sum_div > i and divisor_sum(sum_div) == i:\n            amicable_numbers.update([i, sum_div])\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def d(n):\n        result = 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                result += i\n                if i * i != n:  # if i is a square root, then don't count it twice\n                    result += n // i\n        return result\n\n    amicable_numbers = set()\n    for a in range(1, limit + 1):\n        b = d(a)\n        if a != b and d(b) == a:\n            amicable_numbers.add(a)\n            amicable_numbers.add(b)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def d(n):\n    \"\"\"\n    helper function to calculate sum of factors excluding the number itself\n    \"\"\"\n    sum = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i:\n            continue\n        if i * i != n:\n            sum = sum + i + n // i\n        else:\n            sum = sum + i\n    return sum\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    function to find and sum up all amicable numbers up to a specified limit\n    \"\"\"\n    result = 0\n    for i in range(1, limit):\n        if i == d(d(i)) and i != d(i):\n            result += i\n    return result", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, sentence):\n    return [word for word in sentence.split(\" \") if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split(' ')\n    \n    # Filter out words that are longer than n characters\n    long_words = [word for word in words if len(word) > n]\n    \n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    word_list = words.split()\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    word_list = sentence.split()\n    long_words = [word for word in word_list if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split(' ')\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split(\" \")\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    word_list = sentence.split()\n    long_words = [word for word in word_list if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string_list):\n    words = string_list.split(' ')\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    word_list = words.split(\" \")\n    long_words = [word for word in word_list if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words_str):\n    # Split words_str into a list of words\n    words = words_str.split(' ')\n    \n    # Use list comprehension to get the words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    words = string.split()\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    words = string.split(\" \")\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    word_list = words.split()\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    word_list = sentence.split(' ')\n    long_words = [word for word in word_list if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    word_list = sentence.split()\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    word_list = sentence.split(' ')\n    long_words = [word for word in word_list if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split(' ')\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split(' ')\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    words = string.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 74.31122448979592, "dps_norm": 91.33333333333333, "pass@1": 56.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    # Get the dimension of the square\n    dimension = len(matrix)\n\n    # The sum of the first row is the constant sum\n    magic_constant = sum(matrix[0])\n\n    # Check row sums\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check column sums\n    for i in range(dimension):\n        if sum(row[i] for row in matrix) != magic_constant:\n            return False\n\n    # Check diagonal sums\n    if sum(matrix[i][i] for i in range(dimension)) != magic_constant:\n        return False\n    if sum(matrix[i][dimension - i - 1] for i in range(dimension)) != magic_constant:\n        return False\n\n    # If we made it this far, the matrix is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Find number of rows (n) and columns (m)\n    n = len(matrix)\n    m = len(matrix[0])\n\n    # Calculate the sum of elements in the first row\n    magic_constant = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for j in range(m):\n        if sum(matrix[i][j] for i in range(n)) != magic_constant:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    if sum(matrix[i][n - i - 1] for i in range(n)) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(square):\n    # Assuming a square matrix of order n x n\n    n = len(square)\n\n    # Calculating the sum of the first row\n    magic_constant = sum(square[0])\n\n    # Checking each row for magic constant sum\n    for row in square:\n        if sum(row) != magic_constant:\n            return False\n\n    # Checking each column for magic constant sum\n    for i in range(n):\n        if sum(row[i] for row in square) != magic_constant:\n            return False\n\n    # Checking the diagonal sum from top left to bottom right\n    if sum(square[i][i] for i in range(n)) != magic_constant:\n        return False\n\n    # Checking the diagonal sum from top right to bottom left\n    if sum(square[i][n - i - 1] for i in range(n)) != magic_constant:\n        return False\n\n    # If all conditions are met, the matrix is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Get the length (row and column size) of the matrix\n    n = len(matrix)\n\n    # Initialize the sum of first row\n    sum_row = sum(matrix[0])\n\n    # Check sum of each row\n    for row in matrix:\n        if sum(row) != sum_row:\n            return False\n    \n    # Check sum of each column\n    for j in range(n):\n        if sum(matrix[i][j] for i in range(n)) != sum_row:\n            return False\n\n    # Check sum of two diagonals\n    if sum(matrix[i][i] for i in range(n)) != sum_row:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != sum_row:\n        return False\n\n    # If all checks pass\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Get the size of the matrix\n    size = len(matrix)\n    \n    # Calculate the sum of the first row to use as the target\n    target = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target:\n            return False\n    \n    # Check columns\n    for i in range(size):\n        if sum(row[i] for row in matrix) != target:\n            return False\n    \n    # Check diagonal\n    if sum(matrix[i][i] for i in range(size)) != target:\n        return False\n    \n    # Check anti-diagonal\n    if sum(matrix[i][size-i-1] for i in range(size)) != target:\n        return False\n    \n    # If all checks passed, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # check if it's a square matrix\n    if len(matrix) != len(matrix[0]):\n        return False\n\n    # calculate the sum of the first row\n    magic_constant = sum(matrix[0])\n\n    # check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # check columns\n    for col in range(len(matrix[0])):\n        if sum(matrix[i][col] for i in range(len(matrix))) != magic_constant:\n            return False\n\n    # check diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_constant:\n        return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_constant:\n        return False\n\n    # if all tests pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(square):\n    # Check if the matrix is a square\n    if len(square) != len(square[0]):\n        return False\n\n    # Calculate the sum of the first row\n    magic_constant = sum(square[0])\n\n    # Check horizontal rows\n    for row in square:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check vertical columns\n    for i in range(len(square)):\n        if sum(row[i] for row in square) != magic_constant:\n            return False\n\n    # Check diagonals\n    if sum(square[i][i] for i in range(len(square))) != magic_constant:\n        return False\n    if sum(square[i][len(square)-i-1] for i in range(len(square))) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Transpose the matrix to check the rows and columns\n    transposed = zip(*matrix)\n\n    # Calculate the sum of elements in the first row\n    first_row_sum = sum(matrix[0])\n\n    # Check if sum of each row is equal\n    for row in matrix:\n        if sum(row) != first_row_sum:\n            return False\n\n    # Check if sum of each column is equal\n    for column in transposed:\n        if sum(column) != first_row_sum:\n            return False\n\n    # Check the sum of the two diagonals\n    diagonal_sum_1 = sum(matrix[i][i] for i in range(len(matrix)))\n    if diagonal_sum_1 != first_row_sum:\n        return False\n\n    diagonal_sum_2 = sum(matrix[i][-i - 1] for i in range(len(matrix)))\n    if diagonal_sum_2 != first_row_sum:\n        return False\n\n    # If all the checks passed, the matrix is a magic square\n    return True", "matching_cluster_idx": 11}, {"solution": "def magic_square_test(square):\n    # Get the size of the matrix (assumed to be a square matrix)\n    size = len(square)\n    \n    # Calculate the sum of the first row\n    magic_constant = sum(square[0])\n    \n    # Check rows\n    for row in square:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check columns\n    for col in range(size):\n        if sum(square[i][col] for i in range(size)) != magic_constant:\n            return False\n    \n    # Check diagonals\n    if sum(square[i][i] for i in range(size)) != magic_constant:\n        return False\n    if sum(square[i][size - i - 1] for i in range(size)) != magic_constant:\n        return False\n    \n    # If none of the tests failed, the matrix is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Get the size of the matrix\n    n = len(matrix)\n    # Get the sum of the first row\n    magic_constant = sum(matrix[0])\n\n    # Check rows and columns\n    for i in range(n):\n        if sum(matrix[i]) != magic_constant or sum([row[i] for row in matrix]) != magic_constant:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_constant or sum(matrix[i][n - i - 1] for i in range(n)) != magic_constant:\n        return False\n\n    # If none of the above tests fail, then the matrix is a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # The matrix must be a square matrix\n    if len(matrix) == 0 or len(matrix) != len(matrix[0]):\n        return False\n\n    # The sum of elements in each row, column and two diagonals must be same\n    total_sum = sum(matrix[0])\n    col_sums = [sum(col) for col in zip(*matrix)]\n    diag_sums = [sum(matrix[i][i] for i in range(len(matrix))), sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix)))]\n\n    if any(row_sum != total_sum for row_sum in map(sum, matrix)) or \\\n       any(col_sum != total_sum for col_sum in col_sums) or \\\n       not all(diag_sum == total_sum for diag_sum in diag_sums):\n        return False\n\n    return True", "matching_cluster_idx": 9}, {"solution": "def magic_square_test(matrix):\n    # check if the matrix is a square\n    if len(matrix) != len(matrix[0]):\n        return False\n\n    # calculate the sum of the first row\n    magic_constant = sum(matrix[0])\n\n    # check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # check columns\n    for i in range(len(matrix)):\n        if sum(row[i] for row in matrix) != magic_constant:\n            return False\n\n    # check diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_constant:\n        return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_constant:\n        return False\n\n    # if all checks pass, the matrix is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Find the size of the matrix\n    size = len(mat)\n\n    # Calculate the sum of the first row\n    magic_constant = sum(mat[0])\n\n    # Check the sum of each row\n    for row in mat:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check the sum of each column\n    for col_idx in range(size):\n        if sum(mat[row_idx][col_idx] for row_idx in range(size)) != magic_constant:\n            return False\n\n    # Check the sum of the diagonal\n    if sum(mat[row_idx][row_idx] for row_idx in range(size)) != magic_constant:\n        return False\n\n    # Check the sum of the other diagonal\n    if sum(mat[row_idx][size - row_idx - 1] for row_idx in range(size)) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is a square\n    if len(matrix) != len(matrix[0]):\n        return False\n\n    # Calculate the sum of a row, column or diagonal\n    target_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(len(matrix[0])):\n        if sum(matrix[i][col] for i in range(len(matrix))) != target_sum:\n            return False\n\n    # Check the sum of the two diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the magic constant\n    magic_constant = sum(row[0] for row in matrix)\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n            \n    # Check columns\n    for col in range(len(matrix[0])):\n        if sum(matrix[row][col] for row in range(len(matrix))) != magic_constant:\n            return False\n    \n    # Check diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_constant:\n        return False\n    \n    # Check anti-diagonal\n    if sum(matrix[i][len(matrix)-1-i] for i in range(len(matrix))) != magic_constant:\n        return False\n    \n    # If passed all tests, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the input is a list\n    if type(matrix) is not list:\n        return False\n    # Check if the input is a square matrix\n    if not all(len(row) == len(matrix) for row in matrix):\n        return False\n    # Calculate the sum of the first row\n    magic_sum = sum(matrix[0])\n    # Check if the rows have the same sum\n    if any(sum(row) != magic_sum for row in matrix):\n        return False\n    # Check if the columns have the same sum\n    if any(sum(matrix[j][i] for j in range(len(matrix))) != magic_sum for i in range(len(matrix))):\n        return False\n    # Check if the diagonals have the same sum\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum or sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_sum:\n        return False\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if matrix is square\n    if len(matrix) != len(matrix[0]):\n        return False\n    row_sums = [sum(row) for row in matrix]\n    col_sums = [sum(column) for column in zip(*matrix)]\n    diagonal_sum1 = sum(matrix[i][i] for i in range(len(matrix)))\n    diagonal_sum2 = sum(matrix[i][-i - 1] for i in range(len(matrix)))\n    return all(sum_val == row_sums[0] for sum_val in row_sums + col_sums + [diagonal_sum1, diagonal_sum2])", "matching_cluster_idx": 8}, {"solution": "def magic_square_test(square):\n    # check if square is a list of lists\n    if not all(isinstance(row, list) for row in square):\n        return False\n    # check if all rows are of same length\n    if not all(len(row) == len(square) for row in square):\n        return False\n    # check if all elements are integers\n    if not all(isinstance(element, int) for row in square for element in row):\n        return False\n    \n    # calculate sum of elements in the first row\n    reference_sum = sum(square[0])\n    \n    # check rows, columns and diagonals\n    for i in range(len(square)):\n        if sum(square[i]) != reference_sum or sum(square[j][i] for j in range(len(square))) != reference_sum or sum(square[j][j] for j in range(len(square))) != reference_sum or sum(square[j][len(square)-j-1] for j in range(len(square))) != reference_sum:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def magic_square_test(matrix):\n    # Get the length of the square matrix\n    n = len(matrix)\n\n    # Store the sum of the first row as the expected sum\n    expected_sum = sum(matrix[0])\n\n    # Check the rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n\n    # Check the columns\n    for i in range(n):\n        if sum(matrix[j][i] for j in range(n)) != expected_sum:\n            return False\n\n    # Check the diagonals\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    if sum(matrix[i][n - i - 1] for i in range(n)) != expected_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(square):\n    # Check if the square is a square\n    if len(square) != len(square[0]):\n        return False\n\n    # Calculate the sum of the first row\n    magic_constant = sum(square[0])\n\n    # Check the rows\n    for row in square:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check the columns\n    for i in range(len(square)):\n        if sum(row[i] for row in square) != magic_constant:\n            return False\n\n    # Check the diagonals\n    if sum(square[i][i] for i in range(len(square))) != magic_constant:\n        return False\n    if sum(square[i][len(square)-i-1] for i in range(len(square))) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}]}, "Mbpp/130": {"dps": 72.95964125560539, "dps_norm": 67.5, "pass@1": 78.0, "profiled": [{"solution": "def max_occurrences(lst):\n    max_freq = 0\n    max_item = None\n    for item in lst:\n        freq = lst.count(item)\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    return max_item", "matching_cluster_idx": 1}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to get the counts of each item in the list\n    count_dict = Counter(lst)\n    \n    # Use the most_common() method to get the item with maximum count\n    max_item = count_dict.most_common(1)\n\n    # Return the item, and its count\n    if max_item:\n        return max_item[0][0]\n\n    # If the list is empty, return None\n    return None", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return max(freq_dict, key=freq_dict.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    count = Counter(lst)\n    max_count = max(list(count.values()))\n    for item, freq in count.items():\n        if freq == max_count:\n            return item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    count_dict = {}\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    max_val = max(count_dict.values())\n    for key, value in count_dict.items():\n        if value == max_val:\n            return key\n    return None", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Returns the item with maximum frequency in a list.\n    \n    Parameters:\n    lst (list): a list of elements\n\n    Returns:\n    item: the item with maximum frequency\n\n    \"\"\"\n    # Initialize a dictionary to store the frequency of each item\n    frequency_dict = {}\n\n    # Count the frequency of each item\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    # Find the item with maximum frequency\n    max_freq_item = max(frequency_dict, key=frequency_dict.get)\n\n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    cnt = Counter(lst)\n    return cnt.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # Creating a dictionary to keep count of each item in the list\n    count_dict = {i: lst.count(i) for i in lst}\n\n    # Finding the item with maximum frequency\n    max_item = max(count_dict, key=count_dict.get)\n\n    # Returning the item with maximum frequency\n    return max_item", "matching_cluster_idx": 1}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    count = Counter(lst)\n    return count.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    counter = Counter(lst)\n    max_count = max(list(counter.values()))\n    for item, count in counter.items():\n        if count == max_count:\n            return item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the occurrences of each item\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n\n    # Find the item with maximum frequency\n    max_freq = max(freq_dict.values())\n    max_freq_item = [item for item, freq in freq_dict.items() if freq == max_freq]\n\n    # Return the item with maximum frequency\n    # In case of a tie, return the first item with maximum frequency\n    return max_freq_item[0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(nums):\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    max_freq = max(count_dict.values())\n    for key, value in count_dict.items():\n        if value == max_freq:\n            return key", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    return max(count_dict, key=count_dict.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    max_freq_num = max(counts, key=counts.get)\n    return max_freq_num", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create an empty dictionary\n    count_dict = {}\n    \n    # Traverse through the list and fill dictionary\n    for i in lst:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    \n    # Find maximum occurrence\n    max_freq = max(count_dict.values())\n    \n    # Find corresponding item with maximum occurrence\n    max_item = [item for item, frequency in count_dict.items() if frequency == max_freq]\n    \n    # Return first item in case of multiple items with the same highest frequency\n    return max_item[0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Use a dictionary to store the counts of each item\n    counts = {}\n    for item in lst:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    # Find the item with the maximum count\n    max_item = max(counts, key=counts.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(input_list):\n    frequency_dict = {}\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    max_frequency = max(frequency_dict.values())\n    for item, frequency in frequency_dict.items():\n        if frequency == max_frequency:\n            return item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    counts = Counter(lst)\n    max_val = max(counts.values())\n    max_keys = [k for k, v in counts.items() if v == max_val]\n    return max_keys[0] if max_keys else None", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Count the frequency of each item\n    freq_dict = dict(Counter(lst))\n    # Find the item with maximum frequency\n    max_freq = max(freq_dict.values())\n    for item, freq in freq_dict.items():\n        if freq == max_freq:\n            return item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # Use a dictionary to count the occurrence of each item in the list\n    count_dict = {i: lst.count(i) for i in lst}\n    # Return the item with maximum count\n    return max(count_dict, key=count_dict.get)", "matching_cluster_idx": 1}]}, "Mbpp/137": {"dps": null, "dps_norm": null, "pass@1": 3.0, "profiled": []}, "Mbpp/140": {"dps": 55.40372670807454, "dps_norm": 68.125, "pass@1": 95.0, "profiled": [{"solution": "def extract_singly(lst):\n    \"\"\"\n    A function that flatten a list of lists into a single set of numbers.\n    \"\"\"\n    flatten_lst = []\n    for sub_lst in lst:\n        for num in sub_lst:\n            flatten_lst.append(num)\n    return flatten_lst", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    # initialize an empty set\n    result = set()\n    # iterate over each sublist\n    for sublist in lst:\n        # iterate over each number in the sublist and add it to the set\n        for number in sublist:\n            result.add(number)\n    # return the resulting set\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(nested_list):\n    # Create an empty list\n    result = []\n    # Iterate through each tuple in the nested list\n    for tup in nested_list:\n        # Add each element of the tuple to the result list\n        result += tup\n    # Return the result list as a set\n    return set(result)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(lst):\n    result = []\n    for sublist in lst:\n        for item in sublist:\n            result.append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    output = []\n    for sublist in lst:\n        for item in sublist:\n            output.append(item)\n    return output", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    \"\"\"\n    This function takes a list of tuples and flatten it into a single set of numbers.\n    \"\"\"\n    flat_list = [item for sublist in lst for item in sublist]\n    return set(flat_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(num_list):\n    output_set = set()\n    for num_tuple in num_list:\n        output_set = output_set | set(num_tuple)\n    return output_set", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    result = []\n    for sublist in lst:\n        for item in sublist:\n            result.append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    return set(flat_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    single_list = [num for sublist in nested_list for num in sublist]\n    return set(single_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_tuples):\n    result = []\n    for tup in list_of_tuples:\n        for element in tup:\n            result.append(element)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(nested_list):\n    result = []\n    for inner_list in nested_list:\n        for item in inner_list:\n            result.append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(llist):\n    single_list = []\n    for l in llist:\n        single_list.extend(l)\n    return set(single_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(lst):\n    result = []\n    for sublist in lst:\n        for item in sublist:\n            result.append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    result = []\n    for sublist in lst:\n        for item in sublist:\n            result.append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_tuples):\n    # Initializing an empty list to store the results\n    flat_list = []\n\n    # Looping through each tuple in the input list\n    for tup in list_of_tuples:\n        # Looping through each element in the current tuple and appending it to the flat_list\n        for item in tup:\n            flat_list.append(item)\n\n    # Returning the flat_list as a set to remove duplicates and preserve order\n    return set(flat_list)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    result = []\n    for inner_list in list_of_lists:\n        for item in inner_list:\n            result.append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    \"\"\"\n    A function that takes a list of lists and returns a single set of numbers.\n    \"\"\"\n    flattened_set = set()\n    for sub_list in lst:\n        for item in sub_list:\n            flattened_set.add(item)\n    return flattened_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(lst):\n    return [item for sublist in lst for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    \"\"\"Flatten list of lists to single set of numbers.\n\n    Args:\n        lst (List[Tuple]): list of tuples to flatten\n\n    Returns:\n        Set: single set of numbers\n\n    Examples:\n        >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n        {1, 3, 4, 5, 7}\n    \"\"\"\n    return {n for sub_lst in lst for n in sub_lst}", "matching_cluster_idx": 5}]}, "Mbpp/141": {"dps": 82.38095238095238, "dps_norm": 45.625, "pass@1": 43.0, "profiled": [{"solution": "def pancake_sort(unsorted):\n    \"\"\"\n    Using pancake sorting algorithm to sort a list\n    \"\"\"\n    # Iterating over each index in the list\n    for i in range(len(unsorted), 0, -1):\n        # Finding the max number in unsorted list\n        max_idx = unsorted.index(max(unsorted[:i]))\n        # Flipping the max number to the beginning if it isn't there\n        if max_idx != i - 1:\n            # Flipping the max to its original position\n            unsorted = unsorted[:max_idx+1][::-1] + unsorted[max_idx+1:]\n            # Flipping the whole list to get the maximum number to its sorted position\n            unsorted = unsorted[:i][::-1] + unsorted[i:]\n    return unsorted", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        max_idx = 0\n        for j in range(len(lst) - i):\n            if lst[j] > lst[max_idx]:\n                max_idx = j\n        lst[max_idx], lst[-i-1] = lst[-i-1], lst[max_idx]\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(list_to_sort):\n    \"\"\"\n    Implementation of pancake sort.\n    \"\"\"\n    for cur_size in reversed(range(2, len(list_to_sort)+1)):\n        # Find the index of maximum element\n        max_idx = list_to_sort[:cur_size].index(max(list_to_sort[:cur_size]))\n        if max_idx != cur_size - 1:\n            # if the maximum element is not at the last position\n            if max_idx != 0:\n                # Flip the maximum element to the start\n                list_to_sort[:max_idx+1] = reversed(list_to_sort[:max_idx+1])\n            # Flip the maximum to the end, so that it is in its final sorted place\n            list_to_sort[:cur_size] = reversed(list_to_sort[:cur_size])\n    return list_to_sort", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst), 0, -1):\n        max_index = lst.index(max(lst[:i]))\n        if max_index != i - 1:\n            lst = lst[max_index::-1] + lst[max_index+1:]\n            lst = lst[i-1::-1] + lst[i:]\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(unsorted_list):\n    # Find the maximum element in the list and flip it to the front.\n    # Then flip the maximum element to the end.\n    # Do this process for all elements in the list.\n    for i in range(len(unsorted_list), 0, -1):\n        max_index = unsorted_list.index(max(unsorted_list[:i]))\n        if max_index != i-1:\n            unsorted_list = unsorted_list[:max_index+1][::-1] + unsorted_list[max_index+1:]\n            unsorted_list = unsorted_list[i-1::-1] + unsorted_list[i:]\n    return unsorted_list", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(unsorted):\n    for size in reversed(range(len(unsorted))):\n        for i in range(size):\n            if unsorted[i] > unsorted[i + 1]:\n                unsorted[i], unsorted[i + 1] = unsorted[i + 1], unsorted[i]\n    return unsorted", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Number of elements in arr\n    n = len(arr)\n\n    # Start from the last element and one by one fix arr\n    for i in range(n-1, 0, -1):\n        # Find index of the maximum element such that element at max_index is greater than i\n        max_index = i\n        for j in range(i-1, -1, -1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Swap max_index found with i\n        if max_index != i:\n            arr[i], arr[max_index] = arr[max_index], arr[i]\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(input_list):\n    for cur_size in reversed(range(len(input_list))):\n        # Flip elements to put max value at end of current size\n        max_idx = max(range(cur_size + 1), key=input_list.__getitem__)\n        if max_idx != cur_size:\n            input_list[max_idx], input_list[cur_size] = input_list[cur_size], input_list[max_idx]\n    return input_list", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(input_list):\n    for cur_size in range(len(input_list), 1, -1):\n        # Find the maximum item in the unsorted part of the list\n        max_index = input_list.index(max(input_list[:cur_size]))\n        if max_index != cur_size - 1:\n            # If the maximum item is not already in the last position, \n            # flip it to the last position and flip the whole unsorted list\n            if max_index != 0:\n                input_list[:max_index + 1] = input_list[:max_index + 1][::-1]\n            input_list[:cur_size] = input_list[:cur_size][::-1]\n    return input_list", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)-1, 0, -1):\n        max_idx = max_element(lst, i)\n        lst = flip(lst, max_idx)\n        lst = flip(lst, i)\n    return lst\ndef max_element(lst, end):\n    max_idx = 0\n    for i in range(0, end+1):\n        if lst[i] > lst[max_idx]:\n            max_idx = i\n    return max_idx\ndef flip(lst, k):\n    start = 0\n    while start < k:\n        lst[start], lst[k] = lst[k], lst[start]\n        start += 1\n        k -= 1\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    # Function to implement flip operation\n    def flip(arr, k):\n        start = 0\n        while start < k:\n            arr[start], arr[k] = arr[k], arr[start]\n            start += 1\n            k -= 1\n\n    # Function to find maximum element in unsorted array\n    def max_index(arr, n):\n        max_idx = 0\n        for i in range(1, n):\n            if arr[i] > arr[max_idx]:\n                max_idx = i\n        return max_idx\n\n    # Function to perform pancake sort\n    def pancake_sort(arr):\n        n = len(arr)\n        for i in range(n, 0, -1):\n            # Find index of maximum element in unsorted array\n            max_idx = max_index(arr, i)\n            # Flip the maximum element to the beginning\n            flip(arr, max_idx)\n            # Flip the maximum element to its correct position\n            flip(arr, i - 1)\n        return arr\n\n    return pancake_sort(lst)", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst), 0, -1):\n        # Index of the maximum element in the unsorted part of the list\n        max_idx = lst.index(max(lst[:i]))\n        if max_idx != i - 1:\n            # Flip the maximum element to the leftmost position\n            lst = lst[:max_idx+1][::-1] + lst[max_idx+1:]\n            # Flip the maximum element to its correct position\n            lst = lst[:i][::-1] + lst[i:]\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    def flip(lst, k):\n        \"\"\"Flip the first k elements in the list\"\"\"\n        lst[:k] = lst[:k][::-1]\n        return lst\n\n    n = len(lst)\n    for i in range(n, 0, -1):\n        # find the maximum element index\n        max_idx = lst.index(max(lst[:i]))\n        # if it's not at the first position, flip it to the first position\n        if max_idx != 0:\n            lst = flip(lst, max_idx + 1)\n        # then, flip it to its correct position\n        lst = flip(lst, i)\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    n = len(lst)\n    \n    for i in range(n):\n        # Find the index of the maximum element from 0 to n-i\n        max_index = max_element(lst, 0, n - i)\n        \n        # Move the maximum element to the end\n        lst = flip(lst, max_index)\n        \n        # Move the maximum element to its correct position\n        lst = flip(lst, n - i - 1)\n    \n    return lst\ndef max_element(lst, start, end):\n    max_index = start\n    for i in range(start, end):\n        if lst[i] > lst[max_index]:\n            max_index = i\n    return max_index\ndef flip(lst, end):\n    start = 0\n    while start < end:\n        lst[start], lst[end] = lst[end], lst[start]\n        start += 1\n        end -= 1\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(list_to_sort):\n    \"\"\"\n    Pancake sorting algorithm for sorting a list.\n    Flips items at the max index repeatedly to get the max value to the front.\n    \"\"\"\n    for unsorted_portion in range(len(list_to_sort), 0, -1):\n        max_index = list_to_sort[:unsorted_portion].index(max(list_to_sort[:unsorted_portion]))\n\n        # If the maximum value is not at the front, flip it to the front\n        if max_index != (unsorted_portion - 1):\n            # Flip to move max value to the front\n            list_to_sort = list_to_sort[:max_index+1][::-1] + list_to_sort[max_index+1:]\n            # Flip to move the max value to the end of the sorted section\n            list_to_sort = list_to_sort[:unsorted_portion][::-1] + list_to_sort[unsorted_portion:]\n\n    return list_to_sort", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst), 1, -1):\n        max_idx = lst.index(max(lst[0:i]))\n        if max_idx != i - 1:\n            if max_idx != 0:\n                lst[:max_idx+1] = lst[0:max_idx+1][::-1]\n            lst[0:i] = lst[0:i][::-1]\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(unsorted):\n    for i in range(len(unsorted), 0, -1):\n        # Find the index of the maximum element from the unsorted part of the list\n        max_idx = unsorted.index(max(unsorted[:i]))\n        # Flip the maximum element to the start of the unsorted part of the list\n        unsorted[:max_idx + 1] = reversed(unsorted[:max_idx + 1])\n        # Flip the maximum element to its correct position\n        unsorted[:i] = reversed(unsorted[:i])\n    return unsorted", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    \"\"\"\n    A function to sort a list of elements using the pancake sort method.\n    \"\"\"\n\n    # Get the length of the list.\n    n = len(lst)\n\n    # Start from the last element and iterate through the list backwards.\n    for cur_size in range(n, 0, -1):\n\n        # Find the index of the maximum element in the unsorted part of the list.\n        max_idx = lst.index(max(lst[:cur_size]))\n\n        # If the maximum element is not at the correct position, flip elements to move it to the correct position.\n        if max_idx != cur_size - 1:\n            lst = lst[:max_idx+1][::-1] + lst[max_idx+1:]\n            lst = lst[:cur_size][::-1] + lst[cur_size:]\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"Flip the first k elements in the list.\"\"\"\n    i = 0\n    while i < k / 2:\n        arr[i], arr[k-i-1] = arr[k-i-1], arr[i]\n        i += 1\n    return arr\ndef find_max_index(arr, end):\n    \"\"\"Find index of the maximum number in the list.\"\"\"\n    max_index = 0\n    for i in range(0, end):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\ndef pancake_sort(arr):\n    \"\"\"Sort the list using pancake sort algorithm.\"\"\"\n    cur_size = len(arr)\n    while cur_size > 0:\n        max_index = find_max_index(arr, cur_size)\n        if max_index != cur_size-1:\n            # flip the max number to the beginning\n            arr = flip(arr, max_index+1)\n            # flip the max number to the end\n            arr = flip(arr, cur_size)\n        cur_size -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(list_to_sort):\n    for i in range(len(list_to_sort), 0, -1):\n        max_index = list_to_sort.index(max(list_to_sort[:i]))\n        if max_index != i - 1:\n            if max_index != 0:\n                list_to_sort[:max_index + 1] = reversed(list_to_sort[:max_index + 1])\n            list_to_sort[:i] = reversed(list_to_sort[:i])\n    return list_to_sort", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 32.0, "profiled": [{"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    even_count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:  # The ^ operator is the xor operator\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    # Initialize count to 0\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # Check XOR of the integers is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:  # if xor is even\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    \"\"\"This function finds the count of pairs of integers in a list that xor to an even number.\"\"\"\n    even_count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            # perform xor operation and check if result is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    even_count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:  # The XOR operation is performed with ^, and the modulus operation checks if the result is even\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:  # xor operation\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    even_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 93.0, "profiled": [{"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    if start < 0 or end > len(lst):\n        raise ValueError('The start or end index is out of the list range')\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    if not 0 <= start < len(lst) or not 0 <= end < len(lst):\n        return \"Invalid indices\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    return sum(lst[start_index:end_index + 1])\nlst = [2,1,5,6,8,3,4,9,10,11,8,12]", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start_index, end_index):\n    return sum(num_list[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 79.96124031007751, "dps_norm": 56.42857142857142, "pass@1": 88.0, "profiled": [{"solution": "def odd_values_string(s):\n    \"\"\"Remove characters with odd index values from a given string.\"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(input_string):\n    output_string = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            output_string += input_string[i]\n    return output_string", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    output_string = ''\n    for i in range(0, len(input_string), 2):\n        output_string += input_string[i]\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def odd_values_string(input_str):\n    # initialize an empty string to hold the characters with even index\n    even_chars = \"\"\n\n    # iterate over each character in the input_str\n    for i in range(len(input_str)):\n        # if the index of the character is even\n        if i % 2 == 0:\n            # add it to the string of even characters\n            even_chars += input_str[i]\n\n    return even_chars", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    # Starts with an empty string for the output\n    output_string = \"\"\n    # Iterates over the string\n    for i in range(len(input_string)):\n        # Only adds the character to the output_string if its index is even\n        if i % 2 == 0:\n            output_string += input_string[i]\n    return output_string", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # use list comprehension to form a new string with characters at even indices\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(input_string):\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:  # If the index is even\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters with odd index values from a given string.\n\n    Parameters:\n    s (str): input string\n\n    Returns:\n    str: string with characters with odd index values removed\n\n    \"\"\"\n    # Using list comprehension to get even index characters\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    This function removes characters at odd index from the given string and returns the new string.\n    \"\"\"\n    new_string = input_string[::2]\n    return new_string", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    This function removes characters with odd indices from a given string.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = ''\n\n    # Iterate over each index in the string\n    for i in range(len(s)):\n        # If the index is even (0-based), append the character to the result\n        if i % 2 == 0:\n            result += s[i]\n\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Start from the index 0, and take every second character in the string\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Function to remove characters with odd index values from a given string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    return input_string[::2]", "matching_cluster_idx": 5}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replace_char):\n    return input_string.replace(\" \", replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, char):\n    return text.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    return s.replace(\" \", ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_str, char):\n    return input_str.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(str, char):\n    return str.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace blank spaces in the string with the character\n    s = s.replace(' ', char)\n    return s", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/240": {"dps": 78.29268292682927, "dps_norm": 87.22222222222221, "pass@1": 92.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # replace the last element of list1 with list2\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # remove the last element in the first list\n    list1 = list1[:-1]\n    # append the second list to the first\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of the first list with elements of the second list\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The list to replace the last element of list1 with.\n\n    Returns:\n    list: The modified list1 where the last element is replaced with list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(l1, l2):\n    l1[-1:] = l2\n    return l1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replaces the last element of list1 with the elements of list2\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    This function takes in two lists and replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    # Replace the last element of lst1 with lst2\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with elements of the second list.\n    \"\"\"\n    # Replace last element of the first list with elements of second list\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of the first list with the second list\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}]}, "Mbpp/251": {"dps": 88.70689655172414, "dps_norm": 77.77777777777777, "pass@1": 72.0, "profiled": [{"solution": "def insert_element(list_, element):\n    result = []\n    for item in list_:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, el):\n    result = []\n    for item in lst:\n        result += [el, item]\n    return result", "matching_cluster_idx": 7}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.extend([element, i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elm):\n    result = []\n    for item in lst:\n        result.extend([elm, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elm):\n    result = []\n    for i in lst:\n        result += [elm, i]\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elm):\n    new_list = []\n    for item in lst:\n        new_list.append(elm)\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.extend([elem, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    new_lst = []\n    for item in lst:\n        new_lst.extend([element, item])\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, el):\n    result = []\n    for item in lst:\n        result += [el, item]\n    return result", "matching_cluster_idx": 7}, {"solution": "def insert_element(lst, elem):\n    # The list comprehension goes through the list lst, inserts elem before each element and returns the result\n    return [item for sublist in [[elem, item] for item in lst] for item in sublist]", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.extend([element, i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(list, element):\n    result = []\n    for item in list:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.extend([elem, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for i in lst:\n        result += [elem, i]\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for i in lst:\n        result.extend([elem, i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, el):\n    result = []\n    for item in lst:\n        result.extend([el, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, el):\n    result = []\n    for i in lst:\n        result.extend([el, i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.extend([element, i])\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 62.294520547945204, "dps_norm": 58.8235294117647, "pass@1": 84.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    if n<2:\n        return 0\n    primes = [True] * n\n    p = 2\n    while p * p <= n:\n        if primes[p]:\n            for i in range(p * p, n, p):\n                primes[i] = False\n        p += 1\n    return sum(primes) - 2  # subtract 2 because 0 and 1 are not considered prime numbers", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    # function to check if a number is prime\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(num):\n    if num < 2:\n        return 0\n\n    primes = [True] * num\n    primes[0] = primes[1] = False\n    for i, is_prime in enumerate(primes):\n        if is_prime:\n            for n in range(i*i, num, i):\n                primes[n] = False\n\n    return sum(primes)", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n):\n    # Initialize an empty list to store prime numbers\n    primes = []\n    # Loop through numbers from 2 up to n\n    for i in range(2, n):\n        # Check if the current number is prime\n        if all(i % p > 0 for p in primes):\n            primes.append(i)\n    # Return the length of the prime numbers\n    return len(primes)", "matching_cluster_idx": 3}, {"solution": "def count_Primes_nums(num):\n    prime_numbers = []\n    for potential_prime in range(2, num):\n        is_prime = True\n        for divisor in range(2, potential_prime):\n            if potential_prime % divisor == 0:\n                is_prime = False\n        if is_prime:\n            prime_numbers.append(potential_prime)\n    return len(prime_numbers)", "matching_cluster_idx": -1}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    primes = [True] * n\n    p = 2\n    while p * p <= n:\n        if primes[p] is True:\n            for i in range(p * p, n, p):\n                primes[i] = False\n        p += 1\n    primes[0] = False\n    primes[1] = False\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def is_prime(num):\n    \"\"\"\n    Check if a number is prime.\n    \"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"\n    Count the number of prime numbers less than a given non-negative number.\n    \"\"\"\n    count = 0\n    for i in range(num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    else:\n        primes = [True for _ in range(n)]\n        p = 2\n        while p * p <= n:\n            if primes[p]:\n                for i in range(p * p, n, p):\n                    primes[i] = False\n            p += 1\n        return sum(primes) - 2  # subtract 2 to exclude 0 and 1", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n):\n    if n < 2:  # no prime numbers less than 2\n        return 0\n\n    sieve = [1] * n\n    sieve[0] = 0  # 0 and 1 are not prime numbers\n    sieve[1] = 0  # 1 is not a prime number\n\n    # Sieve of Eratosthenes algorithm\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            for j in range(i*i, n, i):\n                sieve[j] = 0\n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, num):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    count = 0\n    for i in range(num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    return sum(is_prime(i) for i in range(n))", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize count of prime numbers\n    count = 0\n    for num in range(2, n):\n        # Check if the number is prime by iterating through all possible factors\n        for i in range(2, num):\n            if (num % i) == 0:  # If the number is divisible by any other number, it's not prime\n                break\n        else:  # If the number is not divisible by any other number, it's prime\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    # Initialize prime count\n    prime_count = 0\n    for num in range(2, n):\n        # All prime numbers are greater than 1\n        if num > 1:\n            for i in range(2, num):\n                # Check for factors\n                if (num % i) == 0:\n                    # If factor is found, break\n                    break\n            else:\n                # This number is prime\n                prime_count += 1\n    return prime_count", "matching_cluster_idx": 2}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    primes = [1] * n\n    primes[0] = primes[1] = 0\n    for ind, val in enumerate(primes):\n        if val == 1:\n            primes[ind*2::ind] = [0] * (((n - 1)//ind) - 1)\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    primes = [True for _ in range(n+1)]\n    p = 2\n    while p ** 2 <= n:\n        if primes[p] == True:\n            for i in range(p ** 2, n+1, p):\n                primes[i] = False\n        p += 1\n    count = 0\n    for i in range(2, n):\n        if primes[i]:\n            count += 1\n    return count", "matching_cluster_idx": 12}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    This function calculates the number of primes less than a given non-negative number.\n    \"\"\"\n    if n < 2:\n        return 0\n    primes = [True for _ in range(n)]\n    p = 2\n    while p*p <= n:\n        if primes[p] is True:\n            for i in range(p*p, n, p):\n                primes[i] = False\n        p += 1\n    return sum(primes) - 2  # Subtract 2 to exclude 0 and 1", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n\n    primes = [True for _ in range(n)]\n    p = 2\n    while p * p <= n:\n        if primes[p]:\n            for i in range(p * p, n, p):\n                primes[i] = False\n        p += 1\n    \n    return sum(primes) - 2  # subtracting 2 because the numbers 0 and 1 are not prime", "matching_cluster_idx": 13}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}]}, "Mbpp/265": {"dps": 70.93023255813954, "dps_norm": 83.33333333333333, "pass@1": 10.0, "profiled": [{"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    This function checks if all elements in a given list are unique.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in a given list are unique.\n    \"\"\"\n    # Using a set to remove duplicates and then comparing the length of the set and the original list\n    # If the lengths are the same, all elements are unique\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Check if all elements in the list are unique.\"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Function to check if all elements in a list are unique.\n    :param lst: list of elements\n    :return: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 28.205128205128204, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inversion_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(array):\n    inv_count = 0\n    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            if array[i] > array[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inversions = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inversions = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": 97.58620689655173, "dps_norm": 66.66666666666667, "pass@1": 93.0, "profiled": [{"solution": "def large_product(list1, list2, n):\n    products = [i * j for i in list1 for j in list2]\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(lst1, lst2, n):\n    # We multiply two elements from the lists and store the result in a new list\n    products = [a * b for a in lst1 for b in lst2]\n    \n    # We then sort the list in descending order\n    products.sort(reverse=True)\n\n    # We then return a slice of the list that includes only the first n elements\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i*j)\n    products.sort(reverse=True)\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    product_list = [i * j for i in list1 for j in list2]\n    product_list.sort(reverse=True)\n    return product_list[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    products = [a * b for a in list1 for b in list2]\n    products.sort(reverse=True)\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n    products.sort(reverse=True)\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i*j)\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    product_list = [(x*y) for x in list1 for y in list2]\n    product_list.sort(reverse=True)\n    return product_list[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # creating a new list to store the products\n    products = []\n    \n    # iterating over each element of list1 and list2\n    for i in list1:\n        for j in list2:\n            # multiplying each element and appending to the products list\n            products.append(i*j)\n    \n    # sorting the products in descending order\n    products.sort(reverse=True)\n    \n    # returning the first 'num' elements from the sorted list\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i*j)\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    products = [a*b for a in list1 for b in list2]\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    # Create a list to store the products\n    products = []\n    \n    # Iterate through each item in list1\n    for i in list1:\n        # Iterate through each item in list2\n        for j in list2:\n            # Append the product of i and j to the products list\n            products.append(i*j)\n    \n    # Sort the products list in descending order\n    products.sort(reverse=True)\n    \n    # Return the first k items from the products list\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all products\n    products = [(x*y) for x in list1 for y in list2]\n    # Sort the products in descending order\n    products.sort(reverse=True)\n    # Return the first n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    products = [a * b for a in list1 for b in list2]\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    product_list = [i*j for i in list1 for j in list2]\n    product_list.sort(reverse=True)\n    return product_list[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    product_list = [(x*y) for x in list1 for y in list2]\n    product_list.sort(reverse=True)\n    return product_list[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(lst1, lst2, k):\n    combined = [(i*j) for i in lst1 for j in lst2]\n    combined.sort(reverse=True)\n    return combined[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i*j)\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Multiply each element in list1 with each element in list2\n    product_list = [i * j for i in list1 for j in list2]\n    \n    # Sort the product_list in descending order\n    product_list.sort(reverse=True)\n\n    # Return the specified number of largest products\n    return product_list[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(lst1, lst2, n):\n    combined_lst = [(x * y) for x in lst1 for y in lst2]\n    combined_lst.sort(reverse=True)\n    return combined_lst[:n]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 74.71830985915493, "dps_norm": 80.38461538461539, "pass@1": 32.0, "profiled": [{"solution": "def get_max_sum(n):\n    if n <= 1:\n        return n\n\n    # Memoization to store the maximum sum that can be obtained using n\n    max_sum_table = [0]*(n+1)\n    max_sum_table[0] = 0\n    max_sum_table[1] = 1\n\n    for i in range(2, n+1):\n        max_sum_table[i] = max(max_sum_table[i//2] + max_sum_table[i//3] + max_sum_table[i//4] + max_sum_table[i//5], i)\n\n    return max_sum_table[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    # initializing cache with a base case of 0\n    cache = [0] * (n + 1)\n\n    # iterate from 1 to n\n    for i in range(1, n + 1):\n        # applying equation\n        cache[i] = max(cache[i//2] + cache[i//3] + cache[i//4] + cache[i//5], i)\n\n    # return computed result\n    return cache[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    if n<=5:\n        return n\n    else:\n        f_n_2 = get_max_sum(n//2)\n        f_n_3 = get_max_sum(n//3)\n        f_n_4 = get_max_sum(n//4)\n        f_n_5 = get_max_sum(n//5)\n        return max(f_n_2 + f_n_3 + f_n_4 + f_n_5, n)", "matching_cluster_idx": 7}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    This function calculates the maximum sum given by the equation \n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    It uses a dictionary 'memo' to store previously computed results, \n    thereby optimizing the function and reducing its time complexity.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n<1:\n        return 0\n\n    memo[n] = max(get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo), n)\n\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n <= 1:\n        return n\n    return max(n, get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5))", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    cache = {0: 0}  # Initialize cache dictionary\n    def f(n):\n        # Check if the value is already calculated before\n        if n not in cache:\n            # Calculate and store the value in the cache\n            cache[n] = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n        return cache[n]\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store the results of already computed values\n    memo = {0:0, 1:1}\n\n    def recursive(n):\n        # Check if result is already computed\n        if n not in memo:\n            # Compute the result\n            memo[n] = max(recursive(n//2) + recursive(n//3) + recursive(n//4) + recursive(n//5), n)\n        return memo[n]\n\n    return recursive(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store intermediate results\n    memo = {0:0}\n    def helper(n):\n        # If the result is already calculated, return it\n        if n in memo:\n            return memo[n]\n        # Otherwise, calculate and store the result and return it\n        else:\n            result = max(helper(n//2) + helper(n//3) + helper(n//4) + helper(n//5), n)\n            memo[n] = result\n            return result\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {0:0}  # store the calculated maximum sum\n    def f(n):\n        if n not in memo: \n            memo[n] = max((f(n//2) + f(n//3) + f(n//4) + f(n//5)), n)\n        return memo[n]\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    return max((get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5)), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = max((get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo)), n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n < 2:\n        return n\n\n    dp = [0]*(n+1)\n    dp[0] = 0\n    dp[1] = 1\n\n    for i in range(2, n+1):\n        dp[i] = max(dp[i//2] + dp[i//3] + dp[i//4] + dp[i//5], i)\n    \n    return dp[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n, computed = {0:0}):\n    if n not in computed:\n        computed[n] = max([get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5)] + [n])\n    return computed[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Creating a memo dict to cache previously computed sums\n    memo = {0:0}\n\n    def max_sum(n):\n        # If n is in the cache, return the cached sum\n        if n in memo:\n            return memo[n]\n\n        # Compute the sum using the formula and update the cache\n        memo[n] = max((max_sum(n//2) + max_sum(n//3) + max_sum(n//4) + max_sum(n//5)), n)\n        return memo[n]\n    \n    return max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n <= 1:\n        return n\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    if n <= 1:\n        return n\n\n    sums = [0] * (n+1)\n    sums[0] = 0\n    sums[1] = 1\n\n    for i in range(2, n+1):\n        sums[i] = max((sums[int(i/2)] + sums[int(i/3)] + sums[int(i/4)] + sums[int(i/5)]), i)\n    \n    return sums[n]", "matching_cluster_idx": 9}, {"solution": "def get_max_sum(n):\n    memo = dict()\n    def max_sum(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        result = max(max_sum(n//2) + max_sum(n//3) + max_sum(n//4) + max_sum(n//5), n)\n        memo[n] = result\n        return result\n    return max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n <= 1:\n        return n\n\n    # memoization dictionary\n    dp = {0:0, 1:1}\n    \n    def helper(n):\n        if n not in dp:\n            dp[n] = max(helper(n//2) + helper(n//3) + helper(n//4) + helper(n//5), n)\n        return dp[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n <= 1:\n        return n\n    else:\n        return max(n, get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5))", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    # Create a dictionary to store previously computed values\n    computed_values = {0:0, 1:1}\n    def max_sum(n):\n        # If value is already computed, return it\n        if n in computed_values:\n            return computed_values[n]\n        # If not, compute and store value then return it\n        computed_values[n] = max(max_sum(n//2) + max_sum(n//3) + max_sum(n//4) + max_sum(n//5), n)\n        return computed_values[n]\n    return max_sum(n)", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 84.9808429118774, "dps_norm": 67.5, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    count = {}\n    for char in string:\n        count[char] = count.get(char, 0) + 1\n    for char in string:\n        if count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    for i in s:\n        if s.count(i) == 1:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    # Count the occurrences of each character\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Iterate through the string to find the first non-repeating character\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    for index, character in enumerate(string):\n        if string.count(character) == 1:\n            return character\n    return None", "matching_cluster_idx": 1}, {"solution": "def first_non_repeating_character(s):\n    count = {}\n    for char in s:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    for char in s:\n        if count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    for char in string:\n        if string.count(char) == 1:\n            return char\n    return None", "matching_cluster_idx": 1}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        char_count[char] = char_count.get(char, 0) + 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    char_counts = {}\n    for char in s:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    counts = {}\n    for c in s:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n    for c in s:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Function to find the first non-repeated character in a given string.\n    \"\"\"\n    # Initialize a dictionary to store character counts\n    char_counts = {}\n\n    # Count the occurrences of each character in the string\n    for char in string:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n\n    # Iterate through the string to find the first non-repeated character\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n\n    # Return None if all characters are repeated\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    character_count = {}\n\n    # count the occurrence of each character in the string\n    for char in string:\n        if char in character_count:\n            character_count[char] += 1\n        else:\n            character_count[char] = 1\n\n    # find the first character with count of 1\n    for char in string:\n        if character_count[char] == 1:\n            return char\n\n    # return None if no such character found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    # Use a dictionary to store character counts\n    char_counts = {}\n\n    # Traverse the string to count characters\n    for char in string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Traverse the string again to find the first non-repeated character\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n\n    # If all characters are repeated, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    counts = {}\n    for c in s:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n    for c in s:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    count = {}\n    for ch in s:\n        count[ch] = count.get(ch, 0) + 1\n    for ch in s:\n        if count[ch] == 1:\n            return ch\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, elem):\n    if elem in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks if an element exists within a tuple.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, elem):\n    return elem in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, elem):\n    return elem in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, ele):\n    if ele in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Function to check whether an element exists within a tuple\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, elem):\n    return elem in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    if element in tuplex:\n        return True\n    return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, elem):\n    return elem in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if element exists in the tuple\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 85.71428571428571, "dps_norm": 87.22222222222221, "pass@1": 83.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    \"\"\"\n    This function checks whether any value in the first sequence exists in the second sequence.\n\n    Parameters:\n    sequence1 (list): A list of integers.\n    sequence2 (list): A list of integers.\n\n    Returns:\n    bool: True if any value in the first sequence exists in the second sequence; False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5],[6,7,8,9])\n    False\n    \"\"\"\n    for value in sequence1:\n        if value in sequence2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(item in seq1 for item in seq2)", "matching_cluster_idx": 8}, {"solution": "def overlapping(seq1, seq2):\n    # Check if any element of seq1 is in seq2\n    if any(elem in seq2 for elem in seq1):\n        return True\n    # Check if any element of seq2 is in seq1\n    elif any(elem in seq1 for elem in seq2):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    for item in sequence1:\n        if item in sequence2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    for i in sequence1:\n        if i in sequence2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    return bool(set(sequence1) & set(sequence2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    for element in seq1:\n        if element in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(item in seq1 for item in seq2)", "matching_cluster_idx": 8}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence.\n    \"\"\"\n    return any(value in seq2 for value in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    This function checks whether any value in the first sequence exists in the second sequence.\n\n    Parameters:\n    seq1 (list): The first sequence\n    seq2 (list): The second sequence\n\n    Returns:\n    bool: True if any value in seq1 is in seq2; False otherwise\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # iterate over each value in seq1\n    for value in seq1:\n        # check if value exists in seq2\n        if value in seq2:\n            # if exists, return True\n            return True\n    # if no match found after iterating over seq1, return False\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for value in seq1:\n        if value in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # check if there is any common element in both sequences\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    for i in sequence1:\n        if i in sequence2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Check each item in seq1 against every item in seq2\n    for item1 in seq1:\n        for item2 in seq2:\n            if item1 == item2:\n                return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 78.80658436213992, "dps_norm": 92.85714285714286, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    This function concatenates each element of the tuple into a string,\n    separating the elements by a specified delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    return \"-\".join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(str(i) for i in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter=\"-\"):\n    \"\"\"\n    Concatenate each element of tuple by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple):\n    return \"-\".join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Function to concatenate each element of tuple by the delimiter.\n\n    Parameters:\n    input_tuple (tuple): Tuple containing elements to be concatenated\n    delimiter (str, optional): Delimiter to use in concatenation. Defaults to '-'.\n\n    Returns:\n    str: Concatenated string\n    \"\"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(str(i) for i in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    return \"-\".join(str(i) for i in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tuple, delimiter=\"-\"):\n    return delimiter.join(map(str, tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tuple_in):\n    # Concatenate using the \"-\" as delimiter\n    return '-'.join(str(i) for i in tuple_in)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}]}, "Mbpp/424": {"dps": 78.53790613718412, "dps_norm": 91.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [i[-1] for i in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    return [word[-1] for word in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    result = []\n    for word in input_tuple:\n        result.append(word[-1])\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    #initialize an empty list to store the result\n    result = []\n    #iterate over the tuple\n    for word in t:\n        #append the last character of each word to the result list\n        result.append(word[-1])\n    #return the result\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    # initialize an empty list\n    result = []\n    # for each string in the tuple\n    for string in tup:\n        # if the string has more than one character (to avoid IndexErrors)\n        if len(string) > 1:\n            # append the last character to the result\n            result.append(string[-1])\n        # if the string has only one character, append it to the result\n        else:\n            result.append(string)\n    # return the final result\n    return result", "matching_cluster_idx": 2}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    \"\"\"Extract the last index element of each string in a tuple.\"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [i[-1] for i in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    result = []\n    for string in input_tuple:\n        result.append(string[-1])\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [i[-1] for i in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    return [word[-1] for word in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(lst, element):\n    # Initialize count\n    count = 0\n    # Iterate over sublists\n    for sublist in lst:\n        # If element in sublist, increment count\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, element):\n    return sum(1 for sublist in main_list if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    This function counts the number of sublists that contain the specified element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    return sum(1 for sublist in lst if elem in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    count = 0\n    for sub_list in lst:\n        if elem in sub_list:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(input_list, element):\n    count = 0\n    for sublist in input_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, element):\n    # Initialize a count variable to 0\n    count = 0\n    \n    # Loop through each sublist in the main list\n    for sublist in main_list:\n        # If the element is in the sublist, increment the count\n        if element in sublist:\n            count += 1\n            \n    # Return the count\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, element):\n    count = 0\n    for sub_list in main_list:\n        if element in sub_list:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, el):\n    return sum(1 for sublist in lst if el in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elm):\n    \"\"\"\n    Function to count the number of sublists containing a particular element\n\n    Parameters:\n    lst (list): list of lists\n    elm (any type): element to be counted\n\n    Returns:\n    int: number of occurrences of `elm` in `lst`\n    \"\"\"\n\n    return sum(elm in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublist_list, element):\n    count = 0\n    for sublist in sublist_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, el):\n    count = 0\n    for sublist in lst:\n        if el in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(input_list, element):\n    count = 0\n    for sublist in input_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elm):\n    count = 0\n    for sub_lst in lst:\n        if elm in sub_lst:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, el):\n    count = 0\n    for sublist in lst:\n        if el in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.29752066115702, "dps_norm": 55.55555555555556, "pass@1": 95.0, "profiled": [{"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n//2\n\n    # Repeat the sorting process until gap becomes 1\n    while gap > 0:\n\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements a[0..gap-1] are already in gapped order keep adding one more element\n        # until the entire array is gap sorted\n        for i in range(gap,n):\n\n            # add a[i] to the elements that have been gap sorted save a[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for 'temp' is found\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    # Start with a big gap, then reduce the gap\n    n = len(array)\n    gap = n//2\n\n    # Do a gapped  insertion sort for this gap size.The first gap elements \n    # a[0..gap-1] are already in gapped order keep adding one more element \n    # until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap,n):\n            # add a[i] to the elements that have been gap sorted \n            # save a[i] in temp and make a hole at position i\n            temp = array[i]\n            j = i\n            # shift earlier gap-sorted elements up until the correct location for temp is found\n            while  j >= gap and array[j-gap] > temp:\n                array[j] = array[j-gap]\n                j -= gap\n            # put temp (the original a[i]) in its correct location\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    gap = len(array) // 2\n    while gap > 0:\n        for i in range(gap, len(array)):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    length = len(array)\n    gap = length // 2\n    while gap > 0:\n        for i in range(gap, length):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j = j-gap\n            array[j] = temp\n        gap = gap // 2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    gap = len(array) // 2\n    while gap > 0:\n        for i in range(gap, len(array)):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    n = len(array)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n            while  j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    while gap > 0:\n\n        for i in range(gap, n):\n\n            # add a[i] to the elements that have been gap sorted\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for 'temp' is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    n = len(array)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    # Start with a big gap, then reduce the gap\n    n = len(array)\n    gap = n//2\n\n    # Shell Sort\n    while gap > 0:\n        for i in range(gap,n):\n            temp = array[i]\n            j = i\n            while  j >= gap and array[j-gap] > temp:\n                array[j] = array[j-gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    length = len(array)\n    gap = length // 2\n\n    while gap > 0:\n        for i in range(gap, length):\n            temp = array[i]\n            j = i\n\n            # Compare elements and swap\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n\n            array[j] = temp\n        gap //= 2\n\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    # Start with a big gap, then reduce the gap\n    n = len(array)\n    gap = n//2\n\n    # Loop over the array while the gap is greater than zero\n    while gap > 0:\n        # Do a gapped 'insertion sort' for this gap size\n        # The first gap elements a[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap,n):\n            # add a[i] to the elements that have been gap sorted \n            temp = array[i]\n            j = i\n            # shift earlier gap-sorted elements up until the correct \n            # location for 'a[i]' is found\n            while  j >= gap and array[j-gap] > temp:\n                array[j] = array[j-gap]\n                j -= gap\n            # put temp (the original a[i]) in its correct location\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    gap = len(array) // 2\n    while gap > 0:\n        for i in range(gap, len(array)):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": null, "dps_norm": null, "pass@1": 7.0, "profiled": []}, "Mbpp/437": {"dps": null, "dps_norm": null, "pass@1": 8.0, "profiled": []}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 71.0, "profiled": [{"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for i in lst:\n        count += tup.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    count = 0\n    for i in list_input:\n        count += tuple_input.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    # Initialize count to 0\n    count = 0\n    # For each element in the list\n    for i in list_input:\n        # Count the number of times the element is in the tuple\n        count += tuple_input.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    occurrence_count = 0\n    for element in list_input:\n        occurrence_count += tuple_input.count(element)\n    return occurrence_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    count = 0\n    for elem in input_list:\n        count += input_tuple.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    return sum(tup.count(item) for item in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple1, list1):\n    count = 0\n    for element in list1:\n        count += tuple1.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_var, list_var):\n    \"\"\"\n    This function counts the occurrence of elements of list in a tuple\n    \"\"\"\n    count = 0\n    for elem in list_var:\n        count += tuple_var.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    return sum(tpl.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    count = 0\n    for i in lst:\n        count += tpl.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(my_tuple, my_list):\n    count = 0\n    for elem in my_list:\n        count += my_tuple.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    # Initialize counter\n    counter = 0\n    # Iterate over list elements\n    for elem in list_input:\n        # Count the occurrence of the element in the tuple\n        counter += tuple_input.count(elem)\n    return counter", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 97.0, "profiled": [{"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(str1):\n    return str1.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Replace all whitespaces with empty string\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    return input_str.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    This function removes all whitespaces from the input string.\n    :param input_string: The string from which the whitespaces should be removed.\n    :return: The string without whitespaces.\n    \"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Replace all whitespaces with empty string\n    no_whitespace_string = input_string.replace(' ', '')\n    return no_whitespace_string", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Remove all whitespaces from the string.\n    # We use the replace() function, which is used to replace a specified phrase with another.\n    # In this case, we replace all whitespace characters with no character.\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Returns a new list where each string in the given list is reversed.\n    \n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    This function takes a list of strings and returns a new list where each string has been reversed.\n    \"\"\"\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    Returns a new list where every string in the given list is reversed.\n    \"\"\"\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    This function takes a list of strings as input and returns a new list with all the strings reversed.\n    \"\"\"\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    This function reverses each string in a given list.\n    :param input_list: a list of strings\n    :return: a list of reversed strings\n    \"\"\"\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    reversed_list = [s[::-1] for s in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 58.46153846153846, "dps_norm": 84.0, "pass@1": 81.0, "profiled": [{"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    result = [sub[0] for sub in lst]\n    return result", "matching_cluster_idx": 4}, {"solution": "def Extract(input_list):\n    return [sublist[0] for sublist in input_list]", "matching_cluster_idx": 4}, {"solution": "def Extract(input_list):\n    return [sublist[0] for sublist in input_list]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(s, old, new):\n    \"\"\"\n    This function replaces all occurrences of a character in a string with another character.\n\n    Args:\n    s (str): The input string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n\n    Returns:\n    str: The modified string after replacing all occurrences of old character with new character.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, old_char, new_char):\n    # Replaces all occurrences of 'old_char' with 'new_char' in 'input_str'\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old_char: str, new_char: str) -> str:\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(str_input, char_to_replace, new_char):\n    return str_input.replace(char_to_replace, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    This function takes a string, a character to be replaced, and a replacement character, and replaces the old character with the new character in the input string.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, target_char, replacement_char):\n    return input_string.replace(target_char, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n    return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, old_char, new_char):\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, to_replace, replace_with):\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n    \"\"\"\n    return string.replace(to_replace, replace_with)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, target, replacement):\n    return s.replace(target, replacement)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Function to replace characters in a string.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, old_char, new_char):\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, target, replacement):\n    return s.replace(target, replacement)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, c1, c2):\n    return s.replace(c1, c2)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, o, n):\n    return s.replace(o, n)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 86.94630872483222, "dps_norm": 91.66666666666667, "pass@1": 98.0, "profiled": [{"solution": "def big_sum(arr):\n    \"\"\"\n    This function takes an array of integers as an argument,\n    finds the largest and smallest values in the array,\n    and returns the sum of these two values.\n    \"\"\"\n    if len(arr)==0: # if the list is empty\n        return 0\n    else:\n        return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # checking if arr is empty\n    if not arr:\n        return None\n\n    # checking if arr has only 1 element\n    if len(arr) == 1:\n        return arr[0]\n\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function accepts a list of integers, finds the largest and the smallest values in the list, \n    and returns the sum of these two values.\n    \"\"\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function finds the sum of the largest and smallest value in a given array.\n    \"\"\"\n    # Check if array is not empty\n    if arr:\n        return max(arr) + min(arr)\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if arr:\n        return max(arr) + min(arr)\n    else:\n        return 0", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # find minimum and maximum values in the array\n    min_val = min(arr)\n    max_val = max(arr)\n    # return the sum of these values\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    return max(array) + min(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    The function takes an array as input and returns the sum of the largest and smallest value in the array.\n    \"\"\"\n    # Sort the array in ascending order\n    array.sort()\n    # The sum of the smallest and largest values is calculated and returned\n    return array[0] + array[-1]", "matching_cluster_idx": 1}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    This function takes in an array of integers and returns the sum of the largest and smallest integer.\n    \"\"\"\n    # Sort the array in ascending order\n    array.sort()\n\n    # Calculate the sum of the largest and smallest values\n    big_sum_result = array[-1] + array[0]\n    \n    return big_sum_result", "matching_cluster_idx": 1}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"Return the sum of the largest and smallest values in an array.\"\"\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # check if the array is not empty\n    if arr:\n        return max(arr) + min(arr)\n    else:\n        return 0", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function takes an array of numbers as input, finds the largest and smallest numbers in the array\n    and returns their sum.\n\n    Parameters:\n    arr (List[int]): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest numbers in the array.\n    \"\"\"\n\n    # If the list is empty, return 0\n    if len(arr) == 0:\n        return 0\n\n    # Initialize the largest and smallest numbers as the first number in the list\n    smallest = largest = arr[0]\n\n    # Iterate over the list\n    for num in arr:\n\n        # If the current number is smaller than the smallest, update the smallest\n        if num < smallest:\n            smallest = num\n\n        # If the current number is larger than the largest, update the largest\n        if num > largest:\n            largest = num\n\n    # Return the sum of the smallest and largest numbers\n    return smallest + largest", "matching_cluster_idx": 3}, {"solution": "def big_sum(lst):\n    \"\"\"Return the sum of the largest and smallest value in a given list.\"\"\"\n    if len(lst)>0:\n        return max(lst) + min(lst)\n    else:\n        return \"List is empty\"", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) == 0:\n        return 0\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    # We assume that the list is not empty\n    # Otherwise, we should add a check for empty lists\n    return max(nums) + min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": null, "dps_norm": null, "pass@1": 8.0, "profiled": []}, "Mbpp/563": {"dps": 85.24590163934427, "dps_norm": 81.81818181818181, "pass@1": 99.0, "profiled": [{"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    return re.findall(r'\"(.*?)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(str):\n    # Find all substrings in string that are enclosed in quotes\n    quotes = re.findall(r'\"([^\"]*)\"', str)\n    return quotes", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    import re\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(string):\n    import re\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks in a string\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 56.84624017957352, "dps_norm": 54.54545454545455, "pass@1": 11.0, "profiled": [{"solution": "def two_unique_nums(num_list):\n    result = []\n    for num in num_list:\n        if num_list.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(lst):\n    return [item for item in lst if lst.count(item) == 1]", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(lst):\n    # Count the occurrences of each element in the list\n    num_dict = {num: lst.count(num) for num in lst}\n    # Only keep elements which appear exactly once (i.e., they are unique)\n    unique_nums = [num for num, count in num_dict.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(nums):\n    unique_nums = set(nums)\n    return [num for num in nums if nums.count(num) == 1]", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(nums):\n    # create a dictionary\n    num_dict = {}\n    # iterate through each number\n    for num in nums:\n        # if the number is already in the dictionary, increment its count\n        # otherwise, set its count to 1\n        num_dict[num] = num_dict.get(num, 0) + 1\n    \n    # create a list of numbers that appear exactly once\n    unique_nums = [num for num, count in num_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(num_list):\n    unique_nums = []\n    for num in num_list:\n        if num_list.count(num) == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(num_list):\n    \"\"\"\n    This function receives a list of numbers and removes duplicate numbers.\n    \"\"\"\n\n    # Make an empty dictionary to store numbers\n    num_dict = {}\n\n    # Go through each number in the list\n    for num in num_list:\n\n        # If the number is already in the dictionary, increment its count\n        if num in num_dict:\n            num_dict[num] += 1\n\n        # If the number is not in the dictionary, add it with a count of 1\n        else:\n            num_dict[num] = 1\n\n    # Make a new list to store unique numbers\n    unique_num_list = []\n\n    # Go through each item in the dictionary\n    for item in num_dict.items():\n\n        # If the count of the number is 1, add the number to the list\n        if item[1] == 1:\n            unique_num_list.append(item[0])\n\n    return unique_num_list", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    return [num for num, count in counts.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(num_list):\n    # Create a dictionary to store unique numbers\n    unique_dict = {}\n\n    # Iterate over the list\n    for num in num_list:\n        # If the number is already in the dictionary, add it to a list\n        if num in unique_dict:\n            unique_dict[num].append(num)\n        # If not, add it to the dictionary\n        else:\n            unique_dict[num] = [num]\n\n    # Collect the keys with only one occurrence\n    non_duplicates = [key for key, value in unique_dict.items() if len(value) == 1]\n\n    return non_duplicates", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(lst):\n    num_counts = {}\n\n    for num in lst:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n\n    unique_nums = []\n    for num, count in num_counts.items():\n        if count == 1:\n            unique_nums.append(num)\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    unique = []\n    duplicates = []\n    for num in nums:\n        if num not in unique:\n            unique.append(num)\n        elif num not in duplicates:\n            duplicates.append(num)\n    return [num for num in nums if num not in duplicates]", "matching_cluster_idx": 2}]}, "Mbpp/578": {"dps": 80.76190476190476, "dps_norm": 69.0909090909091, "pass@1": 99.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    This function takes three lists of equal length and returns a new list which is the interleaving of the three input lists.\n    \"\"\"\n    # Ensure all lists have same length\n    assert len(list1) == len(list2) == len(list3)\n\n    # Interleave lists\n    interleaved_list = [val for pair in zip(list1, list2, list3) for val in pair]\n\n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = [val for pair in zip(list1, list2, list3) for val in pair]\n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(a, b, c):\n    return [val for pair in zip(a, b, c) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    result = []\n    for i in range(len(lst1)):\n        result.extend([lst1[i], lst2[i], lst3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    return [val for pair in zip(lst1, lst2, lst3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # initialize an empty list to store the result\n    result = []\n    \n    # iterate over the indices of the lists\n    for i in range(len(list1)):\n        # append each element of the three lists to the result list\n        result.extend([list1[i], list2[i], list3[i]])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(l1, l2, l3):\n    interleaved = []\n    for i in range(len(l1)):\n        interleaved.append(l1[i])\n        interleaved.append(l2[i])\n        interleaved.append(l3[i])\n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(a, b, c):\n    return [val for pair in zip(a, b, c) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [j for i in zip(list1, list2, list3) for j in i]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    interleaved = [None]*(len(lst1)*3)\n    for i in range(len(lst1)):\n        interleaved[i*3] = lst1[i]\n        interleaved[i*3+1] = lst2[i]\n        interleaved[i*3+2] = lst3[i]\n    return interleaved", "matching_cluster_idx": 5}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(l1, l2, l3):\n    return [val for pair in zip(l1, l2, l3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(l1, l2, l3):\n    return [val for pair in zip(l1, l2, l3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.extend([list1[i], list2[i], list3[i]])\n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 96.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # split the array at the nth element and add the first part to the end\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    return input_list[n:] + input_list[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    # Split the list at the nth element\n    first_half = lst[:n]\n    second_half = lst[n:]\n\n    # Add the first part to the end\n    return second_half + first_half", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    # Split the list at the nth element and add the first part to the end\n    return input_list[n:] + input_list[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_array, n):\n    # Splitting the list at nth element and adding first part to the end\n    split_list = input_array[n:] + input_array[:n]\n    return split_list", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n < len(arr):\n        arr = arr[n:] + arr[:n]\n    return arr", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list at the nth element\n    # Then combine the two parts and add the first part to the end\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    This function splits a given list at the nth element and adds the first part to the end.\n    \n    Args:\n    lst (list): The list to be split and rearranged.\n    n (int): The index at which the list should be split.\n\n    Returns:\n    list: The rearranged list.\n    \"\"\"\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    return input_list[n:] + input_list[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list at nth position and add the first part to the end\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # split the array at the nth element and add the first part to the end\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    if len(input_list) > n:\n        return input_list[n:] + input_list[:n]\n    return input_list", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits a list at the nth element and moves the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The split list with the first part moved to the end.\n    \"\"\"\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    # Split the list at the nth element and add the first part to the end\n    return input_list[n:] + input_list[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    This function converts a list into a tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    This function converts a list to a tuple\n\n    Arguments:\n    lst -- the list to be converted\n\n    Returns:\n    a tuple which is the conversion result\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 97.13302752293578, "dps_norm": 99.16666666666667, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(lst):\n    if lst:  # checking if the list is not empty\n        return max(lst) - min(lst)\n    return 0", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if lst: # checking if list is not empty\n        return max(lst) - min(lst)\n    else:\n        return \"List is empty\"", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    This function calculates the difference between the largest and smallest values in a given list.\n    \n    :param lst: A list of integers.\n    :return: An integer representing the difference between the largest and smallest values.\n    \"\"\"\n    if not lst:\n        return 0\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if nums:\n        return max(nums) - min(nums)\n    else:\n        return 0", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if len(nums) < 2:\n        return 0\n    else:\n        return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0\n    max_val = max(lst)\n    min_val = min(lst)\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    # Check if the list is empty\n    if len(lst) == 0:\n        return 0\n    \n    min_val = lst[0]\n    max_val = lst[0]\n\n    for num in lst:\n        # Update min_val if we find a smaller number\n        if num < min_val:\n            min_val = num\n        # Update max_val if we find a larger number\n        if num > max_val:\n            max_val = num\n\n    # Return the difference between max_val and min_val\n    return max_val - min_val", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    if len(nums) < 2:\n        return 0\n    else:\n        return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if lst:  # ensure that the list is not empty\n        return max(lst) - min(lst)\n    else:\n        return \"List is empty\"", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if lst:\n        return max(lst) - min(lst)\n    else:\n        return 0", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if lst:  # ensure list is not empty\n        return max(lst) - min(lst)\n    return 0  # or raise an exception if you want to indicate an error", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": null, "dps_norm": null, "pass@1": 8.0, "profiled": []}, "Mbpp/597": {"dps": 95.07462686567165, "dps_norm": 96.25, "pass@1": 82.0, "profiled": [{"solution": "def find_kth(arr1, arr2, k):\n    return sorted(arr1 + arr2)[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Merge the given two sorted arrays and return kth element.\n    \"\"\"\n    # Merge two sorted arrays\n    arr = sorted(arr1 + arr2)\n    # Return kth element\n    return arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Function to find kth element from the given two sorted arrays.\n    \"\"\"\n    # Combine the two sorted arrays into one\n    combined = sorted(arr1 + arr2)\n\n    # Return the kth element\n    return combined[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    This function merges the two sorted lists, sorts the merged list and returns the kth element.\n    \"\"\"\n    # Merge the two lists\n    merged = nums1 + nums2\n    # Sort the merged list\n    merged.sort()\n    # Return the kth element\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    combined = sorted(arr1 + arr2)\n    return combined[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    return sorted(nums1 + nums2)[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    Given two sorted arrays, find the kth element\n    \"\"\"\n    # Merge the two sorted arrays\n    merged = sorted(nums1 + nums2)\n    \n    # Return the kth element from the merged array\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    This function is used to find the kth element from two sorted arrays.\n    \n    :param nums1: a list of sorted integers\n    :param nums2: a list of sorted integers\n    :param k: the kth element to find\n    :return: kth element from merged list of nums1 and nums2\n    \"\"\"\n    \n    # merge both arrays\n    merged = sorted(nums1 + nums2)\n\n    # check if k is out of range\n    if k > len(merged):\n        return \"k is out of range!\"\n    else:\n        return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merging two lists and sorting\n    merged = sorted(arr1 + arr2)\n    \n    # Return kth element\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from the given two sorted arrays.\n    \"\"\"\n    # merge the two arrays\n    merged = sorted(arr1 + arr2)\n\n    # check if k is out of range\n    if k > len(merged) or k < 1:\n        return None\n\n    # return kth element\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    nums1.sort()\n    nums2.sort()\n    i = j = 0\n    curr = prev = None\n    while i + j < k:\n        if i == len(nums1):\n            curr = nums2[j]\n            j += 1\n        elif j == len(nums2):\n            curr = nums1[i]\n            i += 1\n        elif nums1[i] < nums2[j]:\n            curr = nums1[i]\n            i += 1\n        else:\n            curr = nums2[j]\n            j += 1\n        prev = curr\n    return prev", "matching_cluster_idx": 0}, {"solution": "def find_kth(nums1, nums2, k):\n    merged = sorted(nums1 + nums2)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    # Concatenate the two lists\n    merged = sorted(nums1 + nums2)\n\n    # Return kth element from the merged list\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    merged = sorted(nums1 + nums2)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two arrays into one sorted array.\n    merged = sorted(arr1 + arr2)\n    # Check if k is out of range\n    if k > len(merged) or k <= 0:\n        return 'k is out of range.'\n    else:\n        # Return the kth element\n        return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    Function to find the kth element from the given two sorted arrays.\n    :param nums1: First sorted array\n    :param nums2: Second sorted array\n    :param k: Kth element to be found\n    :return: Kth element from the merged sorted array\n    \"\"\"\n    assert k > 0, \"K should be greater than 0\"\n    nums1.extend(nums2)\n    nums1.sort()\n    return nums1[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    Given two sorted arrays, find the kth element.\n    \"\"\"\n    # Merge the arrays\n    merged = sorted(nums1 + nums2)\n    # Return the kth element\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged_arr = sorted(arr1 + arr2)\n    return merged_arr[k-1]", "matching_cluster_idx": 3}]}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 54.0, "profiled": [{"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    words = string.split()[::-1]  \n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str):\n    return \" \".join(input_str.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    This function reverses the words in a given string separated by spaces.\n    \"\"\"\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # split the string into words\n    words = s.split()\n    # reverse the order of the words\n    words = words[::-1]\n    # join the words back into a string with a space separator\n    s = ' '.join(words)\n    return s", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    words = input_string.split()\n    reversed_words = \" \".join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # split the string by spaces and then reverse the list of words\n    words = s.split()[::-1]\n    # join the words back into a string\n    reversed_s = ' '.join(words)\n    return reversed_s", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 67.75362318840581, "dps_norm": 79.46428571428571, "pass@1": 16.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    # Ensure the index is within the bounds of the list\n    if k-1 < len(lst):\n        # Remove the k'th element\n        del lst[k-1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    if k < 1 or k > len(lst):\n        return lst\n    else:\n        return lst[:k-1] + lst[k:]", "matching_cluster_idx": 2}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    This function takes in a list and an integer k, and returns a list with the k'th element removed.\n    \"\"\"\n    del lst[k-1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    if k < 1 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    del lst[k-1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    del lst[k-1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    # Indexing in Python starts from 0, so we need to subtract 1 from k\n    if k-1 in range(len(lst)):\n        return lst[:k-1] + lst[k:]\n    else:\n        return lst", "matching_cluster_idx": 2}, {"solution": "def remove_kth_element(lst, k):\n    # The list is 0-indexed, so we subtract 1 from k\n    del lst[k-1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    # Remove the k'th element from the list\n    del lst[k-1]\n    # Return the modified list\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    if k > 0 and k <= len(lst):\n        return lst[:k-1] + lst[k:]\n    else:\n        return lst", "matching_cluster_idx": 2}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    This function takes a list and a number, 'k', and returns a new list with the k'th element removed.\n    \"\"\"\n    if k < 1 or k > len(input_list):\n        return input_list\n    else:\n        return input_list[:k - 1] + input_list[k:]", "matching_cluster_idx": 2}, {"solution": "def remove_kth_element(lst, k):\n    del lst[k-1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    # validate that k is within the list's range\n    if k-1 < len(lst):\n        # remove the k'th element using the list slicing\n        new_lst = lst[:k-1] + lst[k:]\n        return new_lst\n    else:\n        return \"Invalid k, it is out of the list's range.\"", "matching_cluster_idx": 2}, {"solution": "def remove_kth_element(input_list, k):\n    del input_list[k-1]\n    return input_list", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    This function takes a list and an integer as arguments and returns a list with the same elements, \n    but the k'th element removed.\n    \"\"\"\n    del input_list[k-1]\n    return input_list", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    del lst[k-1]  # Python lists index from 0, so we remove the (k-1)th element\n    return lst", "matching_cluster_idx": 6}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists \n    return the max of the n'th column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # get the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # return the maximum value in the n'th column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]\nn = 2", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Using list comprehension to get nth element of every row and find the max\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Using list comprehension to extract the n'th element from each list in the matrix\n    column = [row[n] for row in matrix]\n    # Returning the max value from the column list\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Function to find the maximum value in the n-th column of the matrix.\n    :param matrix: 2D list (matrix) to process.\n    :param n: Column number to look at.\n    :return: Maximum value in the n-th column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function takes in a matrix represented as a list of lists and an integer n.\n    It returns the maximum value of the n-th column in the matrix.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function returns the max of the n'th column in a matrix.\n\n    Parameters:\n    matrix (List[List[int]]): The input matrix.\n    n (int): The n'th column to find the max of.\n\n    Returns:\n    int: The maximum element in the n'th column of the matrix.\n\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 56.24999999999999, "dps_norm": 57.142857142857146, "pass@1": 14.0, "profiled": [{"solution": "def replace_spaces(s):\n    result = \"\"\n    for c in s:\n        if c == \" \":\n            result += \"_\"\n        elif c == \"_\":\n            result += \" \"\n        else:\n            result += c\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(string):\n    new_string = ''\n    for character in string:\n        if character == ' ':\n            new_string += '_'\n        elif character == '_':\n            new_string += ' '\n        else:\n            new_string += character\n    return new_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(string):\n    new_string = \"\"\n    for char in string:\n        if char == ' ':\n            new_string += '_'\n        elif char == '_':\n            new_string += ' '\n        else:\n            new_string += char\n    return new_string", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(string):\n    result = \"\"\n    for char in string:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(text):\n    result = ''\n    for char in text:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    This function receives a string and replaces all whitespaces with underscores and vice versa.\n    \"\"\"\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    if ' ' in input_string:\n        return input_string.replace(' ', '_')\n    else:\n        return input_string.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_str):\n    if \" \" in input_str:\n        return input_str.replace(\" \", \"_\")\n    else:\n        return input_str.replace(\"_\", \" \")", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    This function takes a string s and replaces all spaces with underscore(_) and vice versa.\n\n    Input:\n    s(str): Input string\n\n    Output:\n    str: Output string after replacement\n    \"\"\"\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    This function takes a string as input and returns the same string but with all spaces replaced with underscores\n    and all underscores replaced with spaces.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    This function takes a string s and replaces whitespaces with underscores \n    and vice versa in the string.\n    \"\"\"\n    new_string = ''\n    for ch in s:\n        if ch == ' ':\n            new_string += '_'\n        elif ch == '_':\n            new_string += ' '\n        else:\n            new_string += ch\n    return new_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    result = ''\n    for character in s:\n        if character == ' ':\n            result += '_'\n        elif character == '_':\n            result += ' '\n        else:\n            result += character\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    # Replace underscores with whitespaces and vice versa\n    return s.replace(' ', '_') if '_' not in s else s.replace('_', ' ')", "matching_cluster_idx": 7}]}, "Mbpp/632": {"dps": 80.48780487804878, "dps_norm": 88.57142857142857, "pass@1": 98.0, "profiled": [{"solution": "def move_zero(lst):\n    # Initializing a new empty list to hold all the non-zero elements.\n    new_lst = [i for i in lst if i!=0]\n    \n    # Fetching the length of the original list and new list.\n    orig_len = len(lst)\n    new_len = len(new_lst)\n    \n    # Extending the new list with zeroes until its length matches the original length.\n    new_lst.extend([0]*(orig_len-new_len))\n    \n    # Returning the new list.\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    for i in lst:\n        if i == 0:\n            lst.remove(i)\n            lst.append(i)\n    return lst", "matching_cluster_idx": 2}, {"solution": "def move_zero(lst):\n    return [i for i in lst if i!=0] + [i for i in lst if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Use list comprehension to separate non-zero numbers and count the zeros\n    no_zeros = [num for num in nums if num != 0]\n    count_zeros = len(nums) - len(no_zeros)\n    \n    # Append zeros to the end of the non-zero numbers list\n    no_zeros.extend([0]*count_zeros)\n    return no_zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    count = nums.count(0)\n    nums[:] = [num for num in nums if num!=0]\n    nums.extend([0]*count)\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    zero_count = lst.count(0)\n    new_list = [i for i in lst if i!=0]\n    new_list.extend([0]*zero_count)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n\n    Parameters:\n    lst (list): The list to move zeroes to the end.\n\n    Returns:\n    list: The list with all zeroes moved to the end.\n\n    Example:\n    >>> move_zero([1,0,2,0,3,4])\n    [1,2,3,4,0,0]\n    \"\"\"\n\n    # count the number of zeros in the list\n    num_zeros = lst.count(0)\n\n    # remove all zeroes from the list\n    lst = [num for num in lst if num != 0]\n\n    # extend the list with the number of zeros at the end\n    lst.extend([0]*num_zeros)\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    for i in nums:\n        if i == 0:\n            nums.remove(i)\n            nums.append(i)\n    return nums", "matching_cluster_idx": 2}, {"solution": "def move_zero(num_list):\n    for i in num_list:\n        if i == 0:\n            num_list.remove(i)\n            num_list.append(i)\n    return num_list", "matching_cluster_idx": 2}, {"solution": "def move_zero(lst):\n    # count the number of zeroes in the list\n    count = lst.count(0)\n    \n    # remove all the zeroes from the list\n    lst = [i for i in lst if i!=0]\n    \n    # extend the list with the count of zeroes\n    lst.extend([0]*count)\n    \n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Count the number of zeroes\n    count = nums.count(0)\n    # Remove zeroes from the list\n    nums = [num for num in nums if num != 0]\n    # Extend the list with number of zeroes at the end\n    nums.extend([0]*count)\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    for i in lst:\n        if i == 0:\n            lst.remove(i)\n            lst.append(i)\n    return lst", "matching_cluster_idx": 2}, {"solution": "def move_zero(lst):\n    count = lst.count(0)\n    lst = [i for i in lst if i!=0]\n    lst.extend([0]*count)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    This function takes in a list of numbers and moves all zeros to the end of the list.\n    \"\"\"\n    # count the number of zeros in the list\n    zero = nums.count(0)\n    \n    # remove all zeros from the list\n    nums = [i for i in nums if i != 0]\n    \n    # extend the list with the number of zeros found at the end\n    nums.extend([0]*zero)\n    \n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Count the number of zeros in the list\n    num_zeros = nums.count(0)\n    \n    # Create a list with the non-zero elements\n    non_zeros = [num for num in nums if num != 0]\n    \n    # Extend the non_zeros list with the number of zeros\n    non_zeros.extend([0]*num_zeros)\n    \n    return non_zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Move all zeroes to the end of a list\"\"\"\n    return [num for num in nums if num!=0] + [0]*(nums.count(0))", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    This function moves all zeroes to the end of the given list.\n    \"\"\"\n    # Initializing empty lists for non-zero and zero values\n    non_zeros = []\n    zeros = []\n\n    # Iterate over the elements in the list\n    for item in lst:\n        # If the element is zero, append it to the zeros list\n        if item == 0:\n            zeros.append(item)\n        # If the element is not zero, append it to the non_zeros list\n        else:\n            non_zeros.append(item)\n\n    # Concatenate the non_zeros list with the zeros list and return the result\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    # Remove all zeroes\n    lst = [num for num in lst if num!=0]\n    # Append zero_count number of zeroes at the end of the list\n    lst += [0] * zero_count\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeros in the given list to the end.\n    \"\"\"\n    # Count zeros in the list\n    num_zeros = lst.count(0)\n\n    # Remove all zeros from the list\n    lst = [num for num in lst if num != 0]\n\n    # Append the number of zeros to the end of the list\n    lst.extend([0]*num_zeros)\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # List comprehension that filters out 0s and concatenates them at the end\n    return [i for i in lst if i!=0] + [i for i in lst if i==0]", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 94.3089430894309, "dps_norm": 50.0, "pass@1": 19.0, "profiled": [{"solution": "def pair_xor_Sum(nums, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += nums[i] ^ nums[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    \"\"\"\n    This function calculates the sum of XOR of all pairs of numbers in the given list.\n    \"\"\"\n    # Initialize the sum to 0\n    xor_sum = 0\n\n    # Iterate over the list to find all pairs\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate the XOR of the pair and add it to the sum\n            xor_sum += lst[i] ^ lst[j]\n\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result\n    res = 0\n\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            # Do XOR and add to result\n            res = res + (arr[i] ^ arr[j])\n\n    return res", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum += lst[i] ^ lst[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    \"\"\"\n    This function finds the sum of xor of all pairs of numbers in the given list.\n    \"\"\"\n    sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum += lst[i] ^ lst[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += lst[i] ^ lst[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    # initialize sum with 0\n    total = 0\n\n    # create a for loop to iterate through lst\n    for i in range(n):\n        # create another loop to iterate through lst from i+1 to n\n        for j in range(i + 1, n):\n            # perform xor operation and add it to total\n            total += lst[i] ^ lst[j]\n    \n    # return the total sum\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += lst[i] ^ lst[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    if len(lst) < n:\n        return \"List is shorter than n\"\n    else:\n        xor_sum = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                xor_sum += lst[i] ^ lst[j]\n        return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += lst[i] ^ lst[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, length):\n    sum = 0\n    for i in range(length):\n        for j in range(i + 1, length):\n            sum += lst[i] ^ lst[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    \"\"\"\n    This function finds the sum of xor of all pairs of numbers in the given list.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += lst[i] ^ lst[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum += lst[i] ^ lst[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    \"\"\"\n    Function to find the sum of xor of all pairs of numbers in the given list.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += lst[i] ^ lst[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst,n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += lst[i] ^ lst[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    sum_xor = 0\n    for i in range(0,n):\n        for j in range(i+1,n):\n            sum_xor += nums[i] ^ nums[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    pair_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            pair_xor_sum += lst[i] ^ lst[j]\n    return pair_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += lst[i] ^ lst[j]\n    return xor_sum\nlst = [5,9,7,6]\nn = len(lst)", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 78.77659574468083, "dps_norm": 82.33333333333333, "pass@1": 89.0, "profiled": [{"solution": "def reverse_Array_Upto_K(array, k):\n    # This will reverse array from 0 to k position.\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    arr[:K] = arr[:K][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    if K > len(arr):\n        return \"Invalid K\"\n    \n    for i in range(int(K/2)):\n        arr[i], arr[K-i-1] = arr[K-i-1], arr[i]\n\n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    \"\"\"\n    This function accepts an array and a number K as input, and reverses the array up to the Kth position.\n    \"\"\"\n    return arr[:K][::-1] + arr[K:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    arr[:K] = arr[:K][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the array upto the given position using slicing\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # [::-1] is a python slicing technique that is used for reversing a list\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr): \n        return arr \n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    arr[:K] = arr[:K][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # If k is greater than array size, return original array\n    if k > len(arr):\n        return arr\n    \n    # Reverse the first k elements\n    for i in range(int(k/2)):\n        arr[i], arr[k-i-1] = arr[k-i-1], arr[i]\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    for i in range(k//2):\n        arr[i], arr[k-i-1] = arr[k-i-1], arr[i]\n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Using slicing to reverse up to k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Check if k is larger than the length of the array\n    # If it is, we will return the same array to avoid an error\n    k = min(k, len(arr))\n    \n    # Reverse the array up to the 'k'th index\n    arr[:k] = arr[:k][::-1]\n    \n    # Return the resulting array\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    arr[:K] = arr[:K][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # arr[k:] returns the elements from kth to the end of the array\n    # [::-1] is used to reverse the selected elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}]}, "Mbpp/720": {"dps": 90.76923076923077, "dps_norm": 97.0, "pass@1": 99.0, "profiled": [{"solution": "def add_dict_to_tuple(my_tuple, my_dict):\n    return my_tuple + (my_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_input, dict_input):\n    \"\"\" \n    The function to add a dictionary to the tuple. \n\n    Parameters:\n    tuple_input (tuple): The tuple input.\n    dict_input (dict): The dictionary input.\n    \n    Returns:\n    tuple: The combined tuple.\n    \"\"\"\n    return tuple_input + (dict_input,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    return tpl + (dct, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, d):\n    return tup + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the resultant tuple.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict_to_add):\n    \"\"\"Adds a dictionary to a tuple and returns the result as a tuple.\"\"\"\n    result = list(tup)\n    result.append(dict_to_add)\n    return tuple(result)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    tup += (dic, )\n    return tup", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_, dict_):\n    \"\"\" Add a dictionary to a tuple\"\"\"\n    list_ = list(tuple_)\n    list_.append(dict_)\n    return tuple(list_)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Add a dictionary to the tuple and return as tuple.\"\"\"\n    # convert input tuple and dictionary to a list and append one after the other\n    output_list = list(input_tuple)\n    output_list.append(input_dict)\n    # convert list back to tuple\n    output_tuple = tuple(output_list)\n    return output_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, d):\n    return tup + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic, )", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 74.53551912568305, "dps_norm": 75.625, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # regular expression to find values between quotation marks\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    # Using RegEx to match strings between quotation marks\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s: str) -> list:\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}]}, "Mbpp/732": {"dps": 95.15503875968992, "dps_norm": 95.5, "pass@1": 100.0, "profiled": [{"solution": "def replace_specialchar(sentence):\n    special_chars = [' ', ',', '.']\n    for char in special_chars:\n        sentence = sentence.replace(char, ':')\n    return sentence", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    s = s.replace(' ', ':')\n    s = s.replace(',', ':')\n    s = s.replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    for char in s:\n        if char in \" ,.\":\n            s = s.replace(char, \":\")\n    return s", "matching_cluster_idx": 0}, {"solution": "def replace_specialchar(string):\n    return string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    special_chars = [' ', ',', '.']\n    for special_char in special_chars:\n        text = text.replace(special_char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_str):\n    return input_str.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    replace_chars = ['.', ',', ' ']\n    for char in replace_chars:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    for ch in [' ', ',', '.']:\n        text = text.replace(ch, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    special_chars = [\" \", \",\", \".\"]\n    for char in special_chars:\n        text = text.replace(char, \":\")\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(str):\n    for c in [' ', ',', '.']:\n        if c in str:\n            str = str.replace(c, ':')\n    return str", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(sentence):\n    sentence = sentence.replace(' ', ':')\n    sentence = sentence.replace(',', ':')\n    sentence = sentence.replace('.', ':')\n    return sentence", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(string):\n    special_characters = [' ', ',', '.']\n    for char in special_characters:\n        string = string.replace(char, ':')\n    return string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    chars = [\" \", \",\", \".\"]\n    for char in chars:\n        text = text.replace(char, \":\")\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    special_chars = [',', '.', ' ']\n    for special_char in special_chars:\n        s = s.replace(special_char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    chars_to_replace = ['.', ',', ' ']\n    for c in chars_to_replace:\n        if c in s:\n            s = s.replace(c, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # replace all occurrences of spaces, commas, or dots with a colon\n    s = s.replace(' ', ':')\n    s = s.replace(',', ':')\n    s = s.replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    special_chars = [' ', ',', '.']\n    for special_char in special_chars:\n        s = s.replace(special_char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(sentence):\n    \"\"\"\n    Function to replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    # Replacing spaces, commas and dots with colon\n    sentence = sentence.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")\n    return sentence", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 83.63636363636364, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(input_tuple):\n    if len(input_tuple) == 0:\n        return {}\n    else:\n        return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple)-1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[n]: tup[n + 1] for n in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[n]: tup[n + 1] for n in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    if None in input_tuple:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    This function checks if the given tuple has any none value or not.\n    If it does, it returns True, otherwise it returns False.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    if None in input_tuple:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    if None in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple):\n    if None in tuple:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    This function checks if the given tuple has any None value or not.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(in_tuple):\n    \"\"\"\n    Check if tuple contains any None values.\n\n    Parameters:\n    in_tuple (tuple): tuple to check for None\n\n    Returns:\n    bool: True if None in tuple, False otherwise.\n    \"\"\"\n    return None in in_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    if None in input_tuple:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    if None in input_tuple:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    if None in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}]}, "Mbpp/750": {"dps": 83.70748299319727, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    This function adds a given tuple to a given list.\n    \"\"\"\n    # append the tuple to the list\n    lst.extend(tpl)\n    # return the updated list\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    This function adds a tuple to a list.\n    \"\"\"\n    # Add tuple to list using extend method\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the tuple to the list.\n\n    Parameters:\n    lst (list): The list to which the tuple should be added.\n    tup (tuple): The tuple to be added.\n\n    Returns:\n    list: The updated list.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds a tuple to a list.\n\n    Args:\n        lst (List): The list to add the tuple to.\n        tup (Tuple): The tuple to add to the list.\n\n    Returns:\n        List: The resulting list after adding the tuple.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"Add a tuple to a list.\"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple to the given list.\n    :param lst: The list to add to.\n    :param tpl: The tuple to add.\n    :return: The new list with the tuple added.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    This function appends a tuple to the end of a list.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    This function takes a list and a tuple and adds the tuple to the end of the list.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(input_list, input_tuple):\n    # Adding the tuple elements to the list\n    input_list.extend(input_tuple)\n    return input_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Function to add the given tuple to the given list.\n    :param lst: list of integers\n    :param tpl: tuple of integers\n    :return: list with added tuple\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Function to add a tuple to the given list.\n\n    Parameters:\n    input_list (list): A list of integers.\n    input_tuple (tuple): A tuple of integers.\n\n    Returns:\n    list: The original list with the tuple elements added.\n    \"\"\"\n    # Adding tuple elements to the list\n    input_list.extend(input_tuple)\n    return input_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend list by tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # extend the list by the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Function to add the given tuple to the given list.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"\n    Adds the given tuple to the given list.\n    \"\"\"\n    my_list.extend(my_tuple)\n    return my_list", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tup):\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}]}, "Mbpp/753": {"dps": 97.31543624161074, "dps_norm": 75.0, "pass@1": 96.0, "profiled": [{"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    return sorted(lst, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records in ascending order\n    records.sort(key = lambda x: x[1])\n    # Return the first k records\n    return records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(data, k):\n    \"\"\"Return minimum k records from tuple list.\"\"\"\n    return sorted(data, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Given a list of tuples, each containing a string and an integer,\n    and an integer k, return the k tuples with the smallest integers.\n    \"\"\"\n    # sort the list of tuples based on the integer values\n    sorted_records = sorted(records, key=lambda x: x[1])\n\n    # return the first k elements\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    return sorted(lst, key = lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    #Sorting the list on the basis of second value in tuple\n    sorted_list = sorted(tuples_list, key=lambda x:x[1])\n    #Returning first k elements\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # Sorting the tuples by the second element of the tuple\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n\n    # Returning first k elements\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Given a list of tuples, return the k tuples with the smallest second element.\n    \"\"\"\n    sorted_tuples = sorted(tuple_list, key=lambda x: x[1])\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Using the sorted() function and lambda to sort the records in ascending order by the second element of the tuples\n    # We also limit the output to the first k records\n    return sorted(records, key=lambda record: record[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    # Sort the list based on second element of tuple\n    lst.sort(key = lambda x: x[1])\n    # Return the first k elements of the list\n    return lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    # Sort list by second item in tuple\n    lst.sort(key=lambda x: x[1])\n\n    # Return first k records\n    return lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort records by value in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n\n    # Return first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    \"\"\"\n    Find minimum k records from tuple list.\n\n    Args:\n    lst: List of tuples where each tuple has two items: a string and an integer\n    k: Number of minimum records to retrieve\n\n    Returns:\n    Minimum k records from the list as a list of tuples\n    \"\"\"\n    lst.sort(key = lambda x: x[1]) # sort the list based on the second element of each tuple\n    return lst[:k] # return the first k elements of the list", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    # Sort the list by the second element in tuple\n    lst.sort(key = lambda x: x[1])\n    return lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    return sorted(tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    return sorted(lst, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 89.65517241379311, "dps_norm": 87.5, "pass@1": 13.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n            \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/757": {"dps": 85.30373831775701, "dps_norm": 34.61538461538461, "pass@1": 43.0, "profiled": [{"solution": "def count_reverse_pairs(lst):\n    n = len(lst)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strs):\n    count = 0\n    str_dict = {}\n    for s in strs:\n        rev_s = s[::-1]\n        if rev_s in str_dict:\n            count += str_dict[rev_s]\n            str_dict[s] = str_dict.get(s, 0) + 1\n        else:\n            str_dict[s] = str_dict.get(s, 0) + 1\n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(input_list):\n    \"\"\"\n    Function to count the pairs of reverse strings in a given string list.\n    \"\"\"\n    count = 0\n    for i in range(len(input_list)):\n        for j in range(i+1, len(input_list)):\n            if input_list[i] == input_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    str_dict = {}\n    for string in str_list:\n        reversed_string = string[::-1]\n        if reversed_string in str_dict:\n            count += str_dict[reversed_string]\n            str_dict[string] = str_dict.get(string, 0) + 1\n        else:\n            str_dict[string] = str_dict.get(string, 0) + 1\n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(strings_list):\n    count = 0\n    for i in range(len(strings_list)):\n        for j in range(i+1, len(strings_list)):\n            if strings_list[i] == strings_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    reverse_pairs = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                reverse_pairs += 1\n    return reverse_pairs", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    pairs = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                pairs += 1\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    n = len(lst)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i+1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strs):\n    count = 0\n    str_map = {}\n\n    for s in strs:\n        rev_s = s[::-1]\n        \n        if rev_s in str_map:\n            count += str_map[rev_s]\n            str_map[s] = str_map.get(s, 0) + 1\n        else:\n            str_map[s] = str_map.get(s, 0) + 1\n    \n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 79.36293436293435, "dps_norm": 80.625, "pass@1": 43.0, "profiled": [{"solution": "def unique_sublists(lst):\n    sublists_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in sublists_dict:\n            sublists_dict[tuple_sublist] += 1\n        else:\n            sublists_dict[tuple_sublist] = 1\n    return sublists_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    # Convert each sublist to a tuple and use collections.Counter\n    # to count occurrences\n    counts = Counter(tuple(sub) for sub in lst)\n    return dict(counts)", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in sublist_dict:\n            sublist_dict[tuple_sublist] += 1\n        else:\n            sublist_dict[tuple_sublist] = 1\n    return sublist_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    unique_dict = {}\n    for sub_list in lst:\n        tup = tuple(sub_list)\n        if tup in unique_dict:\n            unique_dict[tup] += 1\n        else:\n            unique_dict[tup] = 1\n    return unique_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(input_list):\n    # Convert each sublist to tuple and use Counter to count the frequency\n    return dict(Counter(tuple(sub) for sub in input_list))", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sub_list in lst:\n        tuple_item = tuple(sub_list)\n        if tuple_item in count_dict:\n            count_dict[tuple_item] += 1\n        else:\n            count_dict[tuple_item] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    dct = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in dct:\n            dct[tuple_sublist] += 1\n        else:\n            dct[tuple_sublist] = 1\n    return dct", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    d = {}\n    for sub_list in lst:\n        tup = tuple(sub_list)\n        if tup in d:\n            d[tup] += 1\n        else:\n            d[tup] = 1\n    return d", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    dict_count = {}\n    for sub_list in lst:\n        tuple_sub_list = tuple(sub_list)\n        if tuple_sub_list in dict_count:\n            dict_count[tuple_sub_list] += 1\n        else:\n            dict_count[tuple_sub_list] = 1\n    return dict_count", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    # convert each list in lst to tuple\n    tuples = [tuple(sublist) for sublist in lst]\n    # count the number of occurrences of each tuple in tuples\n    counts = Counter(tuples)\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in result:\n            result[tuple_sublist] += 1\n        else:\n            result[tuple_sublist] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in result:\n            result[tuple_sublist] += 1\n        else:\n            result[tuple_sublist] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(input_list):\n    # Create an empty dictionary to store the tuples and their counts\n    result = {}\n\n    # Iterate over the input list\n    for sublist in input_list:\n        # Convert the sublist to a tuple\n        sublist_tuple = tuple(sublist)\n\n        # If the tuple is not in the result dictionary, add it with count 1\n        if sublist_tuple not in result:\n            result[sublist_tuple] = 1\n        # If the tuple is already in the result dictionary, increment the count\n        else:\n            result[sublist_tuple] += 1\n\n    # Return the result dictionary\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    d = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in d:\n            d[tuple_sublist] += 1\n        else:\n            d[tuple_sublist] = 1\n    return d", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Create an empty dictionary\n    result = {}\n\n    # Loop over each list in the input list\n    for sublist in lst:\n        # Convert the list to a tuple\n        sublist_tuple = tuple(sublist)\n\n        # If the tuple is in the dictionary, increment the count\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        # If the tuple is not in the dictionary, add it with a count of 1\n        else:\n            result[sublist_tuple] = 1\n\n    # Return the dictionary\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/760": {"dps": 91.75182481751825, "dps_norm": 85.625, "pass@1": 75.0, "profiled": [{"solution": "def unique_Element(num_list):\n    return len(set(num_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    if len(set(lst)) == 1:  # A set is a data structure that removes duplicates\n        return True\n    else:\n        return False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    This function checks if all elements of a list are identical.\n    Parameters: \n    lst (list): List to be evaluated.\n    \n    Returns:\n    bool: True if all elements are identical, False otherwise.\n    \"\"\"\n    \n    # Return True if the list is empty\n    if not lst:\n        return True\n        \n    # Compare each element of the list with the first element\n    for i in lst:\n        if i != lst[0]:\n            return False\n    \n    # If the execution reaches this point, all elements are identical\n    return True", "matching_cluster_idx": 4}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(list):\n    return len(set(list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return lst.count(lst[0]) == len(lst)", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    This function checks if a list contains only one distinct element.\n    \"\"\"\n    # Check if list is empty\n    if len(lst) == 0:\n        return True\n    else:\n        first_element = lst[0]\n        # Compare each element to the first\n        for element in lst:\n            if element != first_element:\n                return False\n        return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(num_list):\n    return len(set(num_list)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Check if the list has at least two elements\n    if len(set(lst)) == 1:\n        return True\n    else:\n        return False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # If list is empty or contains only one element\n    if len(lst) < 2:\n        return True\n    else:\n        return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return lst.count(lst[0]) == len(lst)", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    This function checks whether a list of numbers contains only one distinct element or not.\n    \"\"\"\n    return len(set(lst)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Check if the list has more than one distinct element\n    if len(set(lst)) > 1:\n        return False\n    else:\n        return True", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(string):\n    return sum(c.isdigit() for c in string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize count to 0\n    count = 0\n    for char in s:\n        # Check if each character is a digit\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    return sum(c.isdigit() for c in string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # initialize a counter variable to zero\n    counter = 0\n    # iterate over each character in the string\n    for char in s:\n        # if the character is a digit, increment the counter\n        if char.isdigit():\n            counter += 1\n    # return the counter value\n    return counter", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Function to count the number of digits in a given string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_str):\n    return sum(c.isdigit() for c in input_str)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    return sum(c.isdigit() for c in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 80.37383177570094, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    return [(input_list[i], input_list[i + 1]) for i in range(len(input_list) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list)-1)]", "matching_cluster_idx": 3}]}, "Mbpp/775": {"dps": 81.44, "dps_norm": 58.57142857142857, "pass@1": 76.0, "profiled": [{"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    return all(el % 2 != 0 for el in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:  # Check if the index is odd and the value at that index is even.\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    This function checks whether every odd index contains odd numbers.\n    \"\"\"\n    return all(el % 2 != 0 for el in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(e % 2 == 1 for i, e in enumerate(lst) if i % 2 == 1)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # iterating through the list with odd indices\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            # if any odd index contains even number, returning False\n            return False\n    # if none of the odd indexes contain even number, returning True\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(el % 2 != 0 for el in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\" Check if every odd index contains odd numbers \"\"\"\n    for i in range(1, len(lst), 2): # iterate over odd indexes\n        if lst[i] % 2 == 0: # if the number in the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    return all(e % 2 != 0 for i, e in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Loop over the list at every odd index (using step of 2)\n    for i in range(1, len(nums), 2):\n        # If the number is even, return False\n        if nums[i] % 2 == 0:\n            return False\n    # If we have looped through the entire list without finding even numbers, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks if every odd index in a list contains an odd number\n\n    Args:\n    lst: list to be checked\n\n    Returns:\n    bool: True if every odd index contains an odd number, else False\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    return all(el % 2 != 0 for i, el in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    This function checks whether every odd index contains odd numbers.\n    \"\"\"\n    # Iterate through the list and check every odd index.\n    for i in range(1, len(lst), 2):\n        # If the number at the odd index is not odd, return False.\n        if lst[i] % 2 == 0:\n            return False\n    # If all numbers at odd indices are odd, return True.\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    return all(el % 2 != 0 for el in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}]}, "Mbpp/777": {"dps": 75.25510204081633, "dps_norm": 80.55555555555556, "pass@1": 64.0, "profiled": [{"solution": "def find_sum(input_list):\n    # Creating a set to store unique numbers\n    unique_set = set(input_list)\n    # Calculating the sum of unique numbers\n    sum_unique = sum(unique_set)\n    return sum_unique", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(x for i, x in enumerate(lst) if lst.index(x) == i)", "matching_cluster_idx": -1}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Function to find the sum of non-repeated elements in a given list.\n    \"\"\"\n    return sum(i for i in set(lst))", "matching_cluster_idx": 5}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    unique_numbers = set(numbers)\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated elements in the provided list.\n\n    Parameters:\n    lst (list): the input list of integers\n\n    Returns:\n    int: the sum of unique elements in the input list\n\n    Examples:\n    >>> find_sum([1,2,3,1,1,4,5,6])\n    21\n    \"\"\"\n    ## Step 1: Initialize a set to store unique elements\n    unique_elements = set()\n\n    ## Step 2: Iterate over the input list and add unique elements to the set\n    for element in lst:\n        unique_elements.add(element)\n\n    ## Step 3: Sum up the unique elements in the set and return\n    return sum(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def find_sum(nums):\n    seen = set()\n    unique_nums = [x for x in nums if x not in seen and not seen.add(x)]\n    return sum(unique_nums)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    seen = set()\n    uniq_sum = 0\n    for num in lst:\n        if num not in seen:\n            seen.add(num)\n            uniq_sum += num\n    return uniq_sum", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(input_list):\n    non_repeated = set()\n    for i in input_list:\n        if i not in non_repeated:\n            non_repeated.add(i)\n    return sum(non_repeated)", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # Create an empty list to store unique numbers\n    unique_numbers = []\n    # Loop through the given list\n    for number in numbers:\n        # If a number is not in unique numbers list, append it\n        if number not in unique_numbers:\n            unique_numbers.append(number)\n    # Return the sum of unique numbers\n    return sum(unique_numbers)", "matching_cluster_idx": 1}, {"solution": "def find_sum(lst):\n    # Using Python's set data structure to eliminate duplicate elements\n    unique_elements = set(lst)\n    # Sum up unique elements\n    sum_unique_elements = sum(unique_elements)\n    return sum_unique_elements", "matching_cluster_idx": 8}, {"solution": "def find_sum(input_list):\n    # convert the list into a set to remove duplicates\n    unique_elements = set(input_list)\n    # calculate the sum of unique elements\n    sum_unique_elements = sum(unique_elements)\n    # return the result\n    return sum_unique_elements", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}]}, "Mbpp/781": {"dps": 41.496062992125985, "dps_norm": 29.0, "pass@1": 98.0, "profiled": [{"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to count divisors of a given number.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(num):\n    count = 0\n    for i in range(1, num+1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while(i <= n):\n        if (n % i == 0):\n            count += 1\n        i = i + 1\n    return count % 2 == 0  # returns True if count is even, False otherwise", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(num):\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}]}, "Mbpp/800": {"dps": 93.50746268656717, "dps_norm": 97.0, "pass@1": 94.0, "profiled": [{"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(str):\n    return str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(string):\n    return string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str):\n    return input_str.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Replace all spaces with no space ('')\n    no_space_string = input_string.replace(' ', '')\n    return no_space_string", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    # Replace all whitespace characters with no space\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"This function removes all spaces from a string.\n\n    Arguments:\n    input_string -- string from which all spaces should be removed\n\n    Return value: \n    The string with all spaces removed.\n    \"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    This function removes all the whitespaces in the string\n    \"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(string):\n    return string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n    return text.replace(' ', '')\ntext = 'python program'", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(str):\n    return str.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(string):\n    \"\"\"\n    Removes all whitespace characters from a string.\n\n    Parameters:\n    string (str): the input string.\n\n    Returns:\n    str: the string with all whitespace characters removed.\n    \"\"\"\n\n    # Replace whitespace characters with no character to remove them\n    new_string = string.replace(' ', '')\n    return new_string", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Removing all the whitespaces in the string.\n    input_string = input_string.replace(\" \", \"\")\n    return input_string", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    \"\"\"\n    This function removes all spaces from a string.\n    \"\"\"\n    return string.replace(' ', '')", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 95.49828178694158, "dps_norm": 99.0, "pass@1": 95.0, "profiled": [{"solution": "def max_sum_list(lst):\n    max_sum = -float('inf')\n    max_list = []\n    for sub_list in lst:\n        current_sum = sum(sub_list)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sub_list\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Function that returns the list of lists with the highest sum.\n\n    Parameters:\n    list_of_lists (list): List of lists where each inner list contains integers.\n\n    Returns:\n    list: The list that has the highest sum of its elements.\n    \"\"\"\n    # Initializing the maximum sum and the corresponding list\n    max_sum = None\n    max_list = None\n\n    # Iterating over each list in the list of lists\n    for inner_list in list_of_lists:\n        # Calculating the sum of the current list\n        current_sum = sum(inner_list)\n\n        # If max_sum is None, then we've not yet encountered any sums\n        # If the current_sum is greater than max_sum, then we've found a new maximum sum\n        if max_sum is None or current_sum > max_sum:\n            max_sum = current_sum\n            max_list = inner_list\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(input_list):\n    # Initialize maximum sum as negative infinity\n    max_sum = float('-inf')\n    # Initialize variable to hold list with maximum sum\n    max_sum_list = None\n    \n    # Iterate over each sublist\n    for sublist in input_list:\n        # Calculate sum of elements in sublist\n        sublist_sum = sum(sublist)\n        # If sum is greater than max_sum, update max_sum and max_sum_list\n        if sublist_sum > max_sum:\n            max_sum = sublist_sum\n            max_sum_list = sublist\n    \n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Initialize the maximum sum and corresponding list\n    max_sum = -float('inf')\n    max_list = None\n    # Iterate over each list in the list\n    for l in lst:\n        # Calculate the sum of the current list\n        current_sum = sum(l)\n        # If the sum is greater than the current maximum sum\n        if current_sum > max_sum:\n            # Update the maximum sum and corresponding list\n            max_sum = current_sum\n            max_list = l\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    \"\"\"Return the list in a list of lists whose sum of elements is the highest.\"\"\"\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    max_sum = -float('inf')\n    max_lst = None\n    for sublist in lst:\n        if sum(sublist) > max_sum:\n            max_sum = sum(sublist)\n            max_lst = sublist\n    return max_lst", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    max_sum = max(sum(sub_lst) for sub_lst in lst)\n    for sub_lst in lst:\n        if sum(sub_lst) == max_sum:\n            return sub_lst", "matching_cluster_idx": 3}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    max_sum = -float('inf')\n    max_lst = None\n    for sub_lst in lst:\n        if sum(sub_lst) > max_sum:\n            max_sum = sum(sub_lst)\n            max_lst = sub_lst\n    return max_lst", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # initiate highest_sum with first element in first sub-list and highest_list with the first sub-list itself\n    highest_sum = sum(lst[0])\n    highest_list = lst[0]\n    for sub_list in lst:\n        # compute the sum of each sub-list\n        current_sum = sum(sub_list)\n        # if the current_sum is higher than highest_sum, update highest_sum and highest_list\n        if current_sum > highest_sum:\n            highest_sum = current_sum\n            highest_list = sub_list\n    return highest_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(input_list):\n    max_sum = -float('inf')\n    max_list = []\n    for l in input_list:\n        if sum(l) > max_sum:\n            max_sum = sum(l)\n            max_list = l\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    max_sum = -float('inf')\n    max_list = []\n    for sublist in lst:\n        if sum(sublist) > max_sum:\n            max_sum = sum(sublist)\n            max_list = sublist\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(input_list):\n    # Initialize a variable to track the maximum sum and index of the list with the maximum sum\n    max_sum = float('-inf')\n    max_sum_index = 0\n    \n    # Traverse through each list in the input list\n    for i in range(len(input_list)):\n        # Calculate the sum of the elements in the current list\n        current_sum = sum(input_list[i])\n        # If this sum is greater than the current max_sum, update max_sum and max_sum_index\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_index = i\n    \n    # Return the list with the maximum sum\n    return input_list[max_sum_index]", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    max_sum = -float('inf')\n    max_list = None\n    for lst in list_of_lists:\n        if sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_data, k):\n    if k in tuple_data:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    This function checks if a certain value k exists in a tuple\n\n    Args:\n    tuples : tuple, required\n    k : any value, required\n\n    Returns:\n    bool: True if k exists in tuples, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    # Check if k is in the tuple\n    if k in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Check if the given tuples contain the k or not.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_k, k):\n    return k in tuple_k", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_check, k):\n    if k in tuple_check:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}]}}}
