{"date": "2024-11-04 19:18", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 81.30178648041522, "dps_norm": 78.05029274764424, "pass@1": 77.53389830508475}, "eval": {"HumanEval/9": {"dps": 73.75394321766561, "dps_norm": 71.66666666666667, "pass@1": 86.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until the given moment\n    in the sequence.\n\n    Args:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    List[int]: A list where each element is the maximum value found up to that index in the input list.\n\n    Examples:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = float('-inf')\n    result = []\n    \n    for num in numbers:\n        # Update the max if the current number is larger\n        if num > max_so_far:\n            max_so_far = num\n        # Append the current max to the result list\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    Args:\n    numbers (List[int]): A list of integers.\n    \n    Returns:\n    List[int]: A list where each element represents the maximum value seen up to that index.\n    \n    Examples:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    # If the list is empty, return an empty list\n    if not numbers:\n        return []\n    \n    # Initialize result list with the first number as the current max\n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    # Iterate through the rest of the numbers\n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    Examples:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n\n    Args:\n    numbers (List[int]): A list of integers to compute the rolling maximum.\n\n    Returns:\n    List[int]: A list where each element is the maximum of all numbers seen so far in the input list.\n    \"\"\"\n    # Use list comprehension to build the result where for each index 'i' in numbers,\n    # we find the maximum value from the start of the list up to index 'i'\n    return [max(numbers[:i+1]) for i in range(len(numbers))]", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a given list of integers, generate a list of the rolling maximum \n    element found up to each position in the sequence.\n\n    This function calculates the maximum value seen so far at each step,\n    maintaining an ever-increasing list of the highest values.\n\n    Args:\n        numbers (List[int]): The list of integers to process.\n\n    Returns:\n        List[int]: A list where each element at index i represents the maximum \n        value from the start of the list up to (and including) index i.\n\n    Example:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    Args:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    List[int]: A list where each element is the maximum from the start to that position.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    # Initialize the list with the first element as the max\n    result = [numbers[0]]\n\n    # Keep track of the maximum seen so far\n    current_max = numbers[0]\n\n    for i in range(1, len(numbers)):\n        # Update the maximum if current number is larger\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        # Append the current max to result\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    List[int]: A list where each element is the maximum value seen so far in the input list.\n\n    Example:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    # Initialize result list with the first element of numbers\n    result = [numbers[0]]\n    \n    # Current maximum value\n    max_so_far = numbers[0]\n\n    # Loop through the numbers starting from the second element\n    for n in numbers[1:]:\n        # If the current number is greater than the max_so_far, update max_so_far\n        if n > max_so_far:\n            max_so_far = n\n        # Append the max_so_far to the result list\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of the rolling maximum element found until the given moment\n    in the sequence.\n    \n    Args:\n    numbers (List[int]): A list of integers where the rolling maximum will be calculated.\n\n    Returns:\n    List[int]: A new list where each element is the maximum value up to that point in the original list.\n\n    Examples:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    # Initialize result with the first number\n    result = [numbers[0]]\n    \n    # Current maximum, starting from the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:\n        # Update the current max if necessary\n        current_max = max(current_max, num)\n        # Append the current max to the result\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    Args:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    List[int]: A list where each element at index i is the maximum value from the beginning of \n    the input list up to and including index i.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    # If the list is empty, return an empty list\n    if not numbers:\n        return []\n\n    result = [numbers[0]]  # Start with the first element\n    current_max = numbers[0]\n\n    # Iterate through the list starting from the second element\n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    This function uses a single loop to keep track of the maximum value seen so far,\n    which is appended to the result list for each element in the input list.\n    \n    Args:\n        numbers (List[int]): The list of integers to process.\n\n    Returns:\n        List[int]: A list where each element at index i is the maximum of \n        numbers up to index i.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    # Initialize the result list and the current max with the first number\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    # Iterate over the remaining numbers\n    for num in numbers[1:]:\n        # Update the max if the current number is larger\n        current_max = max(current_max, num)\n        # Append the maximum found so far to the result list\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until the given moment\n    in the sequence.\n\n    Examples:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list where each element is the maximum up to that point in the original list.\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    Examples:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    # The result list starts with the first number from the input list\n    result = [numbers[0]]\n    \n    # Iterate through the numbers keeping track of the maximum seen so far\n    for num in numbers[1:]:\n        result.append(max(num, result[-1]))\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    Args:\n    numbers (List[int]): A list of integers.\n    \n    Returns:\n    List[int]: A list where each element is the maximum value encountered up to that point in the input list.\n    \n    Example:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    # Initialize result list with the first number\n    result = [numbers[0]]\n    \n    # Use the built-in max function with a dynamic end range for efficiency\n    for i in range(1, len(numbers)):\n        result.append(max(result[-1], numbers[i]))\n        \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers to process.\n\n    Returns:\n        List[int]: A list where each element is the maximum of all elements in the original list up to that index.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    # Initialize with the first element\n    max_list = [numbers[0]]\n    \n    # Keep track of the current maximum\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        # If the current number is greater than current_max, update current_max\n        if num > current_max:\n            current_max = num\n        # Append the maximum so far to the result list\n        max_list.append(current_max)\n\n    return max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until the given moment\n    in the sequence.\n\n    Args:\n    numbers (List[int]): The input list of integers.\n\n    Returns:\n    List[int]: A list where each element at index i represents the maximum value \n               encountered from the beginning of the list up to index i.\n\n    Example:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    # Initialize max_so_far to store the current maximum and the result list\n    max_so_far = float('-inf')\n    result = []\n\n    for num in numbers:\n        # Update max_so_far if the current number is greater\n        if num > max_so_far:\n            max_so_far = num\n        # Append the current max to the result list\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    This function maintains a running maximum as it iterates through the list,\n    ensuring that each element in the result list is the maximum of all elements\n    seen so far from the start of the input list.\n\n    Examples:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \n    Args:\n        numbers (List[int]): A list of integers for which to compute the rolling max.\n\n    Returns:\n        List[int]: A list where each element is the maximum of all previous numbers up to that point.\n\n    Time Complexity:\n    - O(n), where n is the length of the list since we traverse the list only once.\n\n    Space Complexity:\n    - O(n) for the result list, although in-place operations could reduce this.\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a given list of integers, generate a list of rolling maximum elements found \n    until the given moment in the sequence.\n\n    Args:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    List[int]: A list where each element at index i is the maximum element seen \n               in the input list up to and including index i.\n\n    Examples:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Handle empty list\n        return []\n    \n    # Initialize the result list with the first element\n    result = [numbers[0]]\n    \n    # Use max to keep track of the maximum so far\n    current_max = numbers[0]\n    \n    # Iterate over the numbers starting from the second element\n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    Args:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    List[int]: A list where each element is the maximum of all previous elements including itself.\n\n    Examples:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    # If the list is empty, return an empty list\n    if not numbers:\n        return []\n\n    # Initialize the result list with the first element\n    result = [numbers[0]]\n    \n    # Loop through the remaining elements\n    for num in numbers[1:]:\n        # Append the max of the current rolling max and the current number\n        result.append(max(num, result[-1]))\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\nimport doctest\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    Args:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    List[int]: A list where each element is the maximum of all elements seen so far.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    >>> rolling_max([5, 4, 3, 2, 1])\n    [5, 5, 5, 5, 5]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    current_max = float('-inf')  # Start with negative infinity as the initial maximum\n\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    Args:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    List[int]: A list where each element at index i is the maximum of all elements up to and including index i in the input list.\n\n    Examples:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Handle empty list case\n        return []\n\n    # Start with the first number as the initial max\n    result = [numbers[0]]\n    current_max = numbers[0]\n\n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list where each element at index i\n    represents the maximum value found up to and including that index in the original list.\n\n    Args:\n    numbers (List[int]): The list of integers to process.\n\n    Returns:\n    List[int]: A list containing the rolling maximum at each position.\n\n    Examples:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    # Handle edge case: if the list is empty, return an empty list\n    if not numbers:\n        return []\n\n    # Initialize result list with the first number\n    result = [numbers[0]]\n    \n    # Iterate through the remaining numbers\n    for i in range(1, len(numbers)):\n        # Take the maximum of the current number and the previous max\n        result.append(max(numbers[i], result[-1]))\n    \n    return result", "matching_cluster_idx": 4}]}, "HumanEval/0": {"dps": 50.058139534883715, "dps_norm": 56.42857142857143, "pass@1": 83.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n    numbers (List[float]): A list of floating point numbers to check.\n    threshold (float): The threshold distance to compare numbers against.\n\n    Returns:\n    bool: True if any two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make consecutive elements the closest to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Check adjacent numbers in the sorted list for being too close\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i-1] < threshold:\n            return True\n    \n    # If we've gone through all numbers without finding a pair that's too close, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n    numbers (List[float]): A list of float numbers to check.\n    threshold (float): The minimum threshold to check distances against.\n\n    Returns:\n    bool: True if there are any two numbers closer than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to compare adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    # Compare each number with its adjacent number\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i-1] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    Args:\n    numbers (List[float]): A list of floating point numbers to check.\n    threshold (float): The threshold value to determine if two numbers are close.\n\n    Returns:\n    bool: True if there are at least two numbers with a difference less than threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to ensure that adjacent elements are the closest possible\n    sorted_numbers = sorted(numbers)\n    \n    # Check each adjacent pair of numbers after sorting\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Args:\n    numbers (List[float]): A list of floating point numbers.\n    threshold (float): The threshold for the proximity of two numbers.\n    \n    Returns:\n    bool: True if any two numbers are closer than threshold, False otherwise.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n    \n    # Sort the list to check pairs efficiently\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate over adjacent pairs in the sorted list\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Args:\n    numbers (List[float]): A list of floating point numbers to check for proximity.\n    threshold (float): The threshold distance to consider two numbers as close.\n    \n    Returns:\n    bool: True if any two numbers are within threshold distance, False otherwise.\n    \n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily compare adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list comparing each number to the next one\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    \n    # If no pair is found within the threshold, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Args:\n    numbers (List[float]): A list of float numbers to check.\n    threshold (float): The threshold distance within which numbers are considered close.\n\n    Returns:\n    bool: True if any two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to compare adjacent numbers\n    numbers.sort()\n    \n    # Iterate through the sorted list and compare each pair of adjacent elements\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    \n    # If no numbers are found to be within the threshold, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Args:\n    numbers (List[float]): A list of float numbers to check for closeness.\n    threshold (float): The maximum allowed difference between two numbers.\n\n    Returns:\n    bool: True if there exists at least one pair of numbers where their absolute difference \n          is less than the threshold, False otherwise.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to bring adjacent elements closer together\n    sorted_numbers = sorted(numbers)\n    \n    # Check if any two consecutive elements are within the threshold\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    \n    # If we've gone through all numbers and haven't found a pair close enough, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    Args:\n    numbers (List[float]): A list of numbers to check for proximity.\n    threshold (float): The threshold value to compare distances with.\n\n    Returns:\n    bool: True if any two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make comparison easier\n    sorted_numbers = sorted(numbers)\n    \n    # Check for closeness between adjacent elements in the sorted list\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i-1] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, there are any two numbers closer to each other than\n    the given threshold.\n\n    Args:\n    numbers (List[float]): A list of floating point numbers to check.\n    threshold (float): The threshold for closeness.\n\n    Returns:\n    bool: True if any two numbers are closer than the threshold, False otherwise.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make comparison easier\n    sorted_numbers = sorted(numbers)\n    \n    # Compare each number with its next neighbor\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n    numbers (List[float]): A list of floating point numbers.\n    threshold (float): The minimum distance between two numbers to consider them \"close\".\n\n    Returns:\n    bool: True if at least one pair of numbers is closer than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily check the distance between adjacent numbers\n    sorted_numbers = sorted(numbers)\n    \n    # Check the difference between each consecutive pair of numbers\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i+1]) < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n    numbers (List[float]): A list of numbers to check.\n    threshold (float): The threshold distance to compare.\n\n    Returns:\n    bool: True if there are numbers closer than the threshold, False otherwise.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to compare adjacent numbers after sorting\n    sorted_numbers = sorted(numbers)\n    \n    # Check if any two adjacent numbers after sorting are closer than the threshold\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Examples:\n    ```python\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ```\n    \"\"\"\n    # Sort the list to simplify the comparison\n    sorted_numbers = sorted(numbers)\n    \n    # Check each adjacent pair in the sorted list\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i-1] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two numbers closer to each other than\n    the given threshold.\n\n    Args:\n    numbers (List[float]): A list of float numbers to check.\n    threshold (float): The proximity threshold.\n\n    Returns:\n    bool: True if two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily find closest numbers\n    numbers.sort()\n    \n    # Check differences between consecutive numbers\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Args:\n    numbers (List[float]): List of float numbers to check for close elements.\n    threshold (float): The threshold below which two numbers are considered close.\n\n    Returns:\n    bool: True if there are at least two numbers closer than threshold, False otherwise.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to check adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    for i in range(len(sorted_numbers) - 1):\n        # If the difference between two adjacent elements is less than threshold, return True\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    \n    # If no close elements were found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n    numbers (List[float]): A list of float numbers to check.\n    threshold (float): The threshold for closeness between two numbers.\n\n    Returns:\n    bool: True if there are any two numbers in the list closer than the threshold, False otherwise.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n    \n    # Sort the numbers to check adjacent elements for efficiency\n    sorted_numbers = sorted(numbers)\n    \n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Args:\n    numbers (List[float]): A list of floating point numbers.\n    threshold (float): The threshold to compare the distance between numbers.\n    \n    Returns:\n    bool: True if there exist two numbers in the list closer than the threshold, False otherwise.\n    \n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to easily compare adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    # Check if the difference between any two adjacent elements is less than the threshold\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Args:\n    numbers (List[float]): A list of float numbers to check.\n    threshold (float): The closeness threshold for two numbers.\n\n    Returns:\n    bool: True if any two numbers are closer than the threshold, False otherwise.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to compare adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    # Check each pair of adjacent elements in the sorted list\n    for i in range(1, len(sorted_numbers)):\n        if abs(sorted_numbers[i] - sorted_numbers[i-1]) < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Args:\n        numbers (List[float]): A list of numbers to check.\n        threshold (float): The threshold for considering numbers as 'close'.\n    \n    Returns:\n        bool: True if there are at least two numbers closer than the threshold, False otherwise.\n    \n    Examples:\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n    \"\"\"\n    # Sort the numbers first to check adjacent numbers easily\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate over the sorted list and compare each number with its neighbor\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    \n    # If no close elements were found\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    Args:\n    numbers (List[float]): A list of floating point numbers.\n    threshold (float): The distance threshold below which numbers are considered close.\n\n    Returns:\n    bool: True if there exist at least two numbers closer than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to check adjacent elements\n    numbers.sort()\n    \n    # Check the difference between each consecutive pair of numbers\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    \n    # If no pairs were found to be closer than the threshold\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n    numbers (List[float]): A list of floating point numbers.\n    threshold (float): The threshold for closeness.\n\n    Returns:\n    bool: True if any two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to check for closeness\n    sorted_numbers = sorted(numbers)\n    \n    # Compare adjacent elements after sorting\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    \n    # If we've gone through all adjacent pairs and found no close elements\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 37.800632911392405, "dps_norm": 55.833333333333336, "pass@1": 97.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Calculate the Mean Absolute Deviation (MAD) of a list of numbers around their mean.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation of the given list of numbers.\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # If the list is empty, return 0 as MAD doesn't make sense with no data\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n    \n    # Compute the absolute deviation of each element from the mean and then average these deviations\n    total_deviation = sum(abs(x - mean) for x in numbers)\n    mad = total_deviation / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport doctest\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    \n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    abs_deviations = [abs(x - mean) for x in numbers]\n    \n    # Calculate and return the mean of these deviations\n    return sum(abs_deviations) / len(numbers)", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): List of numbers to calculate MAD for.\n\n    Returns:\n        float: The Mean Absolute Deviation of the dataset.\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # If the list is empty, raise an error\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    \n    # Calculate the mean of the numbers\n    mean = statistics.mean(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    abs_deviations = [abs(num - mean) for num in numbers]\n    \n    # Return the average of absolute deviations\n    return statistics.mean(abs_deviations)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): A list of numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation.\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean = statistics.mean(numbers)\n    # Calculate the absolute deviation for each number from the mean\n    deviations = [abs(x - mean) for x in numbers]\n    # Compute the mean of these deviations\n    return statistics.mean(deviations)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport doctest\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n    numbers (List[float]): A list of numbers.\n\n    Returns:\n    float: The mean absolute deviation of the numbers.\n\n    Examples:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty\")\n\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    abs_devs = [abs(x - mean) for x in numbers]\n    \n    # Return the mean of absolute deviations\n    return sum(abs_devs) / len(abs_devs)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Examples:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \n    :param numbers: A list of float values\n    :return: The Mean Absolute Deviation as a float\n    \"\"\"\n    if not numbers:\n        return 0.0  # To handle the case of an empty list\n    \n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the sum of absolute differences from the mean\n    absolute_diff_sum = sum(abs(x - mean) for x in numbers)\n    \n    # Calculate and return the mean absolute deviation\n    return absolute_diff_sum / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport doctest\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([4.0, 4.0, 4.0, 5.0, 5.0])\n    0.4\n    >>> mean_absolute_deviation([-2.0, -1.0, 0.0, 1.0, 2.0])\n    1.2\n    \"\"\"\n    # Check if the list has at least one element\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviation from the mean for each number\n    abs_deviations = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute deviations\n    mad = sum(abs_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Examples:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Compute the absolute deviations from the mean\n    deviations = [abs(x - mean) for x in numbers]\n    \n    # Compute the mean of these absolute deviations\n    mad = sum(deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Examples:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Handle the edge case where the list is empty\n\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate the sum of absolute deviations\n    abs_dev_sum = sum(abs(x - mean) for x in numbers)\n\n    # Calculate the mean absolute deviation\n    return abs_dev_sum / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Args:\n    numbers (List[float]): A list of floating point numbers.\n\n    Returns:\n    float: The mean absolute deviation from the mean.\n\n    Examples:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        raise ValueError(\"The list of numbers cannot be empty.\")\n\n    # Calculate the mean of the numbers\n    data_mean = mean(numbers)\n    \n    # Calculate the sum of absolute deviations from the mean\n    total_deviation = sum(abs(x - data_mean) for x in numbers)\n    \n    # Calculate MAD by averaging the absolute deviations\n    mad = total_deviation / len(numbers)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of numbers to calculate the MAD from.\n\n    Returns:\n        float: The Mean Absolute Deviation.\n\n    Examples:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n        >>> mean_absolute_deviation([0, 100])\n        50.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list must not be empty to calculate MAD.\")\n    \n    # Calculate the mean\n    mean = statistics.mean(numbers)\n    \n    # Calculate absolute deviations from the mean\n    abs_deviations = [abs(x - mean) for x in numbers]\n    \n    # Compute the mean of these absolute deviations\n    mad = statistics.mean(abs_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n    numbers (List[float]): A list of numbers to compute MAD from.\n    \n    Returns:\n    float: The Mean Absolute Deviation.\n    \n    Examples:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([1, 1, 1, 1])\n    0.0\n    \"\"\"\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    abs_deviations = [abs(x - mean) for x in numbers]\n    \n    # Compute the mean of these absolute deviations\n    mad = sum(abs_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of numbers to calculate the MAD from.\n\n    Returns:\n        float: The mean absolute deviation of the dataset.\n\n    Examples:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty\")\n    \n    # Calculate the mean of the numbers\n    average = mean(numbers)\n    \n    # Calculate the mean of absolute deviations\n    return mean(abs(num - average) for num in numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of numbers to calculate the MAD from.\n\n    Returns:\n        float: The Mean Absolute Deviation of the numbers.\n\n    Examples:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Handle case where the list might be empty\n    \n    # Calculate the mean of the numbers\n    avg = mean(numbers)\n    \n    # Compute the absolute deviation from the mean for each number\n    abs_deviations = [abs(x - avg) for x in numbers]\n    \n    # Calculate the average of these absolute deviations\n    mad = mean(abs_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n    numbers (List[float]): A list of numbers for which to calculate the MAD.\n    \n    Returns:\n    float: The Mean Absolute Deviation of the dataset.\n    \n    Example:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0 for an empty list to avoid errors\n    \n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the sum of absolute deviations\n    absolute_deviations_sum = sum(abs(x - mean) for x in numbers)\n    \n    # Calculate the MAD\n    mad = absolute_deviations_sum / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    \n    # Return the average of these absolute deviations\n    return sum(absolute_deviations) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    \n    # Compute the mean of these absolute deviations\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean of the list\n    mean_value = mean(numbers)\n    \n    # Calculate the absolute deviation for each number\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    \n    # Calculate and return the mean of these absolute deviations\n    return mean(absolute_deviations)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = statistics.mean(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    return statistics.mean(deviations)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n    numbers (List[float]): A list of numbers.\n\n    Returns:\n    float: The mean absolute deviation.\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # If the list is empty, return 0.0 since the concept doesn't apply\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean of the numbers\n    mean = statistics.mean(numbers)\n    \n    # Calculate the absolute deviation for each number\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    \n    # Return the mean of these absolute deviations\n    return statistics.mean(absolute_deviations)", "matching_cluster_idx": 0}]}, "HumanEval/16": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 97.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \n    This function counts the unique characters in the string ignoring case. Each character \n    is converted to lowercase before counting to ensure 'A' and 'a' are counted as one.\n\n    Args:\n        string (str): The input string to evaluate.\n\n    Returns:\n        int: The number of distinct characters found in the string.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert string to lowercase and use a set to count unique characters\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    This function converts the string to lowercase to treat upper and lower case letters as identical,\n    then counts unique characters.\n\n    Args:\n    string (str): The input string to analyze.\n\n    Returns:\n    int: The number of distinct characters in the string.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert string to lowercase and remove duplicates by converting to set\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    This function converts the string to lowercase and uses a set to remove duplicate characters,\n    thus counting only distinct characters.\n\n    Args:\n        string (str): The input string to analyze.\n\n    Returns:\n        int: The number of distinct characters in the string, case insensitive.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to lowercase to ignore case sensitivity\n    lower_string = string.lower()\n    \n    # Use a set to get only unique characters\n    unique_chars = set(lower_string)\n    \n    # Return the length of the set which represents the number of distinct characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to treat uppercase and lowercase letters as the same\n    lowercase_string = string.lower()\n    # Use a set to automatically count unique characters\n    return len(set(lowercase_string))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    This function converts all characters to lowercase before counting to ensure\n    that 'A' and 'a' are counted as the same character.\n\n    Args:\n        string (str): The input string to analyze.\n\n    Returns:\n        int: The count of distinct characters in the string.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to treat 'A' and 'a' as the same character\n    lowercase_string = string.lower()\n    # Use a set to find unique characters, as sets only store unique elements\n    unique_chars = set(lowercase_string)\n    # Return the length of the set which represents the number of distinct characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \n    Args:\n    string (str): The input string to analyze.\n\n    Returns:\n    int: Number of distinct characters in the string, ignoring case.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert string to lowercase to ignore case differences\n    lower_string = string.lower()\n    \n    # Use set to remove duplicate characters, then return length of the set\n    return len(set(lower_string))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Args:\n    string (str): The input string to analyze.\n    \n    Returns:\n    int: The number of distinct characters in the string.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case sensitivity\n    lowercase_string = string.lower()\n    \n    # Use a set to automatically eliminate duplicates\n    distinct_chars = set(lowercase_string)\n    \n    # Return the length of the set, which represents the count of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    Args:\n    string (str): The input string to check for distinct characters.\n\n    Returns:\n    int: The number of distinct characters in the string, case insensitive.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lowercase_string = string.lower()\n    # Use a set to get only unique characters\n    return len(set(lowercase_string))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Args:\n        string (str): The input string to analyze for distinct characters.\n\n    Returns:\n        int: The number of unique characters, case-insensitive.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert string to lowercase to ignore case differences\n    lower_string = string.lower()\n    # Use a set to get distinct characters and return its length\n    return len(set(lower_string))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \n    Args:\n    string (str): The input string to analyze\n    \n    Returns:\n    int: The number of distinct characters in the string, ignoring case\n    \"\"\"\n    # Convert the string to lower case to ignore case sensitivity\n    lower_string = string.lower()\n    # Use a set to keep only unique characters\n    distinct_chars = set(lower_string)\n    # Return the count of unique characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \n    Args:\n    string (str): The input string to analyze.\n\n    Returns:\n    int: The count of distinct characters in the string, ignoring case.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert string to lower case to ignore case sensitivity\n    lower_string = string.lower()\n    \n    # Use a set to automatically remove duplicates\n    return len(set(lower_string))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n    string (str): The input string to analyze.\n\n    Returns:\n    int: The number of distinct characters in the string.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    string = string.lower()\n    # Use a set to collect only unique characters\n    unique_chars = set(string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \n    Args:\n    string (str): The input string to analyze.\n\n    Returns:\n    int: The number of distinct characters in the string, ignoring case.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lower_string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(lower_string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    Args:\n    string (str): The input string to analyze.\n\n    Returns:\n    int: The number of distinct characters in the string, ignoring case.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert string to lowercase to ignore case sensitivity\n    lowercase_string = string.lower()\n    \n    # Use a set to count only unique characters\n    distinct_chars = set(lowercase_string)\n    \n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \n    Args:\n    string (str): The input string to check for distinct characters.\n    \n    Returns:\n    int: Number of distinct characters in the string, ignoring case.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert string to lowercase to make comparison case-insensitive\n    lower_string = string.lower()\n    # Convert the string into a set of unique characters and count them\n    return len(set(lower_string))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert string to lowercase to treat characters case-insensitively\n    lowercased_string = string.lower()\n    # Use set to keep only unique characters\n    return len(set(lowercased_string))", "matching_cluster_idx": 8}, {"solution": "import unittest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    Args:\n    string (str): The input string to analyze.\n\n    Returns:\n    int: The count of distinct characters, ignoring case sensitivity.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert string to lowercase to make the comparison case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to count only distinct characters\n    return len(set(lowercase_string))", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert string to lowercase to treat characters case-insensitively\n    lower_string = string.lower()\n    # Use a set to remove duplicates and get unique characters\n    return len(set(lower_string))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \n    Args:\n        string (str): The input string to analyze.\n    \n    Returns:\n        int: The number of distinct characters in the string, case insensitive.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert string to lowercase to make it case-insensitive\n    lower_string = string.lower()\n    # Return the length of the set of characters, which automatically removes duplicates\n    return len(set(lower_string))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \n    Args:\n        string (str): The input string to analyze.\n    \n    Returns:\n        int: The number of unique characters in the string, ignoring case.\n    \n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to lower case to treat 'A' and 'a' as the same character\n    string = string.lower()\n    \n    # Use a set to get only unique characters\n    return len(set(string))", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 83.51089588377724, "dps_norm": 90.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\nimport itertools\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n    numbers (List[float]): A list containing at least two floating point numbers.\n\n    Returns:\n    Tuple[float, float]: A tuple containing the two closest numbers, with the smaller number first.\n\n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Ensure the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Generate all unique pairs of numbers\n    pairs = itertools.combinations(numbers, 2)\n    \n    # Find the pair with the smallest difference\n    closest_pair = min(pairs, key=lambda pair: abs(pair[0] - pair[1]))\n    \n    # Return the pair in the requested format, ensuring the smaller number is first\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to make comparisons easier\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (sorted_numbers[0], sorted_numbers[1])\n\n    # Compare adjacent numbers for the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n    numbers (List[float]): A list of float numbers with at least two elements.\n\n    Returns:\n    Tuple[float, float]: A tuple containing two numbers from the list that are closest to each other.\n\n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Ensure the list has at least two numbers\n    if len(numbers) < 2:\n        raise ValueError(\"The list should contain at least two numbers\")\n\n    # Sorting the numbers to easily compare adjacent pairs\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate through the list to find the smallest difference\n    for i in range(1, len(sorted_numbers)):\n        diff = sorted_numbers[i] - sorted_numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i-1], sorted_numbers[i])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of least length two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list should contain at least two numbers\")\n    \n    # Sort numbers for easier comparison\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (sorted_numbers[0], sorted_numbers[1])  # Initialize with first two elements\n    \n    # Loop through adjacent numbers in the sorted list to find the smallest difference\n    for i in range(1, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i-1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            result = (sorted_numbers[i-1], sorted_numbers[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    Args:\n        numbers (List[float]): A list containing at least two numbers.\n\n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n\n    Raises:\n        ValueError: If the list contains fewer than two numbers.\n\n    Examples:\n        >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n        (2.0, 2.2)\n        >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n        (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list should contain at least two numbers.\")\n\n    # Sort the list to make it easier to compare adjacent numbers\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate over consecutive elements\n    for i in range(1, len(sorted_numbers)):\n        diff = sorted_numbers[i] - sorted_numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i-1], sorted_numbers[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of least length two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # If the list has only two numbers, return them in sorted order\n    if len(numbers) == 2:\n        return tuple(sorted(numbers))\n\n    # Sort the list to make comparison easier\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate through the sorted list to find the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport itertools\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list for easy iteration over adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables\n    min_diff = float('inf')\n    closest_pair = None\n    \n    # Iterate over pairs of adjacent elements in the sorted list\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Ensure list has at least two numbers\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers\")\n    \n    # Sorting numbers to easily check distances between adjacent numbers\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport itertools\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list should contain at least two numbers.\")\n\n    # Use itertools.combinations to get all possible pairs\n    pairs = itertools.combinations(numbers, 2)\n    closest_pair = min(pairs, key=lambda x: abs(x[1] - x[0]))\n    \n    # Return in the specified order (smaller, larger)\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of at least two) select and return two that are the closest to each other \n    and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list first to make comparison easier\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    # Loop through adjacent elements in the sorted list\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport sys\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    Args:\n    numbers (List[float]): A list of numbers with at least two elements.\n\n    Returns:\n    Tuple[float, float]: A tuple containing the two closest numbers where the first element is smaller or equal \n                         to the second.\n\n    Raises:\n    ValueError: If the list contains fewer than two elements.\n\n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the numbers for easier comparison\n    sorted_numbers = sorted(numbers)\n    \n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate through the sorted list to find the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" \n    From a supplied list of numbers (of length at least two), select and return \n    two that are the closest to each other. Return them in order from smaller \n    to larger.\n\n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Ensure the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"List should contain at least two numbers.\")\n    \n    # Generate all possible pairs from the list\n    pairs = combinations(numbers, 2)\n    \n    # Find the pair with the smallest difference\n    min_diff = float('inf')\n    closest_pair = None\n    for pair in pairs:\n        # Calculate the difference\n        diff = abs(pair[1] - pair[0])\n        if diff < min_diff or (diff == min_diff and (pair[0] < closest_pair[0] if closest_pair else True)):\n            min_diff = diff\n            closest_pair = pair if pair[0] <= pair[1] else (pair[1], pair[0])\n    \n    return closest_pair", "matching_cluster_idx": 2}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Ensure there are at least two numbers in the list\n    if len(numbers) < 2:\n        raise ValueError(\"The list should contain at least two numbers.\")\n\n    # Sort the list to make it easier to find pairs\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the smallest difference and the pair\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate through the sorted list to compare adjacent pairs\n    for i in range(len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    Examples:\n    ```python\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    ```\n    \"\"\"\n    # Sort the list for easier distance calculation\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the variables with the first two numbers in the sorted list\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the list to find the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of numbers.\n\n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers.\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([1.0, 1.5, 3.5])\n    (1.0, 1.5)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list should contain at least two numbers.\")\n\n    # Sort the list to make it easier to find adjacent numbers\n    sorted_numbers = sorted(numbers)\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_distance = abs(sorted_numbers[0] - sorted_numbers[1])\n\n    # Check all adjacent pairs in the sorted list\n    for i in range(1, len(sorted_numbers) - 1):\n        distance = abs(sorted_numbers[i] - sorted_numbers[i+1])\n        if distance < min_distance:\n            min_distance = distance\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of at least two elements) select and return two that are the closest to each\n    other, returning them in order (smaller number, larger number).\n    \n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([3.5, 5.6, 7.8, 3.5, 9.0])\n    (3.5, 3.5)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list should contain at least two numbers.\")\n    \n    # Sorting the list to make comparison easier\n    sorted_numbers = sorted(numbers)\n    closest = float('inf')\n    result = (sorted_numbers[0], sorted_numbers[1])\n\n    # Loop through the sorted list, comparing adjacent numbers\n    for i in range(len(sorted_numbers) - 1):\n        current_distance = sorted_numbers[i+1] - sorted_numbers[i]\n        if current_distance < closest:\n            closest = current_distance\n            result = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport math\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of least length two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n\n    Raises:\n        ValueError: If the list contains fewer than 2 numbers.\n    \"\"\"\n    # Check if the list has at least 2 elements\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list to simplify the comparison\n    numbers.sort()\n\n    # Initialize with the first pair\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[1] - numbers[0])\n\n    # Iterate through pairs of numbers to find the closest ones\n    for i in range(1, len(numbers) - 1):\n        diff = abs(numbers[i+1] - numbers[i])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of assumed length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list should contain at least two numbers.\")\n    \n    # Sort the list to simplify the search\n    numbers.sort()\n    \n    # Initialize with a large difference\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n    \n    # Iterate through the sorted list\n    for i in range(len(numbers) - 1):\n        current_diff = numbers[i+1] - numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of least length two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    Args:\n        numbers (List[float]): A list of numbers from which to find the closest pair.\n    \n    Returns:\n        Tuple[float, float]: A tuple of the two closest numbers where the first element is smaller or equal to the second.\n    \n    Examples:\n        >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n        (2.0, 2.2)\n        >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n        (2.0, 2.0)\n    \"\"\"\n    # Check if the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make pair comparison easier\n    sorted_numbers = sorted(numbers)\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(closest_pair[1] - closest_pair[0])\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport sys\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Examples:\n    ```python\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    ```\n\n    Args:\n    numbers (List[float]): A list of at least two floating point numbers.\n\n    Returns:\n    Tuple[float, float]: A tuple containing the two closest numbers in order (smaller, larger).\n\n    Raises:\n    ValueError: If the list contains fewer than two elements.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n\n    # Sort the list to simplify finding adjacent pairs\n    sorted_numbers = sorted(numbers)\n    \n    # Use min() with a key function to find the pair with the smallest difference\n    # The key function returns the difference between consecutive elements\n    smallest_diff, idx = min((sorted_numbers[i+1] - sorted_numbers[i], i) \n                             for i in range(len(sorted_numbers) - 1))\n    \n    # Return the pair in order\n    return (sorted_numbers[idx], sorted_numbers[idx+1])", "matching_cluster_idx": 7}]}, "HumanEval/24": {"dps": 68.19727891156462, "dps_norm": 31.875, "pass@1": 93.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    This function checks numbers from n-1 downwards until it finds a number\n    that divides n without a remainder.\n\n    Args:\n    n (int): The number to find the largest divisor for.\n\n    Returns:\n    int: The largest divisor of n that is less than n. If n is less than 2, returns 1.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(8)\n    4\n    >>> largest_divisor(1)\n    1\n    >>> largest_divisor(2)\n    1\n    \"\"\"\n    # If n is less than 2, return 1 as the largest divisor\n    if n < 2:\n        return 1\n    \n    # Start from n-1 and move downwards\n    for i in range(n-1, 1, -1):\n        if n % i == 0:\n            return i\n    \n    # This return is theoretically unreachable since every number has at least 1 as a divisor,\n    # but included for completeness.\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n\n    Args:\n    n (int): The number for which to find the largest divisor.\n\n    Returns:\n    int: The largest number that divides n evenly, smaller than n. \n         Returns 1 if n is prime or if n is less than or equal to 1.\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(17)\n    1\n    >>> largest_divisor(24)\n    12\n    \"\"\"\n    # If n is less than or equal to 1, return 1 as the largest divisor\n    if n <= 1:\n        return 1\n    \n    # Start from n // 2 because a larger factor of the number n would be n//2 or less\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    \n    # If no divisors are found (which shouldn't happen for n > 1 due to the check above),\n    # or if n is prime, return 1\n    return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n    n (int): The number for which to find the largest divisor.\n\n    Returns:\n    int: The largest divisor of n that is less than n.\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(24)\n    12\n    >>> largest_divisor(5)\n    1\n    \"\"\"\n    # The largest possible divisor that is less than n is n-1\n    for i in range(n - 1, 1, -1):  # Start from n-1 and decrement to 2\n        if n % i == 0:\n            return i\n    # If no divisors are found (i.e., if n is prime), return 1 because every integer is divisible by 1\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    This function iterates from n-1 down to 1 to find the first number \n    (and thus the largest) that divides n without a remainder.\n\n    Args:\n        n (int): The number to find the largest divisor for.\n\n    Returns:\n        int: The largest integer divisor of n, excluding n itself.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(17)\n        1\n        >>> largest_divisor(24)\n        12\n    \"\"\"\n    # We start from n-1 because n itself is not considered as a divisor\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    \n    # If no divisor is found (which shouldn't happen for integers > 1), return 1 as the default smallest divisor\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n    \n    This function starts from n-1 and decrements, checking each number to see if it divides n without a remainder.\n\n    Args:\n    n (int): The number for which the largest divisor is to be found.\n\n    Returns:\n    int: The largest divisor of n that is less than n.\n\n    Raises:\n    ValueError: If n is less than or equal to 1, since there are no divisors smaller than 1.\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(24)\n    12\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"The number must be greater than 1.\")\n\n    # Start from n-1 and decrease because we need the largest divisor less than n\n    for i in range(n - 1, 1, -1):  \n        if n % i == 0:\n            return i\n    return 1  # If no other number divides n (which only happens for prime numbers), 1 is the answer", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"Find the largest number that divides n evenly, which is smaller than n.\n\n    Args:\n        n (int): The number for which to find the largest divisor.\n\n    Returns:\n        int: The largest number that divides n evenly, excluding n itself.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(7)\n        1\n        >>> largest_divisor(100)\n        50\n    \"\"\"\n    # Start from the largest possible divisor below n\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n    \n    # If no divisors found (which should only happen for n == 1 or prime numbers)\n    return 1", "matching_cluster_idx": 1}, {"solution": "import doctest\ndef largest_divisor(n: int) -> int:\n    \"\"\" \n    Finds the largest number that divides n evenly, excluding n itself.\n    \n    Args:\n    n (int): A positive integer\n\n    Returns:\n    int: The largest divisor of n less than n. If n is prime, returns 1.\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(7)  # Prime number\n    1\n    \"\"\"\n    # If n is 1 or 2, 1 is the only divisor smaller than n\n    if n <= 2:\n        return 1\n    \n    # Start checking from the largest possible integer less than n down to 2\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n    \n    # This line should not be reached unless n is prime\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    This function iterates from n-1 down to 2, checking for divisibility.\n    If n is 1 or 2, the function returns 1 since 1 is the only number smaller than \n    or equal to 2 that divides these numbers without remainder.\n\n    Args:\n        n (int): The number to find the largest divisor for.\n\n    Returns:\n        int: The largest number less than n that divides n evenly.\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(6)\n    3\n    >>> largest_divisor(1)\n    1\n    \"\"\"\n    # Handle edge cases\n    if n in [1, 2]:\n        return 1\n    \n    # Start from n-1 and move down to find the largest divisor\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n\n    # If no divisor is found, which should not occur for n > 2, return 1\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(8)\n    4\n    >>> largest_divisor(3)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    # Handle special cases\n    if n <= 1:\n        return 1  # 1 and any number less than or equal to 1 have 1 as the largest divisor\n\n    # Start from n // 2 because a divisor must be smaller than n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    \n    # This line should never be reached due to the above logic, but included for robustness\n    return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    This function starts from n-1 and checks each number down to 1 to find \n    the largest divisor. However, for optimization, we can stop at the square \n    root of n, since if n is not a prime, any factor larger than sqrt(n) will \n    have a corresponding factor smaller than sqrt(n).\n    \n    Args:\n    n (int): The number to find the largest divisor for.\n    \n    Returns:\n    int: The largest divisor of n less than n itself, or 1 if n is prime.\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(17)  # Prime number\n    1\n    >>> largest_divisor(24)\n    12\n    \"\"\"\n    # Handle special cases\n    if n <= 1:\n        return 1\n    \n    # Start from the number one less than n and go down\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n    \n    # If no divisor was found, n is prime, and the largest divisor is 1\n    return 1", "matching_cluster_idx": 1}, {"solution": "import doctest\ndef largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \n    This function looks for the largest divisor of n that is less than n by:\n    - Iterating through potential divisors from n-1 down to 1.\n    - Checking if the number divides n without remainder.\n    \n    Args:\n        n (int): The number to find the largest divisor for.\n\n    Returns:\n        int: The largest number that divides n evenly, which is less than n.\n        If n is less than 2, the function returns 1, as any number divides 1.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(1)\n        1\n        >>> largest_divisor(2)\n        1\n    \"\"\"\n    # Edge case: for numbers less than 2, 1 is the only and largest divisor\n    if n < 2:\n        return 1\n    \n    # Start from n-1 and decrement to find the largest divisor\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n    \n    # This line should not be reached for valid inputs, but included for completeness\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n    n (int): The number to find the largest divisor for.\n\n    Returns:\n    int: The largest divisor of n that is less than n.\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(17)\n    1\n    >>> largest_divisor(1)\n    1\n    \"\"\"\n    # Handle edge cases\n    if n < 1:\n        raise ValueError(\"Number should be positive\")\n    if n == 1:\n        return 1\n    \n    # Start from the middle point and move towards the lower numbers\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n\n    # If no divisors found (shouldn't happen for any n > 1)\n    return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    Args:\n    n (int): The number to find the largest divisor for.\n    \n    Returns:\n    int: The largest divisor of n that is smaller than n itself.\n    \n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(8)\n    4\n    >>> largest_divisor(1)\n    1  # No divisors less than 1, so returns 1 itself\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    # We start from n//2 since no number larger than or equal to n can divide n without remainder\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \n    Args:\n    n (int): The number to find the largest divisor for.\n\n    Returns:\n    int: The largest divisor of n that is less than n.\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(36)\n    18\n    \"\"\"\n    # Start from n-1 and go down to 1, looking for the largest divisor\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    This function iterates from n-1 down to 1 to find the first number that divides n without a remainder.\n\n    Args:\n    n (int): The number to find the largest divisor for.\n\n    Returns:\n    int: The largest number less than n that divides n evenly.\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(17)\n    1\n    >>> largest_divisor(24)\n    12\n\n    Raises:\n    ValueError: If n is less than or equal to 1.\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"The number must be greater than 1.\")\n\n    # Start from n-1 and go down to find the largest divisor\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n    # If no divisor other than 1 is found\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    This function iterates from n-1 down to 2 to find the first (and thus largest) \n    number that divides n without a remainder.\n\n    Args:\n        n (int): The number to find the largest divisor for. Must be greater than 1.\n\n    Returns:\n        int: The largest number less than n that divides n evenly.\n\n    Raises:\n        ValueError: If n is less than or equal to 1.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(36)\n        18\n        >>> largest_divisor(7)\n        1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n\n    # We start from n-1 because we're looking for a divisor less than n\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n\n    # In case n is prime, its only divisors will be 1 and itself\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \n    This function iterates from n-1 down to 1 to find the first divisor, which by definition \n    would be the largest divisor smaller than n.\n\n    Args:\n    n (int): The number to find the largest divisor for.\n\n    Returns:\n    int: The largest divisor of n that is less than n.\n\n    Raises:\n    ValueError: If n is less than or equal to 1, as it has no divisors less than itself.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(13)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1 to have a divisor less than itself.\")\n    \n    # Start from n-1 because no number can evenly divide itself in this context\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    Finds the largest number that divides n evenly and is smaller than n.\n    \n    Args:\n    n (int): The number to find the largest divisor for.\n    \n    Returns:\n    int: The largest divisor of n that is less than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(17)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    # Handle edge cases\n    if n <= 1:\n        return 1\n    \n    # Start from n - 1 down to 2\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n    # If no divisor is found, n would be prime or 1, return 1 as per the example\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n    n (int): The number for which to find the largest divisor.\n\n    Returns:\n    int: The largest divisor of n that is less than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(10)\n    5\n    >>> largest_divisor(33)\n    11\n    \"\"\"\n    # Start from n-1 and work downwards to find the first number that divides n\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n    # If we've made it through the loop, n is prime, so return 1 as the only divisor\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    This function iterates from n/2 downwards to find the largest divisor of n other than itself.\n    \n    Args:\n        n (int): The number to find the largest divisor for.\n\n    Returns:\n        int: The largest divisor of n that is smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(10)\n        5\n        >>> largest_divisor(30)\n        15\n    \"\"\"\n    # Start from n//2 because a larger factor of n must pair with a number less than or equal to n/2\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    # If no divisors are found other than 1, return 1\n    return 1", "matching_cluster_idx": 4}]}, "HumanEval/26": {"dps": 74.4, "dps_norm": 86.25, "pass@1": 95.0, "profiled": [{"solution": "from typing import List\nfrom collections import OrderedDict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    Args:\n        numbers (List[int]): The list of integers to process.\n    \n    Returns:\n        List[int]: A new list with duplicates removed, preserving order of first occurrence.\n    \n    Examples:\n        >>> remove_duplicates([1, 2, 3, 2, 4])\n        [1, 3, 4]\n    \"\"\"\n    # Use OrderedDict to maintain order and count occurrences\n    occurrence_count = OrderedDict.fromkeys(numbers, 0)\n    for num in numbers:\n        occurrence_count[num] += 1\n\n    # Filter out elements that occur more than once\n    result = [num for num, count in occurrence_count.items() if count == 1]\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\nimport doctest\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n    \n    for number in numbers:\n        if number not in seen:\n            seen.add(number)\n            result.append(number)\n        elif number not in duplicates:\n            result.remove(number)\n            duplicates.add(number)\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\nfrom collections import OrderedDict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Use OrderedDict to maintain the order of insertion while removing duplicates\n    # Keep only the first occurrence of each number\n    return list(OrderedDict.fromkeys([num for num in numbers if numbers.count(num) == 1]))", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n\n    Args:\n    numbers (List[int]): A list of integers which might contain duplicates.\n\n    Returns:\n    List[int]: A list where all elements that appear more than once in the input have been removed.\n\n    Example:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Dictionary to count occurrences of each number\n    count = {}\n    \n    # List to maintain the order for elements to keep\n    result = []\n    \n    for num in numbers:\n        # Increment the count for the current number\n        count[num] = count.get(num, 0) + 1\n    \n    # Second pass to build the result list\n    for num in numbers:\n        # If the number appears only once, we keep it\n        if count[num] == 1:\n            result.append(num)\n            # We set the count to a sentinel value so we won't check it again\n            count[num] = -1\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    Args:\n    numbers (List[int]): A list of integers where duplicates might exist.\n    \n    Returns:\n    List[int]: A new list with all duplicates removed while maintaining original order.\n    \n    Examples:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = Counter(numbers)\n    \n    # Create a list that keeps numbers occurring only once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    \n    Args:\n    numbers (List[int]): A list of integers which might contain duplicates.\n\n    Returns:\n    List[int]: A new list where each element only appears once, maintaining the order \n               of first appearance from the original list.\n\n    Examples:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to keep track of how many times each number has appeared\n    # and another to store the order of first appearance for each number\n    occurrences = {}\n    order = {}\n    result = []\n\n    # Count occurrences and determine the order\n    for i, num in enumerate(numbers):\n        if num not in order:\n            order[num] = i\n        occurrences[num] = occurrences.get(num, 0) + 1\n\n    # Build the result list. Only include numbers that appear exactly once\n    for num, count in occurrences.items():\n        if count == 1:\n            result.append(numbers[order[num]])\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n    numbers (List[int]): A list of integers where duplicates might exist.\n\n    Returns:\n    List[int]: A list with all duplicates removed while preserving the order of first occurrence.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 1, 2, 3])\n    [2, 3]\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    # Dictionary to keep track of how many times an element has been seen\n    seen = {}\n    \n    # Result list to maintain order\n    result = []\n\n    for num in numbers:\n        if num not in seen:\n            # If we've never seen this number before, add it to result\n            seen[num] = 1\n            result.append(num)\n        elif seen[num] == 1:\n            # If we've seen this number once before, we're about to see it a second time\n            seen[num] += 1\n            # Remove the number from the result since it's now a duplicate\n            result.remove(num)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    Args:\n    numbers (List[int]): A list of integers where duplicates should be removed.\n\n    Returns:\n    List[int]: A new list with all duplicates removed.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 1, 2, 3, 3])\n    [2]\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    # Count the occurrences of each number\n    count = Counter(numbers)\n    \n    # Filter numbers that appear exactly once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers which might contain duplicates.\n\n    Returns:\n        List[int]: A list where elements that appear more than once in the input \n                   have been removed, preserving the order of the remaining elements.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([5, 5, 6, 7, 7, 8])\n    [6, 8]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    \"\"\"\n    # Count occurrences of each number\n    count = Counter(numbers)\n    \n    # Use a list comprehension to include only numbers that appear exactly once\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    Examples:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([1, 2, 3, 4])\n    [1, 2, 3, 4]\n    \"\"\"\n    # Dictionary to count occurrences\n    count = {}\n    result = []\n    \n    # Count the occurrence of each number\n    for num in numbers:\n        count[num] = count.get(num, 0) + 1\n    \n    # Build the result list only with numbers that occur once\n    for num in numbers:\n        if count[num] == 1:\n            result.append(num)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n    numbers (List[int]): A list of integers where duplicates need to be removed.\n\n    Returns:\n    List[int]: A list with elements that occur only once in the original list, \n               in the order they first appeared.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 1, 2, 3, 3, 4, 5, 5])\n    [2, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count = Counter(numbers)\n    \n    # Filter out numbers that appear more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): The list of integers to process.\n\n    Returns:\n        List[int]: A new list with duplicates removed.\n\n    Examples:\n        >>> remove_duplicates([1, 2, 3, 2, 4])\n        [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = Counter(numbers)\n    \n    # Use a list comprehension to keep only numbers that appear exactly once\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    Args:\n    numbers (List[int]): A list of integers which may contain duplicates.\n    \n    Returns:\n    List[int]: A new list with all duplicates removed, maintaining the original order.\n\n    Examples:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 2, 3, 4, 4])\n    [2, 3]\n    \"\"\"\n    # Use a dictionary to count occurrences while maintaining order\n    count = {}\n    result = []\n    \n    for num in numbers:\n        if num in count:\n            count[num] += 1\n            # If we've seen this number before, it's a duplicate, remove it from result if it was added\n            if count[num] == 2 and num in result:\n                result.remove(num)\n        else:\n            count[num] = 1\n            result.append(num)\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers where duplicates need to be removed.\n\n    Returns:\n        List[int]: A new list with unique elements maintaining original order.\n\n    Examples:\n        >>> remove_duplicates([1, 2, 3, 2, 4])\n        [1, 3, 4]\n    \"\"\"\n    # Use a set to count occurrences\n    from collections import Counter\n    counts = Counter(numbers)\n    # Keep only elements that appear once\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n    numbers (List[int]): A list of integers where duplicates are to be removed.\n\n    Returns:\n    List[int]: A list containing elements from 'numbers' that do not occur more than once, \n               with original order preserved.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1,1,1,2,3,4,4])\n    [2, 3]\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    # Count the occurrences of each number\n    count = Counter(numbers)\n    \n    # Use a list comprehension to include only elements that appear once\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import OrderedDict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n    numbers (List[int]): A list of integers where duplicates are to be removed.\n\n    Returns:\n    List[int]: A new list with all elements that occur only once.\n\n    Example:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Use OrderedDict to keep track of the first occurrence of each number\n    # and its count\n    occurrence = OrderedDict()\n    for num in numbers:\n        if num in occurrence:\n            occurrence[num] += 1\n        else:\n            occurrence[num] = 1\n    \n    # Construct a new list with numbers that appeared only once\n    result = [num for num, count in occurrence.items() if count == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    Args:\n    numbers (List[int]): A list of integers where duplicates should be removed.\n    \n    Returns:\n    List[int]: A new list with elements that appeared only once in the original list.\n    \n    Examples:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 2, 3, 3, 4])\n    [2, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count = Counter(numbers)\n    \n    # Filter numbers that appear only once\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    Args:\n    numbers (List[int]): The list of integers to process.\n    \n    Returns:\n    List[int]: A new list with duplicates removed.\n    \n    Example:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = Counter(numbers)\n    \n    # Use list comprehension to keep only those numbers that appear exactly once\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import OrderedDict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    Args:\n    numbers (List[int]): A list of integers where duplicates need to be removed.\n\n    Returns:\n    List[int]: A list with duplicates removed, maintaining the original order of first occurrence.\n\n    Examples:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 1, 2, 3])\n    [2, 3]\n    \"\"\"\n    # Use OrderedDict to keep the order of elements as they appear first time\n    # We'll use a dict comprehension to add items to OrderedDict\n    # Only the first occurrence of each number is added\n    # Any subsequent occurrence will overwrite the first, effectively keeping only one instance\n    return list(OrderedDict((num, None) for num in numbers if numbers.count(num) == 1).keys())", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n    numbers (List[int]): A list of integers which might contain duplicates.\n\n    Returns:\n    List[int]: A new list with duplicates removed, preserving the order of first occurrence.\n\n    Example:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count = Counter(numbers)\n    \n    # Use list comprehension to keep only numbers that occur exactly once\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 87.59493670886076, "dps_norm": 83.75, "pass@1": 99.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n\n    Examples:\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # 1 is not considered prime by definition\n    if n <= 1:\n        return False\n    \n    # 2 is the smallest prime number\n    if n == 2:\n        return True\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return False\n    \n    # Check for divisibility by odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    # If we haven't found any divisors, the number is prime\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    Examples:\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Numbers less than or equal to 1 are not prime by definition\n    if n <= 1:\n        return False\n    \n    # 2 is the only even prime number\n    if n == 2:\n        return True\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return False\n    \n    # Check odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    Args:\n    n (int): The number to check for primality.\n    \n    Returns:\n    bool: True if n is prime, False otherwise.\n    \n    Examples:\n    ```python\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    ```\n    \"\"\"\n    # Prime numbers are greater than 1\n    if n <= 1:\n        return False\n    \n    # Check for divisibility by numbers from 2 to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    # If we've made it here, n is prime\n    return True", "matching_cluster_idx": 4}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return False\n    \n    # 2 is prime\n    if n == 2:\n        return True\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return False\n    \n    # Check for divisibility up to the square root of n for efficiency\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Check if n is less than 2, which are not primes by definition\n    if n < 2:\n        return False\n    \n    # Only need to check up to the square root of n for efficiency\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    # Check if n is less than 2, which are not prime by definition\n    if n < 2:\n        return False\n    \n    # 2 is prime\n    if n == 2:\n        return True\n    \n    # Even numbers other than 2 are not prime\n    if n % 2 == 0:\n        return False\n    \n    # Check for odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    Examples:\n    ```python\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    ```\n    \"\"\"\n    # Handle special cases\n    if n <= 1:\n        return False\n    if n == 2:  # 2 is prime\n        return True\n    \n    # Check for primality\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    # Check odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    Examples:\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Handle special cases\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return False\n    \n    # Check for divisibility by odd numbers up to sqrt(n)\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    # If no divisors found, n is prime\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    \n    Examples:\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return False\n    \n    # 2 is the only even prime number\n    if n == 2:\n        return True\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return False\n    \n    # Check odd numbers up to the square root of n\n    import math\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    Examples:\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Numbers less than 2 are not prime by definition\n    if n < 2:\n        return False\n    \n    # 2 is the only even prime number\n    if n == 2:\n        return True\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return False\n    \n    # Check odd numbers up to the square root of n for factors\n    # This optimization is based on the fact that if n is not prime,\n    # it will have a factor less than or equal to sqrt(n)\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    # If no divisors were found, n is prime\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    # Handle edge cases first\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    # Check for primality up to the square root of n for efficiency\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    Examples:\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Check if n is less than 2 (not prime by definition)\n    if n < 2:\n        return False\n    \n    # 2 is the only even prime number\n    if n == 2:\n        return True\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return False\n    \n    # Check odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return False\n    \n    # 2 is the only even prime number\n    if n == 2:\n        return True\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return False\n    \n    # Check odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    # 1 is not prime by definition\n    if n <= 1:\n        return False\n    \n    # 2 is the only even prime number\n    if n == 2:\n        return True\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return False\n    \n    # Check for primality up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    Examples:\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Handle edge cases:\n    # - 1 is not considered prime by definition\n    if n <= 1:\n        return False\n    \n    # 2 is the smallest prime number\n    if n == 2:\n        return True\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return False\n\n    # Check for odd divisors up to the square root of n\n    # This reduces the time complexity from O(n) to O(sqrt(n))\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n\n    # If no divisors were found, n is prime\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    # Prime numbers are greater than 1\n    if n <= 1:\n        return False\n    # 2 is prime \n    if n == 2:\n        return True\n    # Even numbers other than 2 are not prime\n    if n % 2 == 0:\n        return False\n    # Check odd numbers up to the square root of n\n    # This reduces the number of checks significantly\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Numbers less than or equal to 1 are not prime by definition\n    if n <= 1:\n        return False\n    # 2 is prime\n    if n == 2:\n        return True\n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return False\n    \n    # Check odd numbers up to the square root of n\n    # This is an optimization; we don't need to check beyond sqrt(n)\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    # Numbers less than or equal to 1 are not prime by definition\n    if n <= 1:\n        return False\n    # 2 is prime\n    if n == 2:\n        return True\n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return False\n    \n    # Check odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n\n    Examples:\n    ```python\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    ```\n    \"\"\"\n    # Numbers less than or equal to 1 are not prime by definition\n    if n <= 1:\n        return False\n    \n    # 2 is the only even prime number\n    if n == 2:\n        return True\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return False\n    \n    # Check for divisibility from 3 to sqrt(n). We only need to go up to sqrt(n)\n    # because if n is divisible by something larger than sqrt(n), it would also\n    # be divisible by something smaller than sqrt(n).\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": 97.22222222222223, "dps_norm": 81.81818181818181, "pass@1": 67.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n\n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Initialize result list with all elements from l\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with sorted values\n    j = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_third[j]\n            j += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n\n    Args:\n    l (list): The input list to be partially sorted.\n\n    Returns:\n    list: A new list with elements at indices divisible by 3 sorted.\n\n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices that are divisible by 3\n    thirds = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    thirds_sorted = sorted(thirds)\n    \n    # Create a new list where only the elements at indices divisible by 3 are changed\n    result = l[:]  # Copy the list to avoid modifying the original\n    j = 0  # Counter for the sorted thirds list\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = thirds_sorted[j]\n            j += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l at indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n\n    Args:\n    l (list): The input list to be partially sorted.\n\n    Returns:\n    list: A new list where every third element from the original list has been sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 5, 9, 8]\n    \"\"\"\n    # Extract elements at indices divisible by 3, sort them, and store in a separate list\n    thirds = sorted(l[i] for i in range(0, len(l), 3))\n    \n    # Reconstruct the list with sorted elements at positions divisible by 3\n    result = l.copy()\n    third_index = 0\n    for i in range(0, len(l), 3):\n        if i < len(l):\n            result[i] = thirds[third_index]\n            third_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l):\n    \"\"\"\n    This function takes a list l and returns a list l' such that:\n    - l' is identical to l in the indices that are not divisible by three,\n    - l's values at indices divisible by three are sorted.\n\n    Parameters:\n    l (list): The input list to be modified.\n\n    Returns:\n    list: A new list where elements at every third index are sorted.\n\n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Filter out elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    third_elements.sort()\n\n    # Create the result list by:\n    # - Placing back the sorted third elements\n    # - Filling in the rest from the original list\n    result = l[:]  # Start with a copy of l\n    j = 0\n    for i in range(0, len(l), 3):\n        result[i] = third_elements[j]\n        j += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Collect the elements at indices divisible by 3\n    third_positions = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third_positions = sorted(third_positions)\n    \n    # Reconstruct the list with sorted elements at third positions\n    result = l.copy()\n    for i, val in zip(range(0, len(l), 3), sorted_third_positions):\n        result[i] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_indices = l[::3]\n    sorted_third = sorted(third_indices)  # Sort these elements\n    \n    # Create a result list with the same length as l\n    result = l.copy()  # Start with a copy of the original list\n    \n    # Replace elements at indices divisible by 3 with sorted ones\n    for i, val in enumerate(sorted_third):\n        result[3*i] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    Args:\n    l (list): The input list to be modified.\n    \n    Returns:\n    list: A new list with elements at indices divisible by 3 sorted, others unchanged.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Initialize result list with the same length as l, filled with None\n    result = [None] * len(l)\n    \n    # Placeholder for position in sorted_third\n    sort_index = 0\n    \n    # Fill in the result list\n    for i in range(len(l)):\n        if i % 3 == 0:  # If index is divisible by 3, take from sorted list\n            result[i] = sorted_third[sort_index]\n            sort_index += 1\n        else:  # Otherwise, keep the original value\n            result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \n    Args:\n    l (list): The input list to be sorted.\n\n    Returns:\n    list: A new list where every third element (starting from index 0) is sorted.\n\n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    if len(l) < 3:\n        return l  # If the list has less than 3 elements, no sorting needed\n    \n    # Collect values at indices divisible by 3\n    third_values = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these collected values\n    third_values.sort()\n    \n    # Create a result list by iterating through the original list\n    # and replacing every third element with the sorted values\n    result = l[:]  # Copy the list to not modify the original\n    third_index = 0\n    for i in range(0, len(l), 3):\n        if i < len(l):\n            result[i] = third_values[third_index]\n            third_index += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    Args:\n    l (list): The input list to be modified.\n    \n    Returns:\n    list: A modified list where elements at indices divisible by three are sorted.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by 3\n    third_indices = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these values\n    sorted_third = sorted(third_indices)\n    \n    # Create the result list\n    result = l[:]  # Start with a copy of the original list\n    \n    # Replace elements at indices divisible by 3 with sorted values\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_third[third_index]\n            third_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l):\n    \"\"\"\n    This function sorts every third element of the given list while leaving other elements unchanged.\n\n    Parameters:\n    l (list): The input list to be partially sorted.\n\n    Returns:\n    list: A new list where only the elements at indices divisible by 3 are sorted.\n\n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 5, 9, 8]\n    \"\"\"\n    # Filter out every third element\n    thirds = [val for i, val in enumerate(l) if i % 3 == 0]\n    # Sort these elements\n    sorted_thirds = sorted(thirds)\n    \n    # Create a new list with the same length as l\n    result = l.copy()\n    # Put the sorted elements back into their respective positions\n    idx = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_thirds[idx]\n            idx += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    sorted_third_elements = sorted(third_elements)\n    \n    # Initialize result list with None values\n    result = [None] * len(l)\n    \n    # Place sorted third elements back into their positions\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_third_elements[third_index]\n            third_index += 1\n        else:\n            # Keep non-third indices the same\n            result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 5, 9, 8]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these elements\n    sorted_vals = sorted(to_sort)\n    \n    # Create a list to store the result\n    result = l.copy()\n    \n    # Replace the values at indices divisible by 3 with sorted values\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_vals[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list `l` and returns a list `l'` where:\n    - Elements at indices not divisible by 3 remain unchanged.\n    - Elements at indices divisible by 3 are sorted in ascending order.\n\n    Args:\n    l (list): The input list to be sorted.\n\n    Returns:\n    list: A new list where every third element from the start has been sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_thirds = sorted(third_elements)\n    \n    # Reconstruct the list\n    result = l[:]  # Make a copy to not modify the original list\n    third_index = 0\n    for i in range(0, len(l), 3):\n        if third_index < len(sorted_thirds):\n            result[i] = sorted_thirds[third_index]\n            third_index += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n\n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Collect elements from indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_thirds = sorted(third_elements)\n    \n    # Initialize the result list\n    result = l.copy()\n    \n    # Update the list with sorted values at indices divisible by 3\n    j = 0\n    for i in range(0, len(l), 3):\n        result[i] = sorted_thirds[j]\n        j += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Filter out elements at indices divisible by 3\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these elements\n    sorted_third_elements = sorted(third_elements)\n    \n    # Create the result list by replacing elements at indices divisible by 3 with sorted elements\n    result = l[:]  # Start with a copy of l\n    j = 0  # Index for sorted_third_elements\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_third_elements[j]\n            j += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that:\n    - l' is identical to l in the indices that are not divisible by three.\n    - Its values at the indices that are divisible by three are equal to the values of the corresponding indices of l, but sorted.\n\n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n\n    :param l: Input list of numbers\n    :return: Processed list as per the given condition\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_3 = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    sorted_divisible = sorted(divisible_by_3)\n    \n    # Initialize result list with the same length as the input list\n    result = [None] * len(l)\n    divisible_index = 0\n\n    # Fill the result list\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible[divisible_index]\n            divisible_index += 1\n        else:\n            result[i] = l[i]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \n    Args:\n    l (list): The input list to be partially sorted.\n\n    Returns:\n    list: A new list where elements at indices divisible by 3 are sorted, others remain in place.\n\n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    to_sort = [l[i] for i in range(0, len(l), 3)]\n    to_sort.sort()\n    \n    # Reconstruct the list, placing sorted elements back at their original positions\n    result = l[:]\n    sort_index = 0\n    for i in range(0, len(l), 3):\n        if i < len(l):\n            result[i] = to_sort[sort_index]\n            sort_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these elements\n    sorted_third = sorted(to_sort)\n    \n    # Create a new list with sorted elements back in place\n    result = l[:]  # Make a copy of l\n    sort_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_third[sort_index]\n            sort_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n\n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    thirds = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these elements\n    thirds_sorted = sorted(thirds)\n    \n    # Create the result list\n    result = list(l)\n    \n    # Index for sorted thirds\n    idx = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            # Replace with sorted value from the thirds list\n            result[i] = thirds_sorted[idx]\n            idx += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that:\n    - l' is identical to l in the indices that are not divisible by three,\n    - its values at the indices that are divisible by three are sorted.\n\n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third_elements = sorted(third_elements)\n    \n    # Create the result list\n    result = l.copy()  # Start with a copy of the original list\n    \n    # Put sorted elements back into their original positions\n    j = 0\n    for i in range(0, len(l), 3):\n        if i < len(l):\n            result[i] = sorted_third_elements[j]\n            j += 1\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    This function removes duplicates from the list and then sorts the result.\n    \n    Args:\n    l (list): A list containing possibly duplicate elements.\n\n    Returns:\n    list: A new list with unique elements sorted in ascending order.\n\n    Examples:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then back to list for sorting\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert list to set to remove duplicates, then convert back to list and sort\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then sort it back to a list\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list\n    \n    Args:\n    l (list): The list to process.\n    \n    Returns:\n    list: A new list containing unique elements from the input list, sorted in ascending order.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert list to a set to remove duplicates, then back to list and sort it\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n\n    Examples:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert list to a set to remove duplicates, then back to a list and sort it\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \n    Args:\n        l (list): The input list which may contain duplicates.\n    \n    Returns:\n        list: A new list containing only the unique elements of `l`, sorted in ascending order.\n    \n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert list to a set to remove duplicates, then sort the set before converting back to a list\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    \n    This function takes a list, removes duplicates, sorts the remaining\n    elements, and returns them in a new list.\n\n    Args:\n    l (list): A list of elements which might include duplicates.\n\n    Returns:\n    list: A new sorted list containing only the unique elements.\n\n    Examples:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert list to set to remove duplicates then convert back to list and sort\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    This function takes a list of any comparable items, removes duplicates by converting\n    the list to a set, and then sorts the resulting unique elements.\n\n    Args:\n        l (list): The input list which might contain duplicates.\n\n    Returns:\n        list: A new list containing only the unique elements from `l`, sorted in ascending order.\n\n    Examples:\n    ```python\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    ```\n    \"\"\"\n    # Convert list to set to remove duplicates, then back to list for sorting\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    This function removes duplicate elements from the input list, \n    returning a new list containing only the unique elements in ascending order.\n\n    Args:\n        l (list): A list of elements which might contain duplicates.\n\n    Returns:\n        list: A new list with unique elements sorted in ascending order.\n\n    Examples:\n    ```python\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    ```\n    \"\"\"\n    # Use set for efficient removal of duplicates, then convert back to list and sort\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    \n    Args:\n        l (list): The input list which might contain duplicates.\n    \n    Returns:\n        list: A new list with unique elements sorted in ascending order.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert list to a set to remove duplicates, then back to list and sort it\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef unique(l: List) -> List:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    This function removes duplicates from the input list,\n    and returns a new list containing the unique elements in ascending order.\n\n    Examples:\n    ```python\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    ```\n    \"\"\"\n    # Convert list to set to remove duplicates, then back to list and sort\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    \n    This function takes a list of elements, removes duplicates, and returns \n    the list sorted in ascending order.\n\n    Examples:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert list to set to remove duplicates\n    # Then convert back to list and sort\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"\n    Return sorted unique elements in a list.\n    \n    This function takes a list, removes duplicate elements, \n    sorts the remaining elements, and returns the result.\n\n    Args:\n    l (list): A list of items to be processed.\n\n    Returns:\n    list: A new list with unique, sorted elements.\n\n    Example:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert list to a set to remove duplicates, then back to a list and sort\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    \n    This function takes a list of elements, removes duplicates, sorts the \n    remaining elements, and returns them as a new list.\n\n    Examples:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \n    Args:\n        l (list): The input list which might contain duplicate elements.\n\n    Returns:\n        list: A new list with sorted unique elements.\n\n    \"\"\"\n    # Convert list to set to remove duplicates, then back to list for sorting\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    Args:\n    l (list): A list of elements.\n\n    Returns:\n    list: A new list containing sorted, unique elements from the input list.\n\n    Example:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert list to set to remove duplicates, then convert back to list and sort\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    This function takes a list as input, removes duplicate elements,\n    sorts the remaining elements, and returns the result.\n\n    Args:\n        l (list): The list which contains elements to be uniquified and sorted.\n\n    Returns:\n        list: A new list with unique elements sorted in ascending order.\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert list to a set to remove duplicates\n    unique_set = set(l)\n    # Convert back to list and sort\n    return sorted(list(unique_set))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list\n\n    Args:\n    l (list): The input list containing possibly duplicate elements.\n\n    Returns:\n    list: A new list with unique elements sorted in ascending order.\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Use a set to remove duplicates, then convert back to a list and sort\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    \n    Examples:\n    ```python\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    ```\n    \n    Args:\n        l (list): The list containing possible duplicates.\n    \n    Returns:\n        list: A new list with unique elements sorted in ascending order.\n    \"\"\"\n    # Convert list to a set to remove duplicates, then back to list for sorting\n    unique_elements = list(set(l))\n    # Sort the list in ascending order\n    unique_elements.sort()\n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    \n    Args:\n        l (list): Input list which might contain duplicate elements.\n    \n    Returns:\n        list: A new list containing the sorted unique elements of l.\n    \n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then back to list for sorting\n    # Sort the list since sets do not maintain order\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n\n    This function takes a list of elements, removes duplicates, sorts the elements,\n    and returns the resulting list.\n\n    Args:\n        l (list): A list of elements which could contain duplicates.\n\n    Returns:\n        list: A new list with unique elements sorted in ascending order.\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then back to a list\n    # and sort the list\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 98.0, "profiled": [{"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n    n (int): The upper limit for checking numbers.\n\n    Returns:\n    int: Count of 7's in numbers divisible by 11 or 13.\n\n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        # Check if the number is divisible by 11 or 13\n        if num % 11 == 0 or num % 13 == 0:\n            # Count the occurrences of '7' in the string representation of the number\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n    n (int): An integer up to which to check the numbers.\n\n    Returns:\n    int: Count of digit 7 occurrences in numbers below n that are divisible by 11 or 13.\n\n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        # Check if the number is divisible by 11 or 13\n        if num % 11 == 0 or num % 13 == 0:\n            # Count occurrences of '7' in the string representation of the number\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n    n (int): The upper bound for the numbers to check.\n    \n    Returns:\n    int: Count of the digit 7 in numbers meeting the criteria.\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            # Convert number to string to easily count digit occurrences\n            if '7' in str(num):\n                count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    This function iterates through numbers from 1 to n-1, checks if they are divisible by 11 or 13, \n    and then counts occurrences of the digit '7' in these numbers.\n\n    Args:\n    n (int): The upper limit (exclusive) for checking numbers.\n\n    Returns:\n    int: Count of digit '7' appearances in numbers divisible by 11 or 13.\n\n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            # Check each digit in the number\n            for digit in str(i):\n                if digit == '7':\n                    count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_digit_seven(number: int) -> int:\n    \"\"\"Count the occurrences of the digit 7 in the given number.\"\"\"\n    return str(number).count('7')\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += count_digit_seven(i)\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n        n (int): The upper bound of the range to check, not inclusive.\n\n    Returns:\n        int: Count of 7s in numbers less than n that are divisible by 11 or 13.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            # Convert number to string to easily count occurrences of '7'\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n        n (int): The upper limit to check (exclusive).\n\n    Returns:\n        int: Count of the digit 7 in numbers less than n divisible by 11 or 13.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    # Check numbers from 1 to n-1\n    for num in range(1, n):\n        # If the number is divisible by 11 or 13\n        if num % 11 == 0 or num % 13 == 0:\n            # Convert number to string to count occurrences of '7'\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        # Check if the number is divisible by 11 or 13\n        if num % 11 == 0 or num % 13 == 0:\n            # Count the occurrences of the digit '7' in the number\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \n    Args:\n        n (int): The upper limit (exclusive) for numbers to check.\n\n    Returns:\n        int: Count of 7's in the appropriate numbers.\n    \"\"\"\n    count = 0\n    # Check for multiples of 11 and 13 up to n\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper bound (exclusive) for checking numbers.\n\n    Returns:\n        int: Count of digit 7 occurrences in numbers divisible by 11 or 13.\n\n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        # Check if the number is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Count the occurrences of '7' in the number\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n    n (int): The upper limit (exclusive) to check.\n\n    Returns:\n    int: Count of 7s in the numbers divisible by 11 or 13.\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            # Convert number to string for easy digit checking\n            num_str = str(num)\n            # Count how many times '7' appears in the string representation\n            count += num_str.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            # Check if '7' is in the number as a string\n            if '7' in str(i):\n                count += str(i).count('7')  # Count all occurrences of 7 in the number\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Args:\n    n (int): The upper bound exclusive limit for checking numbers.\n\n    Returns:\n    int: The count of digit '7' in numbers divisible by 11 or 13 less than n.\n\n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    # Start from 11 or 13, whichever comes first after or at 0\n    for i in range(max(11, 13), n):\n        if i % 11 == 0 or i % 13 == 0:\n            # Convert number to string to count '7'\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # Initialize count for digit 7 appearances\n    count_7 = 0\n    \n    # Loop through numbers less than n\n    for i in range(1, n):\n        # Check if the number is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Convert the number to a string to count '7'\n            for digit in str(i):\n                if digit == '7':\n                    count_7 += 1\n    \n    return count_7", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    \n    # Loop through all numbers less than n\n    for i in range(1, n):\n        # Check if the number is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Convert the number to a string to count occurrences of '7'\n            count += str(i).count('7')\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def count_digit_seven(num):\n    \"\"\"Count occurrences of the digit 7 in the given number.\"\"\"\n    return str(num).count('7')\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += count_digit_seven(i)\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Args:\n    n (int): An upper bound integer (exclusive).\n\n    Returns:\n    int: The count of 7's in numbers below n divisible by 11 or 13.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n    n (int): The upper limit (exclusive) for checking numbers.\n\n    Returns:\n    int: The count of times the digit 7 appears.\n\n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    \n    # Loop through numbers less than n\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            # Check if '7' is in the string representation of num\n            count += str(num).count('7')\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def count_seven(digit):\n    \"\"\"Count occurrences of the digit 7 in a number.\"\"\"\n    return str(digit).count('7')\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(7, n):  # Start from 7 because we're looking for 7s\n        if i % 11 == 0 or i % 13 == 0:\n            count += count_seven(i)\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n    n (int): Upper limit not inclusive\n\n    Returns:\n    int: Count of the digit '7' in relevant numbers\n    \n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # Initialize counter for digit '7'\n    count = 0\n    \n    # Iterate through numbers less than n\n    for num in range(1, n):\n        # Check if the number is divisible by 11 or 13\n        if num % 11 == 0 or num % 13 == 0:\n            # Count occurrences of '7' in the string representation of the number\n            count += str(num).count('7')\n    \n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 94.92635024549918, "dps_norm": 90.0, "pass@1": 96.0, "profiled": [{"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements, sort them, and then reassign them back into list positions\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Reconstruct the list\n    result = l[:]  # Make a copy to not modify the original list\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = even_elements[even_index]\n        even_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a new list where:\n    - Elements at odd indices remain unchanged.\n    - Elements at even indices are sorted.\n\n    Args:\n    l (list): The input list to be partially sorted.\n\n    Returns:\n    list: A new list with even-indexed elements sorted.\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract all elements at even indices, sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Initialize a list to hold the result\n    result = []\n    \n    # Iterate through the original list\n    even_index = 0\n    for i in range(len(l)):\n        # If the index is even, take from sorted even elements\n        if i % 2 == 0:\n            if even_index < len(even_elements):\n                result.append(even_elements[even_index])\n                even_index += 1\n        # If the index is odd, keep the original element\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a new list where:\n    - Values at even indices are sorted.\n    - Values at odd indices remain in their original position.\n\n    Args:\n    l (list): The input list to be sorted partially.\n\n    Returns:\n    list: A new list with the even indices sorted.\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements\n    evens = [x for i, x in enumerate(l) if i % 2 == 0]\n    # Sort these even indexed elements\n    sorted_evens = sorted(evens)\n\n    # Create a new list with original positions but with even indices replaced by sorted values\n    result = []\n    even_index = 0\n    for i, value in enumerate(l):\n        if i % 2 == 0:\n            # Place the next sorted even value\n            result.append(sorted_evens[even_index])\n            even_index += 1\n        else:\n            # Keep odd indexed values the same\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements, sort them, and pair with odd indexed elements\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    odd_elements = [l[i] for i in range(1, len(l), 2)]\n    \n    # Reconstruct the list with sorted even elements and original odd elements\n    result = []\n    even_index, odd_index = 0, 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements[even_index])\n            even_index += 1\n        else:\n            result.append(odd_elements[odd_index])\n            odd_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that:\n    - l' is identical to l in the odd indices.\n    - Even-indexed elements are sorted.\n\n    Args:\n    l (list): The input list to be processed.\n\n    Returns:\n    list: A new list with the even indices sorted and odd indices preserved.\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    evens = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even-indexed elements\n    evens.sort()\n    \n    # Construct the new list\n    result = l[:]  # Copy the original list\n    for i, e in zip(range(0, len(l), 2), evens):\n        result[i] = e\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the sorted values from l's even indices.\n\n    Args:\n    l (list): The input list.\n\n    Returns:\n    list: A new list with even-indexed elements sorted.\n\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices and sort them\n    even_sorted = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Construct the result list\n    result = l.copy()  # Make a copy to avoid modifying the original list\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = even_sorted[even_index]\n        even_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that:\n    - l' is identical to l at odd indices,\n    - values at even indices in l' are the sorted values from the even indices of l.\n\n    Examples:\n    ```python\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    ```\n    \"\"\"\n    # Extract even-indexed elements\n    even_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even-indexed elements\n    even_values.sort()\n    \n    # Create a new list where we'll place sorted even-indexed values\n    result = l.copy()\n    \n    # Place back the sorted even values into their respective even indices\n    for i, value in zip(range(0, len(l), 2), even_values):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements\n    even = l[::2]\n    # Sort these even elements\n    even_sorted = sorted(even)\n    \n    # Create the result list by placing sorted even elements back into their positions\n    # and keeping odd elements in place\n    result = [None] * len(l)\n    for i in range(len(l)):\n        if i % 2 == 0:  # Even index\n            result[i] = even_sorted.pop(0)\n        else:          # Odd index\n            result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed items\n    even_items = [l[i] for i in range(0, len(l), 2)]\n    # Sort them\n    sorted_even_items = sorted(even_items)\n    \n    # Create the result list with original odd positions and sorted even positions\n    result = l[:]  # Make a copy of l to modify\n    for i, val in enumerate(sorted_even_items):\n        result[i * 2] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    Args:\n    l (list): The input list to be partially sorted.\n    \n    Returns:\n    list: A new list with even-index elements sorted.\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices\n    even = l[::2]\n    # Sort these even elements\n    sorted_even = sorted(even)\n    \n    # Reconstruct the list with sorted even elements and original odd elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(sorted_even[i//2])\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n\n    Args:\n    l (list): Input list of integers.\n\n    Returns:\n    list: A new list with even-indexed elements sorted.\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort these elements\n    sorted_even_elements = sorted(even_elements)\n    \n    # Interleave the sorted even elements with the unchanged odd elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Place sorted even elements back at even indices\n            result.append(sorted_even_elements[i // 2])\n        else:\n            # Odd indices remain unchanged\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices\n    evens = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even-indexed elements\n    evens.sort()\n    \n    # Construct the result list\n    result = l.copy()\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = evens[even_index]\n        even_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a new list where:\n\n    - Elements at odd indices remain in their original positions.\n    - Elements at even indices are sorted in ascending order.\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \n    :param l: Input list to be partially sorted\n    :return: List with even index values sorted\n    \"\"\"\n    # Extract even indices\n    evens = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even values\n    sorted_evens = sorted(evens)\n    \n    # Reconstruct the list with odd indices untouched and even indices sorted\n    result = l.copy()  # Create a copy to avoid modifying the original list\n    for i, val in zip(range(0, len(l), 2), sorted_evens):\n        result[i] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n\n    Args:\n    l (list): The input list to be processed.\n\n    Returns:\n    list: A new list with sorted values at even indices.\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort these elements\n    sorted_even = sorted(even_elements)\n    \n    # Construct the result list\n    result = l[:]  # Make a copy of l\n    j = 0\n    for i in range(0, len(l), 2):\n        result[i] = sorted_even[j]\n        j += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the sorted values of the even indices of l.\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \n    :param l: List of integers\n    :return: Modified list where even indices are sorted\n    \"\"\"\n    # Extract even-indexed elements\n    evens = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even-indexed elements\n    evens.sort()\n    \n    # Reconstruct the list\n    result = l.copy()  # Start with a copy of the original list\n    for i, value in zip(range(0, len(l), 2), evens):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices elements\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even elements\n    even_elements.sort()\n    \n    # Create the result list by replacing even indices with sorted elements\n    result = l[:]  # Create a copy of l to avoid modifying the original list\n    for index, value in zip(range(0, len(l), 2), even_elements):\n        result[index] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n\n    Args:\n    l (list): Input list to be partially sorted.\n\n    Returns:\n    list: A new list where even indexed elements are sorted.\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort these even elements\n    even_elements.sort()\n    \n    # Construct the result list\n    result = l[:]  # Create a copy of l to not modify the original list\n    for i, val in enumerate(even_elements):\n        # Place back the sorted even elements\n        result[i * 2] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that:\n    - l' is identical to l at odd indices.\n    - The values at even indices in l' are sorted versions of the even indices in l.\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices\n    even_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even values\n    even_values.sort()\n    \n    # Construct the new list where odd indices remain the same\n    # and even indices take sorted values from even_values\n    result = l.copy()  # Start with a copy of the original list\n    for i, value in zip(range(0, len(l), 2), even_values):\n        result[i] = value\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices\n    evens = [l[i] for i in range(0, len(l), 2)]\n    # Sort these values\n    evens.sort()\n    \n    # Combine odd indices with sorted even indices\n    result = []\n    odd_index = 1\n    for i in range(len(l)):\n        if i % 2 == 0:  # Even indices\n            if evens:\n                result.append(evens.pop(0))\n            # If there are more indices than sorted even values, keep the original value\n            else:\n                result.append(l[i])\n        else:  # Odd indices\n            result.append(l[i])\n            odd_index += 2\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n\n    Args:\n    l (list): The input list to be processed.\n\n    Returns:\n    list: A new list where even indices contain sorted values from the even indices of l.\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices\n    evens = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even values\n    sorted_evens = sorted(evens)\n    \n    # Create a new list with sorted even indices and unchanged odd indices\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:  # Even index\n            if sorted_evens:\n                result.append(sorted_evens.pop(0))\n            else:\n                result.append(None)  # In case there are more even indices than available values\n        else:\n            result.append(l[i])  # Odd index, keep the same\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 54.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0  # Any number mod 1 is 0\n    \n    # Handle base cases\n    if n == 0:\n        return 1\n    \n    # Use exponentiation by squaring for efficiency\n    result = 1\n    base = 2 % p\n    exponent = n\n    \n    while exponent > 0:\n        # If exponent is odd, multiply result with base\n        if exponent & 1:\n            result = (result * base) % p\n        # Square the base\n        base = (base * base) % p\n        # Integer division by 2\n        exponent >>= 1\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    This function uses the method of exponentiation by squaring for efficiency.\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1 % p\n    \n    # Base case for the recursion\n    base = 2\n    \n    # The result starts at 1 since we're doing multiplication\n    result = 1\n    \n    # Convert n to binary and calculate 2^n % p\n    while n > 0:\n        # If n is odd, include the current power of 2 in our result\n        if n & 1:\n            result = (result * base) % p\n        # Square base for next step\n        base = (base * base) % p\n        # Integer division by 2 to move to next binary digit\n        n >>= 1\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Calculate 2^n modulo p using exponentiation by squaring for efficiency.\n\n    This function handles large values of n by using the modular exponentiation\n    technique, which is efficient for dealing with large exponents in modular\n    arithmetic. It avoids overflow by always computing modulo p at each step.\n\n    Args:\n        n (int): The exponent to which 2 should be raised.\n        p (int): The modulus for the operation.\n\n    Returns:\n        int: The result of (2^n) % p.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0  # Any number modulo 1 is 0\n    if n == 0:\n        return 1 % p  # 2^0 = 1, and 1 modulo anything is 1\n\n    result = 1\n    base = 2 % p  # Start with 2, but make sure it's modulo p\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * base) % p  # Only multiply if n is odd\n        base = (base * base) % p  # Square and take modulo p\n        n //= 2  # Integer division by 2\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p using modular exponentiation for efficiency.\n    This function handles large numbers and reduces computation errors by:\n    - Using the property of modular arithmetic: (a*b) % n = ((a % n)*(b % n)) % n\n    - Implementing exponentiation by squaring for n > 20 to avoid overflow.\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1 % p\n    \n    # Use exponentiation by squaring for large n\n    result = 1\n    base = 2 % p  # Ensure base is modulo p\n    while n > 0:\n        if n & 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        n >>= 1  # Right shift n by 1 (equivalent to n //= 2)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p using fast exponentiation to manage large numbers.\n\n    This function uses the method of exponentiation by squaring to compute \n    (2^n) % p efficiently, avoiding overflow for large n.\n\n    Args:\n        n (int): The power to which 2 should be raised.\n        p (int): The modulus.\n\n    Returns:\n        int: 2^n mod p.\n\n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    # Handle edge cases\n    if n == 0:\n        return 1 % p\n    \n    # Use fast exponentiation (exponentiation by squaring)\n    result = 1\n    base = 2 % p  # Start with base mod p to keep numbers small\n    \n    while n > 0:\n        if n % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        n //= 2\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    This function computes 2^n mod p using the method of exponentiation by squaring.\n    \n    Args:\n    n (int): The exponent for 2.\n    p (int): The modulus.\n    \n    Returns:\n    int: 2^n modulo p\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1 % p\n    result = 1\n    base = 2 % p\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        n //= 2\n    return result", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p efficiently using exponentiation by squaring.\n\n    Args:\n        n (int): The exponent to which 2 is raised.\n        p (int): The modulus to compute the result modulo.\n\n    Returns:\n        int: 2^n modulo p.\n\n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    # Base case: if n is 0, return 1\n    if n == 0:\n        return 1 % p\n    \n    # Use exponentiation by squaring to compute 2^n % p efficiently\n    result = 1\n    base = 2 % p\n    \n    # While n is greater than 0\n    while n > 0:\n        # If n is odd, multiply result with base\n        if n & 1:\n            result = (result * base) % p\n        # Square the base\n        base = (base * base) % p\n        # Integer division of n by 2\n        n >>= 1\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p using exponentiation by squaring for efficiency.\n    \n    This function avoids numerical overflow by computing modulo p at each step.\n\n    Examples:\n    ```python\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    ```\n    \n    Args:\n    n (int): The exponent to which 2 is raised.\n    p (int): The modulus.\n\n    Returns:\n    int: 2^n modulo p.\n    \"\"\"\n    # Edge case for n being zero\n    if n == 0:\n        return 1 % p\n    \n    result = 1\n    base = 2 % p  # Initial base, which is 2 modulo p\n    \n    # Exponentiation by squaring\n    while n > 0:\n        if n % 2 == 1:  # If n is odd\n            result = (result * base) % p\n        base = (base * base) % p\n        n = n // 2  # Integer division by 2\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p using efficient modular exponentiation.\n    \n    This function implements the Russian Peasant Multiplication (or binary exponentiation) \n    for modular arithmetic to reduce computation time and handle large numbers.\n\n    Args:\n    n (int): The exponent to which 2 should be raised.\n    p (int): The modulus for the operation.\n\n    Returns:\n    int: The result of (2^n) % p.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Edge cases\n    if n == 0:\n        return 1 % p  # Any number to the power of 0 is 1\n    \n    # Binary exponentiation\n    result = 1\n    base = 2 % p  # Start with 2 % p for efficient computation\n    \n    while n > 0:\n        # If n is odd, multiply current result with base\n        if n & 1:\n            result = (result * base) % p\n        \n        # Square the base for next iteration\n        base = (base * base) % p\n        \n        # Integer division by 2\n        n >>= 1\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    This function uses the concept of exponentiation by squaring for efficiency.\n    \n    Args:\n    n (int): The exponent for 2^n\n    p (int): The modulus for the calculation\n    \n    Returns:\n    int: 2^n modulo p\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Special case for p = 1\n    if p == 1:\n        return 0\n    \n    result = 1\n    base = 2 % p\n    \n    while n > 0:\n        # If n is odd, multiply by base\n        if n & 1:\n            result = (result * base) % p\n        # Square the base\n        base = (base * base) % p\n        # Divide n by 2\n        n >>= 1\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p using modular exponentiation to avoid numeric overflow.\n    \n    This function calculates (2^n) % p efficiently, which can handle very large values of n without \n    running into floating-point precision issues or integer overflow.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Handle the edge case where n is 0\n    if n == 0:\n        return 1 % p\n    \n    # Use the built-in pow function which implements modular exponentiation\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p using exponentiation by squaring for efficiency.\n    This method is used to handle large numbers of n more effectively.\n\n    Args:\n    n (int): The exponent.\n    p (int): The modulus, must be a positive integer.\n\n    Returns:\n    int: The result of 2^n modulo p.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0  # By Fermat's little theorem, 2^n mod 1 = 0\n    if n == 0:\n        return 1   # Any number to the power of 0 is 1\n    \n    # Initialize result\n    result = 1\n    base = 2 % p\n    \n    while n > 0:\n        # If n is odd, multiply base with result\n        if n & 1:\n            result = (result * base) % p\n        # Square the base\n        base = (base * base) % p\n        # Divide n by 2\n        n = n >> 1\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p. This function uses the binary exponentiation method \n    to compute large powers efficiently with respect to modulo operations.\n\n    Args:\n    n (int): The exponent to raise 2 to.\n    p (int): The modulus.\n\n    Returns:\n    int: 2^n % p\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1 % p\n    result = 1\n    base = 2 % p\n    while n > 0:\n        # If n is odd, multiply result by base\n        if n & 1:\n            result = (result * base) % p\n        # Square base, and halve n\n        base = (base * base) % p\n        n = n >> 1\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Compute (2^n) mod p efficiently.\n\n    This function uses modular exponentiation to handle large values of n \n    without running into numerical overflow issues.\n\n    Args:\n    n (int): The exponent to which 2 is raised.\n    p (int): The modulus for the result.\n\n    Returns:\n    int: (2^n) % p\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0  # Any number mod 1 is 0\n    \n    # Initialize result\n    result = 1\n    \n    # Base for exponentiation\n    base = 2\n    \n    # While exponent is positive\n    while n > 0:\n        # If n is odd, multiply result with base\n        if n & 1:\n            result = (result * base) % p\n        # Square the base and half the exponent\n        base = (base * base) % p\n        n = n >> 1  # Equivalent to n //= 2 but faster\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p, optimized for large exponents.\n\n    This function uses the method of exponentiation by squaring, also known\n    as binary exponentiation, which significantly reduces the number of \n    multiplications required for computation.\n\n    Args:\n    n (int): The exponent.\n    p (int): The modulus.\n\n    Returns:\n    int: 2^n mod p\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1 % p\n    \n    result = 1\n    base = 2 % p  # Starting with the first bit\n    while n > 0:\n        if n & 1:  # If the least significant bit is 1\n            result = (result * base) % p\n        base = (base * base) % p  # Square the base\n        n >>= 1  # Right shift n by 1\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p using efficient exponentiation by squaring.\n    \n    This function calculates 2^n % p, where n is non-negative, \n    in a way that avoids overflow for large numbers.\n\n    Args:\n        n (int): The power to which 2 should be raised.\n        p (int): The modulus for the calculation.\n\n    Returns:\n        int: 2^n modulo p\n\n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    # Edge cases\n    if n == 0:\n        return 1 % p  # 2^0 mod p = 1 for any p\n    \n    # Initialize result\n    result = 1\n    base = 2 % p  # Start with 2 mod p\n    \n    # Exponentiation by squaring\n    while n > 0:\n        if n % 2 == 1:  # If n is odd, multiply base with result\n            result = (result * base) % p\n        base = (base * base) % p  # Square the base\n        n = n // 2  # Integer division by 2\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p using efficient modular exponentiation.\n\n    This function employs the method of exponentiation by squaring for better performance,\n    especially with large n.\n\n    Args:\n        n (int): The exponent to which 2 is raised.\n        p (int): The modulus.\n\n    Returns:\n        int: 2^n mod p\n\n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    # Edge cases:\n    # If n is 0, any number to the power of 0 is 1\n    if n == 0:\n        return 1 % p\n\n    # If p is 1, any number modulo 1 is 0\n    if p == 1:\n        return 0\n    \n    # Use binary exponentiation to compute 2^n mod p efficiently\n    result = 1\n    base = 2 % p  # This will optimize for p < 3\n    \n    while n > 0:\n        if n % 2 == 1:  # If n is odd, multiply base^2 to result\n            result = (result * base) % p\n        base = (base * base) % p  # Square base for next bit\n        n = n // 2  # Integer division by 2\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    This function uses the binary exponentiation algorithm for efficiency.\n    \n    Args:\n        n (int): The exponent to which 2 is raised.\n        p (int): The modulus to compute against.\n    \n    Returns:\n        int: The result of 2^n mod p\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    if n == 0:\n        return 1 % p\n    result = 1\n    base = 2 % p\n    while n > 0:\n        if n & 1:  # If n is odd, multiply base to result\n            result = (result * base) % p\n        # Square base and halve the exponent\n        base = (base * base) % p\n        n >>= 1  # This is the same as n //= 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p using the method of exponentiation by squaring to avoid large numbers.\n\n    This function efficiently computes (2^n) % p by:\n    - Using the binary representation of n for fewer operations.\n    - Avoiding large intermediate results by computing mod p at each step.\n\n    Args:\n    n (int): The exponent.\n    p (int): The modulus, which should be greater than 1 for meaningful results.\n\n    Returns:\n    int: 2^n modulo p.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0  # Any number mod 1 is 0 by definition, although not tested in given examples\n    \n    # If p is 2, any power of 2 mod 2 is 0, except for 2^0 which is 1\n    if p == 2:\n        return 1 if n == 0 else 0\n    \n    result = 1\n    base = 2 % p\n    exponent = n\n    \n    while exponent > 0:\n        # If the least significant bit is 1, multiply the result\n        if exponent & 1:\n            result = (result * base) % p\n        # Square the base\n        base = (base * base) % p\n        # Shift the exponent to the right by 1 (equivalent to exponent // 2)\n        exponent >>= 1\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p efficiently.\n\n    This uses binary exponentiation to calculate 2^n mod p, which is much faster \n    than naively multiplying 2 by itself n times and then taking mod p.\n\n    Args:\n        n (int): The exponent, where 2^n is computed.\n        p (int): The modulus.\n\n    Returns:\n        int: 2^n modulo p.\n\n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    if p == 1:\n        return 0  # Any number mod 1 is 0\n    \n    result = 1\n    base = 2 % p\n    \n    # While n is greater than 0\n    while n > 0:\n        # If n is odd, multiply result with base\n        if n & 1:\n            result = (result * base) % p\n        # Square the base\n        base = (base * base) % p\n        # Divide the exponent by 2\n        n >>= 1\n\n    return result", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 67.43961352657004, "dps_norm": 56.25, "pass@1": 98.0, "profiled": [{"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns it without vowels.\n    \n    Args:\n    text (str): The input string which might contain vowels.\n\n    Returns:\n    str: A new string where all vowels (both uppercase and lowercase) have been removed.\n\n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Use regex to match vowels in a case-insensitive manner\n    vowels_pattern = re.compile(r'[aeiou]', re.IGNORECASE)\n    return vowels_pattern.sub('', text)", "matching_cluster_idx": 0}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \n    Args:\n    text (str): The input string from which vowels will be removed.\n\n    Returns:\n    str: A string with all vowels removed, case-insensitive.\n\n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define a set of vowels for quick lookup\n    vowels = set('aeiouAEIOU')\n    \n    # Use a list comprehension to exclude vowels\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    Remove vowels from the input string.\n\n    This function removes all occurrences of vowels (both uppercase and lowercase) from the provided text.\n\n    Args:\n    text (str): The input string from which vowels will be removed.\n\n    Returns:\n    str: A new string with all vowels removed.\n\n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Use regular expression to remove all vowels, case-insensitive\n    return re.sub(r'[aeiou]', '', text, flags=re.IGNORECASE)", "matching_cluster_idx": 0}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define vowels\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to build the new string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    Both uppercase and lowercase vowels are removed.\n\n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n\n    Args:\n    text (str): The input string from which to remove vowels.\n\n    Returns:\n    str: A new string with all vowels removed.\n    \"\"\"\n    # List of vowels including both cases\n    vowels = set('aeiouAEIOU')\n    # Use list comprehension to create a new string without vowels\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns it without vowels.\n\n    Args:\n    text (str): The input string which might contain vowels to be removed.\n\n    Returns:\n    str: A string with all vowels removed.\n\n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Use regex to remove all vowels, case insensitive\n    return re.sub(r'[aeiou]', '', text, flags=re.IGNORECASE)", "matching_cluster_idx": 0}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define vowels, both lowercase and uppercase\n    vowels = set('aeiouAEIOU')\n    \n    # Use a list comprehension to build the string without vowels\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    Args:\n    text (str): The input string which might contain vowels.\n\n    Returns:\n    str: A string where all vowels (a, e, i, o, u - regardless of case) are removed.\n\n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define vowels to remove, including both lowercase and uppercase\n    vowels = 'aeiouAEIOU'\n    # Use a list comprehension to build a new string without vowels, preserving newlines\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # List of vowels (both lowercase and uppercase for case insensitivity)\n    vowels = 'aeiouAEIOU'\n    # Use a list comprehension to construct the new string without vowels\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n\n    Args:\n    text (str): The input string from which to remove vowels.\n\n    Returns:\n    str: A string with all vowels (both lowercase and uppercase) removed.\n\n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define vowels including both lowercase and uppercase\n    vowels = 'aeiouAEIOU'\n    # Use a list comprehension to build a new string excluding vowels\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n\n    Args:\n    text (str): The input string which might contain vowels.\n\n    Returns:\n    str: A string where all vowels have been removed.\n\n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define vowels, both uppercase and lowercase\n    vowels = \"aeiouAEIOU\"\n    # Use list comprehension for efficiency to create new string without vowels\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    This function considers both uppercase and lowercase vowels (A, E, I, O, U, a, e, i, o, u).\n    It preserves all non-vowel characters and retains the original case for other characters.\n\n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n\n    Args:\n    text (str): The input string which might contain vowels.\n\n    Returns:\n    str: A new string with all vowels removed.\n\n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define vowels, both lowercase and uppercase\n    vowels = 'aeiouAEIOU'\n    \n    # Use list comprehension to build a new string excluding vowels\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # The regex pattern matches vowels, both lowercase and uppercase\n    pattern = re.compile(r'[aeiouAEIOU]', re.IGNORECASE)\n    # Use re.sub to replace vowels with an empty string\n    return pattern.sub('', text)", "matching_cluster_idx": 0}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \n    This function uses regex to remove all vowels (both uppercase and lowercase) from the input string.\n    Note: 'y' is not considered a vowel in this context.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Regular expression to match all vowels, case-insensitive\n    vowels = re.compile('[aeiou]', re.IGNORECASE)\n    # Replace all vowels with an empty string\n    return vowels.sub('', text)", "matching_cluster_idx": 0}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    Remove all vowels from the input string.\n    \n    This function accepts a string and returns a new string with all vowels (a, e, i, o, u) removed,\n    irrespective of case.\n\n    Examples:\n    ```python\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    ```\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns it without vowels.\n    \n    Parameters:\n    text (str): The input string from which vowels will be removed.\n    \n    Returns:\n    str: The string with all vowels (both uppercase and lowercase) removed.\n    \n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define vowels, including both upper and lower case\n    vowels = \"aeiouAEIOU\"\n    \n    # Create a list comprehension to build the new string without vowels\n    # This approach preserves newlines and other characters\n    result = ''.join([char for char in text if char not in vowels])\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    This function considers both lowercase and uppercase vowels for removal.\n\n    Parameters:\n    text (str): The input string from which vowels will be removed.\n\n    Returns:\n    str: A string with all vowels removed.\n\n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define a set of vowels including both upper and lower case\n    vowels = set('aeiouAEIOU')\n    \n    # Use a list comprehension to build a new string excluding vowels\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    Vowels considered here are 'a', 'e', 'i', 'o', 'u', case-insensitive.\n    \n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Using regex to match any vowel (case-insensitive)\n    return re.sub(r'[aeiou]', '', text, flags=re.IGNORECASE)", "matching_cluster_idx": 0}]}, "HumanEval/54": {"dps": 95.42553191489361, "dps_norm": 97.14285714285714, "pass@1": 76.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two strings have the same characters regardless of their order and count.\n\n    This function compares the set of unique characters in each string. If the sets\n    are identical, it means both strings have the same characters, albeit possibly\n    in different quantities or orders.\n\n    Args:\n        s0 (str): The first string to compare.\n        s1 (str): The second string to compare.\n\n    Returns:\n        bool: True if both strings contain exactly the same set of characters, False otherwise.\n\n    Examples:\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n        True\n        >>> same_chars('abcd', 'dddddddabc')\n        True\n        >>> same_chars('dddddddabc', 'abcd')\n        True\n        >>> same_chars('eabcd', 'dddddddabc')\n        False\n        >>> same_chars('abcd', 'dddddddabce')\n        False\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n        False\n    \"\"\"\n    # Convert strings to sets to check for unique characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Compare the sets for equality\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, ignoring their frequency and order.\n\n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if both strings have the same unique characters, False otherwise.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert each string to a set of its characters to ignore duplicates and order\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n\n    # Compare the sets\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nimport doctest\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two strings have the same characters, disregarding quantity and order.\n\n    This function uses Counter from collections to count the occurrences of each character\n    in both strings, then compares the resulting sets of keys to ensure they match exactly\n    in terms of character presence.\n\n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if both strings contain exactly the same set of characters, False otherwise.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Count characters in both strings\n    count0 = Counter(s0)\n    count1 = Counter(s1)\n    \n    # Convert to sets of characters to ignore frequency\n    char_set0 = set(count0.keys())\n    char_set1 = set(count1.keys())\n    \n    # Compare the sets\n    return char_set0 == char_set1", "matching_cluster_idx": 2}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two strings have the same characters, regardless of their frequency or order.\n\n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if the strings have the same unique characters, False otherwise.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Sort the characters in each string and remove duplicates\n    # If the set of characters from both strings are the same, they have the same characters\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two strings have the same characters, regardless of their frequency or order.\n    \n    This function converts both strings to sets, which inherently ignore duplicates,\n    and then compares these sets for equality.\n    \n    Args:\n    s0 (str): First string to compare.\n    s1 (str): Second string to compare.\n    \n    Returns:\n    bool: True if both strings contain the same characters, False otherwise.\n    \n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert strings to sets, which will contain only unique characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Compare the sets\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two strings have the same characters, ignoring character frequency.\n\n    This function sorts both strings to compare the unique set of characters present.\n\n    Args:\n    s0 (str): First string to compare\n    s1 (str): Second string to compare\n\n    Returns:\n    bool: True if both strings contain the same characters, False otherwise\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Sort the characters in each string to compare without considering frequency\n    sorted_s0 = sorted(set(s0))\n    sorted_s1 = sorted(set(s1))\n    \n    # Compare the sorted unique characters\n    return sorted_s0 == sorted_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    This function ignores the number of times characters appear and only checks\n    if all unique characters from one string exist in the other.\n\n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if both strings have the same set of characters, False otherwise.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert strings to sets to ignore character count, only unique characters matter\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if both sets are equivalent, meaning they contain the same characters\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two strings have the same characters, regardless of their frequency.\n\n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if the strings have exactly the same characters, False otherwise.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert strings to sets of characters. This automatically removes duplicates\n    # and allows for easy comparison since sets don't care about quantity or order.\n    set1 = set(s0)\n    set2 = set(s1)\n    \n    # Check if both sets are identical\n    return set1 == set2", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two strings have the same characters, disregarding their frequency and order.\n\n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if both strings contain exactly the same characters, False otherwise.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert strings to sets of characters, which automatically remove duplicates\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if both sets are identical\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, ignoring the order and duplicates.\n\n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if both strings have the same unique characters, False otherwise.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Sort the characters and remove duplicates for both strings\n    sorted_s0 = sorted(set(s0))\n    sorted_s1 = sorted(set(s1))\n    \n    # Compare the sorted and unique lists of characters\n    return sorted_s0 == sorted_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, ignoring order and allowing for repetition.\n\n    This function compares if the set of characters in `s0` is identical to the set of characters in `s1`.\n\n    Args:\n        s0 (str): The first string to compare.\n        s1 (str): The second string to compare.\n\n    Returns:\n        bool: True if both strings contain exactly the same characters, False otherwise.\n\n    Examples:\n    ```python\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    ```\n    \"\"\"\n    # Convert strings to sets to ignore the order and count of characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Return if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two strings have the same characters irrespective of their frequency or order.\n\n    This function converts both strings to sorted sets of characters and checks if they are equal.\n    \n    Args:\n    s0 (str): First string to compare.\n    s1 (str): Second string to compare.\n\n    Returns:\n    bool: True if both strings contain the same characters, False otherwise.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert strings to sets to eliminate duplicate characters and then sort for comparison\n    return sorted(set(s0)) == sorted(set(s1))", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two strings have the same characters, disregarding the count of characters.\n\n    This function compares the set of unique characters in each string, ignoring \n    how many times each character appears.\n\n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if both strings contain the same set of characters, False otherwise.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters to ignore the count\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Compare the sets for equality\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    This function determines if the set of characters in s0 is exactly the same \n    as in s1, disregarding the number of occurrences or order.\n\n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if both strings contain the same unique characters, False otherwise.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    \"\"\"\n    # Convert strings to sets of characters for comparison\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Compare the sets; if they are equal, then all characters are the same\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two strings have the same characters, regardless of the count of each character.\n\n    This function sorts the characters in each string and compares them to determine if they \n    contain the same characters in any order or quantity.\n\n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if both strings have exactly the same characters, False otherwise.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Remove duplicates to ensure we only check unique characters\n    unique_s0 = set(s0)\n    unique_s1 = set(s1)\n    \n    # If the sets of unique characters are identical, the strings have the same chars\n    return unique_s0 == unique_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    This function normalizes both strings by:\n    - Sorting the characters of each string.\n    - Removing duplicates by converting to a set.\n    - Sorting the sets to ensure consistent comparison.\n\n    Args:\n        s0 (str): The first string to compare.\n        s1 (str): The second string to compare.\n\n    Returns:\n        bool: True if both strings contain the same characters, False otherwise.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    \"\"\"\n    # Normalize both strings by removing duplicates, sorting, and joining into a string\n    chars_s0 = ''.join(sorted(set(s0)))\n    chars_s1 = ''.join(sorted(set(s1)))\n    \n    # Compare the normalized strings\n    return chars_s0 == chars_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two strings have the same characters, regardless of frequency or order.\n\n    This function:\n    - Counts the number of unique characters in each string.\n    - Checks if these counts are equal, implying the presence of the same set of characters.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n\n    :param s0: The first string to compare\n    :param s1: The second string to compare\n    :return: True if both strings have the same characters, False otherwise\n    \"\"\"\n    # Create sets from the strings to ignore the count of characters, only checking for presence\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # If the sets are of the same length and all elements match, then they contain the same characters\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two strings have the same characters, ignoring the count of characters and their order.\n\n    This function returns True if both strings contain exactly the same set of unique characters,\n    regardless of how many times those characters appear or their arrangement in the string.\n\n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if both strings have the same set of characters, False otherwise.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Create a set from each string to only consider unique characters\n    chars_s0 = set(s0)\n    chars_s1 = set(s1)\n\n    # Compare the sets\n    return chars_s0 == chars_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters regardless of their frequency.\n\n    This function converts both strings to sets of characters, thereby ignoring \n    the count of each character, and then compares these sets.\n\n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if both strings have exactly the same characters, False otherwise.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert strings to sets of characters, which automatically removes duplicates\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Compare the sets for equality\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    This function ignores the order and count of characters, \n    only checking for the presence of characters.\n\n    Args:\n    s0 (str): First string to compare.\n    s1 (str): Second string to compare.\n\n    Returns:\n    bool: True if both strings contain the same unique characters, False otherwise.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert strings to sets to ignore character count and order\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Examples:\n    ```python\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    ```\n    \"\"\"\n    # Convert lists to sets to remove duplicates and use set intersection for common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    # Find the intersection of both sets, then convert back to list and sort\n    result = sorted(list(set1 & set2))\n    return result", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    This function finds the common elements between two lists, removes any duplicates,\n    and returns them in a sorted order.\n\n    Args:\n        l1 (list): The first list of elements.\n        l2 (list): The second list of elements.\n\n    Returns:\n        list: A sorted list containing unique common elements.\n\n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Convert lists to sets to remove duplicates and then use set intersection\n    # to find common elements\n    common_elements = set(l1) & set(l2)\n    \n    # Convert the set back to a list, sort it and return\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n    l1 (list): The first list of elements.\n    l2 (list): The second list of elements.\n\n    Returns:\n    list: A sorted list of unique elements common to both input lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets for efficient lookup, then find intersection\n    # Sets automatically handle uniqueness\n    common_set = set(l1) & set(l2)\n    \n    # Convert back to a list and sort\n    return sorted(list(common_set))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n    l1 (list): The first list to compare.\n    l2 (list): The second list to compare.\n\n    Returns:\n    list: A sorted list of unique elements present in both lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find intersection efficiently\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets which contains only common elements\n    common_set = set1 & set2\n    \n    # Convert back to list, sort it, and return\n    return sorted(list(common_set))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    Args:\n    l1 (list): The first list of elements.\n    l2 (list): The second list of elements.\n\n    Returns:\n    list: A sorted list of unique elements common to both input lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets for efficient membership testing and uniqueness\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert back to list and sort\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Examples:\n    ```python\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    ```\n    \"\"\"\n    # Convert lists to sets to get unique elements, then find intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1 & set2\n    \n    # Convert set back to list and sort it\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    This function finds the intersection of two lists, removes duplicates,\n    and returns the result sorted in ascending order.\n    \n    Args:\n    l1 (list): The first list of numbers.\n    l2 (list): The second list of numbers.\n\n    Returns:\n    list: A sorted list of unique elements common to both input lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find intersection, which automatically removes duplicates\n    common_elements = set(l1) & set(l2)\n    \n    # Convert back to a list, sort, and return\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    Args:\n    l1 (list): First list of elements\n    l2 (list): Second list of elements\n    \n    Returns:\n    list: A sorted list of unique common elements\n    \"\"\"\n    # Convert lists to sets to find unique elements and intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find common elements using set intersection\n    common_elements = set1 & set2\n    \n    # Return sorted list of common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Examples:\n    ```python\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    ```\n    \"\"\"\n    # Convert lists to sets for efficient lookup and to eliminate duplicates\n    set1, set2 = set(l1), set(l2)\n    \n    # Use intersection to find common elements\n    common_elements = set1 & set2\n    \n    # Sort the common elements and convert back to a list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n    l1 (list): The first list to compare.\n    l2 (list): The second list to compare.\n    \n    Returns:\n    list: A sorted list of unique elements common to both input lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets for efficient intersection operation\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert back to list, sort it, and return\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n    l1 (list): The first list of elements.\n    l2 (list): The second list of elements.\n\n    Returns:\n    list: A sorted list containing unique common elements of l1 and l2.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to remove duplicates and then find intersection\n    common_set = set(l1) & set(l2)\n    # Convert back to a list, sort it, and return\n    return sorted(list(common_set))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    This function converts both lists to sets for efficient comparison,\n    finds the intersection, and then sorts the result to return in list form.\n\n    Args:\n    l1 (list): The first list of elements.\n    l2 (list): The second list of elements.\n\n    Returns:\n    list: A sorted list containing unique elements that are common to both input lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to easily find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_set = set1 & set2\n    \n    # Convert back to a sorted list\n    return sorted(list(common_set))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    This function finds the intersection of two lists and returns \n    a list of common elements in ascending order without duplicates.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to remove duplicates and then find the intersection\n    set1, set2 = set(l1), set(l2)\n    result = sorted(set1 & set2)  # Use & for intersection of sets and sort the result\n    return result", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    This function takes two lists as input, finds the common elements between them,\n    removes duplicates, and returns the result sorted in ascending order.\n\n    Args:\n        l1 (list): The first list of elements.\n        l2 (list): The second list of elements.\n\n    Returns:\n        list: A sorted list of unique common elements.\n\n    Examples:\n    ```python\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    ```\n    \"\"\"\n    # Convert lists to sets for efficient intersection operation\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_set = set1.intersection(set2)\n    \n    # Convert the set back to a list and sort it\n    result = sorted(list(common_set))\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n    l1 (list): The first list of elements.\n    l2 (list): The second list of elements.\n\n    Returns:\n    list: A list containing sorted unique elements that are common to both input lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to eliminate duplicates and then find intersection\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert lists to sets to remove duplicates and for efficient intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets, which will contain only common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert back to list and sort it before returning\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n    \"\"\"\n    # Convert lists to sets to find unique common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find intersection of sets\n    common_set = set1.intersection(set2)\n    \n    # Convert back to list and sort\n    return sorted(list(common_set))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n    l1 (list): The first list of integers.\n    l2 (list): The second list of integers.\n\n    Returns:\n    list: A sorted list of unique elements common to both input lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to remove duplicates and then find intersection\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Intersection of sets to get common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert back to list and sort\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets for intersection operation\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to find common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert back to a sorted list of unique elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 78.73263888888889, "dps_norm": 97.22222222222223, "pass@1": 92.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Examples:\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Find the smallest factor first\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            n //= i  # Divide n by i as many times as possible\n        else:\n            i += 1\n    \n    # At this point, n will either be a prime factor or 1\n    # If n is not 1, then it is itself the largest prime factor\n    if n > 1:\n        return n\n    else:\n        return i - 1  # This returns the last prime factor checked", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Examples:\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_factor = 1\n\n    # Function to check if a number is prime\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Find the smallest factor (which will be prime) then use it to reduce n\n    divisor = 2\n    while divisor * divisor <= n:\n        if n % divisor == 0:\n            # If this divisor is larger than current largest, update largest\n            if is_prime(divisor):\n                largest_factor = max(largest_factor, divisor)\n            n //= divisor\n        else:\n            divisor += 1\n    \n    # If n is still greater than 1, then it is prime itself\n    if n > 1:\n        largest_factor = max(largest_factor, n)\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def is_prime(x: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if x < 2:\n        return False\n    for i in range(2, int(x**0.5) + 1):\n        if x % i == 0:\n            return False\n    return True\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime itself.\"\"\"\n    # Initialize the largest prime factor\n    largest = 1\n    \n    # Divide n by the smallest primes to reduce its size\n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            if is_prime(i):\n                largest = i\n            n //= i\n\n    # If n is greater than largest, then n itself is a prime factor\n    if n > largest and is_prime(n):\n        return n\n    else:\n        return largest", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Args:\n    n (int): A number greater than 1 to find the largest prime factor of.\n\n    Returns:\n    int: The largest prime factor of n.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Function to check if a number is prime\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, int(k**0.5) + 1):\n            if k % i == 0:\n                return False\n        return True\n\n    # Start from 2 and go up to find the largest prime factor\n    largest_factor = 1\n    \n    # Divide out all factors of 2 if possible to simplify the loop\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Now check for odd numbers only\n    factor = 3\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n            largest_factor = factor\n        else:\n            factor += 2  # Skip even numbers\n\n    # If n is greater than 1 at this point, it means n itself is prime\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Examples:\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Function to check if a number is prime\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    \n    # Check for factors up to square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = max(largest_factor, i)\n            # Check the corresponding quotient as well, it might also be prime\n            quotient = n // i\n            if is_prime(quotient):\n                largest_factor = max(largest_factor, quotient)\n\n    # If n itself is prime, n would be the largest prime factor\n    if largest_factor == 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Examples:\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Factor out 2 as much as possible since it's the only even prime number\n    largest_factor = 1\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Now n is odd, we only need to check odd numbers up to sqrt(n)\n    factor = 3\n    while factor * factor <= n:\n        if n % factor == 0:\n            if is_prime(factor):\n                largest_factor = max(largest_factor, factor)\n            if is_prime(n // factor):\n                largest_factor = max(largest_factor, n // factor)\n            n //= factor\n        else:\n            factor += 2\n    \n    # If n is greater than 2 at this point, n itself is prime\n    if n > 2:\n        largest_factor = max(largest_factor, n)\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    This function decomposes the number n into its prime factors, \n    returning the largest one. It uses trial division to find factors.\n\n    Args:\n        n (int): The number to factorize. Must be greater than 1 and not a prime.\n\n    Returns:\n        int: The largest prime factor of n.\n\n    Examples:\n        >>> largest_prime_factor(13195)\n        29\n        >>> largest_prime_factor(2048)\n        2\n    \"\"\"\n    def is_prime(num):\n        \"\"\"Check if num is a prime number.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start with the smallest prime number\n    factor = 2\n    while factor * factor <= n:\n        # If n is evenly divisible by factor, then factor is a factor\n        if n % factor == 0:\n            n //= factor  # Integer division\n            # Check if this factor is the largest prime factor\n            if is_prime(n):\n                return n\n        else:\n            # If factor is not a factor, go to the next potential factor\n            # Optimization: Skip even numbers if factor is 2, otherwise increase by 2\n            if factor == 2:\n                factor += 1\n            else:\n                factor += 2\n    # If n is still > 1, then it must be prime (this is the largest factor)\n    if n > 1:\n        return n\n    raise ValueError(\"The input number should be greater than 1 and not a prime itself.\")", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Examples:\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    factor = 2\n    largest_factor = 1\n\n    # Check divisibility by 2 separately since all even numbers have 2 as a factor\n    while n % factor == 0:\n        largest_factor = factor\n        n //= factor\n    \n    # Now check for odd factors up to the square root of n\n    factor = 3\n    while factor * factor <= n:\n        if n % factor == 0:\n            largest_factor = max(largest_factor, factor)\n            while n % factor == 0:\n                n //= factor\n        factor += 2\n    \n    # If n is greater than 2, then n itself is prime and not yet considered\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and n is not prime.\n\n    This function uses trial division to find prime factors:\n    - First, it handles the case of n being divisible by 2 separately for optimization.\n    - Then, it checks for odd factors from 3 up to sqrt(n).\n    - If a factor is found, n is divided by this factor to reduce the number for further factorization.\n\n    Examples:\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \n    Args:\n    n (int): The number whose largest prime factor is to be found.\n\n    Returns:\n    int: The largest prime factor of n.\n    \"\"\"\n    # Handle the case where n is even\n    largest_factor = 2\n    if n % 2 == 0:\n        n //= 2\n        while n % 2 == 0:  # Continue dividing by 2 while n is even\n            n //= 2\n    \n    # Start checking for odd factors\n    factor = 3\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor  # Reduce n by dividing by the factor\n            largest_factor = factor  # Update the largest factor\n        else:\n            factor += 2  # Only check odd numbers since all even numbers > 2 are not prime\n    \n    # If n is greater than 2 at this point, it means n itself is prime\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def is_prime(k: int) -> bool:\n    \"\"\"Check if k is a prime number.\"\"\"\n    if k < 2:\n        return False\n    for i in range(2, int(k**0.5) + 1):\n        if k % i == 0:\n            return False\n    return True\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Examples:\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start from the smallest prime number\n    largest = 1\n    # Continue dividing by smallest prime numbers to find factors\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i divides n, check if i or n/i is prime\n            if is_prime(i):\n                largest = max(largest, i)\n            if i * i != n and is_prime(n // i):  # avoid checking if i is sqrt(n)\n                largest = max(largest, n // i)\n    \n    # If no prime factors found, n itself must be the largest prime factor\n    # This also handles the case where n was mistakenly assumed not to be prime\n    if largest == 1 or not any(n % i == 0 for i in range(2, int(n**0.5) + 1)):\n        largest = n\n\n    return largest", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    Args:\n        n (int): The number to find the largest prime factor for.\n\n    Returns:\n        int: The largest prime factor.\n\n    Examples:\n        >>> largest_prime_factor(13195)\n        29\n        >>> largest_prime_factor(2048)\n        2\n    \"\"\"\n    # Function to check if a number is prime\n    def is_prime(x: int) -> bool:\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n    \n    largest_factor = 1\n    \n    # Find the smallest prime that divides n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i divides n, check if i is prime or the factor (n/i) is larger than current largest_factor\n            if is_prime(i):\n                largest_factor = max(largest_factor, i)\n            if is_prime(n // i):\n                largest_factor = max(largest_factor, n // i)\n    \n    # If we haven't found any prime factors or if the number itself is prime, return n\n    if largest_factor == 1:\n        return n\n    \n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    This function finds all the prime factors of n by trying to divide n by \n    numbers from 2 upwards, reducing n by dividing it with each found factor.\n\n    Args:\n    n (int): The number to find the largest prime factor of.\n\n    Returns:\n    int: The largest prime factor of n.\n\n    Examples:\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, int(k**0.5) + 1):\n            if k % i == 0:\n                return False\n        return True\n\n    largest_factor = -1\n    # Handle the case where n is divisible by 2 multiple times\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Now n is odd, increment by 2 to check only odd numbers\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            if is_prime(i):\n                largest_factor = max(largest_factor, i)\n            n //= i\n    \n    # If n at this point is still greater than 2, then it must be prime\n    if n > 2:\n        largest_factor = max(largest_factor, n)\n    \n    if largest_factor == -1:\n        raise ValueError(\"The function assumes n > 1 and not prime, but it appears to be prime or <= 1.\")\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Examples:\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    >>> largest_prime_factor(600851475143)\n    6857\n    \n    :param n: An integer greater than 1\n    :return: The largest prime factor of n\n    \"\"\"\n    # Initialize the largest factor to 2, since all numbers have 2 as a factor or are odd\n    largest = 2\n    \n    # Keep dividing n by 2 if it's even\n    while n % 2 == 0:\n        n //= 2\n        largest = 2\n    \n    # Now n is odd, start checking from 3\n    factor = 3\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n            largest = factor\n        else:\n            factor += 2  # Since all primes greater than 2 are odd\n    \n    # If n is greater than 2 at this point, it means n itself is prime\n    if n > 2:\n        largest = n\n    \n    return largest", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Args:\n    n (int): The number for which to find the largest prime factor.\n\n    Returns:\n    int: The largest prime factor of n.\n\n    Examples:\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor to 1\n    largest_prime = 1\n    \n    # While n is divisible by 2, keep dividing it by 2\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n    \n    # Check for odd factors from 3 upwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_prime = factor\n            n //= factor\n        factor += 2\n    \n    # If n is greater than 2 at the end of the loop, it means n is prime\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Args:\n        n (int): The number to find the largest prime factor for.\n\n    Returns:\n        int: The largest prime factor of n.\n\n    Examples:\n        >>> largest_prime_factor(13195)\n        29\n        >>> largest_prime_factor(2048)\n        2\n    \"\"\"\n    # Start with the smallest prime number\n    i = 2\n    # Keep dividing n by i as long as it's divisible, and i is prime\n    while i * i <= n:\n        if n % i:  # If i does not divide n, move to next number\n            i += 1\n        else:\n            n //= i  # Divide n by i as many times as possible\n    return n if n > 1 else i  # If n is reduced to 1, the last i is the largest factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Args:\n        n (int): The number whose largest prime factor is to be found.\n\n    Returns:\n        int: The largest prime factor of n.\n\n    Examples:\n        >>> largest_prime_factor(13195)\n        29\n        >>> largest_prime_factor(2048)\n        2\n    \"\"\"\n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start with the smallest prime number, which is 2\n    factor = 2\n    largest_factor = 1\n    \n    # Divide out all factors of 2 first\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Now check odd numbers only for efficiency\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n    \n    # If n is greater than 2 at this point, it must be the largest prime factor\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Args:\n    n (int): The number to find the largest prime factor of.\n    \n    Returns:\n    int: The largest prime factor of n.\n    \n    Examples:\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime number\n    largest_factor = 1\n    # Divide n by 2 while it is even\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check for odd factors up to the square root of n\n    factor = 3\n    while factor * factor <= n:\n        if n % factor == 0:\n            largest_factor = max(largest_factor, factor)\n            while n % factor == 0:\n                n = n // factor\n        factor += 2\n    \n    # If n is still greater than 1, then it is prime itself\n    if n > 1:\n        largest_factor = max(largest_factor, n)\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Args:\n    n (int): The number whose largest prime factor is to be found.\n    \n    Returns:\n    int: The largest prime factor of n.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor to 1\n    largest_factor = 1\n    \n    # Handle the case where n is already a prime\n    if n > 1:\n        # Start with the smallest prime, 2\n        factor = 2\n        while factor * factor <= n:\n            if n % factor == 0:\n                # Update largest prime factor\n                largest_factor = factor\n                # Divide n by factor until it's no longer divisible to get past all multiples of factor\n                while n % factor == 0:\n                    n //= factor\n            factor += 1\n        \n        # If n is still greater than 1, then n itself is a prime number\n        if n > 1:\n            largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Examples:\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Function to determine if a number is prime\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Start with the smallest prime\n    largest_factor = 1\n    \n    # Check each number up to sqrt(n) for prime factorization\n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            # If we find a prime factor, update largest_factor\n            if is_prime(i):\n                largest_factor = max(largest_factor, i)\n            n //= i\n    \n    # If n is still greater than 1, it means n itself is prime\n    if n > 1:\n        largest_factor = max(largest_factor, n)\n    \n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    This function finds the largest prime factor of a number by iteratively dividing\n    by its smallest prime factor until the number is reduced to 1.\n\n    Args:\n        n (int): The number whose largest prime factor is to be found.\n\n    Returns:\n        int: The largest prime factor of n.\n\n    Examples:\n        >>> largest_prime_factor(13195)\n        29\n        >>> largest_prime_factor(2048)\n        2\n    \"\"\"\n    # Initialize largest factor\n    largest = 1\n    \n    # Keep dividing by 2 until n is no longer even\n    while n % 2 == 0:\n        largest = 2\n        n //= 2\n    \n    # Check for odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest = factor\n            n //= factor\n        factor += 2\n    \n    # If n is not 1 at this point, then n itself is the largest prime factor\n    if n > 1:\n        largest = n\n\n    return largest", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 92.46753246753246, "dps_norm": 63.75, "pass@1": 66.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert string to lowercase to handle case-insensitivity\n    s = s.lower()\n    \n    # Define vowels including 'y' for the case check\n    vowels = 'aeiou'\n    \n    # Count vowels\n    count = sum(1 for char in s if char in vowels)\n    \n    # Check if 'y' is at the end\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define vowels, including 'y' for the case where it's at the end\n    vowels = 'aeiouAEIOU'\n    \n    # Count vowels\n    count = sum(1 for char in s.lower() if char in vowels)\n    \n    # Check if 'y' is at the end of the word\n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    1\n    >>> vowels_count(\"yay\")\n    2\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"AEIOU\")\n    5\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"flyby\")\n    1\n    \"\"\"\n    vowels = set('aeiou')\n    count = sum(1 for char in s.lower() if char in vowels)\n    # Check if 'y' at the end counts as a vowel\n    if s and s[-1].lower() == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert the string to lowercase for simplicity in checking\n    s = s.lower()\n    vowels = 'aeiou'\n    \n    # Count vowels where 'y' is treated as a vowel only at the end of the word\n    count = sum(1 for char in s if char in vowels) + (1 if s and s[-1] == 'y' and s[-1] not in vowels else 0)\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Return the count of vowels in the given string.\n    \n    Vowels include 'a', 'e', 'i', 'o', 'u'. 'y' is considered a vowel only at the end of the string.\n\n    Examples:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    1\n    >>> vowels_count(\"a\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"AEIOUaeiou\")\n    10\n    >>> vowels_count(\"yay\")\n    2  # 'y' counts at the end\n    >>> vowels_count(\"yttria\") \n    1  # 'y' does not count here since it's not at the end\n\n    :param s: String to check for vowels\n    :return: Integer representing the number of vowels\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = 0\n    \n    # Count normal vowels\n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check for 'y' or 'Y' at the end\n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Examples:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    1\n    >>> vowels_count(\"try\")\n    1\n    >>> vowels_count(\"queue\")\n    3\n    >>> vowels_count(\"YELLOW\")\n    2\n    >>> vowels_count(\"ay\")  # 'y' at the end\n    2\n    >>> vowels_count(\"A\")\n    1\n    >>> vowels_count(\"\")  # empty string\n    0\n    \"\"\"\n    # Convert to lower case for case insensitivity\n    s = s.lower()\n    \n    # Define vowels\n    vowels = 'aeiou'\n    \n    # Count vowels excluding 'y'\n    count = sum(1 for char in s if char in vowels)\n    \n    # Check if 'y' at the end should be counted as a vowel\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert string to lowercase for easier checking\n    s = s.lower()\n    vowels = set('aeiou')\n    count = sum(1 for char in s if char in vowels)\n    # Check if 'y' at the end should be counted as a vowel\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert string to lower case for case insensitivity\n    s = s.lower()\n    vowels = 'aeiou'\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the string\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert string to lowercase to make comparison easier\n    s = s.lower()\n    vowels = 'aeiou'\n    count = 0\n    \n    # Count all vowels except 'y' which has special condition\n    for char in s:\n        if char in vowels:\n            count += 1\n\n    # Check if 'y' at the end should count as a vowel\n    if s.endswith('y'):\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    \n    # Count all vowels except 'y'\n    count = sum(1 for char in s if char in vowels)\n    \n    # Check if the word ends with 'y' or 'Y'\n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert string to lowercase for case insensitivity\n    s = s.lower()\n    vowels = 'aeiou'\n    \n    # Count the vowels; 'y' at the end is counted separately\n    count = sum(s.count(vowel) for vowel in vowels)\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "import unittest\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert the string to lowercase for simplicity\n    s = s.lower()\n    # Vowels\n    vowels = 'aeiou'\n    count = sum(1 for char in s if char in vowels)\n\n    # Check if 'y' is at the end\n    if s and s[-1] == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert the string to lowercase to handle case insensitivity\n    s = s.lower()\n    \n    # Vowels excluding 'y'\n    vowels = set('aeiou')\n    \n    # Count of vowels including 'y' at the end if applicable\n    count = sum(1 for char in s if char in vowels)\n    \n    # Check if 'y' at the end should count as a vowel\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    1\n    >>> vowels_count(\"a\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"aeiouy\")\n    6\n    >>> vowels_count(\"AYYMD\")\n    2\n    \"\"\"\n    # Convert the string to lowercase for easier vowel checking\n    s = s.lower()\n    vowels = set('aeiou')\n    count = sum(1 for char in s if char in vowels)\n    \n    # Check if 'y' is at the end and should be counted as a vowel\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Examples:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"a\")\n    1\n    >>> vowels_count(\"aeiou\")\n    5\n    >>> vowels_count(\"AEIOU\")\n    5\n    >>> vowels_count(\"rhythm\")\n    1\n    >>> vowels_count(\"SYZYGY\")\n    3\n    >>> vowels_count(\"\")\n    0\n    \"\"\"\n    # Define vowels including 'y' for checking at the end of the word\n    vowels = 'aeiouAEIOU'\n    \n    # Convert s to lowercase for case-insensitive comparison, but keep the original for checking 'y'\n    count = sum(1 for char in s.lower() if char in vowels)\n    \n    # Check if 'y' at the end of the word should be counted as a vowel\n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' at the end is a vowel\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Examples:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    1\n    >>> vowels_count(\"aeiou\")\n    5\n    >>> vowels_count(\"bcdfgh\")\n    0\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"aye\")\n    2\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"Y\")\n    0\n    >>> vowels_count(\"Ly\")\n    1\n    \"\"\"\n    # Convert string to lower case to handle case insensitivity\n    s = s.lower()\n    # Define vowels\n    vowels = set('aeiou')\n    # Count\n    count = sum(1 for char in s if char in vowels)\n    \n    # Check if 'y' at the end is a vowel\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "import unittest\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define vowels, 'y' will be checked separately\n    vowels = set('aeiouAEIOU')\n    # Convert string to lower for case-insensitive counting\n    s = s.lower()\n    \n    # Count vowels, including 'y' if it's the last character\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Returns the number of vowels in the given string. \n    Vowels considered are 'a', 'e', 'i', 'o', 'u'. 'y' is counted as a vowel when it's at the end of the word.\n\n    Args:\n    s (str): A string representing a word.\n\n    Returns:\n    int: The number of vowels in the string.\n\n    Examples:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"Rhythm\")\n    1\n    \"\"\"\n    # Convert the string to lower case for simplicity in checking vowels\n    s = s.lower()\n    # Count vowels, treating 'y' at the end specially\n    vowels = set('aeiou')\n    count = sum(1 for char in s if char in vowels)\n    # Check if 'y' is at the end and not already counted\n    if s and s[-1] == 'y' and 'y' not in vowels:\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "import unittest\ndef vowels_count(s):\n    \"\"\"Count the number of vowels in a word.\n    Vowels are 'a', 'e', 'i', 'o', 'u', and 'y' at the end of the word.\n    \n    Args:\n        s (str): A string representing a word.\n    \n    Returns:\n        int: The number of vowels in the string.\n    \n    Examples:\n        >>> vowels_count(\"abcde\")\n        2\n        >>> vowels_count(\"ACEDY\")\n        3\n    \"\"\"\n    # Convert the string to lowercase for easier vowel checking\n    s = s.lower()\n    # Define vowels\n    vowels = 'aeiou'\n    count = sum(1 for char in s if char in vowels)\n    \n    # Check if 'y' is at the end and add it to the count if it's not already counted as a vowel\n    if s and s[-1] == 'y' and 'y' not in vowels:\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 96.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than or equal to the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in lst1\n    total_chars1 = sum(len(s) for s in lst1)\n    \n    # Calculate the total number of characters in lst2\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # If total_chars1 is less than or equal to total_chars2, return lst1\n    # otherwise, return lst2\n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total length of characters for each list\n    len1 = sum(len(item) for item in lst1)\n    len2 = sum(len(item) for item in lst2)\n    \n    # If lengths are the same or list1's length is less than list2's length, return lst1, otherwise lst2\n    return lst1 if len1 <= len2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Args:\n    lst1 (list): First list of strings.\n    lst2 (list): Second list of strings.\n\n    Returns:\n    list: The list with fewer total characters or lst1 if totals are equal.\n\n    Examples:\n    >>> total_match([], [])\n    []\n    >>> total_match(['hi', 'admin'], ['hI', 'Hi'])\n    ['hI', 'Hi']\n    >>> total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ['hi', 'admin']\n    >>> total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n    ['hI', 'hi', 'hi']\n    >>> total_match(['4'], ['1', '2', '3', '4', '5'])\n    ['4']\n    '''\n\n    # Calculate the sum of lengths for each string in both lists\n    len_sum1 = sum(len(s) for s in lst1)\n    len_sum2 = sum(len(s) for s in lst2)\n    \n    # Return the list with smaller total length or lst1 if lengths are equal\n    return lst1 if len_sum1 <= len_sum2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list that has a total number of characters in all strings less than the other list.\n    If equal, returns the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the sum of lengths for both lists\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n    \n    # Return the list with the lesser total length, or lst1 if they are equal\n    return lst2 if sum2 < sum1 else lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Args:\n    lst1 (list): First list of strings.\n    lst2 (list): Second list of strings.\n\n    Returns:\n    list: The list with fewer total characters or lst1 if they are equal in character count.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in lst1\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    \n    # Calculate the total number of characters in lst2\n    total_chars_lst2 = sum(len(word) for word in lst2)\n    \n    # Return the list with less total characters\n    if total_chars_lst1 < total_chars_lst2 or total_chars_lst1 == total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Args:\n    lst1 (list): First list of strings\n    lst2 (list): Second list of strings\n\n    Returns:\n    list: The list with the fewer total character count, or lst1 if counts are equal.\n\n    Examples:\n    >>> total_match([], [])\n    []\n    >>> total_match(['hi', 'admin'], ['hI', 'Hi'])\n    ['hI', 'Hi']\n    >>> total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ['hi', 'admin']\n    >>> total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n    ['hI', 'hi', 'hi']\n    >>> total_match(['4'], ['1', '2', '3', '4', '5'])\n    ['4']\n    '''\n    # Calculate the total number of characters for each list\n    sum_lst1 = sum(len(s) for s in lst1)\n    sum_lst2 = sum(len(s) for s in lst2)\n\n    # Return the list with the lesser sum of characters\n    # If both have the same sum, return lst1 as per the condition\n    return lst1 if sum_lst1 <= sum_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Compares two lists of strings based on the total number of characters.\n\n    This function returns the list with the fewer total characters. If both lists \n    have an equal number of characters, the first list is returned.\n\n    Args:\n    lst1 (list): A list of strings to compare.\n    lst2 (list): Another list of strings to compare.\n\n    Returns:\n    list: The list with fewer or equal total character count.\n\n    Examples:\n    >>> total_match([], []) \n    []\n    >>> total_match(['hi', 'admin'], ['hI', 'Hi'])\n    ['hI', 'Hi']\n    >>> total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ['hi', 'admin']\n    >>> total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n    ['hI', 'hi', 'hi']\n    >>> total_match(['4'], ['1', '2', '3', '4', '5'])\n    ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Return the list with the lower total character count, or lst1 if equal\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than or equal to the other list.\n\n    If the total number of chars are equal, return lst1.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Return the list with fewer total characters, or lst1 if equal\n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than or equal to the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples:\n    >>> total_match([], []) \n    []\n    >>> total_match(['hi', 'admin'], ['hI', 'Hi']) \n    ['hI', 'Hi']\n    >>> total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ['hi', 'admin']\n    >>> total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n    ['hI', 'hi', 'hi']\n    >>> total_match(['4'], ['1', '2', '3', '4', '5'])\n    ['4']\n    '''\n    # Calculate the total length of characters in each list\n    len_lst1 = sum(len(s) for s in lst1)\n    len_lst2 = sum(len(s) for s in lst2)\n    \n    # Return the list with fewer total characters, or lst1 if they are equal\n    return lst1 if len_lst1 <= len_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, returns the first list.\n\n    Args:\n    lst1 (list): First list of strings\n    lst2 (list): Second list of strings\n\n    Returns:\n    list: The list with fewer total characters, or lst1 if totals are equal.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    \n    # Function to calculate total character count in a list\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n    \n    # Return the list with the smaller character count, or lst1 if they are equal\n    return lst1 if count1 <= count2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Parameters:\n    lst1 (list): First list of strings\n    lst2 (list): Second list of strings\n\n    Returns:\n    list: The list with less total characters or lst1 if equal\n\n    Examples:\n    >>> total_match([], [])\n    []\n    >>> total_match(['hi', 'admin'], ['hI', 'Hi'])\n    ['hI', 'Hi']\n    >>> total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ['hi', 'admin']\n    >>> total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n    ['hI', 'hi', 'hi']\n    >>> total_match(['4'], ['1', '2', '3', '4', '5'])\n    ['4']\n    '''\n    \n    # Function to calculate total length of characters in a list\n    def total_char_length(lst):\n        return sum(len(s) for s in lst)\n\n    # Calculate total lengths\n    len1, len2 = total_char_length(lst1), total_char_length(lst2)\n    \n    # Compare lengths and return appropriate list\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Compares two lists of strings and returns the list with fewer total characters.\n    \n    If both lists have the same number of characters, returns the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    \n    # Calculate total length of characters in lst1\n    len_lst1 = sum(len(s) for s in lst1)\n    \n    # Calculate total length of characters in lst2\n    len_lst2 = sum(len(s) for s in lst2)\n    \n    # Return the list with fewer total characters, or lst1 if totals are equal\n    return lst1 if len_lst1 <= len_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in lst1\n    total_chars1 = sum(len(s) for s in lst1)\n    \n    # Calculate the total number of characters in lst2\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Compare the totals and decide which list to return\n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples:\n    >>> total_match([], []) \n    []\n    >>> total_match(['hi', 'admin'], ['hI', 'Hi'])\n    ['hI', 'Hi']\n    >>> total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ['hi', 'admin']\n    >>> total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n    ['hI', 'hi', 'hi']\n    >>> total_match(['4'], ['1', '2', '3', '4', '5'])\n    ['4']\n    '''\n    # Calculate the total number of characters in lst1\n    total_chars1 = sum(len(s) for s in lst1)\n    \n    # Calculate the total number of characters in lst2\n    total_chars2 = sum(len(s) for s in lst2)\n\n    # Compare the totals and return the appropriate list\n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Determines which list has a lower total character count.\n\n    Args:\n    lst1 (list): A list of strings.\n    lst2 (list): Another list of strings to compare against.\n\n    Returns:\n    list: The list with fewer total characters, or lst1 if counts are equal.\n\n    Examples:\n    >>> total_match([], [])\n    []\n    >>> total_match(['hi', 'admin'], ['hI', 'Hi'])\n    ['hI', 'Hi']\n    >>> total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ['hi', 'admin']\n    >>> total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n    ['hI', 'hi', 'hi']\n    >>> total_match(['4'], ['1', '2', '3', '4', '5'])\n    ['4']\n    '''\n    # Function to calculate total characters in a list of strings\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    # Calculate the total characters for both lists\n    count_lst1 = total_chars(lst1)\n    count_lst2 = total_chars(lst2)\n\n    # Return the list with the lower total character count, or lst1 if they are equal\n    if count_lst1 <= count_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Accepts two lists of strings and returns the list that has \n    total number of chars in all strings less than or equal to the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Args:\n    lst1 (list): The first list of strings\n    lst2 (list): The second list of strings\n\n    Returns:\n    list: The list with fewer or equal total character count, preferring lst1 in case of a tie.\n\n    Examples:\n    >>> total_match([], [])\n    []\n    >>> total_match(['hi', 'admin'], ['hI', 'Hi'])\n    ['hI', 'Hi']\n    >>> total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ['hi', 'admin']\n    >>> total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n    ['hI', 'hi', 'hi']\n    >>> total_match(['4'], ['1', '2', '3', '4', '5'])\n    ['4']\n    '''\n    # Calculate the total character count for lst1\n    count_lst1 = sum(len(s) for s in lst1)\n    \n    # Calculate the total character count for lst2\n    count_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the counts\n    if count_lst1 <= count_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    This function accepts two lists of strings and returns the list that has \n    a lower total character count among all its strings. If equal, it returns lst1.\n\n    Args:\n    lst1 (list): A list of strings to compare.\n    lst2 (list): Another list of strings to compare.\n\n    Returns:\n    list: The list with fewer total characters or lst1 if character counts are equal.\n\n    Examples:\n    >>> total_match([], [])\n    []\n    >>> total_match(['hi', 'admin'], ['hI', 'Hi'])\n    ['hI', 'Hi']\n    >>> total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ['hi', 'admin']\n    >>> total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n    ['hI', 'hi', 'hi']\n    >>> total_match(['4'], ['1', '2', '3', '4', '5'])\n    ['4']\n    '''\n\n    # Calculate the total length of characters in lst1\n    length_lst1 = sum(len(item) for item in lst1)\n    \n    # Calculate the total length of characters in lst2\n    length_lst2 = sum(len(item) for item in lst2)\n    \n    # Compare and return the list with fewer total characters, or lst1 if equal\n    return lst1 if length_lst1 <= length_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    \n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n\n    # Calculate the total character count for both lists\n    total1 = count_chars(lst1)\n    total2 = count_chars(lst2)\n\n    # Compare and return according to the rules provided\n    if total1 == total2:\n        return lst1\n    elif total1 < total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Compares two lists of strings and returns the list with fewer total characters.\n    If both lists have the same number of characters, returns the first list.\n\n    Args:\n    lst1 (list): First list of strings.\n    lst2 (list): Second list of strings.\n\n    Returns:\n    list: The list with the least total character count or the first list if equal.\n\n    Examples:\n    >>> total_match([], [])\n    []\n    >>> total_match(['hi', 'admin'], ['hI', 'Hi'])\n    ['hI', 'Hi']\n    >>> total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ['hi', 'admin']\n    >>> total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n    ['hI', 'hi', 'hi']\n    >>> total_match(['4'], ['1', '2', '3', '4', '5'])\n    ['4']\n    '''\n\n    # Calculate total characters in lst1\n    count_lst1 = sum(len(s) for s in lst1)\n\n    # Calculate total characters in lst2\n    count_lst2 = sum(len(s) for s in lst2)\n\n    # If lst1 has less or equal total characters than lst2, return lst1\n    if count_lst1 <= count_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than or equal to the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Args:\n    lst1 (list): A list of strings\n    lst2 (list): A list of strings\n\n    Returns:\n    list: The list with fewer total characters or lst1 if both have the same total.\n\n    Examples:\n    >>> total_match([], [])\n    []\n    >>> total_match(['hi', 'admin'], ['hI', 'Hi'])\n    ['hI', 'Hi']\n    >>> total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ['hi', 'admin']\n    >>> total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n    ['hI', 'hi', 'hi']\n    >>> total_match(['4'], ['1', '2', '3', '4', '5'])\n    ['4']\n    '''\n\n    # Calculate the total length of characters for each list\n    len1 = sum(len(item) for item in lst1)\n    len2 = sum(len(item) for item in lst2)\n    \n    # Compare the lengths and return accordingly\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 85.0, "dps_norm": 51.666666666666664, "pass@1": 98.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: The sum of even integers found at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Use a list comprehension to select even numbers at odd indices, then sum them\n    return sum([num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: The sum of even integers at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 7, 9])\n        0\n        >>> add([1, 2, 3, 4, 5, 6])\n        6\n    \"\"\"\n    # Use list comprehension with a condition to sum even numbers at odd indices\n    # Odd indices in Python start from 1, 3, 5, etc.\n    return sum([x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n    lst (list of int): A non-empty list of integers.\n\n    Returns:\n    int: The sum of even integers at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([3, 3, 1, 7, 8])\n        0\n        >>> add([8, 8, 4, 6, 8])\n        14\n    \"\"\"\n    # Filter the list to get elements at odd indices\n    odd_index_elements = lst[1::2]\n    \n    # Filter to keep only even elements and then sum them\n    return sum(num for num in odd_index_elements if num % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    This function goes through the list `lst` and sums up all the even numbers\n    found at odd indices (1, 3, 5, etc.). \n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2 \n        >>> add([1, 2, 3, 4, 5, 6])\n        6\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even integers at odd indices in lst.\n\n    \"\"\"\n    # Initialize the sum\n    total = 0\n    \n    # Iterate through the list with enumeration to track the index\n    for index, num in enumerate(lst):\n        # Check if the index is odd and the number is even\n        if index % 2 != 0 and num % 2 == 0:\n            total += num\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n    lst (list of int): A list of integers.\n\n    Returns:\n    int: The sum of all even integers at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 7])\n        0\n        >>> add([2, 4, 6, 8])\n        6\n    \"\"\"\n    # Use a list comprehension to filter even numbers at odd indices,\n    # then sum them up. Remember that index 0 is even, so we start from 1 (which is odd)\n    return sum([num for idx, num in enumerate(lst) if idx % 2 == 1 and num % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, this function adds the even elements that are at odd indices.\n\n    Args:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: The sum of even elements at odd indices in the list.\n\n    Examples:\n    >>> add([4, 2, 6, 7])\n    2\n    >>> add([1, 3, 5, 7, 9])\n    0\n    >>> add([2, 4, 5, 7, 8])\n    4\n    \"\"\"\n    # Sum the even numbers which are at odd indices\n    # Odd indices in Python list are 1, 3, 5, etc.\n    return sum(num for index, num in enumerate(lst) if index % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Args:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: The sum of even integers found at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 2, 3, 4])\n        0\n        >>> add([10, 20, 30, 40])\n        20\n    \"\"\"\n    # Use list comprehension to filter and sum even numbers at odd indices\n    # Indexing in Python starts at 0, so odd indices are 1, 3, 5, etc.\n    return sum([num for idx, num in enumerate(lst) if idx % 2 != 0 and num % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, this function adds the even elements \n    that are at odd indices in the list.\n\n    Parameters:\n    lst (list of int): The input list of integers.\n\n    Returns:\n    int: Sum of even numbers at odd indices.\n\n    Examples:\n    >>> add([4, 2, 6, 7])\n    2\n    >>> add([5, 7, 4, -9, 4, 2])\n    2\n    >>> add([1, 2, 3, 4])\n    4\n    \"\"\"\n    # Use list comprehension to find even numbers at odd indices,\n    # then sum them up\n    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0])", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Parameters:\n    lst (list of int): A non-empty list of integers.\n\n    Returns:\n    int: The sum of even numbers found at odd indices (1-based indexing).\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([5, 7, 2, 3, 8, 4])\n        2\n        >>> add([5, 2, 6, 1, 9])\n        0\n    \"\"\"\n    # Use enumerate to iterate over both index and value, where index starts at 0\n    return sum([num for idx, num in enumerate(lst) if num % 2 == 0 and idx % 2 != 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Args:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: The sum of even elements at odd indices.\n\n    Examples:\n    >>> add([4, 2, 6, 7])\n    2\n    >>> add([1, 2, 3, 4, 5, 6, 7, 8])\n    6\n    >>> add([10, 11, 12, 13])\n    0\n    \"\"\"\n    # Sum up all even numbers that are at an odd index (remember, Python uses 0-indexing, so we check for 1, 3, 5, ...)\n    return sum(num for index, num in enumerate(lst) if index % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, this function adds the even elements that are at odd indices.\n\n    Parameters:\n    lst (list of int): The input list of integers.\n\n    Returns:\n    int: The sum of all even integers found at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    # Use list comprehension to select even numbers at odd indices and sum them\n    return sum(num for index, num in enumerate(lst) if index % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Use list comprehension to filter even numbers at odd indices and sum them up\n    return sum([num for idx, num in enumerate(lst) if idx % 2 != 0 and num % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n    lst (list of int): A non-empty list of integers.\n\n    Returns:\n    int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 2, 3, 4, 5, 6])\n        4\n        >>> add([2, 4, 6, 8, 10, 12])\n        8\n    \"\"\"\n    # Use list comprehension to filter and sum the required numbers\n    # Odd index means index % 2 != 0 in Python, \n    # and we only want even numbers at those indices\n    return sum([num for idx, num in enumerate(lst) if idx % 2 != 0 and num % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2  # Only the second element (index 1) is even at an odd index\n    \"\"\"\n    # Use a list comprehension to find even numbers at odd indices and sum them\n    return sum([num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n    lst (list): A list of integers.\n\n    Returns:\n    int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2  # 2 is at index 1 (odd)\n        add([4, 3, 2, 5]) ==> 0  # No even numbers at odd indices\n        add([1, 2, 3, 4, 5, 6]) ==> 8  # 2 at index 1 + 6 at index 5\n    \"\"\"\n    # Sum only the even numbers at odd indices (indices 1, 3, 5, ...)\n    return sum(number for index, number in enumerate(lst) if index % 2 != 0 and number % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    This function calculates the sum of all even numbers found at indices \n    1, 3, 5, etc. (odd indices, starting from 1).\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of all even numbers at odd positions in the list.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 2, 3, 4])\n        4\n        >>> add([1, 3, 5, 7])\n        0\n    \"\"\"\n    # Initialize sum to zero\n    total = 0\n    # Loop through the list by index, checking only odd indices\n    for i in range(1, len(lst), 2):\n        # If the number at an odd index is even, add it to the total\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2  # Explanation: 2 (even at index 1) + 0 (6 is not at an odd index)\n        add([1, 3, 1, 2]) ==> 0  # Explanation: No even elements at odd indices\n        add([3, 5, 6, 2]) ==> 2  # Explanation: 2 (even at index 3)\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of all even numbers at odd indices.\n    \"\"\"\n    # Use list comprehension to sum up even numbers at odd indices\n    # Index is odd if (index % 2 != 0), number is even if (num % 2 == 0)\n    return sum(num for index, num in enumerate(lst) if index % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n    lst (list of int): A non-empty list of integers.\n\n    Returns:\n    int: The sum of the even integers found at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1,2,3,4,5,6,7])\n        10\n        >>> add([7,1,2,4,7,2])\n        2\n        >>> add([1,3,5,7,4])\n        0\n    \"\"\"\n    # Sum elements where the index is odd (1, 3, 5, etc.) and the number is even\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    This function iterates through the list, checks if an element is at an odd index\n    (indexing from 0, so index 1, 3, 5, etc. are considered odd) and if that element\n    is even, it adds this element to the sum.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([4, 5, 6, 2, 3])\n        6\n        >>> add([2, 3, 4, 5])\n        0\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n    \"\"\"\n    return sum([num for idx, num in enumerate(lst) if idx % 2 != 0 and num % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, this function adds the even elements \n    that are at odd indices.\n\n    Parameters:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: The sum of even numbers located at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 2, 3, 4, 5, 6])\n        6\n    \"\"\"\n    # Use list comprehension to find even numbers at odd indices (index starts from 0)\n    # Since we're interested in odd indices, we check if index % 2 != 0\n    return sum([num for index, num in enumerate(lst) if num % 2 == 0 and index % 2 != 0])", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "HumanEval/87": {"dps": 93.94812680115274, "dps_norm": 57.142857142857146, "pass@1": 96.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    Find coordinates of integer x in the given 2D list (nested lists),\n    sorted by row in ascending order and by column in descending order.\n\n    Args:\n    lst (List[List[int]]): A nested list representing rows of possibly varying lengths.\n    x (int): The integer to search for.\n\n    Returns:\n    List[Tuple[int, int]]: List of (row, column) tuples where x was found.\n\n    Examples:\n    >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    result = []\n    \n    for row_index, row in enumerate(lst):\n        # Find all occurrences of x in the current row\n        for col_index in [i for i, elem in enumerate(row) if elem == x]:\n            result.append((row_index, col_index))\n    \n    # Sort by row in ascending order\n    result.sort(key=lambda coord: coord[0])\n    \n    # Group by row and sort within each group by column in descending order\n    from itertools import groupby\n    result = [list(group) for key, group in groupby(result, key=lambda x: x[0])]\n    result = [sorted(sublist, key=lambda x: x[1], reverse=True) for sublist in result]\n    # Flatten the list of lists back to a list of tuples\n    return [coord for group in result for coord in group]", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find coordinates of x in a jagged list, returning a sorted list of tuples.\n\n    :param lst: A list of lists where each inner list may have a different length\n    :param x: Integer to search for within the list\n    :return: List of tuples containing coordinates (row, column) sorted as specified\n\n    Example:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \"\"\"\n    result = []\n    for row, row_list in enumerate(lst):\n        # Find the positions of x in the current row\n        for col in [i for i, value in enumerate(row_list) if value == x]:\n            result.append((row, col))\n\n    # Sort by row in ascending order, then by column in descending order within each row\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list where each sublist may have different lengths,\n    this function finds all occurrences of integer x and returns\n    their coordinates sorted as specified.\n\n    Args:\n    lst (List[List[int]]): A 2D list representing the matrix.\n    x (int): The integer to search for.\n\n    Returns:\n    List[Tuple[int, int]]: List of coordinates (row, column) where x is found,\n                           sorted by row ascending and column descending.\n\n    Examples:\n    >>> get_row([[1,2,3],[1,2,1],[1,2,3]], 1)\n    [(0, 0), (1, 2), (1, 0), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    coords = []\n    \n    # Iterate through rows\n    for i, row in enumerate(lst):\n        # Find all columns where x is present in this row\n        for j, elem in enumerate(row):\n            if elem == x:\n                coords.append((i, j))\n    \n    # Sort first by row (index 0 of tuple) ascending, then by column (index 1) descending\n    return sorted(coords, key=lambda coord: (coord[0], -coord[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find and return coordinates of all occurrences of x in a 2D list,\n    where rows can have different lengths.\n\n    Args:\n    lst (List[List[int]]): A 2D list where each sublist can have different lengths.\n    x (int): The value to search for.\n\n    Returns:\n    List[Tuple[int, int]]: A list of (row, column) tuples where x is found,\n    sorted by row in ascending order, and then by column in descending order within each row.\n\n    Examples:\n    >>> get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    # Collect all coordinates of x\n    coords = [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]\n    \n    # Group coordinates by row\n    coords_by_row = {}\n    for coord in coords:\n        if coord[0] in coords_by_row:\n            coords_by_row[coord[0]].append(coord[1])\n        else:\n            coords_by_row[coord[0]] = [coord[1]]\n    \n    # Sort within rows by column in descending order\n    sorted_coords = []\n    for row in sorted(coords_by_row.keys()):  # Ensure rows are in ascending order\n        sorted_columns = sorted(coords_by_row[row], reverse=True)\n        sorted_coords.extend([(row, col) for col in sorted_columns])\n    \n    return sorted_coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find integers x in the nested list and return their coordinates.\n\n    Args:\n    lst (List[List[int]]): A list of lists where each inner list might have different lengths.\n    x (int): The integer to search for.\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples where each tuple contains the row and column index of x.\n\n    The results are sorted by row in ascending order, and within each row, \n    by column in descending order.\n\n    Examples:\n    >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    # Initialize an empty list to store the results\n    coordinates = []\n    \n    # Iterate through each row with its index\n    for row_index, row in enumerate(lst):\n        # Find all occurrences of x in the current row\n        for col_index in [i for i, value in enumerate(row) if value == x]:\n            # Append the coordinate as a tuple\n            coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by row in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort within each row by column in descending order\n    # Here we use the fact that lists are stable-sorted in Python, so the row order remains intact\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find the coordinates (row, column) of integer x in the nested list.\n\n    Parameters:\n    lst (list of lists): A nested list where each sublist might have different lengths.\n    x (int): The integer to find within the nested list.\n\n    Returns:\n    list of tuples: Coordinates (row, column) sorted as described.\n\n    Examples:\n    >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    # Collect coordinates\n    coords = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coords.append((i, j))\n    \n    # Sort by row (index 0 of tuple) in ascending order, \n    # then within each row by column (index 1) in descending order\n    coords.sort(key=lambda pair: (pair[0], -pair[1]))\n    \n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds coordinates of x in a 2D list (nested lists), where each row can have a different number of columns.\n\n    Parameters:\n    lst (List[List[int]]): The 2D list to search through.\n    x (int): The integer to search for.\n\n    Returns:\n    List[Tuple[int, int]]: List of tuples representing (row, column) coordinates, sorted by row (ascending)\n    and column within each row (descending).\n\n    Examples:\n    >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    # Find all coordinates where x exists\n    coordinates = [(i, j) for i, row in enumerate(lst) for j, value in enumerate(row) if value == x]\n    \n    # Sort by row in ascending order, then by column in descending order within each row\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n    \n    return sorted_coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find coordinates of the given integer x in a 2D ragged list.\n\n    Args:\n    lst (List[List[int]]): A 2D list with rows potentially of different lengths.\n    x (int): The integer to search for.\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples containing (row, column) coordinates where x is found.\n                           Rows are sorted in ascending order and within each row, columns in descending order.\n\n    Examples:\n    ```python\n    get_row([[1,2,3,4,5,6],\n             [1,2,3,4,1,6],\n             [1,2,3,4,5,1]], 1)\n    # [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    get_row([], 1) # []\n    get_row([[], [1], [1, 2, 3]], 3) # [(2, 2)]\n    ```\n    \"\"\"\n    # Initialize an empty list to store results\n    coords = []\n\n    # Iterate through the list with enumerate to keep track of row indices\n    for row_index, row in enumerate(lst):\n        # Find all column indices where x occurs in this row\n        cols = [col_index for col_index, num in enumerate(row) if num == x]\n        # Add coordinates to the list with correct sorting in columns\n        for col in cols:\n            coords.append((row_index, col))\n    \n    # Sort coordinates by row in ascending order\n    coords.sort(key=lambda pair: (pair[0], -pair[1]))\n    \n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the coordinates of integer x in a ragged 2D list (matrix-like structure).\n\n    Args:\n    lst (List[List[int]]): A 2D list where each inner list might have a different length.\n    x (int): The integer to search for.\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples (row, column) sorted as described.\n\n    Examples:\n    >>> get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    result = []\n    # Iterate over rows with their indices\n    for i, row in enumerate(lst):\n        # Find all occurrences of x in this row\n        for j, num in enumerate(row):\n            if num == x:\n                result.append((i, j))\n    \n    # Sort by row (first element of tuple) in ascending order,\n    # then by column (second element) in descending order for same rows\n    return sorted(result, key=lambda coord: (coord[0], -coord[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find the coordinates of a given integer x in a jagged 2D list.\n\n    Args:\n    lst (List[List[int]]): A jagged list of lists, each sublist can have different lengths.\n    x (int): The integer to search for within the lst.\n\n    Returns:\n    List[Tuple[int, int]]: List of tuples (row, column) where x is found, sorted first by row \n                           in ascending order, then by column in descending order within each row.\n\n    Examples:\n    >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    coords = []\n    # Iterate through each row in lst with its index\n    for row_index, row in enumerate(lst):\n        # For each element in row, if it matches x, record its coordinates\n        for col_index, item in enumerate(row):\n            if item == x:\n                coords.append((row_index, col_index))\n    \n    # Sort by row (first item of the tuple) ascending\n    coords.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find and return coordinates of integer x in a nested list structure.\n\n    This function searches through a 2D list where each sublist may have\n    a different number of elements. It returns coordinates where x appears,\n    sorted first by row (ascending), then by column within each row (descending).\n\n    Args:\n    lst (list of lists): A 2D list where each row can have a varying number of columns.\n    x (int): The integer to search for.\n\n    Returns:\n    list of tuples: Coordinates (row, column) where x was found, sorted as specified.\n\n    Examples:\n    >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coords = []\n\n    # Iterate over the list, keeping track of row indices\n    for row_index, row in enumerate(lst):\n        # Enumerate over each row for column index and value\n        for col_index, value in enumerate(row):\n            if value == x:\n                # If x is found, append the coordinates as a tuple\n                coords.append((row_index, col_index))\n\n    # Sort by row first (default), then reverse by column\n    return sorted(coords, key=lambda coord: (coord[0], -coord[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    :param lst: List of lists representing a ragged matrix\n    :param x: Integer to search for within the lists\n    :return: List of tuples representing coordinates where x was found\n\n    Examples:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\n    >>> get_row([], 1)\n    []\n\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    # List to hold coordinates\n    coords = []\n\n    # Iterate through each row and its index\n    for row_idx, row in enumerate(lst):\n        # Find all occurrences of x in the row\n        cols = [col_idx for col_idx, val in enumerate(row) if val == x]\n        # Add to the list of coordinates with descending column order\n        coords.extend((row_idx, col) for col in sorted(cols, reverse=True))\n\n    # Sort by row in ascending order (this will keep the column sorting intact since it's done per row)\n    coords.sort(key=lambda coord: coord[0])\n    \n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find and return the coordinates of integer x in a jagged list of lists.\n\n    Args:\n    lst (List[List[int]]): A jagged list representing a matrix where rows can have different lengths.\n    x (int): The integer to find in the list.\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples, each representing the coordinate (row, column) \n                           where x appears, sorted by row in ascending order and within \n                           each row by column in descending order.\n\n    Examples:\n    >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    coords = []\n    # Iterate through each row with its index\n    for row_index, row in enumerate(lst):\n        # Use enumerate again to get column index\n        for col_index, value in enumerate(row):\n            if value == x:\n                coords.append((row_index, col_index))\n    \n    # Sorting by row then by column in descending order\n    coords.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find integers x in the list and return their coordinates.\n    \n    Parameters:\n    lst (List[List[int]]): A 2D list representing a ragged matrix.\n    x (int): The integer to find in the 2D list.\n    \n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing (row, column) coordinates \n                           where x is found. Coordinates are sorted by row then \n                           by column in descending order within each row.\n    \"\"\"\n    result = []\n    \n    # Iterate through each row and its index\n    for row_index, row in enumerate(lst):\n        # Find all indices where x occurs in the current row\n        for col_index in [i for i, val in enumerate(row) if val == x]:\n            result.append((row_index, col_index))\n    \n    # Sort by row (first element of tuple) in ascending order\n    result.sort(key=lambda coord: coord[0])\n    \n    # Group by row for secondary sorting\n    from itertools import groupby\n    sorted_coords = []\n    for row, group in groupby(result, key=lambda x: x[0]):\n        # Within each row, sort by column in descending order\n        sorted_coords.extend(sorted(group, key=lambda x: x[1], reverse=True))\n    \n    return sorted_coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        # Find all occurrences of x in the current row\n        coordinates = [(i, j) for j, val in enumerate(row) if val == x]\n        # Sort coordinates within this row by column in descending order\n        coordinates.sort(key=lambda coord: coord[1], reverse=True)\n        result.extend(coordinates)\n    \n    # The result is already sorted by row since we go through the list sequentially\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find coordinates of integer x in a 2D list (matrix-like) where each row may have a different number of columns.\n\n    Args:\n    lst (List[List[int]]): The 2D list to search in.\n    x (int): The integer to search for.\n\n    Returns:\n    List[Tuple[int, int]]: A list of coordinates (row, column) where x was found, sorted as specified.\n\n    Examples:\n    >>> get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    coords = []\n\n    # Iterate over rows\n    for i, row in enumerate(lst):\n        # Find x in current row, reverse the list to get descending column order\n        coords.extend([(i, j) for j, val in enumerate(reversed(row)) if val == x])\n\n    # Reverse to correct for the enumeration from right to left\n    coords = [(i, len(lst[i]) - 1 - j) for i, j in coords]\n    \n    # Sort by rows in ascending order, and within each row, columns in descending order\n    return sorted(coords, key=lambda coord: (coord[0], -coord[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    \n    # Group by row for secondary sorting\n    from itertools import groupby\n    sorted_coordinates = []\n    for _, group in groupby(coordinates, key=lambda coord: coord[0]):\n        # Within each row, sort by column in descending order\n        sorted_coordinates.extend(sorted(group, key=lambda coord: coord[1], reverse=True))\n    \n    return sorted_coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find and return coordinates of integer x in a 2D list (matrix-like structure) where rows can have different lengths.\n    \n    Args:\n    lst (List[List[int]]): The 2D list to search in.\n    x (int): The integer to find.\n    \n    Returns:\n    List[Tuple[int, int]]: A list of tuples where each tuple represents the coordinates (row, column)\n                           of x in lst. Sorted by rows ascending, then by columns descending.\n\n    Examples:\n    >>> get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all occurrences of x in the current row\n        coordinates_in_row = [(row_idx, col_idx) for col_idx, value in enumerate(row) if value == x]\n        # Sort by columns in descending order\n        result.extend(sorted(coordinates_in_row, key=lambda coord: coord[1], reverse=True))\n    \n    # Now sort by row in ascending order\n    return sorted(result, key=lambda coord: coord[0])", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Collect all coordinates where the element equals x\n    coords = [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]\n    \n    # Group by row index for sorting within rows\n    from itertools import groupby\n    key_func = lambda coord: coord[0]  # Key function to group by row\n    \n    # Sort by rows and then within each row sort by column in descending order\n    sorted_coords = sorted(coords, key=lambda c: (-c[1], c[0]))\n    grouped = groupby(sorted_coords, key=key_func)\n    \n    # Flatten the list back after sorting within rows\n    result = []\n    for _, group in grouped:\n        group_list = list(group)\n        group_list.sort(key=lambda c: c[1], reverse=True)  # Sort columns within row\n        result.extend(group_list)\n    \n    # Now sort all rows in ascending order, but since they were already grouped \n    # by row in ascending order, this step maintains the correct order.\n    return sorted(result, key=lambda c: c[0])", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the coordinates of all occurrences of x in a list of lists.\n\n    :param lst: A list of lists representing a ragged matrix.\n    :param x: An integer to search for within the lists.\n    :return: A list of tuples where each tuple represents (row, column) for x.\n\n    Example:\n    >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \"\"\"\n    coords = []\n    # Iterate over each row in the list\n    for row_index, row in enumerate(lst):\n        # Collect column indices for all occurrences of x in this row\n        for col_index, value in enumerate(row):\n            if value == x:\n                coords.append((row_index, col_index))\n    \n    # Sort by row in ascending order\n    coords.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coords", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.81701030927836, "dps_norm": 37.857142857142854, "pass@1": 90.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet down by four positions (2 * 2).\n\n    This function takes a string and shifts each character according to the following rules:\n    - Lowercase letters are shifted down by four places in the alphabet, wrapping around if necessary.\n    - Uppercase letters are treated similarly.\n    - Non-alphabetic characters remain unchanged.\n\n    Args:\n    s (str): The string to encrypt.\n\n    Returns:\n    str: The encrypted string.\n\n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    def shift_char(c):\n        # Only shift alphabetic characters\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n\n    # Apply the shift to each character in the string\n    return ''.join(map(shift_char, s))", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet down by 4 places (2*2).\n\n    Args:\n    s (str): The string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n\n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # Define the original alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Create a shifted alphabet where each character moves down by 4 positions\n    shifted_alphabet = alphabet[4:] + alphabet[:4]\n    \n    # Convert the string to lowercase to match our alphabet case\n    s = s.lower()\n    \n    # Translate each character using a dictionary comprehension\n    translation_table = str.maketrans(alphabet, shifted_alphabet)\n    encrypted = s.translate(translation_table)\n    \n    return encrypted", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt a string by shifting each letter by 4 positions in the alphabet.\n    \n    Args:\n    s (str): The string to be encrypted.\n    \n    Returns:\n    str: The encrypted string where each character has been shifted down \n         by 2 * 2 = 4 places in the alphabet.\n\n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # Define the original and shifted alphabets\n    original = 'abcdefghijklmnopqrstuvwxyz'\n    shifted = original[4:] + original[:4]\n    \n    # Construct the translation table\n    trans_table = str.maketrans(original + original.upper(), shifted + shifted.upper())\n    \n    # Apply the translation to the input string\n    return s.translate(trans_table)", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts the given string by rotating the alphabet down by four places.\n    \n    This function shifts each letter in the input string by four places in the\n    alphabet. Wrapping around occurs if the shift would go past 'z' or 'Z'.\n\n    Parameters:\n    s (str): The string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n\n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # Define the shift; note that 2 * 2 = 4 as per your specification\n    shift = 4\n    \n    # Helper function to rotate a single character\n    def rotate_char(c):\n        if c.isalpha():\n            # Determine the ASCII offset for 'A' or 'a' based on case\n            offset = ord('A') if c.isupper() else ord('a')\n            # Apply rotation and wrap around if necessary\n            return chr((ord(c) - offset + shift) % 26 + offset)\n        return c  # Return the character unchanged if not a letter\n\n    # Map the rotate_char function over each character in the string\n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the given string by rotating each character in the alphabet down by 4 positions.\n    \n    Args:\n    s (str): The string to encrypt.\n    \n    Returns:\n    str: An encrypted string where each letter has been shifted down by 4 places in the alphabet.\n    \n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # Create a rotated alphabet where each letter shifts down by 2*2 places\n    original = 'abcdefghijklmnopqrstuvwxyz'\n    rotated = original[4:] + original[:4]\n    \n    result = []\n    for char in s.lower():\n        if char.isalpha():  # If it's a letter, shift it\n            index = original.index(char)\n            result.append(rotated[index])\n        else:\n            result.append(char)  # Keep non-alphabetic characters as they are\n    \n    # Join the result and return\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by shifting each letter down the alphabet by 4 places.\n    \n    The function applies a Caesar cipher with a shift of 4 to each character in \n    the input string. If the shift goes past 'z' or 'Z', it wraps around to the \n    beginning of the alphabet. Non-alphabetic characters remain unchanged.\n\n    Args:\n    s (str): The string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n\n    Example:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            # Determine the ASCII starting point based on whether the letter is upper or lower case\n            base = ord('A') if char.isupper() else ord('a')\n            # Calculate the new position with wrap around if necessary\n            shifted = chr(base + (ord(char) - base + 4) % 26)\n            result.append(shifted)\n        else:\n            result.append(char)  # Non-alphabetic characters are appended as they are\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by shifting each character down by 4 places in the alphabet.\n    \n    Parameters:\n    s (str): The string to be encrypted.\n    \n    Returns:\n    str: The encrypted string where each letter is shifted down by 4 places \n         in the alphabet, wrapping around to the beginning if necessary.\n    \n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    def shift_char(c):\n        if c not in alphabet:\n            return c  # Non-alphabet characters remain unchanged\n        index = alphabet.index(c)\n        new_index = (index + 4) % 26  # Shift by 4 and wrap around if necessary\n        return alphabet[new_index]\n    \n    # Encrypt the string by applying the shift to each character\n    return ''.join(shift_char(char.lower()) for char in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating each character by 4 places forward in the alphabet.\n    \n    Args:\n    s (str): The string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n\n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Function to rotate character\n    def shift_char(char, shift=4):\n        if char not in alphabet:\n            return char\n        index = alphabet.index(char)\n        new_index = (index + shift) % 26  # Wrap around if necessary\n        return alphabet[new_index]\n\n    # Apply shift to each character in the string\n    return ''.join(shift_char(c) for c in s.lower())", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the input string by rotating the alphabet down by 4 positions.\n\n    This function shifts each letter in the input string by two multiplied by two\n    places forward in the alphabet. Non-alphabetic characters remain unchanged.\n\n    Args:\n    s (str): The string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n\n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # Define the alphabet\n    alphabet_lower = 'abcdefghijklmnopqrstuvwxyz'\n    alphabet_upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Define the shift (2 * 2 = 4)\n    shift = 4\n\n    # Function to shift a single character\n    def shift_char(char):\n        if char.isalpha():\n            if char.islower():\n                return alphabet_lower[(alphabet_lower.index(char) + shift) % 26]\n            elif char.isupper():\n                return alphabet_upper[(alphabet_upper.index(char) + shift) % 26]\n        return char  # Return character unchanged if not a letter\n    \n    # Apply the shift to each character in the string\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts the input string by rotating the alphabet down by four places.\n    \n    This function transforms each letter in the input string by replacing it with \n    the letter four positions ahead in the alphabet, wrapping around from 'z' to 'a' \n    or 'Z' to 'A' as needed. Non-alphabetic characters remain unchanged.\n    \n    Args:\n    s (str): The string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # The alphabet for reference\n    lower = 'abcdefghijklmnopqrstuvwxyz'\n    upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Define shift\n    shift = 2 * 2\n    \n    def rotate_char(c):\n        # Check if character is a letter\n        if c.isalpha():\n            # Find the new character by rotating 4 positions\n            if c.islower():\n                return lower[(lower.index(c) + shift) % 26]\n            else:\n                return upper[(upper.index(c) + shift) % 26]\n        else:\n            # Return non-alphabetic characters unchanged\n            return c\n\n    # Apply rotation to each character in the string\n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt the input string by shifting each letter down by 4 places in the alphabet.\n    \n    Args:\n    s (str): The string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    # Create a mapping for rotation\n    lower_alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    shift = 4  # Two multiplied by two equals four\n    \n    def rotate_char(char):\n        if char.islower():\n            return lower_alphabet[(lower_alphabet.index(char) + shift) % 26]\n        elif char.isupper():\n            return upper_alphabet[(upper_alphabet.index(char) + shift) % 26]\n        else:\n            return char  # Return non-alphabet characters as they are\n    \n    # Use list comprehension to apply rotation to each character\n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts the input string by rotating the alphabet down by 4 places (2 * 2).\n\n    Args:\n    s (str): The string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n\n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # Define the original alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Create the shifted alphabet by rotating 4 positions\n    shifted_alphabet = alphabet[4:] + alphabet[:4]\n    \n    # Initialize an empty result string\n    result = ''\n    \n    for char in s:\n        if char.isalpha():\n            # Determine if the character is upper or lowercase\n            is_upper = char.isupper()\n            # Convert character to lowercase for simplicity in shifting\n            char_lower = char.lower()\n            # Find the new character by looking it up in the shifted alphabet\n            if char_lower in alphabet:\n                index = alphabet.index(char_lower)\n                new_char = shifted_alphabet[index]\n                # If the original was uppercase, make the new one uppercase as well\n                if is_upper:\n                    result += new_char.upper()\n                else:\n                    result += new_char\n            else:\n                # If it's not an alphabetic character, just append as is\n                result += char\n        else:\n            # Non-alphabet characters are preserved\n            result += char\n    \n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts the input string by shifting each character down by four positions in the alphabet.\n    \n    Parameters:\n    s (str): The string to be encrypted.\n    \n    Returns:\n    str: The encrypted string where each letter is shifted by 4 places (2 * 2).\n    \n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    # Create a mapping for the encryption (shift by 4 positions)\n    mapping = {alphabet[i]: alphabet[(i + 4) % 26] for i in range(26)}\n\n    # Encrypt the string by replacing each letter with its shifted counterpart\n    encrypted = ''.join([mapping.get(char.lower(), char) for char in s])\n    \n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypt a string by rotating the alphabet down by four places (2 * 2).\n\n    Args:\n    s (str): The input string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n\n    Example:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    \"\"\"\n    # The alphabet string including only lowercase letters\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Rotate the alphabet by 4 places (2 * 2)\n    rotated = alphabet[4:] + alphabet[:4]\n    \n    # Create a translation table\n    trans = str.maketrans(alphabet + alphabet.upper(), \n                          rotated + rotated.upper())\n    \n    # Translate the string\n    return s.translate(trans)", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the given string by shifting each letter down by four places in the alphabet.\n    \n    For characters 'a' to 'w' or 'A' to 'W', the shift wraps around to the beginning of the alphabet.\n    Non-alphabetic characters remain unchanged.\n\n    Args:\n    s (str): The string to encrypt.\n\n    Returns:\n    str: The encrypted string.\n\n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    def shift_char(c):\n        # Define the alphabet for easy reference\n        lower = 'abcdefghijklmnopqrstuvwxyz'\n        upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        \n        if c.islower():\n            # If the character is lowercase\n            index = lower.index(c)\n            new_index = (index + 4) % 26  # Shift by 4 places with wrap around\n            return lower[new_index]\n        elif c.isupper():\n            # If the character is uppercase\n            index = upper.index(c)\n            new_index = (index + 4) % 26\n            return upper[new_index]\n        else:\n            # If not an alphabetic character, return it unchanged\n            return c\n\n    # Apply the shift to each character in the string\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied by two places (i.e., 4 positions).\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the original alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    # Define the rotated alphabet, shifting down by 4 positions\n    rotated = alphabet[4:] + alphabet[:4]\n    \n    # Convert the string to lowercase to ensure case insensitivity\n    s = s.lower()\n    \n    # Build the encrypted string\n    encrypted = ''\n    for char in s:\n        if char in alphabet:  # Only encrypt if the character is in the alphabet\n            index = alphabet.index(char)\n            encrypted += rotated[index]\n        else:\n            encrypted += char  # If it's not a letter, keep it as is\n    \n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts the input string by rotating each character down by 4 places in the alphabet.\n    \n    This function assumes that characters beyond 'z' wrap around to the beginning of the alphabet.\n    Only alphabets are shifted; other characters remain unchanged.\n    \n    Args:\n    s (str): The string to encrypt.\n    \n    Returns:\n    str: The encrypted string.\n    \n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # Define the lowercase alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Create the shifted alphabet (shift by 4)\n    shifted_alphabet = alphabet[4:] + alphabet[:4]\n    \n    result = []\n    for char in s:\n        if char.isalpha() and char.islower():\n            # Find the index in the original alphabet\n            index = alphabet.index(char)\n            # Get the corresponding character from the shifted alphabet\n            result.append(shifted_alphabet[index])\n        else:\n            # Non-alphabetic characters or uppercase letters remain unchanged\n            result.append(char)\n    \n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied by two (i.e., 4 positions).\n    \n    Args:\n    s (str): The string to encrypt.\n\n    Returns:\n    str: The encrypted string.\n\n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # The rotation amount\n    rotation = 4\n    \n    # Helper function to shift a character\n    def shift_char(c):\n        if c.isalpha():\n            # Determine the base (uppercase or lowercase)\n            base = 'A' if c.isupper() else 'a'\n            return chr((ord(c) - ord(base) + rotation) % 26 + ord(base))\n        return c  # If the character is not a letter, return it unchanged\n\n    # Apply the shift to each character in the string\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts the input string by rotating the alphabet down by four places (2x2).\n    \n    Each character in the string is shifted. If a character goes past 'z', \n    it wraps around to the beginning of the alphabet.\n\n    Args:\n    s (str): The string to encrypt.\n\n    Returns:\n    str: The encrypted string.\n\n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # Define the standard alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Create a lookup table for encryption\n    # This shifts each letter down by 4 positions, wrapping around when necessary\n    lookup = {alphabet[i]: alphabet[(i + 4) % 26] for i in range(26)}\n    \n    # Convert the input string to lowercase to standardize the input\n    s = s.lower()\n    \n    # Encrypt the string by mapping each character to its shifted counterpart\n    # Non-alphabet characters will remain the same since they're not in our lookup table\n    return ''.join(lookup.get(char, char) for char in s)", "matching_cluster_idx": 2}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the input string by rotating each character down by 4 places in the alphabet.\n    \n    Args:\n    s (str): The string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    # Define the lowercase alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # The shift is two multiplied by two, so effectively 4 places\n    shift = 4\n    result = []\n\n    for char in s.lower():  # Convert to lower case to handle mixed case strings\n        if char.isalpha():\n            # Find the index of the character in the alphabet and shift it\n            new_index = (alphabet.index(char) + shift) % 26\n            result.append(alphabet[new_index])\n        else:\n            # If it's not an alphabetic character, keep it as is\n            result.append(char)\n\n    # Join the list of characters into a string\n    return ''.join(result)", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 80.38910505836576, "dps_norm": 56.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list if it exists, otherwise None.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If we have at least two unique numbers, return the second smallest\n    # Otherwise, return None\n    return unique_sorted[1] if len(unique_sorted) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Finds the second smallest distinct element in the list.\n\n    Args:\n    lst (list of int): A list of integers.\n\n    Returns:\n    int or None: The second smallest distinct element or None if it doesn't exist.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_nums = set(lst)\n    \n    # If the set has less than 2 unique elements, there can't be a second smallest\n    if len(unique_nums) < 2:\n        return None\n    \n    # Find the smallest and second smallest numbers\n    smallest = min(unique_nums)\n    # Sort the unique numbers and remove the smallest one to get the next smallest\n    next_smaller = sorted(unique_nums)[1] if unique_nums else None\n    \n    return next_smaller if next_smaller > smallest else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Find the second smallest element in the given list of integers.\n    \n    Args:\n    lst (list): A list of integers.\n    \n    Returns:\n    int or None: The second smallest integer in the list or None if there isn't one.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # If the list is empty or has less than 2 unique elements, return None\n    if len(lst) < 2 or len(set(lst)) < 2:\n        return None\n    \n    # Convert list to set to remove duplicates, then to list for sorting\n    unique_sorted = sorted(set(lst))\n    \n    # The second element in the sorted list is the second smallest\n    return unique_sorted[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Find the second smallest distinct element in a list of integers.\n\n    This function identifies and returns the smallest element that is \n    larger than the smallest element in the list. If such an element \n    does not exist (e.g., if there's only one distinct element or the \n    list is empty), it returns None.\n\n    Args:\n    lst (list of int): The list of integers to search through.\n\n    Returns:\n    int or None: The second smallest distinct element or None if not applicable.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # If the list has fewer than 2 elements, return None as there's no second smallest element\n    if len(lst) < 2:\n        return None\n\n    # Convert the list to a set to get unique values and then sort it to find the smallest elements\n    unique_sorted = sorted(set(lst))\n    \n    # If after sorting, we don't have at least 2 unique elements, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # The second smallest element will be at index 1 in our sorted unique list\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers. This function returns the 2nd smallest element of the list.\n    If there are not at least two distinct elements, it returns None.\n\n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates to handle cases where all elements are the same or for lists with identical values\n    unique_lst = sorted(set(lst))\n    \n    # If the list has fewer than 2 unique elements, return None\n    if len(unique_lst) < 2:\n        return None\n    \n    # The second element in the sorted unique list will be the second smallest\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element or if the list has less than 2 unique elements.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    >>> next_smallest([3, 3, 4, 4])\n    4\n    \"\"\"\n    # Convert to a set to remove duplicates, then back to a list for sorting\n    unique_sorted_lst = sorted(set(lst))\n    \n    # If we have less than 2 unique elements or the list is empty, return None\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    # Return the second element which will be the 2nd smallest\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list, or None if there isn't one.\n\n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Check if the list has less than 2 unique elements\n    if len(set(lst)) < 2:\n        return None\n    \n    # Convert the list to a set to remove duplicates and sort it\n    sorted_unique = sorted(set(lst))\n    \n    # The second element (index 1) in this sorted list is our result\n    return sorted_unique[1] if len(sorted_unique) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the second smallest element of the given list of integers.\n    If the list has less than two unique elements, or is empty, returns None.\n\n    Args:\n    lst (list): A list of integers.\n\n    Returns:\n    int or None: The second smallest integer from the list, or None if not applicable.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([]) is None\n    True\n    >>> next_smallest([1, 1]) is None\n    True\n    \"\"\"\n    # Remove duplicates and sort to find the second smallest\n    sorted_unique = sorted(set(lst))\n    \n    # If there's less than 2 elements or all elements are the same, return None\n    if len(sorted_unique) < 2:\n        return None\n    \n    # Return the second smallest element\n    return sorted_unique[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    This function returns the 2nd smallest element of the list.\n    Returns None if there is no such element or if the list has fewer than two unique elements.\n\n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    # Remove duplicates by converting to a set, then back to a list for sorting\n    unique_lst = sorted(set(lst))\n    \n    # If the list has less than 2 unique elements, return None\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element or if all elements are identical.\n\n    Args:\n    lst (list): A list of integers.\n\n    Returns:\n    int or None: The second smallest number or None if not applicable.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers. \n    This function returns the 2nd smallest unique element of the list or None if it does not exist.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # If the list has fewer than 2 elements or is empty, return None\n    if len(lst) < 2:\n        return None\n    \n    # Convert list to set to remove duplicates, then convert back to list for sorting\n    unique_lst = sorted(set(lst))\n    \n    # If there's less than 2 unique elements, return None\n    if len(unique_lst) < 2:\n        return None\n    \n    # The second smallest element is the second element in the sorted unique list\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the second smallest element of the list.\n    \n    Args:\n    lst (list of int): A list of integers.\n    \n    Returns:\n    int or None: The second smallest number in lst, or None if not possible.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Remove duplicates to handle cases like [1, 1]\n    unique_sorted = sorted(set(lst))\n    \n    # If the list has less than 2 unique elements, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element which is the second smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in the list.\n\n    If the list has fewer than 2 unique elements or is empty, returns None.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Remove duplicates by converting to a set, then back to a sorted list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element in the sorted list, which is the second smallest\n    return unique_sorted[1] if len(unique_sorted) >= 2 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Check if the list has fewer than 2 unique elements or is empty\n    if len(set(lst)) < 2:\n        return None\n\n    # Convert list to set to remove duplicates then back to list\n    unique_sorted = sorted(set(lst))\n    \n    # Return the second element if it exists\n    return unique_sorted[1] if len(unique_sorted) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers. This function returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Remove duplicates by converting to a set and back to a list\n    # Sort the list to find the smallest elements\n    unique_sorted_lst = sorted(set(lst))\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    # The second element in the sorted list is the 2nd smallest\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers. This function returns the 2nd smallest element of the list.\n    If there's no second smallest (i.e., the list has fewer than 2 unique elements), return None.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there's only one unique element after sorting, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # The second element in a sorted list is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Remove duplicates and sort the list\n    if not lst:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    # If the list has less than 2 unique elements, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element (index 1 in a zero-indexed list)\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The second smallest number in the list or None if it doesn't exist.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Convert list to set to remove duplicates for easier processing\n    unique_elements = set(lst)\n    \n    # If the list has less than 2 unique elements, return None\n    if len(unique_elements) < 2:\n        return None\n    \n    # Sort the unique elements\n    sorted_elements = sorted(unique_elements)\n    \n    # Return the second element which is the 2nd smallest\n    return sorted_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the second smallest element of the list. \n    Returns None if there is no such element or if the list has fewer than two distinct elements.\n\n    Parameters:\n    lst (list of int): The input list of integers.\n\n    Returns:\n    int or None: The second smallest element or None if conditions are not met.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Remove duplicates by converting to a set and back to a list, then sort\n    unique_sorted = sorted(set(lst))\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element, which is the second smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the given list.\n    \n    Parameters:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The second smallest unique integer in the list or None if not applicable.\n    \n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then sort it\n    if not lst:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element which is the second smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 94.32048681541582, "dps_norm": 64.16666666666667, "pass@1": 84.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count odd digits\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        # Create the sentence with odd_count substituted\n        sentence = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count)\n        result.append(sentence)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(int(d) % 2 for d in s)\n    \n    result = []\n    for string in lst:\n        odds = count_odds(string)\n        result.append(f\"the number of odd elements {odds}n the str{odds}ng {odds} of the {odds}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        # Count odd digits in the current string\n        odd_count = sum(1 for char in string if int(char) % 2 != 0)\n        \n        # Create the sentence and replace all 'i' with the count of odd digits\n        sentence = f\"the number of odd elements in the string i of the input.\"\n        formatted_sentence = sentence.replace(\"i\", str(odd_count)).replace(\"in\", \"n\")\n        \n        result.append(formatted_sentence)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    Examples:\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    def count_odd(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n    \n    result = []\n    for item in lst:\n        odd_count = count_odd(item)\n        # Replace all 'i's with the count of odd numbers\n        sentence = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(sentence)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for item in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for digit in item if int(digit) % 2 != 0)\n        \n        # Create the output string with the number of odd digits replacing 'i'\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    Examples:\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    def count_odds(s):\n        # Count the number of odd digits in a string\n        return sum(int(d) % 2 for d in s)\n    \n    result = []\n    for item in lst:\n        # Count the number of odd digits in the current string\n        num_odds = count_odds(item)\n        # Replace 'i' with the count in the string format\n        new_string = \"the number of odd elements \" + str(num_odds) + \"n the str\" + str(num_odds) + \"ng \" + str(num_odds) + \" of the \" + str(num_odds) + \"nput.\"\n        result.append(new_string)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for string in lst:\n        odds = count_odds(string)\n        formatted_str = f\"the number of odd elements {odds}n the str{odds}ng {odds} of the {odds}nput.\"\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    def count_odds(s):\n        return sum(1 for digit in s if int(digit) % 2 != 0)\n    \n    result = []\n    for item in lst:\n        odd_digits_count = count_odds(item)\n        # Replace 'i' with the count of odd digits in the string\n        formatted_str = f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\"\n        result.append(formatted_str)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        # Construct the output string by replacing 'i' with the count of odd digits\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    Examples:\n    >>> odd_count(['1234567'])\n    ['the number of odd elements 4n the str4ng 4 of the 4nput.']\n    >>> odd_count(['3', \"11111111\"])\n    ['the number of odd elements 1n the str1ng 1 of the 1nput.', \n     'the number of odd elements 8n the str8ng 8 of the 8nput.']\n    \"\"\"\n    def count_odds(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n    \n    return [\n        \"the number of odd elements \" + str(count_odds(s)) + \"n the str\" + \n        str(count_odds(s)) + \"ng \" + str(count_odds(s)) + \n        \" of the \" + str(count_odds(s)) + \"nput.\" \n        for s in lst\n    ]", "matching_cluster_idx": 0}, {"solution": "def odd_count(lst):\n    res = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(int(d) % 2 != 0 for d in s)\n        \n        # Replace 'i' in the string format with the count of odd numbers\n        formatted_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        res.append(formatted_str)\n    return res", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list where each element i of the output is formatted as described:\n    \"the number of odd elements in the string i of the input.\"\n\n    Args:\n    lst (List[str]): A list where each string contains only digits.\n\n    Returns:\n    List[str]: A list with formatted strings indicating the count of odd digits.\n\n    Examples:\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    res = []\n    for item in lst:\n        # Count the odd digits in the string\n        odd_count = sum(int(digit) % 2 != 0 for digit in item)\n        \n        # Format the string with the count of odd digits\n        formatted = (\"the number of odd elements {0}n the str{0}ng {0} of the {0}nput.\").format(odd_count)\n        res.append(formatted)\n    \n    return res", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for s in lst:\n        odds = count_odds(s)\n        result.append(f\"the number of odd elements {odds}n the str{odds}ng {odds} of the {odds}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        # Count the number of odd digits in the string\n        odd_digit_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        \n        # Create the message with placeholders replaced by odd_digit_count\n        msg = f\"the number of odd elements {odd_digit_count}n the str{odd_digit_count}ng {odd_digit_count} of the {odd_digit_count}nput.\"\n        result.append(msg)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for item in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for digit in item if int(digit) % 2 != 0)\n        \n        # Construct the output string with the number of odd digits\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    Args:\n    lst (list): A list of strings, where each string contains only digits.\n\n    Returns:\n    list: Processed list according to the rules given.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    def count_odds(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n    \n    result = []\n    for string in lst:\n        odd_count = count_odds(string)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        # Count odd digits in the string\n        count_odd = sum(1 for digit in string if int(digit) % 2 != 0)\n        # Create the result string with replaced numbers\n        formatted_str = f\"the number of odd elements {count_odd}n the str{count_odd}ng {count_odd} of the {count_odd}nput.\"\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    Examples:\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    res = []\n    for item in lst:\n        # Count the number of odd digits in the current string\n        odd_digits_count = sum(1 for char in item if int(char) % 2 != 0)\n        # Create the string with replaced numbers\n        output_str = f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\"\n        res.append(output_str)\n    return res", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n\n    result = []\n    for item in lst:\n        odds = count_odd(item)\n        string = f\"the number of odd elements {odds}n the str{odds}ng {odds} of the {odds}nput.\"\n        result.append(string)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(int(d) % 2 for d in s)\n\n    output = []\n    for i, string in enumerate(lst):\n        odd_count = count_odds(string)\n        # Replace 'i' in the string with the count of odd digits\n        result = \"the number of odd elements \" + str(odd_count) + \"n the str\" + str(odd_count) + \"ng \" + str(odd_count) + \" of the \" + str(odd_count) + \"nput.\"\n        output.append(result)\n    return output", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 75.29069767441861, "dps_norm": 80.0, "pass@1": 29.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check each combination\n    if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    s1, s2 = lst\n    # Try both concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_good(s):\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return len(stack) == 0\n\n    # Count open and close parentheses in each string\n    open1, close1 = lst[0].count('('), lst[0].count(')')\n    open2, close2 = lst[1].count('('), lst[1].count(')')\n\n    # Try both concatenation orders\n    if open1 >= close1:\n        if close1 <= open2 and is_good(lst[0] + lst[1]):\n            return 'Yes'\n    else:\n        if open1 <= close2 and is_good(lst[1] + lst[0]):\n            return 'Yes'\n    \n    # If none of the above cases work, then check reversed concatenation\n    if open2 >= close2:\n        if close2 <= open1 and is_good(lst[1] + lst[0]):\n            return 'Yes'\n    else:\n        if open2 <= close1 and is_good(lst[0] + lst[1]):\n            return 'Yes'\n\n    return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        \"\"\"Check if a string of parentheses is balanced.\"\"\"\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:  # If at any point there are more closing than opening, it's not good\n                return False\n        return balance == 0  # The string is good only if we end with a balance of 0\n\n    s1, s2 = lst\n    \n    # Case 1: s1 followed by s2\n    if is_good(s1 + s2):\n        return 'Yes'\n\n    # Case 2: s2 followed by s1\n    if is_good(s2 + s1):\n        return 'Yes'\n\n    # If none of the concatenations work, return 'No'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                if balance == 0:\n                    return False\n                balance -= 1\n        return balance == 0\n\n    # Try both possible concatenations\n    if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if two strings of parentheses can be concatenated in any order to make a balanced string.\n\n    :param lst: A list containing two strings of parentheses.\n    :return: 'Yes' if a balanced string can be formed, 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Count open and close parentheses in both strings\n    open_count_a, close_count_a = lst[0].count('('), lst[0].count(')')\n    open_count_b, close_count_b = lst[1].count('('), lst[1].count(')')\n    \n    # Check if concatenation of A first then B, or B first then A could be balanced\n    if (open_count_a + open_count_b) == (close_count_a + close_count_b):\n        # If total number of open equals close parentheses, it's possible to balance\n        # Check if either concatenation is good\n        if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]):\n            return 'Yes'\n        else:\n            # Here, total parentheses match but placement might not allow balancing\n            return 'No'\n    else:\n        # If the total counts don't match, it's impossible to create a good string\n        return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    def can_balance(str1, str2):\n        # Try all possible concatenations\n        return is_balanced(str1 + str2) or is_balanced(str2 + str1)\n\n    str1, str2 = lst\n    if can_balance(str1, str2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it is possible to concatenate two strings from the list\n    to make a balanced parentheses string.\n\n    Parameters:\n    lst (list): A list containing two strings of parentheses.\n\n    Returns:\n    str: 'Yes' if concatenation can produce balanced parentheses, 'No' otherwise.\n\n    Examples:\n    >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n    'No'\n    '''\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:  # More closing than opening parentheses\n                return False\n        return balance == 0  # Balanced if zero at the end\n    \n    # Check both possible concatenations\n    return 'Yes' if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_good(s):\n        \"\"\"Check if the string has balanced parentheses.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return len(stack) == 0\n\n    # Check both possible concatenations\n    if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Determines if two strings of parentheses can be concatenated to form a balanced string.\n\n    Args:\n    lst (list): A list containing exactly two strings of open '(' and close ')' parentheses.\n\n    Returns:\n    str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n\n    Examples:\n    >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n    'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:  # char is ')'\n                count -= 1\n            # If at any point we have more closing than opening, it's not balanced\n            if count < 0:\n                return False\n        return count == 0\n\n    # Combine both strings in both orders and check for balance\n    for combination in [lst[0] + lst[1], lst[1] + lst[0]]:\n        if is_balanced(combination):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    # Try concatenating in both orders\n    if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Check if two strings of parentheses can form a valid balanced string when concatenated.\n    \n    Args:\n    lst (list): A list containing two strings of parentheses.\n    \n    Returns:\n    str: 'Yes' if the strings can form a balanced parentheses string, 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        # Helper function to check if a string of parentheses is balanced\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                if count == 0:\n                    return False  # More closing than opening parentheses\n                count -= 1\n        return count == 0  # True if all parentheses are matched\n\n    a, b = lst[0], lst[1]\n    \n    # Check if either combination of the strings is balanced\n    return 'Yes' if is_balanced(a + b) or is_balanced(b + a) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Count number of open and close parentheses\n    open1, close1 = s1.count('('), s1.count(')')\n    open2, close2 = s2.count('('), s2.count(')')\n    \n    # If the total number of opens do not match total number of closes, it's impossible\n    if (open1 + open2) != (close1 + close2):\n        return 'No'\n\n    # Check both possible concatenations\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    Check if concatenating two strings of parentheses in any order results in a balanced string.\n\n    Parameters:\n    lst (list): A list containing two strings of only '(' and ')'.\n\n    Returns:\n    str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Try both concatenations\n    first = lst[0] + lst[1]\n    second = lst[1] + lst[0]\n\n    return 'Yes' if is_balanced(first) or is_balanced(second) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Determines if two lists of parentheses can be combined into a balanced parentheses string.\n\n    Args:\n    lst (list): A list containing two strings of open '(' and closed ')' parentheses.\n\n    Returns:\n    str: 'Yes' if the parentheses can be matched to form a valid string, 'No' otherwise.\n\n    Examples:\n    >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n    'No'\n    '''\n    \n    # Helper function to check if a string is balanced\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                if balance == 0:\n                    return False\n                balance -= 1\n        return balance == 0\n\n    # Combine both strings in both possible orders\n    string1, string2 = lst[0], lst[1]\n    combinations = [string1 + string2, string2 + string1]\n    \n    # Check each combination for balance\n    for combination in combinations:\n        if is_balanced(combination):\n            return 'Yes'\n    \n    # If neither combination works\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n    'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:  # char == ')'\n                count -= 1\n            if count < 0:  # More close parens than open at any point, invalid\n                return False\n        return count == 0\n\n    # Try both concatenations\n    return 'Yes' if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s):\n    \"\"\"Check if a string of parentheses is balanced.\"\"\"\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:  # char == ')'\n            balance -= 1\n            if balance < 0:\n                return False\n    return balance == 0\ndef match_parens(lst):\n    '''\n    Checks if it's possible to concatenate two strings of parentheses in some \n    order to form a balanced string.\n\n    :param lst: List of two strings containing only '(' and ')'\n    :return: 'Yes' if a balanced string can be formed, 'No' otherwise.\n\n    Examples:\n    >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n    'No'\n    '''\n    # Check for immediate disqualification conditions\n    if sum(s.count('(') for s in lst) != sum(s.count(')') for s in lst):\n        return 'No'\n    \n    # Check both combinations\n    return 'Yes' if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    def can_make_good(s1, s2):\n        # Check if s1 can end and s2 can start with the required number of parentheses\n        open_count = s1.count('(') - s1.count(')')\n        close_count = s2.count(')') - s2.count('(')\n        \n        if open_count < 0 or close_count < 0:\n            return False\n        \n        # Can we balance s1 by appending some or all of s2?\n        combined = s1 + s2\n        return is_balanced(combined) or is_balanced(s2 + s1)\n\n    s1, s2 = lst\n    if can_make_good(s1, s2) or can_make_good(s2, s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it's possible to concatenate two strings of parentheses to form a balanced string.\n\n    Args:\n    lst (list): A list containing two strings of open or closed parentheses.\n\n    Returns:\n    str: 'Yes' if concatenation can result in a balanced string, 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    # Try both orders of concatenation\n    for order in [lst, lst[::-1]]:\n        # Combine two strings\n        combined = ''.join(order)\n        \n        # Check if the combined string is balanced\n        if is_balanced(combined):\n            return 'Yes'\n\n    # If none of the concatenation results in a balanced string\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Case 1: Try concatenating s1 then s2\n    if is_good(s1 + s2):\n        return 'Yes'\n    \n    # Case 2: Try concatenating s2 then s1\n    if is_good(s2 + s1):\n        return 'Yes'\n    \n    # Neither concatenation results in a good string\n    return 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": 73.01724137931035, "dps_norm": 90.71428571428571, "pass@1": 40.0, "profiled": [{"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # If k is 0 or array is empty, return an empty list\n    if k == 0 or not arr:\n        return []\n    \n    # Take the first k elements\n    result = sorted_arr[:k]\n    \n    # Ensure the result is sorted in ascending order before returning\n    return sorted(result)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n    arr (List[int]): List of integers where -1000 <= arr[i] <= 1000\n    k (int): The number of maximum values to return, where 0 <= k <= len(arr)\n\n    Returns:\n    List[int]: A sorted list of the k largest elements in arr.\n\n    Examples:\n    >>> maximum([-3, -4, 5], 3)\n    [-4, -3, 5]\n    >>> maximum([4, -4, 4], 2)\n    [4, 4]\n    >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n    [2]\n    \"\"\"\n    # If k is 0, return an empty list\n    if k == 0:\n        return []\n    \n    # Use the last k elements of the sorted array as they will be the k largest\n    # Here we're sorting in ascending order to take advantage of Python's sort stability\n    # and then taking the slice from the end\n    return sorted(arr)[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n    arr (List[int]): The input array of integers.\n    k (int): The number of maximum elements to return.\n\n    Returns:\n    List[int]: A list of k maximum elements in ascending order.\n\n    Raises:\n    ValueError: If k is less than 0 or greater than the length of the array.\n\n    Examples:\n    >>> maximum([-3, -4, 5], 3)\n    [-4, -3, 5]\n    >>> maximum([4, -4, 4], 2)\n    [4, 4]\n    >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n    [2]\n    \"\"\"\n    # Input validation\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n\n    # If k is 0, return an empty list\n    if k == 0:\n        return []\n\n    # Return the last k elements which will be the maximum k numbers\n    return sorted_arr[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Check for edge cases\n    if k == 0:\n        return []\n    if k >= len(arr):\n        return sorted(arr)\n    \n    # Use heap to find k maximum elements\n    import heapq\n    # Convert to negative to use min heap as max heap\n    heap = [-num for num in arr]\n    heapq.heapify(heap)\n    \n    # Take k elements from the heap\n    result = [heapq.heappop(heap) for _ in range(k)]\n    \n    # Convert back to positive, sort, and return\n    return sorted([-num for num in result])", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # If k is 0, return an empty list\n    if k == 0:\n        return []\n\n    # Sort the array in descending order and take the top k elements\n    # Then, sort again in ascending order to match the expected output format\n    result = sorted(sorted(arr, reverse=True)[:k])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # If k is 0, return an empty list as per the requirement\n    if k == 0:\n        return []\n    \n    # Slice the sorted array to get the first k elements\n    result = sorted_arr[:k]\n    \n    # Sort in ascending order before returning since we initially sorted in descending\n    return sorted(result)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Parameters:\n    - arr (List[int]): An array of integers.\n    - k (int): The number of maximum elements to return.\n\n    Returns:\n    - List[int]: A sorted list of the k largest elements in arr.\n\n    Examples:\n    ```python\n    maximum([-3, -4, 5], 3)  # Returns [-4, -3, 5]\n    maximum([4, -4, 4], 2)   # Returns [4, 4]\n    maximum([-3, 2, 1, 2, -1, -2, 1], 1)  # Returns [2]\n    ```\n\n    Note:\n    - The length of the array will be in the range of [1, 1000].\n    - The elements in the array will be in the range of [-1000, 1000].\n    - 0 <= k <= len(arr)\n    \"\"\"\n    # Check if k is within the correct bounds\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array inclusive.\")\n    \n    # Sort the array in descending order, then slice to get the top k elements,\n    # and reverse the list to return in ascending order\n    return sorted(arr, reverse=True)[:k][::-1]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        - The length of the array will be in the range of [1, 1000].\n        - The elements in the array will be in the range of [-1000, 1000].\n        - 0 <= k <= len(arr)\n    \"\"\"\n    # Check if k is within the valid range\n    if k == 0:\n        return []\n    if k > len(arr):\n        k = len(arr)\n    \n    # Sort the array in descending order, then take the first k elements\n    # and return them in sorted order (ascending)\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Examples:\n    - Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n    - Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n    - Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Slice the array to get the first k elements if k is less than or equal to array length\n    # If k is 0 or array is empty, this will return an empty list\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n    arr (List[int]): An array of integers.\n    k (int): The number of top elements to return.\n\n    Returns:\n    List[int]: A list of the k maximum numbers from arr, sorted in ascending order.\n\n    Raises:\n    ValueError: If k is greater than the length of arr or less than 0.\n\n    Examples:\n    >>> maximum([-3, -4, 5], 3)\n    [-4, -3, 5]\n    >>> maximum([4, -4, 4], 2)\n    [4, 4]\n    >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n    [2]\n    \"\"\"\n    # Check if k is within bounds\n    if k > len(arr) or k < 0:\n        raise ValueError(\"k must be between 0 and the length of the array inclusive\")\n\n    # Use Python's built-in sorted function to sort the array,\n    # then slice it to get the last k elements in reverse order\n    if k == 0:\n        return []\n    \n    # Sort and take the last k elements, which are the maximum k numbers\n    return sorted(arr, reverse=True)[:k][::-1]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Examples:\n    >>> maximum([-3, -4, 5], 3)\n    [-4, -3, 5]\n    >>> maximum([4, -4, 4], 2)\n    [4, 4]\n    >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n    [2]\n\n    Args:\n    arr (List[int]): An array of integers.\n    k (int): The number of maximum elements to return.\n\n    Returns:\n    List[int]: A sorted list containing the k largest numbers from arr.\n\n    Raises:\n    ValueError: If k is less than 0 or greater than the length of arr.\n    \"\"\"\n    # Check if k is within the valid range\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array inclusive.\")\n    \n    # If k is 0, return an empty list as per requirement\n    if k == 0:\n        return []\n\n    # Sort the array in descending order and take the first k elements\n    # Python's sort is stable, so if there are duplicates, all will appear in the result\n    sorted_arr = sorted(arr, reverse=True)\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: List[int] - An array of integers.\n    :param k: int - The number of maximum elements to return.\n    :return: List[int] - Sorted list of k maximum numbers from arr.\n\n    Example usage:\n    >>> maximum([-3, -4, 5], 3)\n    [-4, -3, 5]\n    >>> maximum([4, -4, 4], 2)\n    [4, 4]\n    >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n    [2]\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # If k is 0 or greater than the length of array, handle accordingly\n    if k == 0:\n        return []\n    if k >= len(arr):\n        return sorted(arr)  # Return sorted array in ascending order for k >= len(arr)\n    \n    # Slice the sorted array to get the k largest numbers, then sort in ascending order\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Check if k is within the bounds of the array length\n    if not (0 <= k <= len(arr)):\n        raise ValueError(\"k must be between 0 and the length of the array inclusive\")\n    \n    # Sort the array in descending order and take the first k elements\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # If k is 0, we should return an empty list\n    if k == 0:\n        return []\n    \n    # Return the k largest elements in sorted order (which will be reversed since we sorted in descending order initially)\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n    arr (List[int]): List of integers.\n    k (int): The number of maximum values to return.\n\n    Returns:\n    List[int]: Sorted list of the k largest values in arr.\n\n    Example:\n        >>> maximum([-3, -4, 5], 3)\n        [-4, -3, 5]\n        >>> maximum([4, -4, 4], 2)\n        [4, 4]\n        >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n        [2]\n    \"\"\"\n    # Check if k is valid\n    if k == 0 or not arr:\n        return []\n    if k > len(arr):\n        k = len(arr)\n\n    # Sort the array in descending order and then take the first k elements\n    # This will give us the k maximum elements\n    result = sorted(arr, reverse=True)[:k]\n    \n    # Since the question asks for the k largest numbers in ascending order,\n    # we sort the result again in ascending order\n    return sorted(result)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: List[int], array of integers\n    :param k: int, number of maximum elements to return\n    :return: List[int], k maximum elements in sorted order\n\n    Examples:\n        >>> maximum([-3, -4, 5], 3)\n        [-4, -3, 5]\n        >>> maximum([4, -4, 4], 2)\n        [4, 4]\n        >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n        [2]\n    \"\"\"\n    # Sort the array in descending order to get maximum numbers first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # If k is 0 or greater than the length of arr, handle accordingly\n    if k == 0 or k > len(arr):\n        return []\n    \n    # Return the first k elements and sort them back in ascending order for the result\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n    arr (List[int]): The input array of integers.\n    k (int): The number of maximum elements to return.\n\n    Returns:\n    List[int]: A sorted list containing the k largest elements from arr.\n\n    Examples:\n        >>> maximum([-3, -4, 5], 3)\n        [-4, -3, 5]\n        >>> maximum([4, -4, 4], 2)\n        [4, 4]\n        >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n        [2]\n    \"\"\"\n    # If k is 0 or less, or larger than array size, return an empty list or full sorted array respectively\n    if k <= 0:\n        return []\n    if k >= len(arr):\n        return sorted(arr)\n    \n    # Use the heapq module for efficient heap operations\n    import heapq\n    \n    # Create a min heap of the k largest elements seen so far\n    heap = []\n    for num in arr:\n        # If we've filled our heap, replace if current number is larger than the smallest in heap\n        if len(heap) < k:\n            heapq.heappush(heap, num)\n        elif num > heap[0]:\n            heapq.heapreplace(heap, num)\n    \n    # Heap is in reverse order (smallest at top), so sort it to meet the requirements\n    return sorted(heap)", "matching_cluster_idx": 4}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n    arr (List[int]): List of integers\n    k (int): Number of maximum elements to return\n\n    Returns:\n    List[int]: A list of k maximum elements from arr, sorted in ascending order\n\n    Examples:\n        >>> maximum([-3, -4, 5], 3)\n        [-4, -3, 5]\n        >>> maximum([4, -4, 4], 2)\n        [4, 4]\n        >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n        [2]\n    \"\"\"\n    # First, sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Handle edge cases:\n    # If k is greater than array length, return the entire sorted array\n    if k > len(sorted_arr):\n        return sorted_arr\n    \n    # If k is 0 or less, return an empty list\n    if k <= 0:\n        return []\n    \n    # Return the last k elements (which are the maximum k elements)\n    return sorted_arr[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Args:\n    arr (List[int]): An array of integers where -1000 <= element <= 1000 and 1 <= len(arr) <= 1000\n    k (int): An integer where 0 <= k <= len(arr)\n\n    Returns:\n    List[int]: A sorted list of k maximum numbers from arr, in ascending order.\n\n    Raises:\n    ValueError: If k is out of the valid range.\n    \"\"\"\n    # Check if k is within the valid range\n    if not (0 <= k <= len(arr)):\n        raise ValueError(\"k must be between 0 and the length of the array inclusive.\")\n    \n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Return the last k elements if k > 0, otherwise return an empty list\n    return sorted_arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # First, check if k is greater than the length of the array\n    if k == 0:\n        return []\n    if k > len(arr):\n        k = len(arr)\n\n    # Sort the array in descending order and take the first k elements\n    result = sorted(arr, reverse=True)[:k]\n    \n    # Since we want in ascending order, reverse the result\n    return sorted(result)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Slice the array to get the k largest elements\n    result = sorted_arr[:k]\n    \n    # Sort the result in ascending order for the output\n    return sorted(result)", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 79.55156950672647, "dps_norm": 58.57142857142858, "pass@1": 91.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Even positions are considered as 0-indexed in this function.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Sum odd numbers at even indices (remember Python uses 0-based indexing)\n    return sum([num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0])", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements \n    that are in even positions (0-indexed).\n\n    Parameters:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: Sum of odd numbers in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Use list comprehension to filter and sum odd numbers at even indices\n    # Remember Python uses 0-based indexing, so even positions are 0, 2, 4, etc.\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Even positions in Python are considered at index 0, 2, 4, etc.\n\n    Parameters:\n    lst (list of int): A list of integers.\n\n    Returns:\n    int: The sum of odd integers at even indices.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Use list comprehension to sum odd numbers at even indices\n    # lst[i] % 2 != 0 checks if the number is odd, and i % 2 == 0 checks if index is even\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements \n    that are in even positions.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    int: The sum of odd integers at even indices (0-based indexing).\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Sum of odd numbers at even indices (remember, in Python, index 0 is considered even)\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    An element is considered to be in an even position if its index is even when zero-indexed.\n\n    Args:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: The sum of all odd numbers found at even indices.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12  # 5 (index 0) + 7 (index 2)\n    >>> solution([3, 3, 3, 3, 3])\n    9  # 3 (index 0) + 3 (index 2) + 3 (index 4)\n    >>> solution([30, 13, 24, 321])\n    0  # No odd numbers at even positions\n    \"\"\"\n    # Use list comprehension with a condition to filter odd numbers at even positions\n    # and sum them up in one go\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    This function iterates through the list, checking if each element's position is even (0-indexed) \n    and if the element itself is odd, then adds it to the sum.\n\n    Args:\n    lst (list of int): A non-empty list of integers.\n\n    Returns:\n    int: The sum of odd integers at even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Use sum with a generator expression to filter and sum appropriate elements\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n    lst (list): A list of integers where positions start from 0.\n\n    Returns:\n    int: Sum of odd numbers at even indices (0-based indexing).\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Use list comprehension with a condition to sum odd numbers at even indices\n    return sum(num for index, num in enumerate(lst) if index % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Parameters:\n    lst (list of int): A list of integers where even indexing starts from 0.\n\n    Returns:\n    int: The sum of all odd integers at even indices (0-based indexing).\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Use enumerate to get both index and value, sum if odd number at even position (0, 2, 4, ...)\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    An even position here means the index of the element is even (0-indexed). \n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Sum elements that are odd and at an even index (0, 2, 4, ...)\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Args:\n    lst (list of int): A list of integers.\n\n    Returns:\n    int: Sum of all odd numbers found in even indices (0-indexed).\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Using list comprehension with enumerate to check odd numbers at even positions (0, 2, 4, etc.)\n    return sum([num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0])", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Position counting starts from 0, so even positions are those at index 0, 2, 4, etc.\n\n    Args:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: The sum of odd integers at even indices.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Use list comprehension to sum only odd numbers at even indices\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Even positions are considered to start at index 0 in this case.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12  # 5 + 7\n    >>> solution([3, 3, 3, 3, 3])\n    9   # 3 + 3 + 3 (0, 2, 4 positions)\n    >>> solution([30, 13, 24, 321])\n    0   # No odd numbers in even positions\n    \"\"\"\n    # Sum elements that are odd and at even indices (0-based)\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements \n    that are in even positions.\n\n    Position indexing starts at 0, hence even positions are at index 0, 2, 4, ...\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \n    :param lst: List of integers\n    :return: Integer representing the sum of odd elements at even indices\n    \"\"\"\n    # Sum odd numbers at even indices\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Parameters:\n    lst (list of int): A list of integers.\n\n    Returns:\n    int: The sum of odd numbers located at even indices (0-based indexing).\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Use a list comprehension to filter and sum:\n    # - Only odd numbers (x % 2 != 0)\n    # - Only at even positions (i % 2 == 0, where i is the index)\n    return sum(x for i, x in enumerate(lst) if x % 2 != 0 and i % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Sum only odd numbers that are at even indices (0, 2, 4, ...)\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Even positions are defined as indices 0, 2, 4, etc. (following Python 0-indexing).\n\n    Examples:\n    - solution([5, 8, 7, 1]) returns 12 because:\n      - 5 is at index 0 (even position) and odd\n      - 7 is at index 2 (even position) and odd\n      - Sum = 5 + 7 = 12\n      \n    - solution([3, 3, 3, 3, 3]) returns 9 because all elements are odd and at even positions:\n      - Sum = 3 + 3 + 3 = 9\n\n    - solution([30, 13, 24, 321]) returns 0 because none of the even positioned numbers are odd.\n\n    :param lst: List of integers\n    :return: Sum of odd integers at even positions\n    \"\"\"\n    # Use list comprehension to filter out odd numbers at even indices and sum them\n    return sum([num for i, num in enumerate(lst) if num % 2 != 0 and i % 2 == 0])", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Here, position indices are considered starting from 0:\n    - Even positions: 0, 2, 4, ...\n    - Odd positions: 1, 3, 5, ...\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Sum up elements that are at even indices (0, 2, 4, ...) and are odd\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    This function iterates through the list checking for elements at even indices (0, 2, 4, ...) \n    and sums them if they are odd.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12 # 5 at index 0 + 7 at index 2\n    solution([3, 3, 3, 3, 3]) ==> 9 # 3 at index 0 + 3 at index 2 + 3 at index 4\n    solution([30, 13, 24, 321]) ==> 0 # No odd elements at even positions\n    \"\"\"\n    # Sum all odd numbers at even indices (0-based indexing)\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Parameters:\n    lst (list of int): A list of integers where position indexing starts at 0.\n\n    Returns:\n    int: The sum of odd integers found at even indices.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Sum elements that are:\n    # 1. Odd (i.e., element % 2 != 0)\n    # 2. At even index positions (i.e., index % 2 == 0)\n    return sum(elem for index, elem in enumerate(lst) if elem % 2 != 0 and index % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Sum of odd elements at even indices (0, 2, 4, ...)\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 87.24409448818899, "dps_norm": 61.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths, and sorts the remaining strings.\n    \n    The function sorts the strings primarily by length (ascending) and secondarily \n    alphabetically if lengths are equal.\n\n    Args:\n    lst (list): A list of strings.\n\n    Returns:\n    list: A new list with even-length strings only, sorted by length and then alphabetically.\n\n    Examples:\n    >>> assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    >>> assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    >>> assert sorted_list_sum([\"one\", \"two\", \"three\", \"four\", \"five\"]) == [\"two\", \"four\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Custom sorting key: first sort by length, then alphabetically if lengths are equal\n    return sorted(even_length_strings, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function takes a list of strings, removes strings with odd lengths,\n    and returns the sorted list where strings are ordered first by length\n    and then alphabetically if lengths are equal.\n\n    Args:\n    lst (list of str): A list of strings to be processed.\n\n    Returns:\n    list of str: Sorted list of strings with even lengths.\n\n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically if lengths are equal\n    return sorted(even_length_strings, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filter out strings with odd lengths, then sort the remaining strings \n    by length and alphabetically within length groups.\n\n    Args:\n    lst (list): A list of strings where only even-length strings will be considered.\n\n    Returns:\n    list: A list of even-length strings sorted first by length then alphabetically.\n\n    Example:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\", \"cd\"])\n    ['aa', 'cd']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"bb\", \"ca\", \"dd\"])\n    ['ab', 'bb', 'ca', 'dd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort strings by length and then alphabetically if lengths are equal\n    return sorted(even_length_strings, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths, and sorts \n    the remaining strings by their length (ascending) and alphabetically for \n    equal lengths.\n\n    Args:\n    lst (list of str): A list of string to be processed.\n\n    Returns:\n    list of str: Sorted list of strings with only even lengths.\n\n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd length\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort by length of each word, then alphabetically if lengths are equal\n    sorted_lst = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Sorts a list of strings, keeping only strings with even lengths.\n\n    This function:\n    1. Filters out strings with odd lengths.\n    2. Sorts the remaining strings first by length (ascending), then alphabetically if lengths are equal.\n\n    Parameters:\n    - lst (list): A list of strings, potentially containing duplicates.\n\n    Returns:\n    - list: A new list containing only strings of even lengths sorted as described.\n\n    Examples:\n    ```python\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    ```\n    \"\"\"\n    # Filter out strings with odd length\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort by length first, then alphabetically for equal lengths\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths from the input list, then sorts the remaining strings.\n\n    Args:\n    lst (list): A list of strings to be processed.\n\n    Returns:\n    list: A sorted list of strings with even lengths only, sorted by length in ascending order,\n          and then alphabetically if lengths are equal.\n\n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    >>> sorted_list_sum([\"hello\", \"world\", \"python\"])\n    ['world', 'hello', 'python']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Sorts a list of strings, removing odd-length strings, and returns the result sorted by length and then alphabetically.\n\n    :param lst: A list of strings\n    :return: A new list with strings of even lengths sorted by length, then alphabetically\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Accepts a list of strings, removes strings with odd lengths, \n    and returns the remaining list sorted by length, then alphabetically if lengths are equal.\n\n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n\n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort by length then by lexicographical order\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function takes a list of strings, removes strings with odd lengths,\n    and returns a sorted list based on string length and alphabetical order.\n\n    Args:\n    lst (list): A list of strings where each string might have different lengths.\n\n    Returns:\n    list: A sorted list where strings are sorted first by length (in ascending order),\n          then alphabetically for strings of the same length.\n\n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd length\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort by length of the word, then alphabetically if lengths are the same\n    sorted_words = sorted(even_length_words, key=lambda x: (len(x), x))\n    \n    return sorted_words", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths and sorts the remaining strings.\n    \n    Args:\n    lst (List[str]): A list of strings to be processed.\n\n    Returns:\n    List[str]: A sorted list of strings with even lengths, ordered by:\n    1. Length of the string (ascending)\n    2. Alphabetically for strings of equal length\n\n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length (ascending) and then alphabetically.\n\n    Parameters:\n    lst (list of str): A list of strings.\n\n    Returns:\n    list of str: A sorted list where each string has an even length.\n\n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd length\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort by length then by alphabetical order\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort first by length then alphabetically if lengths are equal\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths from the input list, sorts the remaining strings\n    by their length (ascending), and if lengths are equal, sorts alphabetically.\n\n    Args:\n    lst (list): A list of strings.\n\n    Returns:\n    list: A list of strings sorted by length then alphabetically, with only even-length words.\n\n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out odd-length strings\n    even_length_strings = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort by length then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths, sorts the remaining strings first by length \n    (ascending) and then alphabetically if lengths are equal, and returns the sorted list.\n\n    Parameters:\n    lst (list of str): A list of strings to be processed.\n\n    Returns:\n    list of str: A new list containing only even-length strings sorted as described.\n\n    Examples:\n    >>> assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    >>> assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort by length and then alphabetically if lengths are the same\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining list sorted first by length (ascending) and then \n    alphabetically if lengths are equal.\n\n    Args:\n    lst (list): A list of strings where all strings are expected to be of the same length.\n\n    Returns:\n    list: A sorted list of strings with even lengths.\n\n    Raises:\n    TypeError: If lst contains elements that are not strings.\n\n    Example:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd length\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the remaining strings first by length and then alphabetically\n    return sorted(sorted(even_length_strings), key=len)", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths, \n    sorts the remaining strings by length (ascending) and then alphabetically,\n    and returns the sorted list.\n    \n    Args:\n    lst (list): A list of strings, which can contain duplicates.\n    \n    Returns:\n    list: A list of strings sorted by length then alphabetically.\n    \n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort by length, then alphabetically if lengths are equal\n    return sorted(sorted(even_length_strings), key=len)", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the list sorted by length, then alphabetically.\n\n    Parameters:\n    lst (list): A list of strings.\n\n    Returns:\n    list: A sorted list of strings with even length.\n\n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd length\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort first by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths, \n    and returns the list sorted by string length in ascending order. \n    If lengths are equal, sorts alphabetically.\n\n    Parameters:\n    lst (list): A list of strings.\n\n    Returns:\n    list: Sorted list of strings with even lengths only.\n\n    Examples:\n    >>> assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    >>> assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    >>> assert sorted_list_sum([\"Hello\", \"World\", \"Python\"]) == [\"Python\", \"World\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length of words, then alphabetically if lengths are equal\n    sorted_words = sorted(even_length_words, key=lambda x: (len(x), x))\n    \n    return sorted_words", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths from the input list, then sorts the remaining strings.\n\n    Args:\n    lst (list of str): A list of strings to process.\n\n    Returns:\n    list of str: A sorted list where strings are sorted by length (ascending) and then alphabetically if lengths are equal.\n\n    Example:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the strings first by length, then alphabetically for strings of the same length\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\" \n    Takes a list of strings, removes strings with odd lengths, and returns \n    a sorted list where elements are ordered by length first, then alphabetically.\n\n    Parameters:\n    lst (list): A list of strings to be processed.\n\n    Returns:\n    list: Sorted list of strings with even lengths.\n\n    Examples:\n    >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n    ['aa']\n    >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n    ['ab', 'cd']\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort by length first, then alphabetically\n    sorted_words = sorted(even_length_words, key=lambda word: (len(word), word))\n    \n    return sorted_words", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 77.96610169491525, "dps_norm": 87.5, "pass@1": 98.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n    \n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n    This function returns True if the number is not prime, False otherwise.\n    \n    :param n: int, the number to check\n    :return: bool, True if n is not prime, False if n is prime\n    \n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(10)\n    True\n    >>> is_not_prime(17)\n    False\n    \"\"\"\n    if n <= 1:\n        return True  # Numbers less than or equal to 1 are not prime\n    \n    # Check for 2 and 3 which are prime numbers\n    if n <= 3:\n        return False\n    \n    # This is checked so that we can skip middle five numbers in below loop\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    \n    i = 5\n    # We'll check up to the square root of n for efficiency\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    \n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(10)\n    True\n    \"\"\"\n    # Handle edge cases\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n == 2:\n        return False  # 2 is prime\n\n    # Check if n is divisible by any number up to the square root of n\n    # We don't need to go beyond sqrt(n) because if n is divisible by something larger than sqrt(n),\n    # it will also be divisible by something smaller than sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Args:\n    n (int): The number to check for primality.\n\n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n\n    Examples:\n    >>> assert is_not_prime(2) == False\n    >>> is_not_prime(1)  # 1 is not prime by definition\n    True\n    >>> is_not_prime(10)\n    True\n    >>> is_not_prime(7)\n    False\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # 2 is the smallest prime number\n    if n == 2:\n        return False\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return True\n    \n    # Check for divisibility by odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \n    A number is considered non-prime if:\n    - It is less than 2\n    - It has any divisors other than 1 and itself\n\n    Args:\n    n (int): The number to check for primality.\n\n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n\n    Examples:\n    >>> is_not_prime(1)\n    True\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(4)\n    True\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check divisibility from 2 to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors were found, n is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    A prime number (or a prime) is a natural number greater than 1 that is not \n    a product of two smaller natural numbers.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n\n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(10)\n    True\n    >>> is_not_prime(17)\n    False\n    \"\"\"\n    # Numbers less than or equal to 1 are not prime by definition\n    if n <= 1:\n        return True\n    \n    # 2 is the only even prime number\n    if n == 2:\n        return False\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return True\n    \n    # Check odd numbers up to the square root of n\n    # If n is divisible by any number from 3 to sqrt(n), then it's not prime\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    \n    # If we haven't returned True by now, then n is prime\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n    \n    A number is not prime if it:\n    1. Is less than 2\n    2. Has any divisors other than 1 and itself\n    \n    Args:\n    n (int): The number to check\n\n    Returns:\n    bool: True if the number is not prime, False otherwise\n    \n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(4)\n    True\n    >>> is_not_prime(17)\n    False\n    \"\"\"\n    # Numbers less than 2 are not prime by definition\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to sqrt(n)\n    # We use the square root because any factor larger than sqrt(n) would have \n    # a corresponding factor smaller than sqrt(n), which we would have already found\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    A prime number is only divisible by 1 and itself. \n    This function returns True if the number is not prime, False if it is prime.\n\n    Parameters:\n    n (int): The number to check for primality.\n\n    Returns:\n    bool: True if n is not prime, False otherwise.\n\n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(4)\n    True\n    >>> is_not_prime(7)\n    False\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # 2 is the smallest prime number\n    if n == 2:\n        return False\n    \n    # Even numbers greater than 2 cannot be prime\n    if n % 2 == 0:\n        return True\n    \n    # Check odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, it's prime\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    # Numbers less than 2 are not prime by definition\n    if n < 2:\n        return True\n    \n    # 2 is prime\n    if n == 2:\n        return False\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return True\n    \n    # Check odd numbers from 3 up to sqrt(n)\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n    \n    A prime number has no positive divisors other than 1 and itself.\n    This function returns True for non-prime numbers, including 0 and 1.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is not prime, False if it is prime or for 2 (the smallest prime).\n    \n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(10)\n    True\n    \"\"\"\n    # 0 and 1 are not prime by definition\n    if n <= 1:\n        return True\n    \n    # 2 is the smallest prime number, so it returns False by the assertion\n    if n == 2:\n        return False\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return True\n    \n    # Check odd numbers up to the square root of n for efficiency\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, it's prime\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n    \n    Args:\n    n (int): The number to check for non-primality.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n\n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(10)\n    True\n    \"\"\"\n    # Numbers less than or equal to 1 are not considered prime or non-prime by definition\n    if n <= 1:\n        return True\n    \n    # 2 is the smallest prime number\n    if n == 2:\n        return False\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return True\n    \n    # Check odd numbers up to the square root of n for divisibility\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, n is prime\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n    \n    This function checks if the given number is less than 2 (which are not primes)\n    or if it has any divisors other than 1 and itself.\n    \n    :param n: The integer to check for non-primality\n    :return: True if the number is not prime, False otherwise\n    \"\"\"\n    if n < 2:  # Numbers less than 2 are not prime by definition\n        return True\n    \n    # Checking divisibility from 2 to the square root of n is sufficient\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, number is not prime\n    \n    return False  # If we've checked all possible divisors and found none, it's prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n    \n    A prime number is only divisible by 1 and itself. If a number \n    has any divisor other than 1 and itself, it's not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(10)\n    True\n    \"\"\"\n    # Numbers less than 2 are not prime by definition\n    if n < 2:\n        return True\n    \n    # Check for divisibility up to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if the given number is not a prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime or less than 2.\n    \n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(15)\n    True\n    >>> is_not_prime(17)\n    False\n    \"\"\"\n    # Numbers less than 2 are not considered prime by definition\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    A prime number is only divisible by 1 and itself. This function returns True if\n    the number is not prime (i.e., composite or less than 2), and False if it is prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is not prime, False otherwise.\n\n    Examples:\n        >>> is_not_prime(1)\n        True\n        >>> is_not_prime(2)\n        False\n        >>> is_not_prime(4)\n        True\n    \"\"\"\n    # Handle special cases\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return True\n    \n    # Check odd numbers up to the square root of n for efficiency\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    A prime number is greater than 1 and has no positive divisors other than 1 and itself.\n    For the sake of simplicity, we'll consider 1 and numbers less than 1 as not prime.\n\n    Parameters:\n    n (int): The number to check for primality.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(10)\n    True\n    \"\"\"\n    # Check if n is less than or equal to 1, which are not prime\n    if n <= 1:\n        return True\n\n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(10)\n    True\n    >>> is_not_prime(17)\n    False\n    \"\"\"\n    # Numbers less than 2 are not prime by definition\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors were found, then n is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    A prime number (or a prime) is a natural number greater than 1 that is not \n    the product of two smaller natural numbers. Thus, this function returns True \n    if the number is not prime, False otherwise.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n\n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(4)\n    True\n    >>> is_not_prime(11)\n    False\n    \"\"\"\n    # Handle special cases\n    if n <= 1:\n        return True  # 0 and 1 are not prime by definition\n    \n    # 2 is the only even prime number\n    if n == 2:\n        return False\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return True\n    \n    # Check odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    \n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    # Check if n is less than 2, which are not prime by definition\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n    \n    Args:\n    n (int): The number to check for primality.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(10)\n    True\n    \"\"\"\n    # Numbers less than or equal to 1 are not prime by definition\n    if n <= 1:\n        return True\n    \n    # Check for divisibility from 2 to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, it's prime (hence not non-prime)\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n    \n    A prime number (or a prime) is a natural number greater than 1 that is not a product of two smaller natural numbers.\n    \n    Parameters:\n    n (int): The number to check for primality.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \n    Examples:\n    >>> assert is_not_prime(2) == False\n    >>> assert is_not_prime(15) == True\n    >>> assert is_not_prime(29) == False\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n <= 1:\n        return True\n    \n    # 2 is the only even prime number\n    if n == 2:\n        return False\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return True\n    \n    # Check odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 74.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers to search through.\n    :param n: Number of largest elements to find.\n    :return: List of n largest integers in descending order.\n    \"\"\"\n    # Check if n is valid\n    if n <= 0:\n        return []\n    elif n >= len(numbers):\n        return sorted(numbers, reverse=True)\n\n    # Use heapq.nlargest for efficiency\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers using a min-heap.\n\n    This function uses Python's heapq module to maintain a heap of at most n elements.\n    As we push numbers onto this heap, we ensure it contains only the n largest elements\n    we've seen so far. Since a min-heap is used, the smallest number in the heap \n    (top of the heap) will always be the n-th largest number in the list.\n\n    :param numbers: List of integers to search through\n    :param n: Number of largest elements to find\n    :return: List of n largest integers in descending order\n\n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    # Use heapq.nlargest which internally uses a heap\n    largest = heapq.nlargest(n, numbers)\n    \n    # heapq.nlargest returns in descending order\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers in the given list of numbers, returned in descending order.\n\n    Parameters:\n    - numbers: List[int] - The list of integers to search through.\n    - n: int - The number of largest integers to return.\n\n    Returns:\n    - List[int] - A list containing the n largest numbers in descending order.\n\n    Raises:\n    - ValueError: If n is greater than the length of numbers or less than 1.\n\n    Examples:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    if n > len(numbers) or n < 1:\n        raise ValueError(\"n must be between 1 and the length of the list\")\n\n    # Use heapq.nlargest which internally uses a heap to find the n largest elements\n    # This automatically handles the case where duplicates exist\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a list of numbers, returned in descending order.\n\n    Parameters:\n    - numbers (list): A list of integers from which to find the largest values.\n    - n (int): The number of largest integers to find.\n\n    Returns:\n    - list: A list of the n largest integers in descending order.\n\n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    # If n is greater than or equal to the length of numbers, we can simply sort the list\n    if n >= len(numbers):\n        return sorted(numbers, reverse=True)\n\n    # Use heapq.nlargest which is efficient for this operation\n    # The list is returned in descending order by default\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # If n is greater than or equal to the length of numbers, we sort and return the entire list in reverse order\n    if n >= len(numbers):\n        return sorted(numbers, reverse=True)\n\n    # Use a min-heap to keep only the n largest elements\n    heap = []\n    for num in numbers:\n        # If the heap size is less than n, push the number into the heap\n        if len(heap) < n:\n            heapq.heappush(heap, num)\n        # If the number is greater than the smallest element in heap, replace it\n        elif num > heap[0]:\n            heapq.heapreplace(heap, num)\n\n    # Since we've kept the n largest in a min-heap, we need to sort them to get them in descending order\n    result = sorted(heap, reverse=True)\n    return result", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use heapq.nlargest to get the n largest elements from the list\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers in descending order.\n\n    Args:\n    numbers (list): A list of integers from which to find the largest elements.\n    n (int): The number of largest elements to return.\n\n    Returns:\n    list: A list containing the n largest numbers from the original list, in descending order.\n\n    Examples:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    # If n is greater than the length of the list, return all in descending order\n    if n >= len(numbers):\n        return sorted(numbers, reverse=True)\n    \n    # Use a min heap to keep track of the n largest elements\n    heap = []\n    for num in numbers:\n        # If the heap has less than n elements, add them\n        if len(heap) < n:\n            heapq.heappush(heap, num)\n        # If the current number is larger than the smallest in heap, replace it\n        elif num > heap[0]:\n            heapq.heapreplace(heap, num)\n    \n    # Convert heap to sorted list in descending order\n    # The heap is naturally in ascending order with smallest on top, \n    # so we reverse it here\n    return sorted(heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # If n is greater than the number of elements in the list, \n    # we'll return the whole list sorted in descending order\n    if n >= len(numbers):\n        return sorted(numbers, reverse=True)\n    \n    # Using heapq.nlargest to get the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # heapq.nlargest does not guarantee any order, so we sort it for descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n    numbers (list): A list of integers.\n    n (int): The number of largest integers to return.\n\n    Returns:\n    list: n largest integers in descending order.\n\n    Raises:\n    ValueError: If n is greater than the length of numbers or if n is less than or equal to 0.\n\n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    if n > len(numbers) or n <= 0:\n        raise ValueError(\"n must be a positive integer not greater than the list's length\")\n\n    # Use heapq.nlargest for efficiency as it uses a heap which has O(n log k) time complexity\n    largest = heapq.nlargest(n, numbers)\n    # Since heapq.nlargest returns the list in descending order, we don't need to reverse it\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from the given list of numbers.\n    \n    This function uses Python's heapq module to maintain a min-heap of size n,\n    which helps in keeping track of the n largest elements seen so far with O(log n) operations for insertion and removal.\n\n    Args:\n    numbers (list of int): A list of integers from which to find the largest.\n    n (int): The number of largest integers to return.\n\n    Returns:\n    list of int: The n largest integers in descending order.\n    \n    Raises:\n    ValueError: If n is greater than the length of the list or less than or equal to 0.\n\n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    if n > len(numbers) or n <= 0:\n        raise ValueError(\"n should be positive and not larger than the list's length.\")\n\n    # Create a min-heap with the first n elements or all if n >= len(numbers)\n    heap = numbers[:n]\n    heapq.heapify(heap)\n\n    # For the rest of the numbers, replace elements in the heap if they are larger than the smallest in heap\n    for num in numbers[n:]:\n        if num > heap[0]:  # If the number is larger than the smallest in the heap\n            heapq.heapreplace(heap, num)\n    \n    # The heap now contains the n largest numbers in the form of a min-heap, so reverse it\n    # Since heap[0] will be the smallest of the largest, which is the n-th largest overall\n    largest = []\n    while heap:\n        largest.append(heapq.heappop(heap))\n    \n    return largest[::-1]  # Reverse the list to get descending order", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to get the n largest elements, which returns them in descending order by default\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers in the given list, returned in descending order.\n\n    Args:\n    numbers (list of int): List of numbers from which to find the largest integers.\n    n (int): The number of largest elements to find.\n\n    Returns:\n    list of int: The n largest integers from the list in descending order.\n\n    Raises:\n    ValueError: If n is greater than the length of numbers or if n is not positive.\n\n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    if n > len(numbers) or n <= 0:\n        raise ValueError(\"n must be positive and not exceed the list's length\")\n\n    # Use heapq.nlargest which directly gives us what we need\n    # It internally uses a heap to keep the largest elements at the top\n    largest = heapq.nlargest(n, numbers)\n    \n    # heapq.nlargest already returns elements in descending order\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers in the list, returned in descending order.\n    \n    :param numbers: List of integers to search from\n    :param n: Number of largest elements to return\n    :return: List of n largest numbers in descending order\n    \"\"\"\n    # If n is larger than the list length, adjust n\n    n = min(n, len(numbers))\n    \n    # We use Python's heapq to create a min-heap from the n largest elements\n    # Here, we're using the smallest of the n largest as our min-heap to keep track of them\n    largest = heapq.nlargest(n, numbers)\n    \n    # Convert the min-heap into a list and reverse it for descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from the given list of numbers, returned in descending order.\n\n    Args:\n    numbers (list): A list of integers where the largest numbers are to be found.\n    n (int): The number of largest elements to return.\n\n    Returns:\n    list: The n largest numbers from the input list, sorted in descending order.\n\n    Raises:\n    ValueError: If n is greater than the length of the list or less than 1.\n\n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    if not 1 <= n <= len(numbers):\n        raise ValueError(\"n must be between 1 and the length of the list inclusive.\")\n    \n    # Since Python's heapq module provides a min-heap by default, we'll use the negative of numbers\n    # to simulate a max-heap behavior for finding largest elements\n    largest = heapq.nlargest(n, numbers)\n    # The list is already sorted in descending order by heapq.nlargest\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from the given list of numbers using a heap.\n\n    Args:\n    numbers (list): A list of numbers from which to find the largest.\n    n (int): The number of largest integers to retrieve.\n\n    Returns:\n    list: A list containing the n largest integers in descending order.\n\n    Raises:\n    ValueError: If n is larger than the length of the numbers list or if n is less than 1.\n\n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    if n > len(numbers) or n < 1:\n        raise ValueError(\"n must be between 1 and the length of the list inclusive.\")\n    \n    # Using heapq.nlargest which internally uses a heap\n    # This gives us the n largest numbers, but they're not in descending order yet\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result to ensure descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers in the given list of numbers, returned in descending order.\n\n    This function uses Python's heapq module to maintain a min-heap of the largest \n    values seen so far. It's efficient because it maintains only 'n' elements at any time.\n\n    Args:\n    numbers (list of int): The list of numbers from which to find the largest.\n    n (int): The number of largest integers to return.\n\n    Returns:\n    list: A list containing the n largest numbers from 'numbers' in descending order.\n\n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    # If we need all or more elements than are available, sort the list and return the last n elements\n    if n >= len(numbers):\n        return sorted(numbers, reverse=True)[:n]\n    \n    # Initialize a min-heap to keep track of the n largest numbers\n    largest = []\n    for num in numbers:\n        # If the heap has less than n elements, we add the number\n        if len(largest) < n:\n            heapq.heappush(largest, num)\n        # If the number is larger than the smallest in our heap, replace the smallest with this number\n        elif num > largest[0]:\n            heapq.heappop(largest)\n            heapq.heappush(largest, num)\n    \n    # Convert heap to a list in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a list of numbers using a min-heap.\n    \n    This function first creates a min-heap with the n smallest elements,\n    then iterates through the list, replacing heap items if larger numbers are found.\n    \n    Args:\n    numbers (list): A list of integers.\n    n (int): The number of largest elements to return.\n    \n    Returns:\n    list: A list of n largest numbers in descending order.\n    \n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    # If we need to find more elements than exist in the list or n is 0, handle accordingly\n    if n > len(numbers) or n == 0:\n        return sorted(numbers, reverse=True)[:n]\n    \n    # Start with a heap that contains the first n elements\n    heap = numbers[:n]\n    heapq.heapify(heap)\n    \n    # Now go through the remaining numbers, potentially replacing the smallest element in the heap\n    for num in numbers[n:]:\n        if num > heap[0]:\n            heapq.heapreplace(heap, num)\n    \n    # Heapify one more time to ensure heap property holds\n    heapq.heapify(heap)\n    \n    # Extract and reverse the list to get the largest elements in descending order\n    return sorted(heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a list of numbers using a heap.\n    \n    This function uses Python's heapq module to efficiently select the\n    top n elements from the list. It constructs a min-heap of size n,\n    where only numbers larger than the smallest number in the heap are \n    added or swapped into the heap. This ensures we keep the largest n \n    elements by the end.\n\n    Args:\n    numbers (list of int): A list of numbers to search through.\n    n (int): The number of largest integers to return.\n\n    Returns:\n    list of int: A list containing the n largest numbers in descending order.\n\n    Raises:\n    ValueError: If n is greater than the length of numbers or less than 1.\n\n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    if n > len(numbers) or n < 1:\n        raise ValueError(\"n must be between 1 and the length of the list\")\n    \n    # Use heapq.nlargest which returns the n largest elements from the iterable\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from the given list and return them in descending order.\n    \n    :param numbers: List[int] - The list of numbers to search through.\n    :param n: int - The number of largest elements to find.\n    :return: List[int] - n largest integers sorted in descending order.\n    \n    :raises ValueError: If n is greater than the length of numbers or if n is less than 1.\n    \"\"\"\n    if n > len(numbers) or n < 1:\n        raise ValueError(\"n must be between 1 and the length of the list inclusive\")\n    \n    # Use heapq.nlargest for efficiency\n    largest = heapq.nlargest(n, numbers)\n    \n    # Since heapq.nlargest returns in descending order, no further sorting is needed\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers in descending order.\n    \n    Args:\n    numbers (list): A list of integers from which to find the largest numbers.\n    n (int): The number of largest integers to return.\n\n    Returns:\n    list: n largest numbers in descending order.\n\n    Examples:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    # If n is greater than the list length or 0, adjust n accordingly\n    if n > len(numbers) or n == 0:\n        n = len(numbers)\n\n    # Use a heap to keep track of the largest elements\n    largest = heapq.nlargest(n, numbers)\n    \n    # Since heapq.nlargest returns elements in descending order, we don't need to sort again\n    return largest", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 54.863945578231295, "dps_norm": 49.0, "pass@1": 49.0, "profiled": [{"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations required to get the same string.\n\n    This function determines how many rotations (greater than 0) are needed \n    to make the string identical to its original form. A rotation of a string \n    moves each character one position to the left, with the first character \n    becoming the last.\n\n    Args:\n    s (str): The string to be checked for rotations.\n\n    Returns:\n    int: The minimum number of rotations needed, or -1 if no such rotation exists \n         (though for any string this will always be less than len(s)).\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abcabc\")\n    3\n    >>> find_Rotations(\"abcd\")\n    4\n    \"\"\"\n    # If the string length is 0 or 1, any rotation would technically work, but \n    # by convention, we'll say 1 rotation for strings of length > 0 to match \n    # the assertion\n    if len(s) <= 1:\n        return 1\n    \n    # Double the string to easily detect the pattern of rotation\n    doubled = s + s\n    \n    # Find the minimum number of rotations\n    for i in range(1, len(s)):\n        # Check if this rotation matches the original string\n        if doubled[i:i+len(s)] == s:\n            return i\n\n    # This should never be reached for any string since rotating a string \n    # len(s) times would bring it back to its original state, but included for completeness\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    if not s:\n        return 0  # No rotation needed for an empty string\n\n    # Length of the string\n    n = len(s)\n    \n    # We'll rotate the string from 1 to n-1 times\n    for i in range(1, n):\n        # Create a new string by rotating s by i positions\n        rotated = s[i:] + s[:i]\n        \n        # If the rotated string matches the original, we found our answer\n        if rotated == s:\n            return i\n    \n    # If no rotation leads to the same string, return n\n    # This case might not occur for non-empty strings where all characters are identical,\n    # but it's here for completeness\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations required to return to the original string.\n    \n    This function calculates how many times the string needs to be rotated \n    to get back to its original form, assuming at least one rotation must occur.\n\n    Args:\n    s (str): The string to analyze.\n\n    Returns:\n    int: The minimum number of rotations (>0) to return to the same string.\n\n    Example:\n    >>> find_Rotations(\"aaaa\")\n    1\n    \"\"\"\n    if not s or len(s.strip()) == 0:\n        return 1  # Edge case: empty string or all spaces would revert to itself immediately\n\n    # String length\n    n = len(s)\n    # A string can return to its original form after 'n' rotations\n    # but we need to find the smallest number > 0\n    rotations = n\n\n    # Check for each potential substring that could be a suffix\n    for i in range(1, n):\n        # If the string is equal to itself shifted by 'i' positions\n        if s == s[i:] + s[:i]:\n            rotations = i\n            break\n\n    # Ensure we return a value greater than 0\n    return rotations if rotations > 0 else n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations required to get the same string.\n\n    Args:\n    s (str): The input string to analyze.\n\n    Returns:\n    int: The minimum number of rotations greater than zero required to match the string itself.\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abcabc\")\n    3\n    >>> find_Rotations(\"abcde\")\n    len(s)\n    \"\"\"\n    # If the string is only one character or empty, 1 rotation is enough since any rotation will yield the same string\n    if len(s) <= 1:\n        return 1\n    \n    # Convert string to list for easy manipulation\n    chars = list(s)\n    for i in range(1, len(s)):\n        # Rotate the list\n        rotated = chars[-i:] + chars[:-i]\n        # If the rotated list matches the original string, return the number of rotations\n        if ''.join(rotated) == s:\n            return i\n    \n    # If no rotation except the string length results in the same string\n    return len(s)", "matching_cluster_idx": -1}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations required to get the same string.\n    \n    Args:\n    s (str): The input string to rotate.\n    \n    Returns:\n    int: Minimum number of rotations greater than 0. Returns 1 if the string is empty or already repeating at its current form.\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"ab\")\n    2\n    \"\"\"\n    if not s:\n        return 1  # Empty string by default needs 1 rotation\n    \n    n = len(s)\n    if n == 1:\n        return 1  # Single character string needs one rotation\n    \n    for rotations in range(1, n):\n        # Check if rotating by 'rotations' times results in the same string\n        rotated = s[rotations:] + s[:rotations]\n        if rotated == s:\n            return rotations\n    \n    # If no rotation matches, it means the string doesn't repeat except at full rotations\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations required to get the same string.\n    \n    This function determines how many times a string needs to be rotated to return to its original form.\n    \n    Args:\n    s (str): The input string to be rotated.\n\n    Returns:\n    int: The minimum number of rotations greater than 0. If the string has no duplicate, \n         this will be equal to its length.\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abcabc\")\n    3\n    \"\"\"\n    # If all characters are the same, only one rotation is needed\n    if len(set(s)) == 1:\n        return 1\n    \n    n = len(s)\n    \n    # Generate all rotations of the string\n    rotations = [s[i:] + s[:i] for i in range(n)]\n    \n    # Check for the smallest k where k > 0 such that rotations[i] == s\n    for k in range(1, n):\n        if rotations[k] == s:\n            return k\n    \n    # If we didn't find a match, we need to return n as a fallback for non-repeating strings\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations required to get the same string.\n    \n    This function determines the smallest number of times the string needs to be\n    rotated to get back to its original state. A rotation here means moving the \n    first character to the end of the string.\n\n    Args:\n    s (str): The input string to be analyzed for rotations.\n\n    Returns:\n    int: The number of rotations needed. If the string has no repeating pattern,\n         this will equal the length of the string since you would need to rotate\n         each character to the front once.\n\n    Raises:\n    ValueError: If the string is empty or None.\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abcabc\")\n    3\n    >>> find_Rotations(\"ab\")\n    2\n    \"\"\"\n    # Check for invalid input\n    if not s or len(s) == 0:\n        raise ValueError(\"Input string cannot be empty or None\")\n\n    length = len(s)\n    \n    # If the string has all unique characters, we need length rotations\n    if len(set(s)) == length:\n        return length\n    \n    for i in range(1, length + 1):\n        # Create the substring for comparison\n        sub = s[i:] + s[:i]\n        if sub == s:\n            return i\n    \n    # This line should not be reached if the above logic is sound, but here for completeness\n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    if not s:  # If string is empty\n        return 0\n    \n    for i in range(1, len(s) + 1):\n        # Rotate the string by i positions\n        rotated = s[-i:] + s[:-i]\n        if rotated == s:\n            return i\n    \n    # If no rotation results in the same string (which won't happen with this problem's constraints)\n    return -1  # Or you can handle this differently, e.g., raise an exception", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations required to get the same string.\n    \n    This function checks how many rotations of the string would result in the original string.\n    - For any string, at least one rotation (the trivial rotation by the string length) will always work.\n    - For strings with periodicity, fewer rotations might be needed.\n    \n    Args:\n    s (str): The input string to check for rotations.\n    \n    Returns:\n    int: The minimum number of rotations required. This number will always be greater than 0.\n    \n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"ababc\")\n    5\n    \n    \"\"\"\n    if len(s) == 0:\n        return 1  # Trivially, any empty string needs only one rotation\n    \n    # Create a concatenated string to simulate rotations without actual string shifting\n    s_double = s + s\n    min_rotations = len(s)  # At worst, you'll need as many rotations as the length of the string\n\n    # Check for shorter periods that would still make the string identical when rotated\n    for i in range(1, len(s)):\n        if s_double[i:i + len(s)] == s:  # If substring from i to i+len(s) matches the original string\n            min_rotations = i\n            break  # We've found the shortest period\n    \n    return min_rotations", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations required to get the same string.\n\n    This function calculates how many times the string needs to be rotated \n    (shifted circularly) until it matches the original string again. \n    Since rotating the string by its length will always bring it back to itself,\n    we look for the smallest number of rotations where this happens first.\n\n    Args:\n    s (str): The input string to be rotated.\n\n    Returns:\n    int: The minimum number of rotations (> 0) needed to get back the original string.\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"ab\")\n    2\n    >>> find_Rotations(\"abc\")\n    3\n    \"\"\"\n    if len(s) == 0 or s == s[1:] + s[0]:  # Edge cases: empty string or all same characters\n        return 1\n\n    for i in range(1, len(s)):\n        # Rotate the string 's' by 'i' characters and check if it matches the original\n        if s == s[i:] + s[:i]:\n            return i\n    \n    # This line should never be reached for the given problem, \n    # but included for completeness if there's an unexpected input\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations required to return the original string.\n\n    This function checks how many rotations are needed until the string matches its original form,\n    excluding the case where no rotation (0) results in the same string.\n\n    Parameters:\n    s (str): The string to check for rotations.\n\n    Returns:\n    int: The minimum number of rotations > 0 to return to the same string.\n\n    Example:\n    >>> find_Rotations(\"aaaa\")\n    1\n    \"\"\"\n    # If the string length is 0 or 1, any rotation will result in the same string\n    if len(s) <= 1:\n        return 1\n\n    # Initial rotation is 1 since we exclude the case of no rotation\n    rotations = 1\n\n    # Rotate the string and compare\n    while True:\n        # Check if rotating once more results in the original string\n        if s[rotations:] + s[:rotations] == s:\n            return rotations\n        rotations += 1", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    :param s: Input string to check for rotations.\n    :return: Minimum number of rotations. Returns the length of the string if no rotation results in the same string within less than the string's length.\n    \"\"\"\n    # If the string has less than 2 characters, no rotation can produce the same string\n    if len(s) < 2:\n        return 0\n    \n    # Loop through each possible rotation, but not more than necessary since\n    # a full cycle will return us back to the original string\n    for i in range(1, len(s)):\n        # Rotate the string by 'i' positions\n        rotated = s[i:] + s[:i]\n        # If the rotated string matches the original, return this rotation count\n        if rotated == s:\n            return i\n    \n    # If no rotation matches before len(s), the minimum rotation equals the length\n    # of the string itself to cycle back to the original\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations to return to the same string.\n    \n    Args:\n    s (str): The string to check for rotations.\n\n    Returns:\n    int: The minimum number of rotations required.\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abcabcabc\")\n    3\n    >>> find_Rotations(\"xyxy\")\n    2\n    \"\"\"\n    # If the string length is 0, 1 or all characters are the same, only one rotation is needed\n    if len(s) <= 1 or len(set(s)) == 1:\n        return 1\n\n    # Duplicate the string to handle cases where the pattern repeats across the boundary\n    extended = s + s\n    min_rotation = len(s)  # Set to maximum possible rotations\n\n    for i in range(1, len(s)):\n        # Slice of length 'len(s)' starting from position 'i'\n        sub_str = extended[i:i + len(s)]\n        if sub_str == s:\n            # We've found a match, so update min_rotation if this is less\n            min_rotation = min(min_rotation, i)\n    \n    return min_rotation", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    This function rotates the string one position at a time and checks if it matches \n    the original string after rotation. It counts the number of rotations until a match \n    is found, with a minimum of 1 rotation.\n\n    Args:\n    s (str): The input string to rotate.\n\n    Returns:\n    int: Minimum number of rotations required to match the original string.\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abcde\")\n    5\n    >>> find_Rotations(\"abababa\")\n    7\n    \"\"\"\n    # If the string length is 1, one rotation is needed to come back to itself\n    if len(s) == 1:\n        return 1\n    \n    # Generate all rotations of the string\n    rotations = [s[i:] + s[:i] for i in range(len(s))]\n    \n    # Start from 1 since 0 rotations would mean no change\n    for i in range(1, len(s)):\n        # If the string matches itself after i rotations, return i\n        if rotations[i] == s:\n            return i\n    \n    # If we've gone through all rotations without finding a match before the last,\n    # then the string length rotations are needed to match itself again\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) needed to return to the original string.\n    \n    This function checks how many rotations it takes for the string to return to its original form.\n    Rotation means moving the last character to the beginning of the string.\n\n    Args:\n        s (str): The string to be rotated.\n\n    Returns:\n        int: The minimum number of rotations greater than zero. If the string \n             has no repetition in its rotations, it will return the length of the string.\n\n    Raises:\n        ValueError: If the string is empty.\n\n    Examples:\n        >>> find_Rotations(\"aaaa\")\n        1\n        >>> find_Rotations(\"abc\")\n        3\n    \"\"\"\n    if not s:\n        raise ValueError(\"String cannot be empty\")\n    \n    # The maximum number of rotations needed is the length of the string minus 1\n    for i in range(1, len(s)):\n        # Rotate the string by i times\n        rotated = s[-i:] + s[:-i]\n        # If the rotated string matches the original, we've found our answer\n        if rotated == s:\n            return i\n    \n    # If we've made it through all rotations and didn't find a match, the \n    # string has no repetitions when rotated, so we need len(s) rotations\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations required to return to the original string.\n    \n    This function determines how many times the string needs to be cyclically \n    shifted (rotated) until it matches its initial form again. Each rotation \n    shifts the first character to the last position, then reevaluates the string.\n\n    Args:\n    s (str): The string to analyze.\n\n    Returns:\n    int: The number of rotations. Returns 1 for empty string or a string where \n         all characters are the same, as these cases inherently require no rotation \n         or one rotation to return to the same state.\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abcde\")\n    5\n    >>> find_Rotations(\"\")\n    1\n    \"\"\"\n    # If the string is empty or contains only one unique character, return 1\n    if len(s) <= 1 or len(set(s)) == 1:\n        return 1\n    \n    # Iterate through possible rotations\n    for rotations in range(1, len(s)):\n        if s == s[rotations:] + s[:rotations]:\n            return rotations\n    \n    # If the loop completes without returning, the string length itself is the answer\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to return the same string.\n\n    Args:\n    s (str): The input string to be analyzed.\n\n    Returns:\n    int: The minimum number of rotations greater than 0 to get back the original string.\n\n    Example:\n    >>> assert find_Rotations(\"aaaa\") == 1\n    >>> find_Rotations(\"abcdefghijklmnopqrstuvwxyz\")\n    26\n    \"\"\"\n    if not s or len(s) == 1:\n        return 1  # Any string with length <= 1 can rotate back to itself with just one rotation\n\n    # Find all rotation points where the string can match itself with a rotation\n    n = len(s)\n    rotation_points = []\n    \n    # Look for the minimum rotation where the string matches itself\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:  # Checking if string matches with rotation\n            rotation_points.append(i)\n\n    # Since we are asked for rotations greater than 0, the smallest rotation \n    # that isn't 0 should be the one we want\n    return min(rotation_points) if rotation_points else n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n    s (str): The string to be checked for rotations.\n\n    Returns:\n    int: The minimum number of rotations needed, or the length of the string if no such rotation exists.\n\n    Examples:\n    >>> assert find_Rotations(\"aaaa\") == 1\n    >>> find_Rotations(\"abcabcabc\")\n    3\n    \"\"\"\n    # If all characters are the same, only one rotation is needed\n    if len(set(s)) == 1:\n        return 1\n    \n    # Length of the string\n    n = len(s)\n    \n    # Check all possible rotations\n    for i in range(1, n):\n        # Check if rotating by 'i' positions results in the same string\n        if s == s[i:] + s[:i]:\n            return i\n    \n    # If no rotation less than n results in the same string, \n    # then the whole string length rotation is needed, but this will be ignored\n    # because we want a rotation greater than 0 and less than length of string\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    :param s: The string to check for rotations\n    :return: The number of rotations needed or the length of the string if no rotations work\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abc\")\n    3\n    >>> find_Rotations(\"a\")\n    1\n    >>> find_Rotations(\"xyzxy\")\n    2\n    \"\"\"\n    if not s:  # Handle empty string\n        return 0\n    \n    n = len(s)\n    # If the string has all characters the same, it needs only 1 rotation\n    if len(set(s)) == 1:\n        return 1\n\n    # Check for rotations\n    for i in range(1, n):\n        # If string is equal to its rotated version, return i\n        if s == s[i:] + s[:i]:\n            return i\n    \n    # If no proper rotation found, return length of string\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations required for the string to match itself again.\n    \n    A rotation of a string s by i characters is defined as moving the last i characters\n    of s to the front while the rest move to the right, e.g., \"abcdef\" rotated by 2 becomes \"efabcd\".\n\n    Args:\n    s (str): The input string to rotate.\n\n    Returns:\n    int: Minimum number of rotations to get the same string (greater than 0).\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abcabcabc\")\n    3\n    \"\"\"\n    # Length of the string\n    n = len(s)\n    \n    # If string length is 0 or 1, no rotations are needed\n    if n <= 1:\n        return 0\n    \n    # Start with a full rotation\n    for rotations in range(1, n):\n        # Check if the string after rotation matches the original string\n        if s == s[-rotations:] + s[:-rotations]:\n            return rotations\n    \n    # If no match found before, return the length of the string, \n    # meaning all rotations lead to the same result (only for certain patterns like \"abcabcabc\")\n    return n", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": 73.9068100358423, "dps_norm": 96.11111111111111, "pass@1": 59.0, "profiled": [{"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    s (str): The original string.\n    char (str): The character to remove from the string.\n\n    Returns:\n    str: A new string with the first and last occurrence of the character removed.\n         If the character does not exist in the string or if removing the characters would result in an empty string, \n         returns the original string or an empty string respectively.\n\n    Examples:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    >>> remove_Occ(\"abcba\", \"b\")\n    'aca'\n    >>> remove_Occ(\"aaa\", \"a\")\n    ''\n    >>> remove_Occ(\"nooccurrence\", \"x\")\n    'nooccurrence'\n    \"\"\"\n    # Find the indices of the first and last occurrences\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    # If the character is not in the string, or if first_index > last_index, return the string as is\n    if first_index == -1 or first_index > last_index:\n        return s\n    \n    # Construct the new string by slicing around the found indices\n    # If first_index equals last_index, we remove the character once\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    else:\n        # Remove from first occurrence to before last occurrence\n        return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    s (str): The input string.\n    char (str): The character to be removed (once from the beginning and once from the end).\n\n    Returns:\n    str: A string with the first and last occurrences of the specified character removed.\n\n    Examples:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    >>> remove_Occ(\"program\", \"r\")\n    'pogam'\n    >>> remove_Occ(\"abracadabra\", \"a\")\n    'brcadabr'\n    \"\"\"\n    # Find the index of first occurrence\n    first_index = s.find(char)\n    \n    # If the character is not in the string, return the string as is\n    if first_index == -1:\n        return s\n    \n    # Find the index of last occurrence starting from the end\n    last_index = s.rfind(char)\n    \n    # Remove the first occurrence\n    if first_index == last_index:\n        # If there's only one occurrence, remove it and adjust the string accordingly\n        return s[:first_index] + s[first_index + 1:]\n    else:\n        # Remove both occurrences\n        return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Args:\n    s (str): The input string.\n    char (str): The character to be removed. It should be a single character string.\n\n    Returns:\n    str: A new string with the first and last occurrence of 'char' removed. \n         If the character appears only once, both occurrences are effectively \n         removed, or the string remains unchanged if the character doesn't exist.\n\n    Raises:\n    ValueError: If char is not a single character.\n\n    Examples:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    >>> remove_Occ(\"abba\", \"a\")\n    'bb'\n    >>> remove_Occ(\"no match here\", \"x\")\n    'no match here'\n    \"\"\"\n    if len(char) != 1:\n        raise ValueError(\"The character to remove must be a single character string.\")\n    \n    # Find indices of first and last occurrence\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    \n    # If char occurs only once, we remove it twice to mimic removal of both first and last\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:] if first_index != -1 else s\n    \n    # Remove first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    # Adjust last_index if necessary due to the removal of the first char\n    if last_index > first_index:\n        last_index -= 1\n    # Now remove the last occurrence which might have changed position after first removal\n    s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n    \n    Args:\n    s (str): The input string.\n    char (str): The character to be removed (must be a single character).\n    \n    Returns:\n    str: A string with the first and last occurrence of the character removed.\n         If the character does not appear or only appears once, removes that one occurrence.\n\n    Examples:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    >>> remove_Occ(\"abcda\", \"a\")\n    'bcd'\n    >>> remove_Occ(\"banana\", \"n\")\n    'bana'\n    \"\"\"\n    # Check if the character exists in the string\n    if char not in s:\n        return s\n    \n    # Find indices of first and last occurrence of the character\n    first = s.find(char)\n    last = s.rfind(char)\n    \n    # Handle cases where char appears only once or at both ends\n    if first == last:\n        return s[:first] + s[first + 1:]\n    else:\n        # Remove the first occurrence and adjust the last index due to removal\n        first_part = s[:first]\n        middle_part = s[first + 1:last]\n        last_part = s[last + 1:] if last < len(s) - 1 else ''\n        return first_part + middle_part + last_part", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the indices of the first and last occurrences of the character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # If first and last are the same, we only need to remove one character\n    if first_index == last_index:\n        return s[:first_index] + s[last_index + 1:]\n    \n    # Remove the first and last occurrence of the character\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    This function scans the string for the given character and removes only\n    the first and last instance of it. If the character does not exist or appears\n    only once, it will behave accordingly.\n\n    Args:\n    s (str): The input string to modify.\n    char (str): The single character to remove from the string.\n\n    Returns:\n    str: The modified string with the first and last occurrence of the character removed.\n\n    Raises:\n    ValueError: If 'char' is not a single character.\n\n    Examples:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    >>> remove_Occ(\"banana\", \"a\")\n    'bana'\n    >>> remove_Occ(\"abc\", \"d\")\n    'abc'\n    \"\"\"\n    # Ensure the char parameter is a single character\n    if len(char) != 1:\n        raise ValueError(\"The character to remove must be a single character.\")\n\n    # Find the indices of the first and last occurrence of the character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n\n    # If char doesn't exist, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n\n    # If first and last indices are the same, remove only one instance\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove the first and last occurrences\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Args:\n    s (str): The input string.\n    char (str): The character to be removed from the string.\n\n    Returns:\n    str: A new string with the first and last occurrence of 'char' removed.\n\n    Example:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    \"\"\"\n    # Find indices of first and last occurrence\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    # If the character is not found at all, return the original string\n    if first_index == -1:\n        return s\n    \n    # If first and last are the same, remove only once\n    if first_index == last_index:\n        return s[:first_index] + s[last_index + 1:]\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # Adjust the last index because we've removed a character\n    last_index -= 1\n    \n    # Remove the last occurrence, ensuring we don't index out of bounds\n    if last_index >= 0:\n        s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n    \n    Args:\n    s (str): The original string from which characters are to be removed.\n    char (str): The character to remove (single character string).\n\n    Returns:\n    str: A new string with the first and last occurrence of 'char' removed if they exist.\n\n    Examples:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    >>> remove_Occ(\"xyxyx\", \"x\")\n    'yxy'\n    >>> remove_Occ(\"12341\", \"1\")\n    '234'\n    \"\"\"\n    # If the character is not in the string, return the original string\n    if char not in s:\n        return s\n    \n    # Find the first and last occurrence of the character\n    first = s.find(char)\n    last = s.rfind(char)\n\n    # If there's only one occurrence, remove it\n    if first == last:\n        return s[:first] + s[first + 1:]\n\n    # Remove the first and last occurrence\n    return s[:first] + s[first + 1:last] + s[last + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    s (str): The input string.\n    char (str): The character to remove (must be length 1).\n    \n    Returns:\n    str: A new string with the first and last occurrence of 'char' removed. \n         If the character does't exist in the string, return the original string.\n    \n    Raises:\n    ValueError: If char is not a single character.\n    \n    Example:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    \"\"\"\n    # Ensure char is a single character\n    if len(char) != 1:\n        raise ValueError(\"The 'char' argument must be a single character.\")\n    \n    # Find the first and last occurrence of char\n    first = s.find(char)\n    last = s.rfind(char)\n    \n    # If char is not found, return the string unchanged\n    if first == -1:\n        return s\n    \n    # Remove first occurrence\n    s = s[:first] + s[first+1:]\n    \n    # Adjust 'last' index since the string has been altered\n    last = s.rfind(char)\n    \n    # If there was only one occurrence or last index is now -1, just return\n    if last == -1:\n        return s\n    \n    # Remove last occurrence\n    s = s[:last] + s[last+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of 'char' removed.\n    \n    Examples:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    >>> remove_Occ(\"abcda\", \"a\")\n    'bcd'\n    >>> remove_Occ(\"banana\", \"a\")\n    'bann'\n    \"\"\"\n    # Find the index of the first occurrence of char\n    first_index = s.find(char)\n    if first_index == -1:  # If char is not in the string, return the string as is\n        return s\n    \n    # Find the index of the last occurrence of char\n    last_index = s.rfind(char)\n    \n    # If the first and last are the same, we need to handle special case\n    if first_index == last_index:\n        return s[:first_index] + s[last_index + 1:]\n    \n    # If the character occurs only once or not at all, handle it\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    Args:\n    s (str): The input string to modify.\n    char (str): A single character to remove from the start and end of the string.\n\n    Returns:\n    str: A new string with the first and last occurrences of `char` removed.\n\n    Raises:\n    ValueError: If `char` is not a single character or if `char` does not exist in `s`.\n    \"\"\"\n    if len(char) != 1:\n        raise ValueError(\"The second argument must be a single character.\")\n    \n    # Find the index of first and last occurrences of char\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    if first_index == -1 or last_index == -1:\n        return s  # char is not in the string, return the string unchanged\n    \n    # If first and last occurrence are at the same position\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    # Remove first occurrence and last occurrence\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of char removed.\n\n    Examples:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    >>> remove_Occ(\"Python\", \"o\")\n    'Pythn'\n    >>> remove_Occ(\"abcda\", \"a\")\n    'bcd'\n    \"\"\"\n    # Find the index of the first and last occurrence\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n\n    # If char is not in string or string is empty, return the string as is\n    if first_index == -1 or not s:\n        return s\n    \n    # If first and last occurrences are the same, we should only remove one\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove the first occurrence\n    result = s[:first_index] + s[first_index + 1:]\n    # Now remove the last occurrence considering the string has been modified\n    last_index_in_result = result.rfind(char)\n    return result[:last_index_in_result] + result[last_index_in_result + 1:]", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Check if the character exists in the string\n    if char not in s:\n        return s\n    \n    # Find the first and last index of the character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    # If first and last occurrence are same, remove just that occurrence\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove both occurrences if they're different\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string: str, char: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of a specified character from the string.\n\n    Args:\n    string (str): The input string from which characters are to be removed.\n    char (str): The character to remove. Assumed to be a single character string.\n\n    Returns:\n    str: A new string with the first and last occurrence of `char` removed if they exist.\n\n    Examples:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    >>> remove_Occ(\"abcda\", \"a\")\n    'bcd'\n    >>> remove_Occ(\"abc\", \"d\")\n    'abc'\n    \"\"\"\n    # Check if char is in the string to avoid unnecessary operations\n    if char not in string:\n        return string\n    \n    # Find indices of first and last occurrences\n    first_index = string.find(char)\n    last_index = string.rfind(char)\n    \n    # If the character appears once or not at all, handle accordingly\n    if first_index == last_index == -1:\n        return string\n    elif first_index == last_index:\n        # If it only appears once, remove it and return\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove first occurrence\n    temp = string[:first_index] + string[first_index + 1:]\n    \n    # Now find the new last occurrence since indices have shifted\n    last_index = temp.rfind(char)\n    \n    # If there's still another occurrence, remove it\n    if last_index != -1:\n        return temp[:last_index] + temp[last_index + 1:]\n    else:\n        # If there was only one occurrence after removing the first, return temp\n        return temp", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The original string.\n    char (str): The character to be removed. Must be a single character.\n\n    Returns:\n    str: A new string with the first and last occurrences of 'char' removed.\n\n    Raises:\n    ValueError: If 'char' is not a single character.\n\n    Example:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    >>> remove_Occ(\"abbaa\", \"a\")\n    'bb'\n    \"\"\"\n    # Check if char is a single character\n    if len(char) != 1:\n        raise ValueError(\"The second argument must be a single character.\")\n    \n    # Find the indices of the first and last occurrence of char\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    # If the character does not exist in the string, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # If both indices are the same, it means there's only one occurrence\n    if first_index == last_index:\n        # Remove the character at this index\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove first and last occurrence\n    result = s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n    return result", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    Args:\n    s (str): The input string.\n    char (str): The character to be removed.\n\n    Returns:\n    str: A new string with the first and last occurrences of the character removed.\n\n    Example:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    \"\"\"\n    # Find the indices of the first and last occurrence of the character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    # If the character does not exist or exists only once\n    if first_index == -1 or first_index == last_index:\n        # Remove all occurrences if only one exists, or return the original string if none exists\n        return s.replace(char, '')\n    \n    # Slice the string to exclude the first and last occurrence of the character\n    result = s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a specified character from the string.\n    \n    Args:\n    s (str): The input string from which characters will be removed.\n    char (str): The character to be removed; only the first and last occurrence are removed.\n    \n    Returns:\n    str: A new string with the first and last occurrence of the given character removed.\n    \n    Examples:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    >>> remove_Occ(\"abcdcba\", \"b\")\n    'acdca'\n    \"\"\"\n    # Check if the string is empty or if char is not in the string\n    if not s or char not in s:\n        return s\n    \n    # Find indices of the first and last occurrence of char\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    # If the first and last are the same, remove only one occurrence\n    if first_index == last_index:\n        result = s[:first_index] + s[last_index + 1:]\n    else:\n        # Remove first and last occurrences of char\n        result = s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Removes the first and last occurrence of a specified character from the string.\n\n    Args:\n    s (str): The input string.\n    char (str): The character to be removed from the string.\n\n    Returns:\n    str: A new string with the first and last occurrences of the character removed.\n\n    Raises:\n    ValueError: If the char length is not 1.\n\n    Examples:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    >>> remove_Occ(\"abcda\", \"a\")\n    'bcd'\n    >>> remove_Occ(\"abbba\", \"b\")\n    'aba'\n    \"\"\"\n    # Check if char is indeed a single character\n    if len(char) != 1:\n        raise ValueError(\"The character to remove must be a single character.\")\n    \n    # Find the index of first occurrence\n    first_index = s.find(char)\n    if first_index == -1:  # Character not found, return original string\n        return s\n    \n    # Find the index of last occurrence starting from the end\n    last_index = s.rfind(char)\n    \n    # If first and last indices are the same, we've handled the case where only one occurrence exists\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove the first occurrence\n    result = s[:first_index] + s[first_index + 1:]\n    \n    # Adjust the last_index to account for the string now being 1 character shorter\n    adjusted_last_index = last_index - 1 if last_index > first_index else last_index\n    # Remove the last occurrence\n    result = result[:adjusted_last_index] + result[adjusted_last_index + 1:]\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n    \n    Args:\n    s (str): The original string to modify.\n    char (str): The character to remove (first and last occurrence).\n\n    Returns:\n    str: A new string with the specified character removed from both ends if present.\n\n    Raises:\n    ValueError: If 'char' is not a single character.\n\n    Examples:\n    >>> remove_Occ(\"hello\", \"l\")\n    'heo'\n    >>> remove_Occ(\"banana\", \"a\")\n    'bnana'\n    >>> remove_Occ(\"banana\", \"z\")\n    'banana'\n    \"\"\"\n    if len(char) != 1:\n        raise ValueError(\"The char argument must be a single character.\")\n\n    # Find indices of first and last occurrence of char\n    first = s.find(char)\n    last = s.rfind(char)\n    \n    # If char is not in s, return s as is\n    if first == -1 or last == -1:\n        return s\n    \n    # Remove the character from the end first to not affect indexing for removal from start\n    if first != last:  # Only remove last if it's different from first\n        s = s[:last] + s[last+1:]\n    \n    # Then remove from start\n    if first != -1:  # Ensure the character still exists in the modified string\n        s = s[:first] + s[first+1:]\n\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(string, char):\n    # Check if char is in string to avoid IndexError\n    if char not in string:\n        return string\n    \n    # Find the first and last occurrence of char\n    first_index = string.find(char)\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence or char appears only once, remove it once\n    if first_index == last_index:\n        return string[:first_index] + string[first_index + 1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index + 1:last_index] + string[last_index + 1:]", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort the given matrix in ascending order based on the sum of each row.\n\n    Args:\n    matrix (List[List[int]]): A 2D list where each sublist is a row of the matrix.\n\n    Returns:\n    List[List[int]]: A new matrix where rows are sorted by their sum.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Sort by sum of rows using a key function\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix based on the sum of each row in ascending order.\n\n    Args:\n    matrix (list of lists): The input matrix to be sorted.\n\n    Returns:\n    list of lists: A new matrix sorted by row sums in ascending order.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Create a list of tuples where each tuple contains the sum of a row and the row itself\n    indexed_matrix = [(sum(row), row) for row in matrix]\n    \n    # Sort this list based on the sum (first element of the tuple)\n    indexed_matrix.sort(key=lambda x: x[0])\n    \n    # Extract only the rows from the sorted list of tuples\n    return [row for _, row in indexed_matrix]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort the matrix rows in ascending order based on the sum of each row.\n\n    Args:\n    matrix (List[List[int]]): The input matrix, where each element is a row represented by a list.\n\n    Returns:\n    List[List[int]]: A new matrix where rows are sorted by their sum.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Create a list of tuples where each tuple contains the sum of the row and the row itself\n    # Then sort this list based on the sum (which is the first item in the tuple)\n    sorted_rows = sorted((sum(row), row) for row in matrix)\n    \n    # Extract just the rows from the sorted list of tuples\n    return [row for _, row in sorted_rows]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort the given matrix in ascending order based on the sum of elements in each row.\n    \n    Args:\n    matrix (List[List[int]]): A 2D list representing the matrix to be sorted.\n    \n    Returns:\n    List[List[int]]: A new matrix with rows sorted based on row sums.\n    \n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # First, we'll pair each row with its sum for comparison\n    with_sum = [(row, sum(row)) for row in matrix]\n    \n    # Sort these pairs based on the sum\n    sorted_with_sum = sorted(with_sum, key=lambda x: x[1])\n    \n    # Extract only the sorted rows, discarding the sum\n    sorted_matrix = [row for row, total in sorted_with_sum]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix based on the sum of elements in each row in ascending order.\n\n    Args:\n    matrix (List[List[int]]): A 2D list representing the matrix to be sorted.\n\n    Returns:\n    List[List[int]]: A new matrix sorted by row sums in ascending order.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Create a list of tuples where each tuple contains a row and its sum\n    indexed_matrix = [(sum(row), row) for row in matrix]\n    \n    # Sort this list based on the sum\n    indexed_matrix.sort(key=lambda x: x[0])\n    \n    # Extract just the rows back into the matrix format\n    return [row for (_, row) in indexed_matrix]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of each row's elements.\n\n    Args:\n    matrix (List[List[int]]): A 2D list representing a matrix of integers.\n\n    Returns:\n    List[List[int]]: A new matrix where rows are sorted by their sum in ascending order.\n\n    Examples:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Sort rows by sum of their elements\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of each row's elements.\n\n    Args:\n    matrix (List[List[int]]): A 2D list representing the matrix.\n\n    Returns:\n    List[List[int]]: A new matrix where rows are sorted according to their sum in ascending order.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Sort rows by summing each row and then sorting based on the sum\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order based on the sum of each row.\n    \n    Args:\n    matrix (List[List[int]]): The input matrix to be sorted.\n    \n    Returns:\n    List[List[int]]: A new matrix with rows sorted according to their sum.\n    \n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Create a list of tuples (row_sum, original_row_index, row)\n    indexed_matrix = [(sum(row), i, row) for i, row in enumerate(matrix)]\n    \n    # Sort by the sum of rows\n    indexed_matrix.sort(key=lambda x: x[0])\n    \n    # Extract the sorted rows\n    return [row for _, _, row in indexed_matrix]\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order based on the sum of the elements in each row.\n\n    Args:\n    matrix (List[List[int]]): A 2D list representing the matrix to be sorted.\n\n    Returns:\n    List[List[int]]: A new matrix with rows sorted by their sum in ascending order.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Use sorted with a key function that calculates the sum of each row\n    # The key function returns the sum of the row, which sorted uses for comparison\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Function to compute the sum of elements in a row\n    def row_sum(row):\n        return sum(row)\n    \n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=row_sum)\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sum_row(row):\n    \"\"\"Calculate the sum of elements in a row.\"\"\"\n    return sum(row)\ndef sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n    matrix (List[List[int]]): A matrix represented as a list of lists.\n\n    Returns:\n    List[List[int]]: The matrix sorted by row sums.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Sort the matrix by using the sum of each row as the key\n    return sorted(matrix, key=sum_row)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order based on the sum of its rows.\n\n    Args:\n    matrix (List[List[int]]): A 2D list representing the matrix.\n\n    Returns:\n    List[List[int]]: The sorted matrix.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Compute the sum of each row\n    sum_of_rows = [sum(row) for row in matrix]\n    \n    # Zip the matrix rows with their sums, sort by the sums, and unzip\n    # We use 'sorted' with a lambda function to sort based on row sums\n    sorted_matrix = [row for _, row in sorted(zip(sum_of_rows, matrix), key=lambda x: x[0])]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a matrix based on the ascending order of the sum of its rows.\n\n    Args:\n    matrix (List[List[int]]): A 2D list representing the matrix.\n\n    Returns:\n    List[List[int]]: A new matrix where rows are sorted by their sum in ascending order.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Create a list of tuples (sum of row, row)\n    row_sum_with_row = [(sum(row), row) for row in matrix]\n    \n    # Sort this list based on sum\n    # The lambda ensures we sort by the first item of the tuple (the sum)\n    sorted_rows = sorted(row_sum_with_row, key=lambda x: x[0])\n    \n    # Extract only the rows, discarding the sum\n    return [row for _, row in sorted_rows]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order based on the sum of the elements in each row.\n\n    Args:\n    matrix (List[List[int]]): A 2D list where each sublist is a row of the matrix.\n\n    Returns:\n    List[List[int]]: The matrix sorted by row sums.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Sort the matrix using a key function which sums each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort the matrix in ascending order according to the sum of its rows.\n\n    Args:\n    matrix (List[List[int]]): A 2D list representing the matrix where each inner list is a row.\n\n    Returns:\n    List[List[int]]: A new matrix with rows sorted by their sum in ascending order.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Sort based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Create a list of tuples where each tuple contains the sum of row elements and the original row\n    sorted_rows = sorted((sum(row), row) for row in matrix)\n    \n    # Extract just the rows from the sorted list of tuples\n    return [row for _, row in sorted_rows]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n    matrix (List[List[int]]): A matrix represented as a list of lists where each inner list is a row.\n\n    Returns:\n    List[List[int]]: A new matrix sorted based on row sums.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Calculate the sum for each row\n    sums = [sum(row) for row in matrix]\n    \n    # Use zip to pair the row sum with the row, sort by the sum, and then unzip to get rows in order\n    sorted_matrix = [row for _, row in sorted(zip(sums, matrix), key=lambda x: x[0])]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix based on the sum of each row in ascending order.\n\n    Args:\n    matrix (List[List[int]]): The input matrix to be sorted.\n\n    Returns:\n    List[List[int]]: A new matrix with rows sorted by their sum.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Create a list of tuples where each tuple contains the sum of a row and the row itself\n    rows_with_sum = [(sum(row), row) for row in matrix]\n    \n    # Sort the list by the sum of each row\n    rows_with_sum.sort(key=lambda x: x[0])\n    \n    # Extract only the rows from the sorted list of tuples\n    return [row for _, row in rows_with_sum]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n    matrix (List[List[int]]): A 2D list where each sublist represents a row in the matrix.\n    \n    Returns:\n    List[List[int]]: A new matrix with rows sorted by their sum in ascending order.\n    \n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Use sorted with a custom key to sort based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Compute sum for each row and pair with the row index\n    with_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort by sum, which will also maintain row order if sums are equal\n    with_sums.sort()\n    \n    # Reconstruct the matrix with sorted rows\n    sorted_matrix = [matrix[i] for _, i in with_sums]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 84.54268292682927, "dps_norm": 93.75, "pass@1": 80.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n    This function returns:\n    - True if the entire string consists of lowercase letters separated by underscores, \n      and no other characters are present.\n    - False otherwise, including if the string is empty or starts/ends with an underscore.\n\n    Parameters:\n    text (str): The string to check.\n\n    Returns:\n    bool: Whether the string format is correct.\n\n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"a_cbbbc_\")\n    False\n    >>> text_lowercase_underscore(\"A_cbbbc\")\n    False\n    >>> text_lowercase_underscore(\"a_cbbc_1\")\n    False\n    \"\"\"\n    # Regular expression to match a string starting with lowercase letters,\n    # followed by zero or more groups of underscore then lowercase letters,\n    # and not ending with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Check if the string contains sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    text (str): The string to check.\n    \n    Returns:\n    bool: True if the string matches the criteria, False otherwise.\n    \n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"Aab_Cbbbc\")\n    False\n    >>> text_lowercase_underscore(\"ab cd ef\")\n    False\n    \"\"\"\n    # The pattern matches one or more lowercase letters followed by zero or more \n    # groups of underscore and lowercase letters\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    match = re.match(pattern, text)\n    \n    # If there's a match, the string contains only sequences of lowercase letters \n    # separated by underscores\n    return match is not None", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    # Regular expression to match only lowercase letters and underscores\n    # ^ asserts position at start of a line\n    # [a-z]+ matches one or more lowercase letters\n    # (_[a-z]+)* matches zero or more sequences of underscore followed by lowercase letters\n    # $ asserts position at the end of a line\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    return bool(pattern.match(s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    # Define the regular expression pattern for lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Check if the entire string matches the pattern\n    match = re.match(pattern, text)\n    return match is not None", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Check if the input string consists of sequences of lowercase letters joined with an underscore.\n\n    Args:\n    text (str): The string to be checked.\n\n    Returns:\n    bool: True if the string contains only lowercase letters separated by underscores or is a single lowercase word, False otherwise.\n\n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"A_cbbbc\")\n    False\n    >>> text_lowercase_underscore(\"foo___bar\")\n    True\n    >>> text_lowercase_underscore(\"this_is_a_test\")\n    True\n    >>> text_lowercase_underscore(\"thisIsATest\")\n    False\n    >>> text_lowercase_underscore(\"\")\n    False\n    \"\"\"\n    # Regex pattern explanation:\n    # ^ - Start of string\n    # ([a-z]+_) - One or more lowercase letters followed by an underscore\n    # * - The previous group can appear zero or more times\n    # ([a-z]+)? - Optionally, one or more lowercase letters at the end\n    # $ - End of string\n    pattern = r'^(?:[a-z]+_)*[a-z]+$'\n    \n    # If the string matches the pattern or is an empty string, it's not valid according to our definition\n    # because the string must contain at least one lowercase letter sequence joined by an underscore.\n    if not text or re.match(pattern, text) is None:\n        return False\n    return True", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    # This regex pattern looks for:\n    # - Start of the string (^)\n    # - One or more lowercase letters ([a-z]+)\n    # - Optionally followed by one or more underscores followed by one or more lowercase letters (_[a-z]+)*\n    # - End of the string ($)\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    return bool(pattern.match(s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n    s (str): The string to check.\n\n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n\n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"Aab_cbbbc\")\n    False\n    >>> text_lowercase_underscore(\"a_c\")\n    True\n    >>> text_lowercase_underscore(\"a_bc_d\")\n    True\n    >>> text_lowercase_underscore(\"a_bc d\")\n    False\n    \"\"\"\n    # Regular expression pattern to match lowercase letters separated by underscores\n    # The pattern looks for:\n    # 1. One or more lowercase letters, \n    # 2. Optionally followed by underscore and another set of lowercase letters\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Check if the string consists of sequences of lowercase letters joined by underscores.\n\n    This function verifies that:\n    - The string contains only lowercase letters and underscores.\n    - There are no consecutive underscores.\n    - The string does not start or end with an underscore.\n\n    Args:\n    s (str): The string to be checked.\n\n    Returns:\n    bool: True if the string meets all criteria, False otherwise.\n\n    Examples:\n    >>> assert text_lowercase_underscore(\"aab_cbbbc\") == True\n    >>> assert text_lowercase_underscore(\"a_b_c\") == True\n    >>> assert text_lowercase_underscore(\"aa_bb_cc\") == True\n    >>> assert text_lowercase_underscore(\"aa_b_cc__d\") == False  # Consecutive underscores\n    >>> assert text_lowercase_underscore(\"Aa_bb\") == False  # Contains uppercase\n    >>> assert text_lowercase_underscore(\"_ab\") == False  # Starts with underscore\n    >>> assert text_lowercase_underscore(\"ab_\") == False  # Ends with underscore\n    >>> assert text_lowercase_underscore(\"\") == False  # Empty string\n    \"\"\"\n    # The regex checks:\n    # 1. Start of string (^)\n    # 2. One or more lowercase letters ([a-z]+)\n    # 3. Zero or one underscore (_?)\n    # 4. End of string ($) ensuring the string ends with letters not underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to ensure the whole string matches the pattern\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 6}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Check if the string contains only lowercase letters joined with underscores.\n    \n    This function verifies if all characters in the string are either:\n    - Lowercase letters [a-z]\n    - Underscores that separate lowercase sequences\n\n    Args:\n    s (str): The string to check.\n\n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n\n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"aB_cd\")\n    False\n    >>> text_lowercase_underscore(\"___\")\n    True\n    \"\"\"\n    # Check if the string is empty, which would not match the pattern\n    if not s:\n        return False\n    \n    # Use regex to match the pattern: \n    #  - Start with optional letters, followed by one or more letters with underscores separating them\n    #  - Ensure no uppercase letters are in the string\n    import re\n    pattern = r'^([a-z]+(_[a-z]+)*)?$'\n    if re.match(pattern, s):\n        return True\n    return False", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Determines if the input string contains only sequences of lowercase letters joined with an underscore.\n\n    Args:\n    s (str): The string to check.\n\n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n\n    Examples:\n    >>> assert text_lowercase_underscore(\"aab_cbbbc\") == True\n    >>> assert text_lowercase_underscore(\"aAb_cbbbc\") == False\n    >>> assert text_lowercase_underscore(\"aAb__cbbbc\") == False\n    >>> assert text_lowercase_underscore(\"aAb cbbbc\") == False\n    \"\"\"\n    # The pattern looks for:\n    # - One or more lowercase letters (\\w+)\n    # - Followed by an underscore followed by one or more lowercase letters, which can occur zero or more times\n    # - Optionally ending with an underscore and lowercase letters\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    if re.match(pattern, s):\n        return True\n    return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Determines if the string contains sequences of lowercase letters joined with an underscore.\n\n    This function checks if the entire string matches the following criteria:\n    - Consists only of sequences of lowercase letters separated by underscores.\n    - Does not start or end with an underscore.\n    - No consecutive underscores.\n\n    Args:\n        s (str): The input string to check.\n\n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n\n    Examples:\n        >>> text_lowercase_underscore(\"aab_cbbbc\")\n        True\n        >>> text_lowercase_underscore(\"a_b_c\")\n        True\n        >>> text_lowercase_underscore(\"aa_bb_cc_\")\n        False\n        >>> text_lowercase_underscore(\"A_b_c\")\n        False\n        >>> text_lowercase_underscore(\"a__b\")\n        False\n    \"\"\"\n    # Regex pattern to match strings like \"lowercase_lowercase_...\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Check if the given string consists only of lowercase letters possibly joined with underscores.\n\n    Args:\n    text (str): The string to check.\n\n    Returns:\n    bool: True if the string contains only lowercase letters and underscores, False otherwise.\n\n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"AaB_CBBbc\")\n    False\n    >>> text_lowercase_underscore(\"a_b_c_\")\n    True\n    >>> text_lowercase_underscore(\"a__b\")\n    True\n    \"\"\"\n    # Regular expression to match strings with only lowercase letters and underscores\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n    s (str): The input string to check.\n\n    Returns:\n    bool: True if the string consists only of lowercase letters and underscores separating words,\n          False otherwise.\n\n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"AAB_CBBBC\")\n    False\n    >>> text_lowercase_underscore(\"aab_cbbc_\")\n    False\n    >>> text_lowercase_underscore(\"abc_cde_fgh\")\n    True\n    \"\"\"\n    # The pattern matches:\n    # - One or more lowercase letters at the start (^), followed by an underscore\n    # - One or more lowercase letters between underscores\n    # - Ends with one or more lowercase letters ($)\n    pattern = r'^([a-z]+_)*[a-z]+$'\n    if not s:\n        return False  # Empty string does not meet the criteria\n    \n    # Use fullmatch to ensure the entire string matches the pattern\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Checks if the input string contains only sequences of lowercase letters joined with an underscore.\n\n    Args:\n        s (str): The string to check.\n\n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n\n    Examples:\n        >>> text_lowercase_underscore(\"aab_cbbbc\")\n        True\n        >>> text_lowercase_underscore(\"aab_Cbbbc\")\n        False\n        >>> text_lowercase_underscore(\"aaB_cbbbc\")\n        False\n        >>> text_lowercase_underscore(\"123\")\n        False\n    \"\"\"\n    # The pattern looks for:\n    # - Start of string (^)\n    # - One or more lowercase letters ([a-z]+) optionally followed by an underscore\n    # - End of string ($)\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Check if the string contains only sequences of lowercase letters joined with an underscore.\n\n    Args:\n    s (str): The string to check.\n\n    Returns:\n    bool: True if the string matches the described pattern, False otherwise.\n\n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"ABC\")\n    False\n    >>> text_lowercase_underscore(\"a_b_c\")\n    True\n    >>> text_lowercase_underscore(\"a_B_c\")\n    False\n    >>> text_lowercase_underscore(\"a__b\")\n    True\n    >>> text_lowercase_underscore(\"a\")\n    True\n    \"\"\"\n    # The regex pattern looks for:\n    # - Start of string (^)\n    # - One or more lowercase letters ([a-z]+) followed by \n    # - an underscore or the end of the string (_|$) repeatedly\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    # This pattern checks for:\n    # 1. Start of string (^)\n    # 2. One or more lowercase letters ([a-z]+)\n    # 3. Zero or more sequences of underscore followed by lowercase letters ((?:_[a-z]+)*)\n    # 4. End of string ($)\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Determine if the string consists of lowercase letters joined by underscores.\n\n    This function checks if:\n    - The string only contains lowercase letters and underscores.\n    - There is no leading or trailing underscore.\n\n    Args:\n        s (str): The string to check.\n\n    Returns:\n        bool: True if the string meets the criteria, False otherwise.\n\n    Examples:\n        >>> text_lowercase_underscore(\"aab_cbbbc\")\n        True\n        >>> text_lowercase_underscore(\"a_b_C\") \n        False\n        >>> text_lowercase_underscore(\"_abc\")\n        False\n    \"\"\"\n    # Check if the string starts or ends with an underscore\n    if s.startswith('_') or s.endswith('_'):\n        return False\n    \n    # Regular expression to match lowercase letters joined by underscores\n    # Here 'a' matches any lowercase letter, '_' matches underscore, and '^' and '$' ensure whole string match\n    pattern = r'^([a-z]+_)*[a-z]+$'\n    \n    # If the pattern matches the string, return True, otherwise False\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Determines if the string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n    s (str): The string to check.\n\n    Returns:\n    bool: True if the string matches the criteria, False otherwise.\n\n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"Aab_def_ghi\")\n    False\n    >>> text_lowercase_underscore(\"abc_def_Ghi\")\n    False\n    \"\"\"\n    # Check if the string contains only lowercase letters and underscores\n    if not s.replace('_', '').islower() or not s:\n        return False\n    \n    # Split the string by underscores and check each segment\n    segments = s.split('_')\n    \n    # Ensure that there are no empty segments after splitting\n    if '' in segments:\n        return False\n    \n    # All segments should be non-empty and consist of only lowercase letters\n    return all(segment.isalpha() and segment.islower() for segment in segments)", "matching_cluster_idx": 4}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if the given string consists only of sequences of lowercase letters\n    joined by underscores.\n\n    Args:\n    text (str): The string to be checked.\n\n    Returns:\n    bool: True if the string matches the specified pattern, False otherwise.\n\n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"Aab_Cbbbc\")\n    False\n    >>> text_lowercase_underscore(\"aab__cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"aa bc\")\n    False\n    \"\"\"\n    # The regex pattern:\n    # ^       - start of string\n    # [a-z]+  - one or more lowercase letters\n    # (_[a-z]+)* - zero or more occurrences of an underscore followed by lowercase letters\n    # $       - end of string\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Check if the input string contains only lowercase letters and underscores,\n    where underscores must join sequences of lowercase letters.\n\n    Args:\n    s (str): The input string to check.\n\n    Returns:\n    bool: True if the string meets the criteria, False otherwise.\n\n    Examples:\n    >>> assert text_lowercase_underscore(\"aab_cbbbc\") == True\n    >>> assert text_lowercase_underscore(\"aab_cbbbc_\") == False\n    >>> assert text_lowercase_underscore(\"Aab_cbbbc\") == False\n    \"\"\"\n    # The regex pattern:\n    # ^            - Start of string\n    # (?!\\d)       - Negative lookahead for digits (ensure no digits at start)\n    # [a-z]+       - One or more lowercase letters\n    # (?:          - Start of non-capturing group\n    #   _[a-z]+    - Underscore followed by one or more lowercase letters\n    # )*           - End of group, can appear zero or more times\n    # (?<!\\d)      - Negative lookbehind for digits (ensure no digits at end)\n    # $            - End of string\n    pattern = r'^(?!\\d)[a-z]+(?:_[a-z]+)*(?<!\\d)$'\n    \n    # If the string matches the pattern entirely, it's valid\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 6}]}, "Mbpp/19": {"dps": 72.02020202020202, "dps_norm": 84.66666666666667, "pass@1": 98.0, "profiled": [{"solution": "def test_duplicate(nums):\n    \"\"\"\n    Determine if there are any duplicate elements in the given list of integers.\n\n    Args:\n    nums (list of int): The list to check for duplicates.\n\n    Returns:\n    bool: True if there are any duplicates, False otherwise.\n\n    Example:\n    >>> test_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> test_duplicate([1, 2, 3, 4, 5, 1])\n    True\n    \"\"\"\n    # Convert the list to a set. If the length of the set is different from the list,\n    # then there are duplicates.\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determine if the given array contains any duplicate elements.\n\n    Args:\n    arr (list): A list of integers to check for duplicates.\n\n    Returns:\n    bool: True if the list contains any duplicate, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> test_duplicate([1, 2, 3, 3, 4])\n    True\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then compare lengths\n    if len(arr) != len(set(arr)):\n        return True\n    return False", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determine if the given array contains any duplicate elements.\n\n    Args:\n    arr (list of int): The list of integers to check for duplicates.\n\n    Returns:\n    bool: True if there are duplicates, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1,2,3,4,5])\n    False\n    >>> test_duplicate([1,2,3,4,4])\n    True\n    \"\"\"\n    # Convert the list to a set. If the lengths are not equal, there were duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determine if the given array contains any duplicate elements.\n\n    This function uses a set for efficient lookup to check for duplicates.\n\n    Args:\n    arr (list): A list of integers to check for duplicates.\n\n    Returns:\n    bool: True if there are any duplicates, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> test_duplicate([1, 1, 2, 3, 4])\n    True\n    \"\"\"\n    # Convert the list to a set. If lengths differ, there must be duplicates.\n    if len(arr) != len(set(arr)):\n        return True\n    return False", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if there are any duplicates in the given array.\n\n    Args:\n    arr (list): A list of integers to check for duplicates.\n\n    Returns:\n    bool: True if there are any duplicates, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1,2,3,4,5])\n    False\n    >>> test_duplicate([1,2,3,2,1])\n    True\n    \"\"\"\n    # Use a set to track elements we've seen\n    seen = set()\n    \n    for item in arr:\n        # If the item is already in the set, it's a duplicate\n        if item in seen:\n            return True\n        # Add the item to the set\n        seen.add(item)\n    \n    # If we've gone through all items without finding a duplicate, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determine if the array contains any duplicate elements.\n\n    Args:\n    arr (list of int): The list of integers to check for duplicates.\n\n    Returns:\n    bool: True if any duplicates are found, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> test_duplicate([1, 2, 2, 3, 4])\n    True\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # Then compare the length of the set with the original list\n    if len(set(arr)) < len(arr):\n        return True\n    return False", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determine if the array contains any duplicate integers.\n\n    Args:\n    arr (list): A list of integers to check for duplicates.\n\n    Returns:\n    bool: True if there are any duplicates, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> test_duplicate([1, 2, 2, 3, 4])\n    True\n    \"\"\"\n    # Using a set for O(n) time complexity to check for duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determine if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers to check for duplicates.\n    \n    Returns:\n    bool: True if there are any duplicates, False otherwise.\n    \n    Examples:\n    >>> test_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> test_duplicate([1, 2, 3, 3, 4])\n    True\n    \"\"\"\n    # Using a set to check for duplicates since set only keeps unique values\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if there are any duplicate elements in the given array.\n\n    Args:\n    arr (list): An array of integers to check for duplicates.\n\n    Returns:\n    bool: True if the array contains any duplicates, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1,2,3,4,5])\n    False\n    >>> test_duplicate([1,2,2,3,4])\n    True\n    \"\"\"\n    # Use a set to check for duplicates as sets in Python do not allow duplicates\n    seen = set()\n    for item in arr:\n        if item in seen:\n            return True\n        seen.add(item)\n    return False", "matching_cluster_idx": 14}, {"solution": "def contains_duplicate(arr):\n    \"\"\"\n    Determine if the array contains any duplicate elements.\n\n    Args:\n    arr (list): A list of integers to check for duplicates.\n\n    Returns:\n    bool: True if any element appears more than once, False otherwise.\n\n    Examples:\n    >>> contains_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> contains_duplicate([1, 2, 3, 4, 4])\n    True\n    \"\"\"\n    # Use a set for O(1) lookup time\n    seen = set()\n    for num in arr:\n        # If the number is already in the set, we have a duplicate\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\ndef test_duplicate(arr):\n    \"\"\"\n    Test function to check for duplicates using the contains_duplicate function.\n\n    Args:\n    arr (list): List of integers to test.\n\n    Returns:\n    bool: Result from contains_duplicate function.\n\n    >>> assert test_duplicate([1, 2, 3, 4, 5]) == False\n    \"\"\"\n    return contains_duplicate(arr)", "matching_cluster_idx": 13}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determine if the given array contains any duplicate elements.\n\n    This function iterates through the array and uses a set for O(1) \n    lookup to check if an element has already been encountered.\n\n    Args:\n    arr (list): The list of integers to check for duplicates.\n\n    Returns:\n    bool: True if there is any duplicate, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> test_duplicate([1, 2, 3, 2, 1])\n    True\n    \"\"\"\n    # Set to keep track of numbers we've seen\n    seen = set()\n    \n    for num in arr:\n        # If the number is already in our set, we've found a duplicate\n        if num in seen:\n            return True\n        # Add the number to the set\n        seen.add(num)\n    \n    # If we've gone through all numbers without finding a duplicate\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers to check for duplicates.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \n    Examples:\n    >>> test_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> test_duplicate([1, 2, 3, 3, 5])\n    True\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # If the length of the set is less than the original list, there were duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determine if the given array contains any duplicate elements.\n\n    Args:\n    arr (list): A list of integers to check for duplicates.\n\n    Returns:\n    bool: True if the list contains any duplicate, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1,2,3,4,5])\n    False\n    >>> test_duplicate([1,2,3,4,4])\n    True\n    \"\"\"\n    # Convert the list to a set to remove all duplicates. \n    # If the length changes, there was at least one duplicate\n    return len(set(arr)) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if the given array contains any duplicate elements.\n\n    Args:\n    arr (list of int): The list of integers to check for duplicates.\n\n    Returns:\n    bool: True if the array contains duplicates, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> test_duplicate([1, 2, 3, 4, 4])\n    True\n    \"\"\"\n    # Using set to remove all duplicates, then compare length\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if the given array contains any duplicate elements.\n\n    Args:\n    arr (list): A list of integers to check for duplicates.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1,2,3,4,5])\n    False\n    >>> test_duplicate([1,1,2,3,4])\n    True\n    \"\"\"\n    # Use set to compare length. If a duplicate exists, the length of set will be less than the array's length.\n    if len(arr) != len(set(arr)):\n        return True\n    return False", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determine if the array contains any duplicate element.\n\n    Parameters:\n    arr (list): A list of integers to check for duplicates.\n\n    Returns:\n    bool: True if there are duplicates, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> test_duplicate([1, 2, 2, 3, 4])\n    True\n    \"\"\"\n    # Convert the list to a set to remove duplicates and compare lengths\n    if len(arr) != len(set(arr)):\n        return True\n    return False", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determine if the given array contains any duplicate elements.\n    \n    This function uses a set for O(n) time complexity to check for duplicates.\n    \n    Args:\n    arr (list): A list of integers to check for duplicates.\n\n    Returns:\n    bool: True if there are any duplicate elements, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> test_duplicate([1, 2, 3, 4, 4])\n    True\n    \"\"\"\n    # If the length of the set of the array is not equal to the length of the original array,\n    # then there must be duplicates since sets don't allow duplicate elements.\n    if len(arr) != len(set(arr)):\n        return True\n    return False", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n\n    This function uses a set to check for duplicates, which provides O(n) time complexity.\n\n    Args:\n    arr (list): An array of integers to check for duplicates.\n\n    Returns:\n    bool: True if there are duplicates, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1,2,3,4,5])\n    False\n    >>> test_duplicate([1,1,2,3,4,5])\n    True\n    \"\"\"\n    # Convert list to set, if length changes, we have duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determine if the given array contains any duplicate elements.\n\n    Args:\n    arr (list): A list of integers to check for duplicates.\n\n    Returns:\n    bool: True if there are any duplicates in the array, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1,2,3,4,5])\n    False\n    >>> test_duplicate([1,2,3,4,4])\n    True\n    \"\"\"\n    # Convert the array to a set. If the lengths are different, there were duplicates.\n    return len(set(arr)) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if the array contains any duplicate integers.\n\n    Args:\n    arr (list): A list of integers to check for duplicates.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> test_duplicate([1, 2, 2, 3])\n    True\n    \"\"\"\n    # Convert the list to a set. If the length differs, duplicates exist\n    if len(arr) != len(set(arr)):\n        return True\n    return False", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 70.65384615384616, "dps_norm": 78.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a given list of numbers.\n\n    This function iterates through the list and returns the minimum value.\n    If the list is empty, it returns None.\n\n    Args:\n        numbers (list): A list containing numeric values.\n\n    Returns:\n        int or float or None: The smallest number in the list, or None if the list is empty.\n\n    Examples:\n        >>> smallest_num([10, 20, 1, 45, 99])\n        1\n    \"\"\"\n    if not numbers:\n        return None\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in the given list.\n\n    This function assumes the list contains at least one number and all\n    elements are comparable numbers. If the list is empty, it will raise\n    a ValueError.\n\n    Args:\n    numbers (list): A list of numbers to search through.\n\n    Returns:\n    The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in the given list.\n\n    Parameters:\n    numbers (list): A list of numbers to search through.\n\n    Returns:\n    int or float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    >>> smallest_num([-5, 0, 5, -10, -15])\n    -15\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Use Python's built-in min function to find the smallest number\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list of numbers.\n\n    Args:\n    numbers (list): A list of integers where the smallest number is to be found.\n\n    Returns:\n    int: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    >>> smallest_num([-10, 20, -5])\n    -10\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Start with the first number as the smallest, then compare\n    smallest = numbers[0]\n    for num in numbers[1:]:\n        if num < smallest:\n            smallest = num\n            \n    return smallest", "matching_cluster_idx": 2}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in the given list.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Example:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    \"\"\"\n    # Check if the list is not empty to avoid IndexError\n    if not numbers:\n        raise ValueError(\"The list cannot be empty\")\n    \n    # Initialize smallest with the first element or infinity for non-empty lists\n    smallest = min(numbers)\n    \n    # This isn't necessary for the Python `min()` function but included for clarity\n    for number in numbers:\n        if number < smallest:\n            smallest = number\n            \n    return smallest", "matching_cluster_idx": 1}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a given list of numbers.\n    \n    Args:\n    numbers (list): A list of numbers to search through.\n    \n    Returns:\n    int or float: The smallest number found in the list.\n    \n    Raises:\n    ValueError: If the list is empty or contains non-numeric values.\n    \n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    >>> smallest_num([-1, -5, 0, 3.5])\n    -5\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Initialize smallest with the first number or check for non-numeric values\n    smallest = None\n    for num in numbers:\n        if smallest is None:\n            if not isinstance(num, (int, float)):\n                raise ValueError(\"The list must only contain numeric values.\")\n            smallest = num\n        else:\n            # Compare with the current smallest\n            if not isinstance(num, (int, float)):\n                raise ValueError(\"The list must only contain numeric values.\")\n            if num < smallest:\n                smallest = num\n    \n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in the provided list.\n    \n    This function takes a list of numbers and returns the smallest number in that list.\n    If the list is empty, it raises a ValueError since there's no smallest number in an empty list.\n    \n    Args:\n    numbers (list): A list of numbers to search through.\n    \n    Returns:\n    number: The smallest number found in the list.\n    \n    Raises:\n    ValueError: If the list provided is empty.\n    \n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    >>> smallest_num([-5, -2, -1])\n    -5\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty; no smallest number can be determined.\")\n    # Python's built-in min() function is efficient for this purpose\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list of numbers.\n    \n    Args:\n    numbers (list): A list of numbers from which to find the smallest number.\n    \n    Returns:\n    int or float: The smallest number in the list.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \n    Example:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Start with the first element as the smallest\n    smallest = numbers[0]\n    \n    # Iterate through the list to find a smaller number\n    for num in numbers[1:]:\n        if num < smallest:\n            smallest = num\n            \n    return smallest", "matching_cluster_idx": 2}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a given list of numbers.\n\n    Parameters:\n    numbers (list): A list of numbers to search through.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty\")\n    \n    # Using min function which is efficient for finding the smallest number\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in the given list of numbers.\n\n    Args:\n    numbers (list): A list of integers or float numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    TypeError: If any element in the list is not a number.\n\n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    >>> smallest_num([-5, -2, -9, 1])\n    -9\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Verify all elements are numbers\n    if not all(isinstance(n, (int, float)) for n in numbers):\n        raise TypeError(\"All elements in the list must be numbers.\")\n    \n    # Use the built-in min function to find the smallest number\n    return min(numbers)", "matching_cluster_idx": 0}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a given list of numbers.\n\n    Args:\n    numbers (list): A list containing integers.\n\n    Returns:\n    int: The smallest number found in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    >>> smallest_num([-5, -2, 0, 1])\n    -5\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Initialize with the first element for efficiency, or use min() function\n    # smallest = numbers[0] for iterating method\n    # Here we use min() for simplicity and efficiency:\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in the provided list.\n\n    Args:\n    numbers (list of int): A list containing integers.\n\n    Returns:\n    int: The smallest number in the list. If the list is empty, it returns None.\n\n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    >>> smallest_num([])\n    None\n    \"\"\"\n    # Check if the list is not empty to avoid errors\n    if numbers:\n        return min(numbers)\n    else:\n        return None", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in the given list.\n\n    Args:\n    numbers (list): A list of numbers to search through.\n\n    Returns:\n    int or float: The smallest number found in the list.\n\n    Raises:\n    ValueError: If the list is empty or if it contains non-numeric values.\n\n    Example:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n\n    # Initialize the smallest with the first element or use float('inf') if you want to support an empty list\n    smallest = numbers[0]\n    \n    # Iterate over each number in the list\n    for num in numbers:\n        # Check if the current number is smaller than the smallest seen so far\n        if num < smallest:\n            smallest = num\n    \n    # Return the smallest number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list of numbers.\n\n    This function takes a list of numbers and returns the smallest one. \n    It assumes that the list contains at least one number.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    number: The smallest number from the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    >>> smallest_num([3, -5, 0, 1])\n    -5\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Use Python's built-in min function to find the smallest number\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in the given list.\n\n    :param numbers: List[int] - A list of integers\n    :return: int - The smallest number from the list\n    :raises ValueError: If the list is empty\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a given list of numbers.\n    \n    Args:\n    numbers (list): A list of numbers to search through.\n    \n    Returns:\n    int or float: The smallest number in the list.\n    \n    Raises:\n    ValueError: If the list is empty.\n    \n    Example:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty\")\n    \n    # Use Python's built-in min function to find the smallest number\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in the given list.\n\n    Args:\n    numbers (list): A list of numbers where we need to find the smallest.\n\n    Returns:\n    int or float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Example:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Return the minimum number using Python's built-in min function\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a given list of numbers.\n\n    Args:\n    numbers (list): A list of numbers where the smallest is to be found.\n\n    Returns:\n    int or float: The smallest number in the list. If the list is empty,\n    it raises an IndexError.\n\n    Raises:\n    TypeError: If the list contains non-numeric types.\n\n    Example:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    \"\"\"\n    if not numbers:\n        raise IndexError(\"The list is empty\")\n    \n    # Convert all items to float for type consistency and find min\n    try:\n        return min(float(num) for num in numbers)\n    except ValueError:\n        raise TypeError(\"All elements in the list must be numeric\")", "matching_cluster_idx": 0}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a given list of numbers.\n\n    Args:\n    numbers (list): A list containing numeric elements.\n\n    Returns:\n    The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Use Python's built-in min function which finds the minimum element in an iterable\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a given list.\n\n    This function iterates through the list to determine\n    the smallest value present.\n\n    Args:\n    numbers (list of int or float): A list containing numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Example:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty\")\n    \n    # Initialize smallest with the first element or positive infinity\n    smallest = min(numbers[0], float('inf'))\n    \n    # Iterate over each number in the list\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    \n    return smallest", "matching_cluster_idx": 3}]}, "Mbpp/75": {"dps": 93.21428571428572, "dps_norm": 68.33333333333334, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples from the list where all elements are divisible by k.\n\n    Args:\n    tuple_list (List[Tuple[int]]): A list of tuples containing integers.\n    k (int): The number by which all elements should be divisible.\n\n    Returns:\n    List[Tuple[int]]: A list of tuples where each element is divisible by k.\n\n    Examples:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Use a list comprehension to check divisibility for all elements in each tuple\n    return [t for t in tuple_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples from the given list where all elements are divisible by k.\n\n    Args:\n    tuples_list (List[Tuple[int, ...]]): A list of tuples containing integers.\n    k (int): The divisor to check against.\n\n    Returns:\n    List[Tuple[int, ...]]: A list of tuples where all numbers are divisible by k.\n\n    Example:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Use list comprehension to filter tuples where every element is divisible by k\n    return [t for t in tuples_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples from the given list where all elements are divisible by k.\n\n    Args:\n    tuples_list (List[Tuple[int]]): A list of tuples containing integers.\n    k (int): The divisor to check for divisibility.\n\n    Returns:\n    List[Tuple[int]]: List of tuples where all elements are divisible by k.\n\n    Example:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Use list comprehension to filter tuples\n    result = [t for t in tuples_list if all(elem % k == 0 for elem in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    tuple_list (list of tuple): A list of tuples where each tuple contains integers.\n    k (int): The integer by which all elements in a tuple must be divisible.\n\n    Returns:\n    list of tuple: A list of tuples where each element in the tuple is divisible by k.\n\n    Example:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # List comprehension to filter tuples where all elements are divisible by k\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples where all elements are divisible by k.\n\n    Args:\n    tuples_list (list): A list of tuples containing integers.\n    k (int): The number by which all elements of a tuple should be divisible.\n\n    Returns:\n    list: A list of tuples from tuples_list where every element is divisible by k.\n\n    Examples:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Use list comprehension to filter tuples based on the condition\n    return [t for t in tuples_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples from a list where all elements are divisible by k.\n    \n    Args:\n    tuples_list (list of tuple): A list of tuples to check.\n    k (int): The divisor to check divisibility against.\n\n    Returns:\n    list of tuple: A list containing tuples whose all elements are divisible by k.\n\n    Examples:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Use a list comprehension to filter tuples where all elements are divisible by k\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples in which all elements are divisible by k.\n\n    Args:\n    tuples_list (list of tuple): A list of tuples where each tuple contains integers.\n    k (int): The divisor to check divisibility against.\n\n    Returns:\n    list of tuple: A list containing tuples where all elements are divisible by k.\n\n    Example:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Filter tuples where every number is divisible by k\n    result = [t for t in tuples_list if all(num % k == 0 for num in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples where all elements are divisible by k.\n\n    Args:\n    tuples_list (List[Tuple[int, ...]]): A list of tuples containing integers.\n    k (int): The divisor to check for divisibility.\n\n    Returns:\n    List[Tuple[int, ...]]: A list of tuples where every element in each tuple \n                           is divisible by k.\n\n    Examples:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Filter tuples where all elements are divisible by k\n    result = [tup for tup in tuples_list if all(elem % k == 0 for elem in tup)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples from the list where all elements are divisible by k.\n    \n    Args:\n    tuples_list (list of tuple): A list containing tuples of numbers.\n    k (int): The divisor to check against.\n\n    Returns:\n    list: A list of tuples where all elements are divisible by k.\n    \n    Example:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Use list comprehension to filter tuples\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples from the given list where all elements are divisible by k.\n\n    Args:\n    tuples_list (list of tuple): A list of tuples containing numbers.\n    k (int): The number to check divisibility against.\n\n    Returns:\n    list of tuple: A list containing tuples where all elements are divisible by k.\n\n    Examples:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Use list comprehension to find tuples where all elements are divisible by k\n    return [t for t in tuples_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    tuples_list (list of tuple): A list where each item is a tuple.\n    k (int): The divisor to check divisibility.\n\n    Returns:\n    list of tuple: Tuples where all elements are divisible by k.\n\n    Example:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Use list comprehension to filter tuples\n    return [t for t in tuples_list if all(num % k == 0 for num in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k.\n\n    :param tuples_list: List of tuples to check.\n    :param k: The divisor to check divisibility with.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    # Use a list comprehension to filter tuples where all elements are divisible by k\n    return [t for t in tuples_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples from the given list where all elements are divisible by k.\n    \n    Args:\n    tuples_list (List[Tuple[int, ...]]): A list of tuples containing integers.\n    k (int): The number to check divisibility with.\n    \n    Returns:\n    List[Tuple[int, ...]]: A list of tuples where each element in each tuple is divisible by k.\n\n    Example:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Use list comprehension to filter tuples where all elements are divisible by k\n    return [t for t in tuples_list if all(num % k == 0 for num in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples from the given list where all elements are divisible by k.\n\n    Parameters:\n    - tuples_list: List of tuples to check.\n    - k: Integer by which each element in the tuples must be divisible.\n\n    Returns:\n    - List of tuples where all elements are divisible by k.\n\n    Example:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Use a list comprehension to filter tuples\n    return [t for t in tuples_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples where all elements are divisible by k.\n\n    Args:\n    tuples_list (List[Tuple[int, ...]]): A list of tuples containing integers.\n    k (int): The divisor to check divisibility against.\n\n    Returns:\n    List[Tuple[int, ...]]: List of tuples where all elements are divisible by k.\n\n    Example:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Use list comprehension to filter tuples\n    return [t for t in tuples_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k.\n\n    Args:\n    tuples_list (list of tuples): A list containing tuples of integers.\n    k (int): The number to check divisibility against.\n\n    Returns:\n    list of tuples: A list of tuples where all elements are divisible by k.\n\n    Example:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    # Initialize an empty list to hold the result\n    result = []\n    \n    # Iterate over each tuple in the provided list\n    for tup in tuples_list:\n        # Assume the tuple meets the criteria until proven otherwise\n        all_divisible = True\n        # Check each element in the tuple\n        for item in tup:\n            # If any element is not divisible by k, set all_divisible to False\n            if item % k != 0:\n                all_divisible = False\n                break  # No need to check further if one element fails\n        # If all elements were divisible by k, add the tuple to the result\n        if all_divisible:\n            result.append(tup)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples from the list where all elements are divisible by k.\n\n    :param tuples_list: List of tuples to check.\n    :param k: The divisor to check divisibility with.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for current_tuple in tuples_list:\n        # Check if every number in the tuple is divisible by k\n        if all(num % k == 0 for num in current_tuple):\n            result.append(current_tuple)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples from the list where all elements are divisible by k.\n\n    Args:\n    tuples_list (list of tuple): List of tuples to check.\n    k (int): The number to check divisibility by.\n\n    Returns:\n    list of tuple: Tuples where every element is divisible by k.\n\n    Examples:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples from a list where all elements are divisible by k.\n\n    Parameters:\n    tuples_list (list of tuple): List of tuples to check.\n    k (int): The divisor to check divisibility against.\n\n    Returns:\n    list of tuple: List of tuples where all elements are divisible by k.\n    \"\"\"\n    # Use list comprehension to filter tuples based on the condition\n    return [t for t in tuples_list if all(num % k == 0 for num in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples from the given list where all elements are divisible by k.\n\n    :param tuples_list: List of tuples to check.\n    :param k: The number all tuple elements must be divisible by.\n    :return: List of tuples where each element is divisible by k.\n\n    :Example:\n    >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n    [(6, 24, 12)]\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        # Check if every number in the tuple is divisible by k\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 83.50490196078431, "dps_norm": 84.28571428571428, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    \"\"\"\n    Calculates the frequency of each element in the given list.\n    \n    Args:\n    lst (list): A list of hashable elements where frequency needs to be calculated.\n\n    Returns:\n    dict: A dictionary where keys are the list elements and values are their frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to hold the frequency counts\n    frequency = {}\n    \n    # Iterate over each item in the list\n    for item in lst:\n        # If the item exists in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            frequency[item] = 1\n            \n    return frequency", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(lst):\n    \"\"\"\n    Calculate the frequency of elements in a list.\n\n    This function takes a list and returns a dictionary where the keys are the unique\n    elements from the list, and the values are the number of times each element appears.\n\n    Args:\n    lst (list): A list of elements to count.\n\n    Returns:\n    dict: A dictionary representing the frequency count of elements.\n\n    Example:\n    >>> freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Use Counter from collections to count occurrences of each item in the list\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Calculate the frequency of elements in the given list.\n\n    This function takes a list of elements and returns a dictionary where\n    keys are unique elements from the list and values are the count of\n    occurrences of each element.\n\n    Args:\n    lst (list): A list containing hashable elements.\n\n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n\n    Example:\n    >>> freq_count([10, 10, 10, 20, 30, 30])\n    {10: 3, 20: 1, 30: 2}\n    \"\"\"\n    # Initialize an empty dictionary to store frequencies\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        if item in frequency:\n            # If the item is already in the dictionary, increment its count\n            frequency[item] += 1\n        else:\n            # Otherwise, add the item to the dictionary with an initial count of 1\n            frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Calculate the frequency of elements in a list.\n\n    This function takes a list of elements and returns a dictionary where\n    the keys are the unique elements from the list, and the values are \n    the count of occurrences for each element.\n\n    Args:\n    lst (list): A list containing hashable items whose frequency needs to be calculated.\n\n    Returns:\n    dict: A dictionary with elements as keys and their frequency as values.\n\n    Example:\n    >>> freq_count([1, 2, 2, 3, 3, 3, 4])\n    {1: 1, 2: 2, 3: 3, 4: 1}\n    \"\"\"\n    # Initialize an empty dictionary to store frequency\n    frequency_dict = {}\n    \n    # Loop through each item in the list\n    for item in lst:\n        if item in frequency_dict:\n            # If the item exists, increment its count\n            frequency_dict[item] += 1\n        else:\n            # If the item is new, add it to the dictionary with a count of 1\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(elements):\n    \"\"\"\n    Returns a dictionary where keys are unique elements from the input list\n    and values are the frequency of those elements in the list.\n\n    Args:\n    elements (list): A list of elements whose frequency is to be calculated.\n\n    Returns:\n    dict: A dictionary containing the count of each unique element.\n\n    Example:\n    >>> freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Initialize an empty dictionary to store the count of each element\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for item in elements:\n        # If the item is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # Otherwise, add the item to the dictionary with a count of 1\n        else:\n            frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(elements):\n    \"\"\"\n    Calculate the frequency of elements in the provided list.\n\n    This function takes a list of elements and returns a dictionary where\n    keys are the unique elements from the list and values are their counts.\n\n    Args:\n    elements (list): A list of hashable elements to count.\n\n    Returns:\n    dict: A dictionary representing the frequency count of each element.\n\n    Examples:\n    >>> freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Initialize an empty dictionary to keep track of counts\n    frequency = {}\n    \n    # Iterate through each element in the list\n    for element in elements:\n        # If the element exists in the dictionary, increment its count,\n        # otherwise, add it with a count of 1\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    \n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(elements):\n    \"\"\"\n    Function to calculate the frequency of each unique element in a list.\n    \n    Args:\n    elements (list): A list of elements to count the frequency from.\n\n    Returns:\n    dict: A dictionary where keys are unique elements and values are their frequencies.\n    \n    Example:\n    >>> freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Initialize an empty dictionary to hold the frequency counts\n    frequency_dict = {}\n\n    # Count each element in the list\n    for element in elements:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(elements):\n    \"\"\"\n    This function takes a list of elements and returns a dictionary\n    where the keys are unique elements from the list and values are their frequencies.\n\n    :param elements: List of elements whose frequency needs to be counted\n    :type elements: list\n    :return: Dictionary containing frequencies of elements\n    :rtype: dict\n    \"\"\"\n    # Use a dictionary to keep count of each element\n    frequency = {}\n    \n    for item in elements:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(lst):\n    \"\"\"\n    Function to calculate the frequency of elements in a list.\n\n    This function uses Counter from collections to count occurrences\n    of each element in the provided list, then returns this count\n    as a dictionary.\n\n    Args:\n    lst (list): A list of elements whose frequencies are to be counted.\n\n    Returns:\n    dict: A dictionary where keys are unique elements from lst, and values \n          are the number of times each element appears in lst.\n\n    Example:\n    >>> freq_count([10, 10, 10, 20, 20, 30])\n    {10: 3, 20: 2, 30: 1}\n    \"\"\"\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the input list.\n\n    Args:\n    lst (list): A list of elements to count frequency for.\n\n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n\n    Example:\n    >>> freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Use Counter from collections which is a dict subclass for counting hashable objects\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(elements):\n    \"\"\"\n    Returns a dictionary where keys are the elements from the input list\n    and values are their respective frequencies.\n\n    Args:\n    elements (list): A list of elements to count.\n\n    Returns:\n    dict: A dictionary with elements as keys and their count as values.\n\n    Examples:\n    >>> freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate over each element in the list\n    for element in elements:\n        # If the element is already a key in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            frequency_dict[element] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(elements):\n    \"\"\"\n    Calculate the frequency of elements in the given list.\n\n    Args:\n    elements (list): A list of hashable elements.\n\n    Returns:\n    dict: A dictionary where keys are the unique elements from the list,\n          and values are their respective frequencies.\n\n    Example:\n    >>> freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Use Counter from collections to efficiently count occurrences\n    return dict(Counter(elements))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Calculate the frequency of each element in the given list.\n\n    Args:\n    lst (list): A list of elements to count frequencies.\n\n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their respective counts.\n\n    Example:\n    >>> freq_count([10, 10, 10, 20, 20, 30])\n    {10: 3, 20: 2, 30: 1}\n    \"\"\"\n    # Initialize an empty dictionary to keep track of frequencies\n    frequency_dict = {}\n    \n    # Iterate over each item in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        # Otherwise, add the item with a count of 1\n        frequency_dict[item] = frequency_dict.get(item, 0) + 1\n    \n    return frequency_dict", "matching_cluster_idx": 4}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Function to count the frequency of elements in the given list.\n    \n    Parameters:\n    input_list (list): A list containing elements to be counted.\n    \n    Returns:\n    dict: A dictionary where keys are the unique elements of the list \n          and values are their frequencies.\n\n    Example:\n    >>> freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Using a dictionary comprehension to count the frequency of each element\n    return {item: input_list.count(item) for item in set(input_list)}", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Calculate the frequency of all elements in the given list.\n    \n    Args:\n    lst (list): A list of elements to count the frequency from.\n    \n    Returns:\n    dict: A dictionary where keys are unique elements from the list and values are their frequencies.\n\n    Example:\n    >>> freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Initialize an empty dictionary to keep count of each element\n    frequency = {}\n    \n    # Loop through each element in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        # If not, initialize the count to 1\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Calculate the frequency of each element in the given list.\n    \n    Parameters:\n    lst (list): A list of elements to count frequencies for.\n    \n    Returns:\n    dict: A dictionary where keys are the unique elements of lst and values are their frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to hold the frequencies\n    frequency = {}\n    \n    # Count the frequency of each element in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculate the frequency of each element in the given list.\n\n    Args:\n    input_list (list): A list containing hashable elements.\n\n    Returns:\n    dict: A dictionary where keys are the unique elements from the list\n          and values are their frequencies.\n\n    Example:\n    >>> freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Initialize an empty dictionary to store the frequency\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for item in input_list:\n        # If the item is already in the dictionary, increment its count\n        # Otherwise, add it to the dictionary with a count of 1\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Function to get the frequency of all elements in a list.\n\n    Args:\n    lst (list): The list whose elements' frequencies are to be counted.\n\n    Returns:\n    dict: A dictionary where keys are unique elements from the list and values are their frequencies.\n\n    Examples:\n    >>> freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Initialize an empty dictionary to hold the frequency count\n    freq_dict = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            # If it's not in the dictionary, add it with a count of 1\n            freq_dict[item] = 1\n    \n    # Return the frequency dictionary\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Calculate the frequency of each element in the given list.\n\n    Args:\n    lst (list): A list of elements to count frequencies for.\n\n    Returns:\n    dict: A dictionary where keys are unique elements from lst and values are their respective counts.\n\n    Example:\n    >>> freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Initialize an empty dictionary to hold frequencies\n    frequency_dict = {}\n\n    # Loop over each item in the list\n    for item in lst:\n        # If the item exists in the dictionary, increment its count\n        # If it does not exist, set its count to 1\n        frequency_dict[item] = frequency_dict.get(item, 0) + 1\n\n    return frequency_dict", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Calculate the frequency of each element in the given list.\n\n    Args:\n    lst (list): A list containing hashable elements.\n\n    Returns:\n    dict: A dictionary where keys are unique elements from the list\n          and values are their frequencies.\n\n    Examples:\n    >>> freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Initialize an empty dictionary to store frequencies\n    frequency = {}\n    \n    # Iterate over each item in the list\n    for item in lst:\n        # If the item exists in the dictionary, increment its count\n        # If not, set its count to 1\n        frequency[item] = frequency.get(item, 0) + 1\n    \n    return frequency", "matching_cluster_idx": 4}]}, "Mbpp/90": {"dps": 86.6829268292683, "dps_norm": 90.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list of words.\n\n    Args:\n    words (list): A list of strings where each string is a word.\n\n    Returns:\n    int: The length of the longest word.\n\n    Example:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    \"\"\"\n    # Use max with a key function to find the word with the maximum length, then return its length\n    if not words:  # Check if the list is empty\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list of words.\n\n    Args:\n    words (list of str): A list of words where each word is a string.\n\n    Returns:\n    int: The length of the longest word.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    >>> len_log([\"this\", \"is\", \"a\", \"test\"]) \n    4\n    \"\"\"\n    if not words:\n        raise ValueError(\"The list of words cannot be empty.\")\n\n    # Find the word with maximum length\n    max_length = max(len(word) for word in words)\n    \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    This function finds the length of the longest word in the given list.\n\n    Parameters:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word in the list.\n\n    Example:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    \"\"\"\n    if not words:  # If the list is empty, return 0\n        return 0\n    \n    # Use max with a key function that returns the length of each word\n    longest_word = max(words, key=len)\n    \n    return len(longest_word)", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the list.\n\n    Args:\n    words (list of str): A list of words to check.\n\n    Returns:\n    int: The length of the longest word.\n\n    Example:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    \"\"\"\n    # Check if the list is empty to avoid errors\n    if not words:\n        return 0\n    \n    # Use max with a key function that returns the length of each word\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the list.\n\n    Args:\n    words (list): A list of strings where each string is a word.\n\n    Returns:\n    int: The length of the longest word.\n\n    Example:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    \"\"\"\n    # Check if the list is empty\n    if not words:\n        return 0\n    \n    # Use max with key function to find the longest word's length\n    # The key function provides the length of each word to max()\n    longest_length = max(len(word) for word in words)\n    \n    return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n\n    Parameters:\n    - words (list of str): A list of strings where each string is a word.\n\n    Returns:\n    - int: The length of the longest word.\n\n    Example:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    \"\"\"\n    # Use max() with a key function to find the longest word by its length\n    if not words:\n        return 0  # Return 0 if the list is empty, otherwise max() would raise an error\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list of strings.\n\n    Args:\n    words (list): A list of strings.\n\n    Returns:\n    int: The length of the longest word.\n\n    Example:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    \"\"\"\n    # Check if the list is empty\n    if not words:\n        return 0\n    \n    # Find the maximum length using a list comprehension\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    Args:\n    words (list): A list of strings where each string is a word.\n\n    Returns:\n    int: The length of the longest word.\n\n    Examples:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    >>> len_log([\"a\", \"ab\", \"abc\"])\n    3\n    \"\"\"\n    # Check if the list is not empty to avoid errors\n    if not words:\n        return 0\n    \n    # Find the longest word using max() with key function \n    # that returns the length of the word\n    longest_word = max(words, key=len)\n    \n    # Return the length of the longest word\n    return len(longest_word)", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list of words.\n\n    Args:\n    words (list of str): A list of words to check.\n\n    Returns:\n    int: The length of the longest word.\n\n    Examples:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    \"\"\"\n    # Check if the list is not empty to avoid errors\n    if not words:\n        return 0\n    \n    # Find the length of the longest word using max with key function\n    longest_length = max(len(word) for word in words)\n    return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list of words.\n\n    Args:\n    words (list of str): A list of words to search through.\n\n    Returns:\n    int: The length of the longest word.\n\n    Example:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    \"\"\"\n    # Check if the list is empty to avoid errors\n    if not words:\n        return 0\n    \n    # Return the length of the longest word by using max with a key function that returns the length of each word\n    return len(max(words, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the list.\n\n    Args:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word.\n\n    Example:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    \"\"\"\n    # Check if the list is not empty, to avoid errors with max function on empty list\n    if not words:\n        return 0\n    \n    # Use max() with a key function to find the longest word by length\n    max_length = max(len(word) for word in words)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    This function iterates over each word in the list, compares the length\n    of each word, and returns the length of the longest one.\n\n    Args:\n    words (list of str): A list of words to search through.\n\n    Returns:\n    int: The length of the longest word found in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> len_log([\"python\",\"PHP\",\"bigdata\"])\n    7\n    >>> len_log([\"a\",\"b\",\"cd\"])\n    2\n    \"\"\"\n    # Check if the list is empty\n    if not words:\n        raise ValueError(\"The list of words cannot be empty.\")\n    \n    # Use max with a key function to find the word with maximum length, \n    # then return its length\n    return len(max(words, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n\n    This function iterates over each word in the provided list, calculates\n    its length, and keeps track of the maximum length found.\n\n    Args:\n    words (list of str): A list containing words to analyze.\n\n    Returns:\n    int: The length of the longest word in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    >>> len_log([\"a\", \"bb\", \"ccc\"])\n    3\n    \"\"\"\n    if not words:\n        raise ValueError(\"The list of words cannot be empty.\")\n    \n    # Use max with a key function to find the longest word's length\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n\n    This function iterates through a list of words, measures their length,\n    and returns the length of the longest word found.\n\n    Args:\n    words (list of str): A list of words to check.\n\n    Returns:\n    int: The length of the longest word.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    >>> len_log([\"a\", \"ab\", \"abc\"])\n    3\n    \"\"\"\n    if not words:\n        raise ValueError(\"The list of words cannot be empty.\")\n    \n    # Use max with a key function to find the word with the maximum length\n    max_length = max(len(word) for word in words)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n\n    Args:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word.\n\n    Examples:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    \"\"\"\n    # Use a generator expression to find the maximum length of words\n    if not words:\n        return 0\n    \n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list of words.\n\n    Args:\n    words (list of str): A list containing words.\n\n    Returns:\n    int: The length of the longest word.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    \"\"\"\n    # Check if the list is empty\n    if not words:\n        raise ValueError(\"The list of words cannot be empty\")\n    \n    # Find the maximum length using a generator expression for efficiency\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n\n    Parameters:\n    words (list of str): A list of words to check.\n\n    Returns:\n    int: The length of the longest word in the list.\n\n    Examples:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    >>> len_log([\"data\", \"science\", \"machine\"])\n    7\n    \"\"\"\n    # Check if the list is empty\n    if not words:\n        return 0\n    \n    # Find the longest word by using the max function with a key\n    longest_word = max(words, key=len)\n    \n    # Return the length of the longest word\n    return len(longest_word)", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    Args:\n    words (list of str): A list of words to check.\n\n    Returns:\n    int: The length of the longest word in the list.\n\n    Examples:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    >>> len_log([\"a\", \"ab\", \"abc\", \"abcd\"])\n    4\n    \"\"\"\n    if not words:  # If the list is empty, return 0\n        return 0\n    \n    # Use max with a key function to find the word with maximum length\n    # Then use the len function to get its length\n    return len(max(words, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n\n    Args:\n    words (list): A list of strings where each string is a word.\n\n    Returns:\n    int: The length of the longest word.\n\n    Example:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    \"\"\"\n    # Check if the list is empty to avoid errors with max function\n    if not words:\n        return 0\n    \n    # Find the word with maximum length using max with key function\n    longest_word = max(words, key=len)\n    \n    # Return the length of the longest word\n    return len(longest_word)", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list of words.\n\n    Args:\n    words (list of str): A list of words to analyze.\n\n    Returns:\n    int: The length of the longest word.\n\n    Examples:\n    >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n    7\n    \"\"\"\n    # If the list is empty, return 0 to avoid errors\n    if not words:\n        return 0\n    \n    # Find the length of the longest word by using max with a key function\n    # The key function is lambda w: len(w) which returns the length of each word\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 78.04878048780488, "dps_norm": 60.0, "pass@1": 77.0, "profiled": [{"solution": "def index_minimum(lst):\n    \"\"\"\n    Finds and returns the first value of the tuple with the smallest second value from a list of tuples.\n\n    Args:\n    lst (list of tuple): A list where each element is a tuple with at least two items.\n\n    Returns:\n    str or None: The first element of the tuple with the minimum second element, or None if the list is empty.\n\n    Examples:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    >>> index_minimum([])\n    None\n    \"\"\"\n    # If the list is empty, return None\n    if not lst:\n        return None\n    \n    # Use the min function with a key function to find the tuple with the smallest second element\n    min_tuple = min(lst, key=lambda x: x[1])\n    \n    # Return the first element of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first element of the tuple which has the smallest second element in the list.\n\n    :param tuples_list: List of tuples where each tuple contains two elements: \n                        a string and an integer.\n    :type tuples_list: list[tuple[str, int]]\n    :return: The first element of the tuple with the minimum second value.\n    :rtype: str\n    \"\"\"\n    # Check if the list is empty to avoid IndexError\n    if not tuples_list:\n        return None\n    \n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    # Check if the list is empty\n    if not tuples:\n        return None\n    \n    # Use min function with a key that looks at the second item of each tuple\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, this function returns the first value of the tuple \n    with the smallest second value.\n\n    :param tuples_list: List of tuples where each tuple has at least two elements.\n    :return: The first element of the tuple with the minimum second value.\n    \n    Example:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    # If the list is empty, we raise an exception\n    if not tuples_list:\n        raise ValueError(\"The list of tuples cannot be empty.\")\n    \n    # Start with the first tuple as the current minimum\n    min_tuple = tuples_list[0]\n    \n    # Iterate through the list, updating the min_tuple if a smaller second value is found\n    for current in tuples_list[1:]:\n        if current[1] < min_tuple[1]:\n            min_tuple = current\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(items):\n    if not items:\n        return None  # Return None for empty lists\n    return min(items, key=lambda x: x[1])[0]  # Use min with key function to find tuple with smallest second value", "matching_cluster_idx": 2}, {"solution": "def index_minimum(pairs):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n\n    :param pairs: List of tuples where each tuple contains two items, the second being numeric\n    :type pairs: list[tuple[str, int]]\n    :return: The first value from the tuple with the smallest second value\n    :rtype: str or None if the list is empty\n    \"\"\"\n    if not pairs:  # Check if the list is empty\n        return None\n    \n    # Use min with a key function to find the tuple with the smallest second value\n    return min(pairs, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first element of the tuple with the smallest second element.\n\n    Example:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    # Check if the list is not empty to avoid errors\n    if not tuples_list:\n        raise ValueError(\"The list of tuples cannot be empty.\")\n\n    # Using min with a custom key to find the tuple with the smallest second element\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Find and return the first element of the tuple with the smallest second value.\n\n    Args:\n    tuples_list (list of tuple): A list of tuples where each tuple contains at least two elements.\n\n    Returns:\n    str or Any: The first element of the tuple with the minimum second value.\n\n    Raises:\n    ValueError: If the list is empty or if any tuple has fewer than two elements.\n\n    Examples:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    >>> index_minimum([(1, 5), (2, 10), (3, 3)])\n    3\n    \"\"\"\n    # Check if the list is empty\n    if not tuples_list:\n        raise ValueError(\"The list of tuples cannot be empty.\")\n    \n    # Check if each tuple has at least two elements\n    for item in tuples_list:\n        if len(item) < 2:\n            raise ValueError(\"Each tuple must contain at least two elements.\")\n    \n    # Use min() with a key function to find the tuple with the smallest second element\n    # The key function returns the second item of each tuple for comparison\n    result = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return result[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value from a list of tuples.\n\n    Args:\n    tuples_list (list of tuples): List where each tuple contains two elements, \n                                  where the second element is comparable.\n\n    Returns:\n    Any: The first element of the tuple with the minimum second element.\n\n    Examples:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    >>> index_minimum([('a', 1), ('b', 1), ('c', 2)])\n    'a'\n    \"\"\"\n    if not tuples_list:\n        return None  # In case the list is empty, return None\n    \n    # Use min() with a key function to find the tuple with the smallest second value\n    # The key function returns the second item of each tuple for comparison\n    result_tuple = min(tuples_list, key=lambda x: x[1])\n    return result_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(pairs):\n    \"\"\"\n    Find and return the first value of the tuple with the smallest second value from a list of tuples.\n    \n    Args:\n    pairs (list of tuple): A list where each tuple contains two elements; \n                           the second element is a number for comparison.\n\n    Returns:\n    str: The first element of the tuple with the smallest second element.\n\n    Raises:\n    ValueError: If the list is empty or if tuples do not conform to the expected format.\n\n    Example:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    # Check if the list is empty\n    if not pairs:\n        raise ValueError(\"The list of pairs is empty.\")\n\n    # Find the tuple with the minimum second value\n    min_pair = min(pairs, key=lambda x: (x[1] if len(x) > 1 else float('inf')))\n    \n    # Ensure the tuple has at least two elements\n    if len(min_pair) < 2:\n        raise ValueError(\"Invalid tuple found. Each tuple must contain at least two elements.\")\n\n    # Return the first element of the minimum tuple\n    return min_pair[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, return the first element of the tuple \n    with the smallest second value.\n    \n    :param lst: List of tuples, where each tuple contains (name, score)\n    :return: The name associated with the smallest score\n    :raises ValueError: If the input list is empty\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Use min() with a key function to find the tuple with the smallest second element\n    # Then, return the first element of that tuple\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(pairs):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value from the list of tuples.\n\n    Args:\n    pairs (list of tuple): A list where each tuple contains a string and an integer.\n\n    Returns:\n    str: The string from the tuple with the smallest integer value.\n\n    Examples:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    # Check if the list is empty to avoid errors\n    if not pairs:\n        return None\n\n    # Use min() with a key function to find the tuple with the smallest second element\n    # The key function returns the second item of each tuple for comparison\n    smallest_tuple = min(pairs, key=lambda x: x[1])\n    \n    # Return the first item of the tuple which has the smallest second item\n    return smallest_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, this function returns the first element (string)\n    from the tuple with the smallest second element (integer).\n\n    Args:\n    lst (list of tuples): A list where each tuple contains a string followed by an integer.\n\n    Returns:\n    str: The string associated with the minimum integer value.\n\n    Examples:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    # Use min() with a key function to find the tuple with the smallest second element\n    # Then return the first element of this tuple\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    This function iterates through a list of tuples, comparing the second value\n    (index 1) of each tuple to find the smallest. It returns the corresponding\n    first value (index 0) of that tuple.\n\n    Args:\n    tuples_list (list of tuple): A list where each tuple has at least two elements,\n                                 and the second element can be compared.\n\n    Returns:\n    Any: The first element of the tuple with the smallest second element.\n         If the list is empty, it will raise an IndexError.\n\n    Raises:\n    ValueError: If any tuple doesn't have at least two elements.\n\n    Examples:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    >>> index_minimum([('apple', 10), ('banana', 5), ('cherry', 15)])\n    'banana'\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples cannot be empty.\")\n    \n    # Use min with a key function to find the tuple with the minimum second element\n    # The key function returns the second element of the tuple for comparison\n    min_tuple = min(tuples_list, key=lambda x: (len(x) < 2, x[1]))\n    \n    if len(min_tuple) < 2:\n        raise ValueError(f\"Tuple {min_tuple} doesn't have a second element for comparison.\")\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    if not lst:\n        return None  # Handle empty list scenario\n    \n    # Use min with a key function to find the tuple with the smallest second element\n    smallest_tuple = min(lst, key=lambda x: x[1])\n    \n    # Return the first value of the tuple with the smallest second value\n    return smallest_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(pairs):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \n    :param pairs: List of tuples where each tuple contains a name (str) and a number (int)\n    :return: The string from the tuple with the minimum second value\n    :raises ValueError: If the input list is empty\n    \n    Example:\n    >>> assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'\n    \"\"\"\n    if not pairs:\n        raise ValueError(\"The list cannot be empty\")\n    \n    # Sort by the second value of each tuple, then return the first value of the first tuple\n    return min(pairs, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(pairs):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    Args:\n    pairs (list of tuples): A list where each tuple contains at least two elements, the first \n                            being any type (usually a string or number) and the second being \n                            comparable (like numbers).\n\n    Returns:\n    The first element of the tuple with the smallest second value.\n\n    Examples:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    >>> index_minimum([(3, -1), (1, 5), (2, 0)])\n    3\n    \"\"\"\n    if not pairs:  # Check if the list is empty\n        return None\n    \n    # Use the min function with a key that selects the second item of each tuple\n    return min(pairs, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples where each tuple contains a name and a value,\n    return the name associated with the smallest value.\n\n    Args:\n    lst (list of tuple): List where each tuple contains (name, value).\n\n    Returns:\n    str: The name from the tuple with the smallest value.\n\n    Example:\n    >>> assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'\n    \"\"\"\n    # Check if the list is empty to avoid IndexError\n    if not lst:\n        return None\n    \n    # Find the tuple with the smallest second value\n    # Using min with a key function to compare the second item in each tuple\n    smallest_tuple = min(lst, key=lambda x: x[1])\n    \n    # Return the first item of the tuple (the name)\n    return smallest_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(data):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value from a list of tuples.\n\n    Args:\n    data (list of tuple): A list where each tuple has at least two elements, \n                          the first being the name and the second being a numeric value.\n\n    Returns:\n    str or None: The name associated with the smallest value, or None if the list is empty.\n\n    Examples:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    >>> index_minimum([])\n    None\n    \"\"\"\n    if not data:\n        return None\n    \n    # Use min with a key function to find the tuple with the smallest second element\n    # The key function returns the second item in each tuple for comparison\n    min_tuple = min(data, key=lambda x: x[1])\n    \n    # Return the first item of the tuple with the minimum second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(pairs):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple \n    with the smallest second value.\n\n    Args:\n    pairs (list of tuple): A list where each tuple contains two elements;\n                           the first is a string and the second is a number.\n\n    Returns:\n    str: The string from the tuple with the smallest second value.\n\n    Example:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    # If the list is empty, return None or handle accordingly\n    if not pairs:\n        return None\n    \n    # Use min with a key function that looks at the second element of the tuple\n    # The key function returns the second item for comparison\n    return min(pairs, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 98.05555555555554, "dps_norm": 96.42857142857143, "pass@1": 73.0, "profiled": [{"solution": "def divisor(n):\n    \"\"\"\n    This function calculates the number of divisors of a given integer n.\n\n    Args:\n    n (int): The number to find divisors for.\n\n    Returns:\n    int: The count of divisors of n.\n\n    Example:\n    >>> divisor(15)\n    4\n    \"\"\"\n    # Handle special cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Use symmetry in number of divisors for efficiency\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors for a given integer.\n\n    This function counts all positive divisors of n, including 1 and n itself if n > 1.\n\n    Parameters:\n    n (int): The integer for which to count the divisors.\n\n    Returns:\n    int: The number of divisors of n.\n\n    Raises:\n    ValueError: If n is less than 1.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(28)\n    6\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"The input must be a positive integer.\")\n    \n    # Count includes 1 and n if n != 1\n    count = 0\n    # Only need to check up to the square root of n for efficiency\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, count it\n            count += 1\n            # If i is not the square root of n, then n/i is also a divisor\n            if i != n // i:\n                count += 1\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    # Initialize count of divisors to 0\n    count = 0\n    \n    # Loop up to the square root of n for efficiency\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If 'i' is a divisor, then both 'i' and 'n/i' are divisors\n            if i * i == n:\n                count += 1  # This avoids counting the square root twice for perfect squares\n            else:\n                count += 2\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer n.\n    \n    This function calculates all the divisors of the number by checking \n    from 1 up to the square root of n for efficiency. If n is divisible \n    by i, then both i and n//i are divisors (unless they are the same).\n\n    Args:\n    n (int): The integer for which to find divisors.\n\n    Returns:\n    int: The count of divisors of n.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(20)\n    6\n    >>> divisor(1)\n    1\n    \"\"\"\n    # Ensure n is at least 1\n    if n < 1:\n        raise ValueError(\"Number must be greater than 0\")\n\n    count = 0\n    # Check divisors up to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, count both i and its pair\n            if i * i == n:\n                count += 1  # Perfect square case, don't count twice\n            else:\n                count += 2\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Count the number of divisors for a given integer n.\n    \n    Args:\n    n (int): The number for which to count divisors.\n    \n    Returns:\n    int: The count of divisors for n.\n    \n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(100)\n    9\n    \"\"\"\n    # Initialize the count of divisors\n    count = 0\n    \n    # Handle edge cases\n    if n <= 0:\n        raise ValueError(\"Number must be greater than zero.\")\n    \n    # Check from 1 to the square root of n, because divisors come in pairs\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is not a square root divisor, add both i and n/i\n            if i * i != n:\n                count += 2\n            else:\n                # If i is a square root divisor, only count it once\n                count += 1\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The number for which to count divisors.\n\n    Returns:\n    int: The count of divisors.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(1)\n    1\n    \"\"\"\n    if n == 0:\n        return 0  # By convention, 0 has no divisors\n    \n    # Initialize the count to include 1 and n (except for 1, which is counted twice)\n    count = 2 if n != 1 else 1\n    \n    # We only need to check up to the square root of n for efficiency\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, both i and n/i are divisors\n            # But if i*i == n, we count it only once\n            count += 2 if i * i != n else 1\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n\n    This function calculates how many positive divisors an integer has. \n    A divisor of an integer n is any integer that divides n without leaving a remainder.\n\n    Args:\n    n (int): The number for which to find the divisors.\n\n    Returns:\n    int: The count of divisors for the number n.\n\n    Example:\n    >>> divisor(15)\n    4\n    \"\"\"\n    # Handle special cases\n    if n == 0:\n        raise ValueError(\"The number of divisors for zero is undefined.\")\n    if n < 0:\n        n = -n  # Consider only the absolute value for divisors\n    \n    count = 0\n    # Loop up to the square root of n for efficiency\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, i and n//i both are\n            count += 2 if i * i != n else 1  # Avoid counting sqrt(n) twice if n is a perfect square\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of the given integer n.\n\n    This function calculates the total count of integers that divide \n    'n' without leaving a remainder. It counts 1 and the number itself.\n\n    Args:\n    n (int): The number for which divisors are to be counted.\n\n    Returns:\n    int: The number of divisors of 'n'.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(12)\n    6\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        raise ValueError(\"Number must be greater than zero.\")\n    \n    # Count of divisors\n    count = 0\n    \n    # Check all numbers from 1 to sqrt(n) for optimization\n    # Since a larger factor of n must be a multiple of a smaller factor that has already been counted\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are different, they contribute two divisors each\n            if i * i != n:\n                count += 2\n            else:\n                # If i is the square root of n, count it once\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors for a given integer.\n\n    This function counts how many positive integers divide 'n' without leaving a remainder.\n    The function uses the fact that for every divisor d of n, n/d is also a divisor,\n    thereby optimizing the counting process to only check up to the square root of n.\n\n    Args:\n    n (int): The number for which to count divisors.\n\n    Returns:\n    int: The total count of divisors for n.\n\n    Example:\n    >>> divisor(15)\n    4  # Divisors are 1, 3, 5, 15\n    \"\"\"\n    # We'll store divisors to ensure uniqueness\n    divisors = set()\n    \n    # Check divisors from 1 up to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, then n/i is also a divisor\n            divisors.add(i)\n            if i != n // i:  # Add only if i is not the square root of n\n                divisors.add(n // i)\n    \n    return len(divisors)", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors for a given integer.\n    \n    This function counts all divisors of the number, including 1 and the number itself.\n    It optimizes by counting up to the square root of n for efficiency.\n    \n    Args:\n    n (int): The integer for which to count the divisors.\n    \n    Returns:\n    int: The number of divisors.\n    \n    Raises:\n    ValueError: If n is less than or equal to 0.\n    \n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(12)\n    6\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Number must be greater than zero\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are not the same, both are counted\n            if i * i != n:\n                count += 2\n            else:\n                # If divisors are the same (like for perfect squares)\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors for a given integer.\n\n    This function counts all positive divisors of n, including 1 and n itself.\n    The time complexity is O(sqrt(n)) since we only check up to the square root of n.\n\n    Parameters:\n    n (int): The number for which to count divisors.\n\n    Returns:\n    int: The count of divisors for the number n.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(12)\n    6\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The number must be greater than zero.\")\n\n    # Count divisors\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is not the square root of n, then both i and n//i are divisors\n            if i * i != n:\n                count += 2\n            else:\n                count += 1\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer n.\n\n    This function calculates the number of divisors by iterating up to the square root\n    of n, counting divisors and using the property that if i is a divisor of n, then \n    n/i is also a divisor (unless i == n/i, in which case it's counted once).\n\n    Parameters:\n    n (int): The integer for which to count divisors.\n\n    Returns:\n    int: The count of all divisors of n.\n\n    Example:\n    >>> divisor(15)\n    4\n    >>> divisor(10)\n    4\n    >>> divisor(18)\n    6\n    \"\"\"\n    if n == 0:\n        return 0  # Conventionally, 0 has 0 divisors\n    if n < 0:\n        n = abs(n)  # Consider absolute value for negative numbers\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If 'i' divides n, then both i and n/i are divisors\n            if n // i != i:\n                count += 2  # Add 2 if i and n/i are different\n            else:\n                count += 1  # Add 1 if i is the square root of n\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n    \n    This function computes the count by iterating up to the square root of n\n    for efficiency, considering that divisors come in pairs where one divides \n    into the other.\n\n    Args:\n    n (int): The integer for which to find the number of divisors.\n\n    Returns:\n    int: The count of divisors of n.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(1)\n    1\n    >>> divisor(12)\n    6\n    \"\"\"\n    if n == 0:\n        return 0  # By convention, 0 has no divisors\n    count = 0\n    for i in range(1, int(n**0.5) + 1):  # Only need to go up to sqrt(n)\n        if n % i == 0:\n            # If divisors are different, it means we have found two divisors\n            if i * i != n:  \n                count += 2\n            else:\n                # Special case for square root divisor, only counted once\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors for a given integer.\n    \n    This function counts all the integers from 1 up to and including n that\n    can evenly divide n. Since divisors come in pairs (except for perfect \n    squares), for efficiency, we only need to check up to sqrt(n), then \n    multiply by 2 for pairs, or add 1 if n is a perfect square.\n    \n    Args:\n    n (int): The number for which to find divisors.\n    \n    Returns:\n    int: The count of divisors of n.\n    \n    Raises:\n    ValueError: If n is less than 1.\n    \n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(10)\n    4\n    >>> divisor(100)\n    9\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"The number must be a positive integer.\")\n    \n    # Initial count includes 1 and n itself\n    count = 0\n    i = 1\n    \n    # Loop up to the square root of n\n    while i * i <= n:\n        if n % i == 0:\n            # If n is divisible by i, it's a divisor, and so is n/i\n            if n // i != i:  # Avoid counting square root twice for perfect squares\n                count += 2\n            else:\n                count += 1\n        i += 1\n    \n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n\n    This function counts how many numbers divide the given integer n without a remainder.\n    It includes 1 and n itself in the count.\n\n    Parameters:\n    n (int): The number whose divisors are to be counted.\n\n    Returns:\n    int: The count of divisors for n.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(12)\n    6\n    \"\"\"\n    if n <= 0:\n        return 0  # Non-positive integers don't have divisors in this context\n    \n    # We'll check up to the square root of n for efficiency\n    # since divisors come in pairs if one is less than sqrt(n), the other must be greater\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, count both i and n/i unless they're the same (perfect square)\n            count += 1\n            if i != n // i:  # To avoid counting the same divisor twice for perfect squares\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given positive integer.\n\n    This function counts how many numbers less than or equal to 'n' divide 'n' without leaving a remainder.\n    \n    Args:\n    n (int): The number to find divisors for. Must be greater than 0.\n\n    Returns:\n    int: The count of divisors.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Example:\n    >>> divisor(15)\n    4\n    \"\"\"\n    # Check if n is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    count = 0\n    # We only need to check up to the square root of n because \n    # if 'a' divides 'n', then 'n/a' also divides 'n'. This optimization \n    # halves our computational effort for large numbers.\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i divides n, then i is a divisor. \n            # If i != n/i, then n/i is also a divisor, hence add 2 to count.\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors for a given integer n.\n    \n    Args:\n    n (int): The integer for which to count divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \n    Raises:\n    ValueError: If n is not a positive integer.\n    \n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(10)\n    4\n    >>> divisor(1)\n    1\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The number must be a positive integer.\")\n    \n    # Handle edge case for 1\n    if n == 1:\n        return 1\n    \n    # Initialize count with 1 and n, as all numbers are divisible by 1 and itself\n    count = 2  # For 1 and n itself\n    \n    # Check for divisors up to sqrt(n) to optimize\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i divides n, then both i and n/i are divisors\n            count += 1 if i * i == n else 2\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors for a given positive integer.\n\n    This function uses a more efficient method by counting divisors up to \n    the square root of n, which leverages the fact that divisors come in \n    pairs (except when n is a square number).\n\n    Args:\n    n (int): A positive integer for which to count divisors.\n\n    Returns:\n    int: The count of divisors of n.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(12)\n    6\n    \"\"\"\n    # Check if n is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"The number must be a positive integer.\")\n    \n    # Initialize the count of divisors\n    count = 0\n    \n    # Loop up to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, n//i is also a divisor\n            # Count i as divisor\n            count += 1\n            \n            # If i is not the square root, add another divisor\n            if i != n // i:\n                count += 1\n\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors for a given integer n.\n    \n    This function calculates the count of divisors by checking all numbers \n    from 1 up to n. The time complexity for this approach is O(n), but it's \n    straightforward for understanding purposes. For very large numbers, \n    more efficient algorithms like finding up to sqrt(n) would be better.\n\n    Args:\n    n (int): The integer to check for divisors.\n\n    Returns:\n    int: The count of divisors of n.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(1)\n    1\n    \"\"\"\n    # Handle edge case where n is less than 1\n    if n < 1:\n        return 0\n    \n    # Initialize count of divisors\n    count = 0\n    \n    # Check each number from 1 to n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Determine the number of divisors for the given integer n.\n\n    Args:\n    n (int): The integer whose divisors are to be counted.\n\n    Returns:\n    int: The count of divisors of n.\n\n    Example:\n    >>> divisor(15)\n    4  # Divisors are 1, 3, 5, 15\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    if n == 1:\n        return 1  # 1 has only one divisor: itself\n\n    # Count of divisors\n    divisor_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are different, both i and n/i are divisors\n            if i * i != n:  # i != n//i for perfect squares\n                divisor_count += 2\n            else:\n                # Perfect square, count i only once\n                divisor_count += 1\n    \n    return divisor_count", "matching_cluster_idx": 6}]}, "Mbpp/97": {"dps": 90.66666666666667, "dps_norm": 82.5, "pass@1": 100.0, "profiled": [{"solution": "def frequency_lists(nested_list):\n    from collections import Counter\n    from itertools import chain\n    \n    # Flatten the list of lists into a single list\n    flat_list = list(chain.from_iterable(nested_list))\n    \n    # Count the frequency of each element\n    frequency_dict = dict(Counter(flat_list))\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    \"\"\"\n    Calculate the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (list): A list containing sublists or individual elements.\n\n    Returns:\n    dict: A dictionary where keys are unique elements from the flattened list \n          and values are their frequencies.\n\n    Example:\n    >>> frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])\n    {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    # Flatten the nested list into a single list\n    flat_list = [item for sublist in nested_list for item in (sublist if isinstance(sublist, list) else [sublist])]\n    \n    # Count the frequency of each item in the flattened list\n    freq_dict = {}\n    for item in flat_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    \n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Flatten the list of lists\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Count frequency of each element using a dictionary comprehension\n    frequency = {element: flattened_list.count(element) for element in set(flattened_list)}\n    \n    return frequency", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Compute the frequency of each element in a list of lists.\n\n    This function flattens a list of lists into a single list, then counts the \n    frequency of each element in this flattened list.\n\n    Args:\n        nested_list (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n        Dict[int, int]: A dictionary where keys are the unique elements from the \n        flattened list and values are their respective counts.\n\n    Example:\n        >>> frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])\n        {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    # Flatten the list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    # Use Counter to count frequency\n    return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Count the frequency of each item\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from typing import List, Dict\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    # Flatten the list of lists into a single list\n    flattened = [item for sublist in lists for item in sublist]\n    \n    # Use a dictionary to count occurrences of each number\n    frequency = {}\n    for number in flattened:\n        if number in frequency:\n            frequency[number] += 1\n        else:\n            frequency[number] = 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Flatten the list of lists\n    flattened = [item for sublist in lists for item in sublist]\n    \n    # Create a dictionary to count frequency\n    freq_dict = {}\n    for num in flattened:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(list_of_lists: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Compute the frequency of each element in a flattened list of lists.\n\n    This function flattens a list of lists into a single list, then counts\n    the occurrences of each number.\n\n    Args:\n        list_of_lists (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n        Dict[int, int]: A dictionary where keys are unique elements from \n                        the flattened list, and values are their frequencies.\n\n    Examples:\n        >>> frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])\n        {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    # Flatten the list of lists\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Count the frequency of each element using Counter\n    return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists_of_lists):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in lists_of_lists for item in sublist]\n    \n    # Create a dictionary to store frequency\n    frequency = {}\n    \n    # Count frequency of each number\n    for num in flat_list:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    from collections import Counter\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    # Use Counter to count occurrences\n    return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "def flatten_list(lists):\n    \"\"\"Flatten a list of lists into a single list.\"\"\"\n    return [item for sublist in lists for item in sublist]\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculate the frequency of each element in a flattened list of lists.\n    \n    Args:\n    list_of_lists (List[List[int]]): A list containing sublists with integers.\n\n    Returns:\n    Dict[int, int]: A dictionary where keys are elements from the list and values are their frequencies.\n    \n    Example:\n    >>> frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])\n    {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    flat_list = flatten_list(list_of_lists)\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    This function takes a list of lists, flattens it, and then counts how many times \n    each element appears in the entire structure.\n\n    Args:\n        lists (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n        Dict[int, int]: A dictionary where keys are the integers from the flattened list \n        and values are their frequencies.\n\n    Example:\n        >>> frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])\n        {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    # Flatten the list of lists into one list\n    flat_list = [item for sublist in lists for item in sublist]\n    \n    # Use Counter to get the frequency of each element\n    return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef flatten_list(nested_list: List[List[int]]) -> List[int]:\n    \"\"\"Flatten a list of lists into a single list.\"\"\"\n    return [item for sublist in nested_list for item in sublist]\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    - nested_list (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n    - Dict[int, int]: A dictionary where keys are unique elements and values are their frequencies.\n\n    Example:\n    >>> frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])\n    {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    # Flatten the nested list\n    flat_list = flatten_list(nested_list)\n    \n    # Use Counter to count frequencies\n    frequency = Counter(flat_list)\n    \n    # Convert Counter object to regular dictionary\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists_of_lists):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in lists_of_lists for item in sublist]\n    \n    # Count the frequency of each element using a dictionary comprehension\n    frequency = {item: flat_list.count(item) for item in set(flat_list)}\n    \n    return frequency", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a list of lists.\n\n    This function flattens the given list of lists and then calculates\n    how many times each unique integer appears in the flattened list.\n\n    Args:\n    lists (List[List[int]]): A list where each item is a list of integers.\n\n    Returns:\n    Dict[int, int]: A dictionary where keys are the unique integers from the \n    lists and values are their respective frequencies.\n\n    Example:\n    >>> frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])\n    {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in lists for item in sublist]\n    \n    # Use Counter to count occurrences of each number\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Calculate the frequency of each element in a flattened list of lists.\n\n    This function takes a list of lists, flattens it into a single list,\n    and then counts how many times each element appears.\n\n    Args:\n    nested_list (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n    Dict[int, int]: A dictionary where keys are the elements from the lists \n                    and values are their frequencies.\n\n    Example:\n    >>> frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])\n    {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count occurrences of each number\n    frequency = Counter(flat_list)\n    \n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to hold the frequencies\n    freq = {}\n    \n    # Iterate through each sublist in the list of lists\n    for sublist in lists:\n        # Iterate through each element in the sublist\n        for item in sublist:\n            # Increment the count for the item in the dictionary\n            if item in freq:\n                freq[item] += 1\n            else:\n                freq[item] = 1\n    \n    # Return the frequency dictionary\n    return freq", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists_of_lists):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists_of_lists for item in sublist]\n    \n    # Use a dictionary to count frequency\n    frequency = {}\n    for item in flat_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Use a dictionary to count the frequency of each element\n    frequency_dict = {}\n    for element in flat_list:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n    \n    This function takes a list of lists, flattens it into a single list,\n    then counts the occurrences of each element.\n    \n    Args:\n    lists (list of list): A list containing sublists of integers.\n\n    Returns:\n    dict: A dictionary where keys are the elements from the flattened list,\n          and values are their respective frequencies.\n\n    Example:\n    >>> frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])\n    {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    \n    # Use a dictionary to count frequencies\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n            \n    return frequency_dict", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 24.058441558441558, "dps_norm": 68.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends elements of the list `lst` to the tuple `tup`.\n\n    Args:\n    lst (list): The list containing elements to be appended to the tuple.\n    tup (tuple): The original tuple to which elements will be added.\n\n    Returns:\n    tuple: A new tuple with the elements of `lst` appended to `tup`.\n\n    Example:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert the tuple to a list for modification, append the list elements, then convert back to tuple\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple and return a new tuple.\n    \n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing elements from tup followed by elements from lst.\n    \n    Example:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the end of the given tuple.\n\n    This function takes a list and a tuple, then concatenates the list to the tuple,\n    returning a new tuple that includes all elements from the original tuple followed\n    by all elements from the list.\n\n    Args:\n    lst (list): The list of elements to be appended.\n    tup (tuple): The initial tuple to which elements are to be appended.\n\n    Returns:\n    tuple: A new tuple containing elements from 'tup' followed by elements from 'lst'.\n\n    Examples:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert tuple to a list to allow append operation, then extend with the given list\n    result = list(tup) \n    result.extend(lst)\n    \n    # Convert the list back to a tuple for the result\n    return tuple(result)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the elements of a list to a tuple.\n\n    Args:\n    lst (list): The list whose elements need to be appended to the tuple.\n    tup (tuple): The original tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with all elements from `tup` followed by all elements from `lst`.\n\n    Example:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert tuple to list for concatenation, then back to tuple\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Append the elements of a list to a tuple and return the new tuple.\n\n    Args:\n    lst (list): The list whose elements are to be appended to the tuple.\n    tpl (tuple): The original tuple to which elements will be added.\n\n    Returns:\n    tuple: A new tuple that contains all elements from the original tuple followed by all elements from the list.\n\n    Examples:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert the tuple to a list, append the elements from lst, then convert back to tuple\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends a list to the end of a tuple and returns the new tuple.\n\n    Args:\n    lst (list): The list to be appended to the tuple.\n    tpl (tuple): The original tuple.\n\n    Returns:\n    tuple: A new tuple with elements of the list appended to the original tuple.\n\n    Example:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Combine tuple and list into a new tuple\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append elements of the given list to the given tuple.\n\n    Args:\n    lst (list): The list containing elements to be appended.\n    tup (tuple): The initial tuple to which elements will be added.\n\n    Returns:\n    tuple: A new tuple with elements from both the initial tuple and the list.\n\n    Example:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the elements of a list to the end of a tuple.\n\n    Args:\n    lst (list): A list to be appended to the tuple.\n    tup (tuple): A tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the list elements.\n\n    Example:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert the tuple to a list for modification, append the list, then convert back to tuple\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Args:\n    input_list (list): A list of elements to be appended.\n    input_tuple (tuple): The tuple to which elements are appended.\n\n    Returns:\n    tuple: A new tuple containing all elements from `input_tuple` followed by all elements from `input_list`.\n\n    Example:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert the tuple to list, extend with list elements, and convert back to tuple\n    return tuple(list(input_tuple) + input_list)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the elements of a list to the end of a tuple.\n\n    Args:\n    lst (list): The list whose elements are to be added to the tuple.\n    tup (tuple): The original tuple.\n\n    Returns:\n    tuple: A new tuple with elements from the list appended to the original tuple.\n\n    Example:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert tuple to list, extend with new list, and convert back to tuple\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Args:\n    lst (list): The list to be appended to the tuple.\n    tup (tuple): The tuple to which elements will be added.\n\n    Returns:\n    tuple: A new tuple containing all elements from the original tuple \n           followed by all elements from the list.\n\n    Example:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert the tuple to a list to make it mutable, append the new list,\n    # then convert back to a tuple\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends a list to the end of a tuple.\n\n    Args:\n    lst (list): The list to be appended to the tuple.\n    tup (tuple): The original tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the elements of the original tuple followed by the list elements.\n\n    Examples:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert tuple to list to append elements, then convert back to tuple\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the elements of the given list to the given tuple.\n\n    This function takes a list and a tuple, and returns a new tuple\n    which contains all the elements from the original tuple followed\n    by all elements from the list.\n\n    Args:\n    lst (list): The list to append to the tuple.\n    tup (tuple): The tuple to which elements will be appended.\n\n    Returns:\n    tuple: A new tuple combining elements from the original tuple and list.\n\n    Examples:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert the list to a tuple for concatenation\n    # Then use the + operator to join tuples\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends a list to a tuple and returns the new tuple.\n\n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The original tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the elements of lst appended to tup.\n\n    Examples:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert tuple to list, extend with the new list, and convert back to tuple\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple and returns a new tuple.\n\n    Args:\n    lst (list): The list to be appended to the tuple.\n    tup (tuple): The original tuple to which elements are to be added.\n\n    Returns:\n    tuple: A new tuple with elements from the original tuple followed by elements from the list.\n\n    Examples:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Args:\n    lst (list): The list to be appended to the tuple.\n    tup (tuple): The initial tuple.\n\n    Returns:\n    tuple: A new tuple containing all elements from tup followed by all elements from lst.\n\n    Example:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert the tuple to a list, append elements from the list, then convert back to tuple\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple with elements of 'tup' followed by elements of 'lst'.\n    \n    Example:\n    >>> assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert the tuple to a list to allow appending\n    result = list(tup)\n    # Extend the list with the elements of lst\n    result.extend(lst)\n    # Convert back to tuple for the return value\n    return tuple(result)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends a list to a tuple and returns the resulting tuple.\n\n    Args:\n    lst (list): The list to be appended to the tuple.\n    tpl (tuple): The initial tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple consisting of the original tuple elements followed by the elements of the list.\n\n    Examples:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert the tuple to a list for appending, then back to a tuple\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    input_list (list): The list of items to be appended.\n    input_tuple (tuple): The original tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing all elements from the original tuple plus the elements from the list.\n\n    Example:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert tuple to list for mutation, append the input list, and convert back to tuple\n    result = list(input_tuple) + input_list\n    return tuple(result)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Args:\n    lst (list): The list to be appended to the tuple.\n    tup (tuple): The initial tuple.\n\n    Returns:\n    tuple: A new tuple with the contents of the original tuple followed by the elements of the list.\n\n    Example:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n    \"\"\"\n    # Convert the list to a tuple and concatenate with the original tuple\n    return tup + tuple(lst)", "matching_cluster_idx": 4}]}, "Mbpp/108": {"dps": 86.20481927710843, "dps_norm": 91.81818181818181, "pass@1": 92.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the lists\n    merged_list = list1 + list2 + list3\n    \n    # Use Python's built-in sorted function to sort the merged list\n    # This function returns a new sorted list, leaving the original lists unchanged\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into one sorted list.\n\n    Args:\n    list1 (list): The first list of numbers to be merged.\n    list2 (list): The second list of numbers to be merged.\n    list3 (list): The third list of numbers to be merged.\n\n    Returns:\n    list: A new list containing all elements from the input lists in sorted order.\n\n    Example:\n    >>> merge_sorted_list([25, 24, 15], [19, 20, 11], [24, 26])\n    [11, 15, 19, 20, 24, 24, 25, 26]\n    \"\"\"\n    # Combine all lists into one\n    combined = list1 + list2 + list3\n    \n    # Sort the combined list\n    # Using merge sort here for efficiency, but Python's default sort is TimSort which is based on merge sort anyway\n    return sorted(combined)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First list of numbers\n    list2 (list): Second list of numbers\n    list3 (list): Third list of numbers\n    \n    Returns:\n    list: A merged list sorted in ascending order.\n    \"\"\"\n    # Combine all lists into one\n    combined = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Args:\n    list1 (list): First list of integers to be merged.\n    list2 (list): Second list of integers to be merged.\n    list3 (list): Third list of integers to be merged.\n\n    Returns:\n    list: A sorted list containing all elements from the input lists.\n\n    Example:\n    >>> merge_sorted_list([25, 15, 5], [19, 11, 233], [24, 26, 54])\n    [5, 11, 15, 19, 24, 25, 26, 54, 233]\n    \"\"\"\n    # Combine all lists into one list\n    combined = list1 + list2 + list3\n    \n    # Sort the combined list in ascending order\n    sorted_list = sorted(combined)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all lists\n    combined = list1 + list2 + list3\n    \n    # Sort the combined list\n    # Using bubble sort here for simplicity, although not the most efficient for larger lists\n    n = len(combined)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if combined[j] > combined[j+1]:\n                combined[j], combined[j+1] = combined[j+1], combined[j]\n    \n    return combined", "matching_cluster_idx": 0}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three unsorted lists into one sorted list.\n    \n    Args:\n    list1, list2, list3 (list): The three lists to be merged and sorted.\n    \n    Returns:\n    list: A single list containing all elements from the input lists in ascending order.\n    \"\"\"\n    # Combine all lists\n    combined = list1 + list2 + list3\n    \n    # Sort the combined list\n    # Using Timsort (Python's default sorting algorithm), which has an average time complexity of O(n log n)\n    return sorted(combined)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Args:\n    list1 (list): First list of numbers\n    list2 (list): Second list of numbers\n    list3 (list): Third list of numbers\n\n    Returns:\n    list: A merged list sorted in ascending order.\n    \"\"\"\n    # Combine all lists into one\n    merged = list1 + list2 + list3\n    \n    # Sort the combined list\n    merged.sort()\n    \n    return merged", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    # Flatten all lists into one\n    merged = []\n    for lst in lists:\n        merged.extend(lst)\n    \n    # Sort the merged list\n    merged.sort()\n    return merged", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list in ascending order.\n\n    Args:\n    list1 (list): First list of numbers.\n    list2 (list): Second list of numbers.\n    list3 (list): Third list of numbers.\n\n    Returns:\n    list: A single list containing all elements from the input lists, sorted.\n\n    Example:\n    >>> merge_sorted_list([25, 24], [19, 20], [24])\n    [19, 20, 24, 24, 25]\n    \"\"\"\n    # Combine all lists into one\n    combined = list1 + list2 + list3\n    \n    # Sort the combined list\n    # Using merge sort algorithm for efficiency when dealing with sorted sublists\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        \n        result = []\n        left_index, right_index = 0, 0\n        \n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] < right[right_index]:\n                result.append(left[left_index])\n                left_index += 1\n            else:\n                result.append(right[right_index])\n                right_index += 1\n        \n        result += left[left_index:]\n        result += right[right_index:]\n        \n        return result\n\n    # Here we apply merge sort to get the final sorted list\n    return merge_sort(combined)", "matching_cluster_idx": 3}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1, list2, list3 (list): Lists of numbers to be merged and sorted.\n    \n    Returns:\n    list: A single list containing all elements from input lists in sorted order.\n    \"\"\"\n    # Combine all lists into one\n    combined = list1 + list2 + list3\n    \n    # Sort the combined list in ascending order\n    # The sorted function returns a new sorted list from the elements of any sequence\n    return sorted(combined)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    # Flatten all lists into one\n    merged = []\n    for lst in lists:\n        merged.extend(lst)\n    \n    # Sort the merged list\n    merged.sort()\n    \n    return merged", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all lists into one\n    merged_list = list1 + list2 + list3\n    \n    # Sort the combined list in ascending order\n    # Here we use sort() which modifies the list in-place for efficiency\n    merged_list.sort()\n    \n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all lists\n    combined = list1 + list2 + list3\n    \n    # Use Python's built-in sort which uses Timsort (a hybrid of merge sort and insertion sort)\n    combined.sort()\n    \n    return combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into one sorted list.\n\n    Args:\n    list1 (list): The first list of numbers.\n    list2 (list): The second list of numbers.\n    list3 (list): The third list of numbers.\n\n    Returns:\n    list: A single list containing all elements from the input lists, sorted in ascending order.\n\n    Example:\n    >>> merge_sorted_list([25, 24, 15], [19, 20], [26])\n    [15, 19, 20, 24, 25, 26]\n    \"\"\"\n    # Combine all lists into one\n    combined = list1 + list2 + list3\n    \n    # Use Python's built-in sort function which uses Timsort algorithm\n    # It has a worst-case complexity of O(n log n) for sorting\n    combined.sort()\n    \n    return combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Args:\n    list1 (list): The first list to merge.\n    list2 (list): The second list to merge.\n    list3 (list): The third list to merge.\n\n    Returns:\n    list: A new list containing all elements from the input lists in sorted order.\n\n    Example:\n    >>> merge_sorted_list([25, 24], [19, 20], [24, 26])\n    [19, 20, 24, 24, 25, 26]\n    \"\"\"\n    # Combine all three lists\n    combined = list1 + list2 + list3\n    \n    # Sort the combined list\n    # Using the sorted() function with a key for natural sorting behavior\n    return sorted(combined)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*args):\n    \"\"\"\n    Merges multiple lists into a single sorted list.\n\n    Args:\n    *args: Variable number of lists to be merged.\n\n    Returns:\n    list: A new list containing all elements from input lists, sorted in ascending order.\n\n    Example:\n    >>> merge_sorted_list([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48])\n    [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]\n    \"\"\"\n    # Combine all lists into one list\n    merged_list = []\n    for lst in args:\n        merged_list.extend(lst)\n    \n    # Sort the combined list\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    \"\"\"\n    Merges an arbitrary number of lists into a single sorted list.\n\n    Args:\n    *lists: Variable number of lists to be merged.\n\n    Returns:\n    list: A single list containing all elements from the input lists in sorted order.\n    \"\"\"\n    # Flatten all lists into one list\n    all_elements = [item for sublist in lists for item in sublist]\n    \n    # Sort the flattened list\n    # Here we use a list comprehension with sorting, which is efficient for small to medium lists\n    return sorted(all_elements)", "matching_cluster_idx": 9}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First list of numbers\n    list2 (list): Second list of numbers\n    list3 (list): Third list of numbers\n    \n    Returns:\n    list: A new list containing all numbers from the input lists, sorted in ascending order.\n    \"\"\"\n    # Combine all lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all lists\n    merged = list1 + list2 + list3\n    \n    # Sort the combined list\n    sorted_list = sorted(merged)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Args:\n    list1 (list): The first list of numbers.\n    list2 (list): The second list of numbers.\n    list3 (list): The third list of numbers.\n\n    Returns:\n    list: A new list containing all elements from the input lists, sorted in ascending order.\n\n    Example:\n    >>> merge_sorted_list([25, 24], [19, 20], [24, 26])\n    [19, 20, 24, 24, 25, 26]\n    \"\"\"\n    # Combine all elements from the three lists\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list in one go\n    return sorted(combined_list)", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 64.1076923076923, "dps_norm": 82.5, "pass@1": 84.0, "profiled": [{"solution": "from typing import List, Set\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> Set[int]:\n    \"\"\"\n    Find the common elements in all given nested lists.\n\n    This function determines the intersection of elements across all sublists\n    within the nested list structure.\n\n    Args:\n    nested_lists (List[List[int]]): A list of lists where each sublist contains integers.\n\n    Returns:\n    Set[int]: A set containing elements that are present in all sublists.\n\n    Examples:\n    >>> common_in_nested_lists([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n    {3}\n    >>> common_in_nested_lists([[12, 18], [18, 12, 7, 14], [12, 18, 21, 14]])\n    {12, 18}\n    \"\"\"\n    # If there's only one list or no lists, return all unique elements or an empty set respectively\n    if len(nested_lists) <= 1:\n        return set().union(*nested_lists)\n    \n    # Start with the first list's set of elements\n    common = set(nested_lists[0])\n    \n    # For each list in nested_lists, intersect its elements with the current common set\n    for sublist in nested_lists[1:]:\n        common.intersection_update(sublist)\n        if not common:  # If at any point common set becomes empty, no need to continue\n            break\n    \n    return common", "matching_cluster_idx": 7}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return set()\n\n    # Convert all elements to sets for intersection operations\n    set_lists = [set(lst) for lst in nested_lists]\n\n    # Start with the first set and intersect with subsequent sets\n    common_elements = set_lists[0]\n    for s in set_lists[1:]:\n        common_elements.intersection_update(s)\n\n    return list(common_elements)\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Start with the first list as the set of common elements\n    if not nested_lists:\n        return set()\n    \n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        # Use intersection to keep only elements that are in both sets\n        common_elements &= set(lst)\n        \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements among all lists in a nested list structure.\n\n    This function takes a list of lists and returns a list containing elements \n    that are present in every inner list.\n\n    Args:\n    nested_lists (List[List[int]]): A list of lists where each sublist contains integers.\n\n    Returns:\n    List[int]: A list of integers common to all sublists.\n\n    Example:\n    >>> assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Convert the first list to a set for efficient lookup\n    common = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for sublist in nested_lists[1:]:\n        # Update 'common' to be the intersection with the current sublist\n        common &= set(sublist)\n        \n        # Optimization: If common becomes empty, we can exit early\n        if not common:\n            return []\n    \n    return list(common)", "matching_cluster_idx": 6}, {"solution": "from typing import List, Any\ndef common_in_nested_lists(nested_lists: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Find the common elements among all lists in the given nested lists.\n\n    Args:\n    nested_lists (List[List[Any]]): A list of lists containing elements of any type.\n\n    Returns:\n    List[Any]: A list of elements that are common to all nested lists.\n\n    Examples:\n    >>> common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])\n    [18, 12]\n    \"\"\"\n    # If the nested list is empty, return an empty list\n    if not nested_lists:\n        return []\n\n    # Convert each sublist to a set for faster intersection operation\n    sets = [set(lst) for lst in nested_lists]\n    \n    # Start with the first set, then iteratively intersect with the rest\n    result = sets[0]\n    for s in sets[1:]:\n        result = result.intersection(s)\n    \n    # Convert set back to list to match the expected output format\n    return list(result)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Start with the first list\n    if not nested_lists:\n        return set()\n    \n    # Convert the first list to a set for faster lookup\n    common_set = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        # Update common_set to include only elements that are in both common_set and the current list\n        common_set.intersection_update(lst)\n    \n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements among all lists within a nested list structure.\n    \n    This function iterates through each list in the nested list and uses set \n    intersection to find common elements.\n\n    Parameters:\n    nested_lists (list of lists): A list containing lists whose common elements are to be found.\n\n    Returns:\n    list: A list of elements common to all inner lists.\n\n    Examples:\n    >>> common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])\n    [18, 12]\n    \"\"\"\n    # Check if the nested_lists is empty or contains empty lists\n    if not nested_lists or any(not lst for lst in nested_lists):\n        return []\n    \n    # Convert the first list to a set for intersection operations\n    common = set(nested_lists[0])\n    \n    # Iterate over each list in the nested list\n    for lst in nested_lists[1:]:\n        common = common.intersection(set(lst))\n        if not common:\n            # If at any point we find no common elements, return an empty list\n            return []\n    \n    # Convert set to list for the result and ensure order consistency\n    return sorted(list(common))", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Start with the first list to find the initial set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over each list in nested_lists, starting from the second list\n    for lst in nested_lists[1:]:\n        # Update common_elements to keep only elements that are also in the current list\n        common_elements.intersection_update(lst)\n        \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"\n    Find common elements in a list of nested lists.\n\n    Args:\n    lists (list of lists): A collection of lists to find common elements from.\n\n    Returns:\n    set: A set containing elements common to all nested lists.\n\n    Example:\n    >>> common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])\n    {18, 12}\n    \"\"\"\n    # Convert the first list to a set for initial reference\n    if not lists:\n        return set()\n    common = set(lists[0])\n    \n    # Use set intersection to find elements common in all lists\n    for lst in lists[1:]:\n        common &= set(lst)\n    \n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"\n    Find the common elements in a list of nested lists.\n\n    Args:\n    lists (list): A list containing nested lists of integers.\n\n    Returns:\n    list: A list of common elements found in all nested lists.\n\n    Example:\n    >>> common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])\n    [12, 18]\n    \"\"\"\n    # If there are no lists to compare, return an empty list\n    if not lists:\n        return []\n\n    # Start with the first list's set\n    common = set(lists[0])\n    \n    # Intersect with sets of all other lists\n    for l in lists[1:]:\n        common &= set(l)\n\n    # Convert set back to list and sort it for consistent output\n    return sorted(list(common))", "matching_cluster_idx": 6}, {"solution": "from typing import List\nfrom functools import reduce\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Find the common elements among all lists within a nested list.\n\n    Args:\n    nested_lists (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n    List[int]: A list of integers that are present in all sublists.\n\n    Example:\n    >>> common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])\n    [18, 12]\n    \"\"\"\n    # If there are no lists, return an empty list\n    if not nested_lists:\n        return []\n    \n    # Convert each set in the nested lists to sets for efficient intersection\n    sets = [set(lst) for lst in nested_lists]\n    \n    # Use reduce to find intersection of all sets\n    if not sets:  # Handle case where all lists might be empty\n        return []\n    \n    result = reduce(set.intersection, sets)\n    \n    # Convert set back to sorted list\n    return sorted(list(result))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n    nested_lists (list of lists): A list containing sublists of numbers.\n\n    Returns:\n    set: A set containing elements that appear in all sublists.\n\n    Example:\n    >>> assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]))==set([18, 12])\n    \"\"\"\n    # If the list is empty, return an empty set\n    if not nested_lists:\n        return set()\n\n    # Convert the first list into a set for fast membership tests\n    common = set(nested_lists[0])\n\n    # Iterate over each list in the nested list\n    for lst in nested_lists[1:]:\n        # Update common with elements that are in the current list\n        # This effectively computes intersection by reducing the common set to elements\n        # that are present in both the current 'common' set and the current list\n        common.intersection_update(set(lst))\n\n    return common", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find common elements in a list of lists.\n\n    This function takes a nested list where each sublist contains elements,\n    and returns the elements common to all sublists.\n\n    Args:\n    nested_lists (List[List[int]]): A list of lists containing integer elements.\n\n    Returns:\n    List[int]: A list of integers that are present in every sublist.\n\n    Example:\n    >>> common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])\n    [18, 12]\n    \"\"\"\n    # If the nested list is empty, return an empty list\n    if not nested_lists:\n        return []\n\n    # Convert all elements in sublists to sets for set intersection\n    sets = [set(sublist) for sublist in nested_lists]\n\n    # Use set intersection to find common elements\n    common_elements = sets[0].intersection(*sets[1:])\n    \n    # Convert set back to a sorted list for consistency in order\n    return sorted(list(common_elements))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Start with the first list as the reference for common elements\n    common = set(nested_lists[0])\n    \n    # Iterate over the rest of the lists\n    for lst in nested_lists[1:]:\n        common &= set(lst)  # Intersection operation to keep only common elements\n    \n    return list(common)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Convert all items to sets and use set intersection to find common elements\n    result = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        result.intersection_update(set(lst))\n    \n    return list(result)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # If the nested list is empty, return an empty set\n    if not nested_lists:\n        return set()\n\n    # Convert all inner lists to sets for easier intersection operations\n    sets = [set(lst) for lst in nested_lists]\n    \n    # Use reduce with set intersection to find common elements among all sets\n    from functools import reduce\n    result = reduce(set.intersection, sets)\n    \n    return list(result)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lists):\n    if not lists:\n        return []\n\n    # Convert the first list into a set for efficient lookups\n    common_elements = set(lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in lists[1:]:\n        # Keep only the elements that are in the current list\n        common_elements.intersection_update(set(lst))\n\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements among all lists within nested_lists.\n    \n    This function takes a list of lists and returns a list of elements \n    that appear in every sublist.\n\n    Args:\n    nested_lists (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n    List[int]: A list containing the common elements found in all sublists.\n\n    Example:\n    >>> common_in_nested_lists([[12, 18, 23], [7, 12, 18], [12, 15, 18]])\n    [12, 18]\n    \"\"\"\n    if not nested_lists:  # If the list is empty, return an empty list\n        return []\n    \n    # Convert the first list to a set for efficient intersection\n    common_set = set(nested_lists[0])\n    \n    # Iterate over the rest of the lists to find intersection\n    for l in nested_lists[1:]:\n        common_set.intersection_update(set(l))\n    \n    # Convert set back to list since the order in the original example is preserved\n    return list(common_set)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds common elements in all lists within a nested list structure.\n\n    Args:\n    nested_lists (list of list): A list where each element is itself a list.\n\n    Returns:\n    list: A list containing elements that are present in all nested lists.\n\n    Example:\n    >>> common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 18, 20]])\n    [12, 18]\n    \"\"\"\n    # If the nested list is empty, return an empty list\n    if not nested_lists:\n        return []\n\n    # Use set intersection to find common elements across all lists\n    common_set = set(nested_lists[0])  # Start with the first list\n    for lst in nested_lists[1:]:\n        common_set &= set(lst)\n\n    # Convert set to list for return value\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements among all lists within the nested lists.\n\n    Args:\n    nested_lists (List[List[int]]): A list of lists containing integers where\n                                    we need to find common elements.\n\n    Returns:\n    List[int]: A list of integers that are common to all provided lists.\n\n    Example:\n    >>> common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])\n    [12, 18]\n    \"\"\"\n    if not nested_lists: \n        return []\n    \n    # Convert the first list to a set for intersection operations\n    common = set(nested_lists[0])\n    \n    # Iterate over the rest of the lists\n    for lst in nested_lists[1:]:\n        # Update common with the intersection of current common elements with the next list\n        common &= set(lst)\n        # If there are no common elements left, we can break early\n        if not common:\n            break\n    \n    return list(common)", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 64.0, "profiled": [{"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    if n <= 1:\n        return 0\n    sum_div = 1  # 1 is always a divisor for numbers greater than 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:\n                sum_div += n // i\n    return sum_div\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to limit.\"\"\"\n    total = 0\n    amicable_set = set()\n\n    for a in range(1, limit + 1):\n        if a in amicable_set:\n            continue  # Skip already processed amicable numbers\n        \n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            # Check for amicable pair\n            if a < b <= limit:\n                amicable_set.add(a)\n                amicable_set.add(b)\n                total += a + b\n            elif a <= limit < b:\n                amicable_set.add(a)\n                total += a\n    \n    return total", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors_sum = 1  # 1 is always a divisor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == (n // i):  # If divisors are equal, it's a perfect square\n                divisors_sum += i\n            else:\n                divisors_sum += i + (n // i)\n    return divisors_sum\ndef are_amicable(a, b):\n    \"\"\"Check if two numbers are amicable.\"\"\"\n    return sum_of_divisors(a) == b and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for num in range(2, limit + 1):  # Start from 2 since 1 has no amicable pair\n        pair = sum_of_divisors(num)\n        if pair > num and are_amicable(num, pair):\n            amicable_sum += num + pair  # Add both numbers as they might be outside our range\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Find the sum of all proper divisors of n.\"\"\"\n    sum_divisors = 1  # Start with 1 because 1 is a divisor of every number except itself\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            # If i != n/i, we add both divisors. If they are equal, we've already added one of them\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef is_amicable(a, b):\n    \"\"\"Check if two numbers are amicable.\"\"\"\n    return sum_of_divisors(a) == b and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers up to the given limit.\"\"\"\n    amicable_set = set()\n    for num in range(1, limit + 1):\n        sum_div = sum_of_divisors(num)\n        if sum_div > num and sum_div <= limit:  # Potential amicable pair\n            if is_amicable(num, sum_div):\n                amicable_set.add(num)\n                amicable_set.add(sum_div)\n    return sum(amicable_set)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of all proper divisors of n.\"\"\"\n    total = 1  # 1 is always a divisor except for n itself\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers from 1 to 'limit'.\n    \n    An amicable number is defined as the number d(n) where:\n    - d(n) is the sum of the proper divisors of n\n    - n != d(n)\n    - d(d(n)) = n\n    \n    :param limit: The upper bound of numbers to check for amicability.\n    :return: Sum of all amicable numbers up to 'limit'.\n    \"\"\"\n    amicable_sum = 0\n    amicable_numbers = set()\n    \n    for a in range(2, limit + 1):  # Start from 2 because 1 isn't amicable\n        if a in amicable_numbers:  # Skip numbers we've already found to be amicable\n            continue\n        b = sum_of_divisors(a)\n        if sum_of_divisors(b) == a and a != b:  # Check if they are amicable\n            amicable_numbers.add(a)\n            amicable_numbers.add(b)\n            if b <= limit:\n                amicable_sum += a + b\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_div = 1  # 1 is always a proper divisor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:\n                sum_div += n // i\n    return sum_div\ndef is_amicable(a, b):\n    \"\"\"Check if numbers a and b are amicable.\"\"\"\n    return sum_proper_divisors(a) == b and sum_proper_divisors(b) == a and a != b\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for i in range(1, limit + 1):\n        sum_div_i = sum_proper_divisors(i)\n        if sum_div_i <= limit and i < sum_div_i and is_amicable(i, sum_div_i):\n            amicable_sum += i + sum_div_i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"Returns the sum of all proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef is_amicable(a):\n    \"\"\"Check if a number is amicable.\"\"\"\n    b = sum_divisors(a)\n    return sum_divisors(b) == a and a != b\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers up to the given limit.\"\"\"\n    total = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            total += num\n    return total", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    divisor_sum = 1  # Start with 1 since we exclude n itself\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisor_sum += i\n            if i != n // i:\n                divisor_sum += n // i\n    return divisor_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers up to the given limit.\"\"\"\n    amicable_sum = 0\n    amicable_pairs = set()\n\n    for a in range(2, limit):\n        # If 'a' has already been part of an amicable pair, skip it\n        if a in amicable_pairs:\n            continue\n        \n        b = sum_of_divisors(a)\n        \n        # If 'b' exceeds the limit, stop checking for 'a'\n        if b > limit:\n            continue\n        \n        # Check if they are amicable\n        if sum_of_divisors(b) == a and a != b:\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n            amicable_sum += a + b\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of a number.\"\"\"\n    sum_div = 1  # 1 is always a divisor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:  # Avoid counting the square root twice if n is a perfect square\n                sum_div += n // i\n    return sum_div\ndef is_amicable(a, b):\n    \"\"\"Check if two numbers are amicable.\"\"\"\n    return sum_proper_divisors(a) == b and sum_proper_divisors(b) == a and a != b\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for i in range(1, limit + 1):\n        sum_div_i = sum_proper_divisors(i)\n        if sum_div_i <= limit and is_amicable(i, sum_div_i):\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            if i != n // i:  # In case i is not the square root\n                divisors.add(n // i)\n    return sum(divisors)\ndef are_amicable(a, b):\n    \"\"\"Check if two numbers are amicable.\"\"\"\n    return sum_of_divisors(a) == b and sum_of_divisors(b) == a and a != b\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers up to the limit.\"\"\"\n    amicable_sum = 0\n    for i in range(1, limit + 1):\n        d_i = sum_of_divisors(i)\n        if d_i <= limit and are_amicable(i, d_i):\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of the proper divisors of n.\"\"\"\n    total = 1  # 1 is a divisor for all numbers greater than 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # Avoid counting sqrt(n) twice if n is not square\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers from 1 to limit.\n    \n    Amicable numbers are defined as a pair of numbers for which \n    the sum of the proper divisors of each is equal to the other number.\n    \n    Args:\n    limit (int): The upper limit to check for amicable numbers.\n    \n    Returns:\n    int: The sum of all amicable numbers up to limit.\n    \n    Example:\n    >>> amicable_numbers_sum(999)\n    504\n    \"\"\"\n    amicable_sum = 0\n    for a in range(2, limit + 1):  # Start from 2 since 1 has no proper divisors\n        b = sum_of_divisors(a)\n        if b <= a or b > limit:  # If b > a or b > limit, no need to check further\n            continue\n        \n        # Check if a and b are amicable\n        if sum_of_divisors(b) == a:\n            amicable_sum += a + b\n            print(f\"Amicable pair: {a}, {b}\")\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors for a number n.\"\"\"\n    # 1 is always a divisor\n    total = 1  \n    # Check up to the square root for efficiency\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, then n/i is also a divisor\n            total += i + (n // i if i * i != n else 0)\n    return total\ndef is_amicable(a):\n    \"\"\"Check if number 'a' is part of an amicable pair.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers from 1 to 'limit'.\n    \n    An amicable number is one where the sum of its proper divisors \n    equals another number whose sum of proper divisors equals the first.\n    \"\"\"\n    return sum(num for num in range(1, limit+1) if is_amicable(num))", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_div = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i + (n // i if i * i != n else 0)\n    return sum_div\ndef is_amicable(a):\n    \"\"\"Check if number 'a' is amicable.\"\"\"\n    b = sum_divisors(a)\n    return b != a and sum_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to limit.\"\"\"\n    return sum(a for a in range(1, limit + 1) if is_amicable(a))", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of a number.\"\"\"\n    divisors_sum = 1  # 1 is always a divisor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef is_amicable(a, b):\n    \"\"\"Check if two numbers are amicable.\"\"\"\n    return sum_of_divisors(a) == b and sum_of_divisors(b) == a and a != b\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_divisors(a)\n        if a < b <= limit and is_amicable(a, b):  # Ensures a < b to avoid double counting\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of all proper divisors of n.\"\"\"\n    sum_divisors = 1  # 1 is always a proper divisor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            # If i is not sqrt(n), then n/i is also a divisor\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    # Dictionary to memoize sums of divisors\n    d = {}\n    \n    for a in range(1, limit + 1):\n        # If 'a' has not been calculated yet\n        if a not in d:\n            d[a] = sum_of_divisors(a)\n        b = d[a]\n        \n        # If 'b' exceeds our limit or 'b' equals 'a', no need to proceed\n        if b > limit or b == a:\n            continue\n        \n        # If 'b' has not been calculated, calculate now\n        if b not in d:\n            d[b] = sum_of_divisors(b)\n        \n        # Check for amicable pair\n        if d[b] == a and a < b:\n            amicable_sum += a + b\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of all proper divisors of n.\"\"\"\n    # 1 is always a proper divisor\n    total = 1\n    # Check up to the square root for divisors to improve efficiency\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, add both i and n/i if they're not the same\n            total += i + (n // i if i * i != n else 0)\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculate the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for a in range(2, limit + 1):  # Start from 2 as 1 is not considered for amicability\n        b = sum_of_proper_divisors(a)\n        # Check if b is also in range and forms an amicable pair with a\n        if b <= limit and a != b:\n            if sum_of_proper_divisors(b) == a:\n                # a and b are an amicable pair\n                amicable_sum += a\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of all proper divisors of n.\"\"\"\n    total = 1  # 1 is always a divisor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # Avoid duplicate for perfect squares\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to the given limit.\"\"\"\n    amicables = set()\n    for a in range(1, limit + 1):\n        b = sum_of_divisors(a)\n        if sum_of_divisors(b) == a and a != b:\n            if a < limit:\n                amicables.add(a)\n            if b < limit:\n                amicables.add(b)\n    return sum(amicables)", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    \"\"\"Calculate the sum of all proper divisors of a number.\"\"\"\n    total = 1  # 1 is always a divisor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # Avoid adding the square root twice if n is a perfect square\n                total += n // i\n    return total\ndef is_amicable(a):\n    \"\"\"Check if a number is amicable.\"\"\"\n    b = sum_proper_divisors(a)\n    return b != a and sum_proper_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to limit.\"\"\"\n    total = 0\n    for num in range(2, limit + 1):  # Start from 2 since 1 can't be amicable\n        if is_amicable(num):\n            total += num\n    return total", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of all proper divisors of a number.\"\"\"\n    total = 1  # 1 is always a divisor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Find the sum of all amicable numbers up to 'limit'.\n    \n    An amicable number is a number where the sum of its proper divisors \n    is equal to another number, and the sum of that number's proper \n    divisors is equal to the original number. However, they are not \n    equal to each other.\n    \n    :param limit: Upper limit of the range to check for amicable numbers.\n    :return: Sum of all amicable numbers up to 'limit'.\n    \"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b if b <= limit else a\n    # Here we make sure we're only adding each number once by comparing a and b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n.\"\"\"\n    total = 1  # 1 is always a divisor, except for 1 itself where we return 0\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # This ensures we don't add the same divisor twice for perfect squares\n                total += n // i\n    return total\ndef is_amicable(a):\n    \"\"\"Check if a number is part of an amicable pair.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers from 1 to the specified limit.\n    \n    An amicable number is one where the sum of its proper divisors equals another \n    number, and vice versa, but they are not equal to each other.\n    \n    :param limit: Upper bound for finding amicable numbers\n    :return: Sum of all amicable numbers up to the limit\n    \"\"\"\n    return sum(num for num in range(1, limit + 1) if is_amicable(num))", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_div = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:  # Avoid adding the square root twice if perfect square\n                sum_div += n // i\n    return sum_div\ndef is_amicable(a):\n    \"\"\"Check if a number is amicable.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers from 1 to the specified limit.\n    \n    Args:\n    limit (int): The upper bound of the range to check for amicable numbers.\n    \n    Returns:\n    int: The sum of all amicable numbers within the limit.\n    \"\"\"\n    total = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            total += num\n    return total", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 89.63800904977376, "dps_norm": 74.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Args:\n    n (int): The minimum number of characters a word should have to be considered long.\n    sentence (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words from the sentence that are longer than n characters.\n\n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words based on length\n    long_words_list = [word for word in words if len(word) > n]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words longer than n characters in a given sentence.\n\n    Parameters:\n    n (int): The minimum number of characters for words to be considered long.\n    sentence (str): A string containing the words to be analyzed.\n\n    Returns:\n    list: A list of words from the sentence that are longer than n characters.\n\n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words in the given sentence that are longer than n characters.\n    \n    Args:\n    n (int): The minimum length of words to return.\n    sentence (str): The sentence to check for long words.\n\n    Returns:\n    list: A list of words from the sentence that are longer than n characters.\n\n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words that are longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words in a sentence that are longer than n characters.\n\n    Args:\n    n (int): The minimum number of characters for a word to be considered long.\n    sentence (str): A string of words from which to extract the long words.\n\n    Returns:\n    list: A list of words that are longer than n characters.\n\n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Convert sentence to a list of words, removing any punctuation\n    words = ''.join(char.lower() if char.isalnum() or char.isspace() else ' ' for char in sentence).split()\n    \n    # Filter words that are longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": -1}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words in the given text that are longer than n characters.\n    \n    Parameters:\n    n (int): The minimum length of words to be included in the result.\n    text (str): The input text to search for long words.\n    \n    Returns:\n    list: A list of words from the text that are longer than n characters.\n    \n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the text into words\n    words = text.split()\n    \n    # Use a list comprehension to filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Args:\n    n (int): The minimum length of words to be considered 'long'.\n    sentence (str): A string containing the sentence to check for long words.\n\n    Returns:\n    list: A list of words from the sentence that are longer than 'n' characters.\n\n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words that are longer than n characters\n    long_word_list = [word for word in words if len(word) > n]\n    \n    return long_word_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    - n (int): The minimum length for words to be considered 'long'.\n    - sentence (str): A string containing words.\n\n    Returns:\n    - list: A list of words that are longer than n characters.\n\n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Use list comprehension to find words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words longer than n characters in the given sentence.\n\n    Args:\n    n (int): The number of characters that defines 'long'.\n    sentence (str): The sentence to analyze.\n\n    Returns:\n    list: A list of words from the sentence longer than n characters.\n\n    Examples:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Use list comprehension to find words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words in the given text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum length of words to be considered.\n    text (str): The string from which to extract words.\n\n    Returns:\n    list: A list of words longer than n characters.\n\n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the text into words\n    words = text.split()\n    \n    # Filter words that are longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Parameters:\n    n (int): The number of characters to compare against.\n    sentence (str): A string of words separated by spaces.\n\n    Returns:\n    list: A list of words from the sentence that are longer than n characters.\n\n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    long_words = [word for word in words if len(word) > n]\n    \n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words in the given sentence that are longer than n characters.\n\n    Parameters:\n    - n: int, the minimum length of words to include\n    - sentence: str, the sentence from which to extract long words\n\n    Returns:\n    - list: A list containing words longer than n characters.\n\n    Examples:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "import re\ndef long_words(n, sentence):\n    # Split the sentence into words, considering punctuation as separators\n    words = re.findall(r'\\b\\w+\\b', sentence)\n    # Filter words that are longer than 'n' characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 1}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words longer than n characters from the given sentence.\n\n    Parameters:\n    n (int): The minimum length for words to be considered 'long'.\n    sentence (str): A string containing words to be checked.\n\n    Returns:\n    list: A list of words from the sentence that are longer than n characters.\n\n    Examples:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words that are longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words longer than n characters in a given sentence.\n\n    Parameters:\n    n (int): The minimum length of words to be returned.\n    sentence (str): The sentence to parse for long words.\n\n    Returns:\n    list: A list of words from the sentence longer than n characters.\n\n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words that are longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/130": {"dps": 89.64125560538116, "dps_norm": 82.5, "pass@1": 84.0, "profiled": [{"solution": "from collections import Counter\ndef max_occurrences(items):\n    \"\"\"\n    Find the item with the maximum frequency in the given list.\n    \n    Args:\n    items (list): A list of comparable items where we need to find the most frequent one.\n    \n    Returns:\n    The item with the maximum number of occurrences. If multiple items have the same \n    maximum frequency, it returns the first one encountered during iteration.\n    \n    Example:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    \"\"\"\n    # Count occurrences of each item\n    count = Counter(items)\n    \n    # Find the maximum frequency\n    max_freq = max(count.values())\n    \n    # Return the first item with the maximum frequency\n    # Here we use next with a default value to handle the case where items might be empty\n    return next(item for item, freq in count.items() if freq == max_freq)", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in the list.\n\n    Args:\n    lst (list): A list of items to analyze.\n\n    Returns:\n    The item with the highest frequency in the list. If there's a tie, \n    it returns the first encountered item with that frequency.\n\n    Examples:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    \"\"\"\n    # Use a dictionary to count occurrences\n    count = {}\n    for item in lst:\n        if item in count:\n            count[item] += 1\n        else:\n            count[item] = 1\n    \n    # Find the item with max occurrence\n    # We use max with a key function that returns the count for each item\n    max_item = max(count, key=count.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n\n    Args:\n    lst (list): A list of items.\n\n    Returns:\n    Any: The item from the list with the highest frequency. If multiple items\n         have the same max frequency, it returns one of them.\n\n    Example:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    \"\"\"\n    # Use Counter to count occurrences of each item\n    count = Counter(lst)\n    \n    # Find the max frequency\n    max_freq = max(count.values())\n    \n    # Get the first item with this frequency\n    for item, freq in count.items():\n        if freq == max_freq:\n            return item", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    \n    # Count the occurrences of each number\n    counts = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    # max() with a key function to compare based on the count of items\n    max_item = max(counts, key=counts.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count occurrences of each number in the list\n    count = Counter(lst)\n    \n    # Find the item with the maximum count\n    # If there are multiple items with the same max frequency, return the first one encountered\n    if not lst:\n        return None  # In case the list is empty, return None\n    return max(count, key=count.get)", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(arr):\n    \"\"\"\n    Find the item with the maximum frequency in the given list.\n\n    Args:\n    arr (list): A list of items where we need to find the maximum frequency.\n\n    Returns:\n    Any: The item from the list with the highest frequency. If there are multiple items with the same \n         maximum frequency, it returns one of them.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Example:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The list cannot be empty.\")\n\n    # Count the frequency of each item using a dictionary\n    frequency = {}\n    for item in arr:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n\n    # Find the item with the maximum frequency\n    max_freq = max(frequency.values())\n    for item, count in frequency.items():\n        if count == max_freq:\n            return item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in the given list.\n\n    This function counts the occurrences of each item in the list\n    and returns the item with the highest frequency. If there are\n    multiple items with the same highest frequency, it returns the\n    first one encountered.\n\n    Args:\n    lst (list): A list of items where items can be hashable.\n\n    Returns:\n    Any: The item from the list with the maximum frequency.\n\n    Examples:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    \"\"\"\n    # Use a dictionary to count occurrences of each element\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the maximum frequency and corresponding item\n    max_freq = 0\n    max_item = None\n    for item, count in frequency.items():\n        if count > max_freq:\n            max_freq = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Count the frequency of each number\n    from collections import Counter\n    count = Counter(lst)\n    \n    # Find the maximum frequency\n    max_freq = max(count.values())\n    \n    # Get all numbers that have this maximum frequency\n    for num, freq in count.items():\n        if freq == max_freq:\n            return num", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef max_occurrences(items):\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n    \n    Args:\n    items (list): A list of hashable items.\n\n    Returns:\n    The item with the maximum frequency. If multiple items have the same max frequency, \n    it returns any one of them.\n\n    Examples:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    \"\"\"\n    # If the list is empty, raise an exception since we can't determine a max frequency\n    if not items:\n        raise ValueError(\"The list cannot be empty\")\n\n    # Use Counter to count occurrences of each item\n    item_counts = Counter(items)\n    \n    # Get the maximum frequency\n    max_count = max(item_counts.values())\n    \n    # Find all items with this max count and return the first one encountered\n    for item, count in item_counts.items():\n        if count == max_count:\n            return item", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\nfrom typing import List, Any\ndef max_occurrences(items: List[Any]) -> Any:\n    \"\"\"\n    Find the item with the maximum frequency in the given list.\n\n    This function counts the occurrences of each item in the list and \n    returns the one with the highest frequency. In case of a tie, it \n    returns the first encountered item with that maximum frequency.\n\n    Args:\n    items (List[Any]): A list of items where duplicates can occur.\n\n    Returns:\n    Any: The item that occurs most frequently in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Example:\n    >>> max_occurrences([2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2])\n    2\n    \"\"\"\n    if not items:\n        raise ValueError(\"The list cannot be empty.\")\n\n    # Use Counter to count occurrences\n    count = Counter(items)\n    \n    # Find max frequency\n    max_count = max(count.values())\n    \n    # Find all items with the max frequency\n    for item, frequency in count.items():\n        if frequency == max_count:\n            return item\n\n    # This line should never be reached due to the previous logic\n    raise AssertionError(\"No item was found with maximum frequency.\")", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in the given list.\n    \n    Args:\n    lst (list): A list of comparable items.\n\n    Returns:\n    The item with the highest frequency. If multiple items have the same maximum frequency,\n    it returns one of them.\n\n    Example:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    \"\"\"\n    # Use Counter to count occurrences of each item\n    count = Counter(lst)\n    \n    # Find the item(s) with the max count\n    max_count = max(count.values())\n    for item, freq in count.items():\n        if freq == max_count:\n            return item  # Return any item with max frequency; first encountered", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count occurrences of each number\n    count = Counter(lst)\n    # Find the item with the max count. If there are multiple items with the same \n    # maximum frequency, it will return one of them (in Python 3.7+, order is preserved)\n    return max(count, key=count.get)", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(arr):\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n\n    Args:\n    arr (list): A list of integers where the frequency of items needs to be checked.\n\n    Returns:\n    int: The item with the highest frequency in the list. \n         If multiple items have the same highest frequency, it returns one of them.\n\n    Examples:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    \"\"\"\n    # Use a dictionary to count occurrences of each number\n    from collections import Counter\n    count = Counter(arr)\n    \n    # Find the maximum frequency\n    max_freq = max(count.values())\n    \n    # Find all elements that have this frequency\n    max_elements = [k for k, v in count.items() if v == max_freq]\n    \n    # Return the first one if there are multiple with the same frequency\n    return max_elements[0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(items):\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n\n    This function uses a dictionary to count occurrences of each item,\n    then finds the item with the highest frequency.\n\n    Args:\n    items (list): A list of hashable items.\n\n    Returns:\n    The item with the highest frequency. If multiple items have the same\n    max frequency, it returns the first encountered in the original list.\n\n    Example:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    \"\"\"\n    # Count the occurrences of each item in the list\n    occurrences = {}\n    for item in items:\n        if item in occurrences:\n            occurrences[item] += 1\n        else:\n            occurrences[item] = 1\n    \n    # Find the item with the maximum frequency\n    # If multiple items share the max frequency, this will return the first\n    # one encountered due to how max() works with dictionaries\n    return max(occurrences, key=occurrences.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count occurrences of each number\n    frequency = {}\n    for num in lst:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Find the item with maximum frequency\n    max_freq = max(frequency.values())\n    # Return any item that has the max frequency; if there are ties, we'll return one of them\n    for num, freq in frequency.items():\n        if freq == max_freq:\n            return num", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(items):\n    \"\"\"\n    Find the item with the maximum frequency in the given list.\n\n    Args:\n    items (list): A list of items to analyze.\n\n    Returns:\n    Any: The item with the highest occurrence. If multiple items have the same\n         maximum frequency, it returns one of them.\n\n    Examples:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    \"\"\"\n    # Use Counter to count occurrences of each item\n    count = Counter(items)\n    \n    # Find the maximum frequency\n    max_freq = max(count.values())\n    \n    # Filter items to find all with the max frequency, and return the first one encountered\n    for item, freq in count.items():\n        if freq == max_freq:\n            return item", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\nfrom typing import List, Any\ndef max_occurrences(lst: List[Any]) -> Any:\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n\n    This function uses a Counter to count occurrences of each item and then\n    returns the item with the highest count. If there's a tie, it returns the \n    first encountered item with that maximum frequency.\n\n    Args:\n        lst (List[Any]): A list of items of any comparable type.\n\n    Returns:\n        Any: The item with the maximum frequency in the list.\n\n    Examples:\n        >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n        2\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Count occurrences of each item in the list\n    item_counts = Counter(lst)\n    \n    # Find the maximum frequency\n    max_count = max(item_counts.values())\n    \n    # Find all items with the maximum count\n    most_frequent = [item for item, count in item_counts.items() if count == max_count]\n    \n    # Return the first (or only) item with the maximum frequency\n    return most_frequent[0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(items):\n    # Initialize a dictionary to count occurrences\n    frequency = {}\n    \n    # Count the frequency of each item\n    for item in items:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with maximum frequency\n    max_freq = 0\n    max_item = None\n    for item, count in frequency.items():\n        if count > max_freq:\n            max_freq = count\n            max_item = item\n        # In case of a tie, the first encountered item with this frequency is selected\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in a list.\n    \n    This function counts the occurrences of each element in the list, \n    then returns the element with the highest count. If there are ties,\n    it returns the first encountered item with the maximum frequency.\n\n    Args:\n    lst (list): The list of elements to search through.\n\n    Returns:\n    Any: The item with the maximum occurrences in the list.\n\n    Example:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    \"\"\"\n    # Use a dictionary to count occurrences of each element\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    \n    # Find the maximum count\n    max_freq = max(count_dict.values())\n    \n    # Return the first item that has the max frequency\n    for key, value in count_dict.items():\n        if value == max_freq:\n            return key", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count occurrences of each item\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    \n    # Find the item with the max count\n    max_count = 0\n    max_item = None\n    for item, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item if max_item is not None else None", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": 54.838709677419345, "dps_norm": 68.75, "pass@1": 68.0, "profiled": [{"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeros to non-zero elements in the given array.\n\n    :param arr: List of integers\n    :return: Float representing the ratio of zeros to non-zeros\n    \"\"\"\n    # Count zeros in the array\n    zero_count = sum(1 for x in arr if x == 0)\n    \n    # Count non-zero elements\n    non_zero_count = len(arr) - zero_count\n    \n    # Handle the case where there are no non-zero elements to avoid division by zero\n    if non_zero_count == 0:\n        return float('inf')  # Return infinity if all elements are zero\n    \n    # Calculate the ratio\n    ratio = zero_count / non_zero_count\n    \n    return ratio", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n    \n    Args:\n    arr (list): An array of integers where we will count the zeros.\n    \n    Returns:\n    float: The ratio of zeroes to the total count of non-zeroes.\n    \n    Example:\n    >>> zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])\n    0.18181818181818182\n    \"\"\"\n    # Count zeros and non-zeros\n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    # Check if there are any non-zeros to avoid division by zero\n    if non_zero_count == 0:\n        return float('inf')  # Or return a specific value or behavior you prefer when there are no non-zero numbers\n    \n    # Calculate and return the ratio\n    return zero_count / non_zero_count", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes\n    zeroes = sum(1 for num in arr if num == 0)\n    \n    # Count the number of non-zeroes\n    non_zeroes = len(arr) - zeroes\n    \n    # Avoid division by zero\n    if non_zeroes == 0:\n        return float('inf')  # Return infinity if there are no non-zero elements\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    ratio = zeroes / non_zeroes\n    return ratio", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    # Count zeroes\n    zeroes = sum(1 for num in arr if num == 0)\n    # Count non-zeroes\n    non_zeroes = len(arr) - zeroes\n    \n    # Handle edge cases where there are no non-zeroes or only zeroes\n    if non_zeroes == 0:\n        return float('inf') if zeroes > 0 else float('nan')  # Return infinity if there are only zeroes, NaN if empty list\n    else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    - arr (list): An array of integers.\n\n    Returns:\n    - float: The ratio of zeroes to non-zeroes.\n\n    Example:\n    >>> zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])\n    0.18181818181818182\n    \"\"\"\n    # Count number of zeros\n    zeros = sum(1 for x in arr if x == 0)\n    \n    # Count non-zeroes\n    non_zeros = len(arr) - zeros\n\n    # Avoid division by zero\n    if non_zeros == 0:\n        return float('inf') if zeros > 0 else 0\n    \n    # Return the ratio\n    return zeros / non_zeros", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n    arr (list): A list of integers.\n\n    Returns:\n    float: The ratio of the count of zeros to the count of non-zeroes in the array.\n    \n    Examples:\n    >>> zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])\n    0.18181818181818182\n    \"\"\"\n    # Count the number of zeros in the array\n    zero_count = sum(1 for num in arr if num == 0)\n    \n    # Count the number of non-zeros\n    non_zero_count = len(arr) - zero_count\n    \n    # Avoid division by zero if all numbers are zeros\n    if non_zero_count == 0:\n        return float('inf') if zero_count > 0 else 0\n    else:\n        # Calculate the ratio of zeros to non-zeros\n        return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n    \n    :param arr: List of integers\n    :return: Float representing the ratio of zeroes to non-zeroes\n    \n    Example:\n    >>> math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    True\n    \"\"\"\n    # Count zeroes in the array\n    zero_count = sum(1 for num in arr if num == 0)\n    \n    # Count non-zero elements\n    non_zero_count = len(arr) - zero_count\n    \n    # Handle the case where all elements might be zero or non-zero\n    if non_zero_count == 0:\n        return float('inf') if zero_count > 0 else 0\n    else:\n        # Calculate the ratio of zeroes to non-zeroes\n        ratio = zero_count / non_zero_count\n        return ratio", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n    \n    Args:\n    arr (list): An array of integers.\n\n    Returns:\n    float: The ratio of the count of zeros to the count of non-zeros.\n\n    Example:\n    >>> zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])\n    0.18181818181818182\n    \"\"\"\n    # Count the number of zeros in the array\n    zero_count = sum(1 for num in arr if num == 0)\n    \n    # Count the number of non-zero elements\n    non_zero_count = len(arr) - zero_count\n    \n    # If there are no non-zero elements, return 0 or handle accordingly\n    if non_zero_count == 0:\n        return float('inf') if zero_count > 0 else 0.0\n    \n    # Calculate and return the ratio\n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n    arr (list): List of integers where we count the zeroes and non-zeroes.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. If there are no non-zeroes, returns math.inf.\n\n    Example:\n    >>> math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    True\n    \"\"\"\n    # Count zeroes and non-zeroes\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = len(arr) - zeroes\n    \n    # If there are no non-zeroes, we return infinity as per mathematical convention\n    if non_zeroes == 0:\n        return math.inf\n    \n    # Calculate ratio\n    ratio = zeroes / non_zeroes\n    \n    return ratio", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes\n    zeroes = sum(1 for x in arr if x == 0)\n    \n    # Count the number of non-zeroes\n    non_zeroes = len(arr) - zeroes\n    \n    # To avoid division by zero, we'll use a try-except block\n    try:\n        ratio = zeroes / non_zeroes\n    except ZeroDivisionError:\n        # If there are no non-zero numbers, we'll consider the ratio as 0 or infinity, but for testing we'll say it's 0\n        ratio = 0 if zeroes == 0 else float('inf')\n    \n    return ratio", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Args:\n    arr (list): An array of integers.\n\n    Returns:\n    float: The ratio of the number of zeros to the number of non-zeros. If there are no non-zeroes,\n           returns float('inf') or 0 if there are no zeros.\n\n    Example:\n    >>> math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    True\n    \"\"\"\n    # Count the number of zeros\n    zero_count = sum(1 for num in arr if num == 0)\n    \n    # Count the number of non-zeros\n    non_zero_count = len(arr) - zero_count\n    \n    # Handle edge cases where either zero or non-zero count is zero\n    if non_zero_count == 0:\n        return float('inf') if zero_count > 0 else 0\n    else:\n        # Return the ratio, handling potential division by zero with the previous check\n        return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeros to non-zeros in an array of integers.\n\n    This function counts the number of zeros in the given array and compares\n    it with the count of non-zero elements to produce a ratio.\n\n    Args:\n    arr (list): A list of integers where the ratio of zeros to non-zeros is calculated.\n\n    Returns:\n    float: The ratio of zeros to non-zeros. If there are no non-zero elements, \n           it returns 0 to avoid division by zero.\n\n    Example:\n    >>> zero_count([0, 1, 0, 2, 0])\n    0.6\n\n    Note:\n    - If the array contains all zeros or all non-zeros, the function handles this edge case.\n    - Rounding might be necessary for assertion comparisons due to float precision.\n    \"\"\"\n    zero_count = sum(1 for x in arr if x == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return 0 if zero_count == 0 else float('inf')  # Handle case where there are only zeros\n    \n    # Calculate the ratio\n    ratio = zero_count / non_zero_count\n    return ratio", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes elements. If there are no non-zero elements,\n           it will return infinity or zero depending on whether all elements are zero.\n\n    Example:\n    >>> assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    \"\"\"\n    # Count zeroes\n    zero_count = sum(1 for num in arr if num == 0)\n    # Count non-zeroes\n    non_zero_count = len(arr) - zero_count\n    \n    # Handle edge cases:\n    if non_zero_count == 0:  # If all numbers are zero\n        return float('inf') if zero_count > 0 else 0.0\n    else:\n        return zero_count / non_zero_count", "matching_cluster_idx": 5}, {"solution": "import numpy as np\nimport math\ndef zero_count(arr):\n    # Convert array to numpy array for efficient counting\n    arr = np.array(arr)\n    \n    # Count the number of zeros\n    zero_count = np.count_nonzero(arr == 0)\n    # Total number of elements in the array\n    total_count = len(arr)\n    \n    # Check if there are any non-zero elements to avoid division by zero\n    if total_count - zero_count == 0:\n        return float('inf')  # If all elements are zero, return infinity\n    \n    # Calculate the ratio of zeros to non-zeros\n    ratio = zero_count / (total_count - zero_count)\n    return ratio", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n    arr (list): An array of integers where we count zeroes and non-zeroes.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. If there are no non-zero elements, \n           this function returns positive infinity to avoid division by zero.\n\n    Examples:\n    >>> math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    True\n    >>> zero_count([0, 0, 0, 0])  # All are zero\n    inf\n    \"\"\"\n    # Count the number of zeros\n    zeros = sum(1 for num in arr if num == 0)\n    \n    # If the list only contains zeros, return infinity\n    if zeros == len(arr):\n        return float('inf')\n    \n    # Count non-zero numbers\n    non_zeros = len(arr) - zeros\n    \n    # Calculate and return the ratio\n    return zeros / non_zeros", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    # Count of zeroes\n    zeroes = sum(1 for num in arr if num == 0)\n    # Count of non-zeroes\n    non_zeroes = len(arr) - zeroes\n    \n    # Avoid division by zero\n    if non_zeroes == 0:\n        return float('inf') if zeroes > 0 else float('nan')\n    \n    # Return the ratio\n    return zeroes / non_zeroes", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    # Count zeroes\n    zero_count = sum(1 for num in arr if num == 0)\n    \n    # Count non-zeroes\n    non_zero_count = len(arr) - zero_count\n    \n    # To avoid division by zero if there are no non-zero elements\n    if non_zero_count == 0:\n        return float('inf')  # or any other suitable representation for division by zero\n    \n    # Calculate the ratio\n    ratio = zero_count / non_zero_count\n    \n    return ratio", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    # Count zeros\n    zero = sum(1 for num in arr if num == 0)\n    # Count non-zeros\n    non_zero = len(arr) - zero\n    \n    # If there are no non-zero elements, avoid division by zero\n    if non_zero == 0:\n        return float('inf') if zero > 0 else 0\n    \n    # Calculate the ratio of zeros to non-zeros\n    ratio = zero / non_zero\n    return ratio", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    # Count zeros\n    zero_count = sum(1 for num in arr if num == 0)\n    \n    # Count non-zeros\n    non_zero_count = len(arr) - zero_count\n    \n    # If there are no non-zero numbers, we would divide by zero. \n    # Handle this case separately to avoid an error.\n    if non_zero_count == 0:\n        return float('inf') if zero_count != 0 else 0  # Return infinity if all numbers are zero, 0 if no numbers at all\n    \n    # Calculate ratio\n    ratio = zero_count / non_zero_count\n    \n    return ratio", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    if not arr:  # Handle empty list case\n        return float('inf')  # or return 0, or any special value for division by zero\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    nonzero_count = len(arr) - zero_count\n    \n    if nonzero_count == 0:  # If there are no non-zero elements, return infinity or handle it as you see fit\n        return float('inf')\n    \n    # Calculate the ratio, use abs to handle negative ratios which might occur with different definitions\n    ratio = abs(zero_count / nonzero_count)\n    return ratio", "matching_cluster_idx": 4}]}, "Mbpp/140": {"dps": 77.7639751552795, "dps_norm": 77.5, "pass@1": 98.0, "profiled": [{"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flattens a list of lists or tuples into a single set of numbers.\n    \n    Args:\n    nested_list (List[Union[Tuple[int], List[int]]]): A list containing tuples or lists of numbers.\n    \n    Returns:\n    Set[int]: A set containing all the numbers from the nested structures.\n    \n    Example:\n    >>> assert set(extract_singly([(3, 4, 5), [4, 5, 7], [1, 4]])) == {3, 4, 5, 7, 1}\n    \"\"\"\n    flat_set = set()\n    for item in nested_list:\n        # Check if the item is iterable but not a string (since we want numbers, not characters)\n        if hasattr(item, '__iter__') and not isinstance(item, str):\n            for number in item:\n                flat_set.add(number)\n        else:\n            # If the item is not iterable, we assume it's a number to be added to the set\n            flat_set.add(item)\n    return flat_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    This function iterates over each sublist in the nested list, \n    converting all items into a set which inherently removes duplicates.\n\n    Args:\n    nested_list (list): A list containing tuples, lists, or mixed iterable of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the nested list.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    flat_set = set()\n    for sub_list in nested_list:\n        # Extend flat_set with elements from sub_list, converting everything to set for uniqueness\n        flat_set.update(sub_list)\n    return flat_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(lst_of_tuples):\n    \"\"\"\n    Flatten the list of tuples into a single set of numbers.\n\n    This function takes a list where each element is a tuple of integers and \n    returns a set containing all unique integers from those tuples.\n\n    Args:\n    lst_of_tuples (list of tuple): A list containing tuples of integers.\n\n    Returns:\n    set: A set of all unique integers from the tuples.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    # Use a set comprehension to get all unique elements from the flattened list\n    return {num for tup in lst_of_tuples for num in tup}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n    nested_list (list): A list containing lists or tuples of integers.\n\n    Returns:\n    set: A set containing all unique integers from the nested lists.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    # Initialize an empty set to hold unique numbers\n    flat_set = set()\n    \n    # Iterate through each element in the outer list\n    for element in nested_list:\n        # Ensure the element is iterable (like a list or tuple)\n        if hasattr(element, '__iter__') and not isinstance(element, (str, bytes)):\n            # If iterable, extend the set with its items\n            flat_set.update(element)\n        else:\n            # If not iterable, assume it's a single number and add it directly\n            flat_set.add(element)\n    \n    return flat_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(lists_of_tuples):\n    \"\"\"\n    Flatten a list of tuples into a set of unique numbers.\n    \n    Args:\n    lists_of_tuples (list of tuple): A list where each item is a tuple of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the tuples.\n\n    Example:\n    >>> assert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])\n    \"\"\"\n    # Use a set comprehension to gather all numbers from all tuples into one set\n    return {num for tup in lists_of_tuples for num in tup}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lists_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    This function takes a list containing tuples or lists, extracts all numbers \n    from them, and returns a set of unique numbers.\n\n    Args:\n    lists_of_lists (list of tuple/list): A list where each element can be either \n                                        a tuple or list of numbers.\n\n    Returns:\n    set: A set of unique numbers extracted from the nested lists.\n\n    Examples:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n\n    >>> extract_singly([(1, 2), [3, 4], (4, 5), (1,)])\n    {1, 2, 3, 4, 5}\n    \"\"\"\n    # Using list comprehension to flatten the structure into a set\n    # This will automatically take care of duplicates since we're using a set\n    return set(num for inner_list in lists_of_lists for num in inner_list)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n    \n    Args:\n    nested_list (list of iterable): A list containing iterables (like lists or tuples) of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the nested list.\n\n    Example:\n    >>> assert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    result = set()\n    \n    # Iterate through each iterable in the nested_list\n    for item in nested_list:\n        # Add all elements from this iterable to the result set\n        # This automatically removes any duplicates\n        result.update(item)\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "def extract_singly(lists_of_tuples):\n    \"\"\"\n    Flatten a list of tuples into a single set of numbers.\n\n    This function takes a list where each element is a tuple of numbers,\n    and flattens it into a set containing all unique numbers.\n\n    Args:\n    lists_of_tuples (list): A list where each element is a tuple of integers.\n\n    Returns:\n    set: A set of all unique numbers from the input tuples.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    # Using a set comprehension to create a set from all elements in all tuples\n    return {num for tup in lists_of_tuples for num in tup}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists/tuples into a single set of unique numbers.\n    \n    This function takes a list where each element is itself a list or tuple \n    and combines all elements into one set, removing any duplicates.\n\n    Args:\n    list_of_lists (list): A list containing lists or tuples of numbers.\n\n    Returns:\n    set: A set of unique numbers from the nested lists.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    # Use a set comprehension to flatten and remove duplicates in one step\n    return {num for sublist in list_of_lists for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten a list of iterables into a set of unique elements.\n    \n    This function takes a list where each element can be any iterable (list, tuple, etc.)\n    and flattens it into a set containing all the individual elements.\n\n    Args:\n    nested_list (list): A list containing iterables of numbers.\n\n    Returns:\n    set: A set of all unique numbers from the nested iterables.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    # Using a set comprehension to create a set from all elements in the nested iterables\n    return {item for sublist in nested_list for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten a list of tuples or lists into a single set of numbers.\n\n    This function takes an iterable where each element is an iterable of numbers \n    and returns a set containing all unique numbers from those iterables.\n\n    Args:\n    nested_list (list of list/tuple): A list containing iterables of numbers.\n\n    Returns:\n    set: A set with all unique numbers extracted from the nested list.\n\n    Examples:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    # Using a set comprehension to flatten and deduplicate the nested lists/tuples\n    return {num for inner_list in nested_list for num in inner_list}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flattens a list of iterables into a single set of numbers.\n\n    This function takes a list containing various iterables (like tuples or lists)\n    and returns a set containing all unique numbers found within these iterables.\n\n    Args:\n    nested_list (list): A list where each element is an iterable of numbers.\n\n    Returns:\n    set: A set containing all the unique numbers from the nested structures.\n\n    Example:\n    >>> assert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    flat_set = set()\n    \n    # Iterate through each item in the nested list\n    for item in nested_list:\n        # Since item can be any iterable (tuple, list, set), we extend our set with all elements\n        # from this iterable. Using |= for in-place union operation to add items from item to flat_set\n        flat_set |= set(item)\n    \n    return flat_set", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n    nested_list (list): A list containing tuples or lists of numbers.\n\n    Returns:\n    set: A set containing all numbers from the nested structures.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    # Convert all tuples or lists to a flat list\n    flat_list = []\n    for item in nested_list:\n        if isinstance(item, (list, tuple)):\n            flat_list.extend(item)\n        else:\n            flat_list.append(item)\n    \n    # Return the set of unique numbers\n    return set(flat_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flattens a list of lists or tuples into a single set of numbers.\n\n    Args:\n    nested_list (list): A list containing lists or tuples of integers.\n\n    Returns:\n    set: A set containing all unique numbers from the nested lists or tuples.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    # Use a set comprehension to flatten and deduplicate numbers\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lists):\n    \"\"\"\n    Flattens a list of lists or tuples into a single set of numbers.\n\n    This function takes an iterable where each item can be another iterable \n    (like lists or tuples) and flattens all nested iterables into one single \n    set of unique numbers.\n\n    Parameters:\n    lists (iterable): An iterable containing iterables of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the nested iterables.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    result = set()\n    for iterable in lists:\n        # Flatten each iterable by extending the set with its elements\n        result.update(iterable)\n    return result", "matching_cluster_idx": 7}, {"solution": "def extract_singly(lists):\n    \"\"\"\n    Flatten a list of tuples into a single set of unique numbers.\n\n    Args:\n    lists (list of tuples): A list where each element is a tuple of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the tuples.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    # Use a set comprehension to gather all numbers in one set\n    return {num for tup in lists for num in tup}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Flattens a list of tuples into a single set of numbers.\n\n    This function takes a list where each item is a tuple of numbers,\n    flattens this structure into a one-dimensional collection, and then\n    converts it into a set to remove any duplicates.\n\n    Args:\n    list_of_tuples (list of tuples): A list containing tuples of numbers.\n\n    Returns:\n    set: A set containing unique numbers from all tuples.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    set([3, 4, 5, 7, 1])\n    \"\"\"\n    # Use a set comprehension to flatten and unique the numbers\n    return set(number for tuple_item in list_of_tuples for number in tuple_item)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n    nested_list (list): A list containing nested iterable of numbers.\n\n    Returns:\n    set: A set of all numbers from the nested structures, removing any duplicates.\n\n    Examples:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    # Use set comprehension for efficiency, flattening all elements into one set\n    return {num for inner_iter in nested_list for num in (inner_iter if isinstance(inner_iter, (list, tuple)) else [inner_iter])}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_lists):\n    \"\"\"\n    Flatten the list of lists or tuples into a single set of numbers.\n\n    Args:\n    nested_lists (list of list/tuple): A list containing inner lists or tuples of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the nested structures.\n\n    Example:\n    >>> assert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])\n    \"\"\"\n    # Use a set comprehension to flatten the nested structures and ensure uniqueness\n    return {num for sublist in nested_lists for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_lists):\n    \"\"\"\n    Flatten a list of tuples/lists into a single set of numbers.\n\n    Args:\n    nested_lists (list): A list containing tuples or lists of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the nested lists.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    # Using a set comprehension to get all unique numbers\n    return {num for sublist in nested_lists for num in sublist}", "matching_cluster_idx": 5}]}, "Mbpp/141": {"dps": 70.9297052154195, "dps_norm": 42.5, "pass@1": 88.0, "profiled": [{"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort the given list using the pancake sort algorithm.\n    \n    Pancake sort works by repeatedly finding the maximum element in the unsorted portion\n    of the array, flipping it to the beginning, and then flipping it to its correct position.\n    \n    Args:\n    arr (list): List of elements to be sorted.\n\n    Returns:\n    list: A new sorted list containing the elements from the original list.\n\n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    def flip(arr, k):\n        # Flip the first k elements of the list\n        arr[:k] = arr[:k][::-1]\n    \n    # Start with the full list and work down\n    for i in range(len(arr), 1, -1):\n        # Find the index of the maximum element in unsorted portion\n        max_index = arr.index(max(arr[:i]))\n        \n        # If the max element is not at the end, move it there\n        if max_index != i - 1:\n            if max_index != 0:\n                # Flip the max to the beginning\n                flip(arr, max_index + 1)\n            # Now flip it to the end\n            flip(arr, i)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n    \n    Pancake sort works by repeatedly reversing prefixes of the list to move the largest \n    unsorted element to its correct position from the back.\n\n    :param arr: List of integers to sort\n    :return: Sorted list in ascending order\n\n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"Reverse the first k elements of the array.\"\"\"\n        arr[:k] = arr[:k][::-1]\n\n    n = len(arr)\n    # Start from the complete array and go down to the second element\n    for i in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_index = arr.index(max(arr[:i]))\n        # If the max element isn't already at the end\n        if max_index != i-1:\n            # First, flip the max element to the beginning\n            if max_index != 0:\n                flip(arr, max_index + 1)\n            # Then, flip it to its correct position\n            flip(arr, i)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Implements the Pancake Sort algorithm to sort a list of integers.\n    This function sorts the list by repeatedly finding the maximum element\n    from the unsorted part of the array, bringing it to the top, then flipping\n    the array to push this element to its correct position.\n\n    Args:\n    arr (list): List of integers to be sorted.\n\n    Returns:\n    list: A new list with the integers sorted in ascending order.\n\n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    def flip(arr, k):\n        # Helper function to reverse the first k elements of arr\n        for i in range(k // 2):\n            arr[i], arr[k-i-1] = arr[k-i-1], arr[i]\n\n    n = len(arr)\n    while n > 1:\n        # Find index of the maximum element in the unsorted part\n        max_index = arr.index(max(arr[:n]))\n        \n        # If the max element is not at n-1, we need to move it there\n        if max_index != n - 1:\n            # First, flip the max element to the beginning\n            flip(arr, max_index + 1)\n            # Then flip the entire unsorted part to put max at n-1\n            flip(arr, n)\n        \n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        \"\"\"Helper function to reverse elements up to index k.\"\"\"\n        left = 0\n        while left < k:\n            arr[left], arr[k] = arr[k], arr[left]\n            left += 1\n            k -= 1\n\n    def find_max(arr, n):\n        \"\"\"Find the index of the maximum element in arr from index 0 to n.\"\"\"\n        max_index = 0\n        for i in range(n + 1):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        return max_index\n\n    # Start from the complete array and one by one \n    # reduce current size by one \n    current_size = len(arr) - 1\n    while current_size > 0:\n        # Find index of the maximum element in arr[0..current_size]\n        max_index = find_max(arr, current_size)\n        \n        # If the max element is not at the end of the array, then we need to move it to the end\n        if max_index != current_size:\n            # Flip max element to the beginning\n            if max_index != 0:\n                flip(arr, max_index)\n            # Flip the whole array to put the max element at the end\n            flip(arr, current_size)\n        \n        # Reduce current size by 1, as the largest element is now at its correct position\n        current_size -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort the given list using the pancake sort algorithm.\n    \n    This algorithm works by repeatedly flipping the largest element\n    to the top of the stack and then flipping it to its correct position.\n\n    :param arr: List to be sorted\n    :return: Sorted list\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"Helper function to reverse the elements up to index k.\"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    # Current size of the list (or portion to be sorted)\n    current_size = len(arr)\n    \n    # Start from the complete array and one by one reduce current size by one\n    while current_size > 1:\n        # Find index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[:current_size]))\n        \n        # If the max element is not already at the end\n        if max_index != current_size - 1:\n            # Move max to beginning if not already there\n            if max_index != 0:\n                flip(arr, max_index + 1)\n            # Now move the max at the end of the considered part\n            flip(arr, current_size)\n        \n        # Reduce the problem size\n        current_size -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse a portion of the list\n    def flip(arr, k):\n        left = 0\n        while left < k:\n            arr[left], arr[k] = arr[k], arr[left]\n            left += 1\n            k -= 1\n    \n    # Start from the complete array and one by one reduce current size by one\n    n = len(arr)\n    for i in range(n, 1, -1):\n        # Find the maximum element in arr[0..i-1]\n        max_index = arr.index(max(arr[:i]))\n        \n        # If the max element is not at the end, move it there\n        if max_index != i - 1:\n            # First, flip max element to the beginning\n            flip(arr, max_index)\n            # Now flip the max element to its correct position at i-1\n            flip(arr, i - 1)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of numbers in ascending order using the Pancake Sort algorithm.\n    \n    :param arr: List of integers to be sorted\n    :return: Sorted list in ascending order\n    \n    The Pancake Sort algorithm works by repeatedly flipping the entire list or part of the list \n    until it is sorted. Here's how it works:\n    1. Find the largest unsorted element in the array.\n    2. Flip the whole array up to this element to bring it to the beginning.\n    3. Flip the array again so that the largest element is at its final position.\n    4. Repeat the process for the remaining unsorted portion of the list.\n\n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    if not arr:\n        return arr  # Return if the list is empty\n    \n    # Helper function to reverse a portion of the list\n    def flip(arr, k):\n        start = 0\n        while start < k:\n            arr[start], arr[k] = arr[k], arr[start]\n            start += 1\n            k -= 1\n    \n    for size in range(len(arr), 1, -1):\n        # Find the index of the max element in the unsorted part\n        max_index = arr.index(max(arr[:size]))\n        if max_index != size - 1:\n            # Flip the list up to max element to bring it to the front\n            flip(arr, max_index)\n            # Flip the sorted portion to place the max at its correct position\n            flip(arr, size - 1)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Implement the pancake sort algorithm to sort a list of integers in ascending order.\n    \n    This function uses the pancake sort algorithm where:\n    - It repeatedly finds the maximum element, moves it to the top with a flip,\n    - then moves it to its correct position at the bottom with another flip.\n    \n    Args:\n    arr (list): The list to be sorted.\n    \n    Returns:\n    list: The sorted list in ascending order.\n    \n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"Flip the first k elements of the list.\"\"\"\n        start = 0\n        while start < k:\n            arr[start], arr[k] = arr[k], arr[start]\n            start += 1\n            k -= 1\n\n    for curr_size in range(len(arr) - 1, 0, -1):\n        # Find index of the maximum element in arr[0..curr_size]\n        max_index = arr.index(max(arr[:curr_size+1]))\n        \n        # If max element is not at the end\n        if max_index != curr_size:\n            # First flip up to the max element\n            if max_index > 0:\n                flip(arr, max_index)\n            # Now flip to bring max to the end\n            flip(arr, curr_size)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n    \n    The pancake sort works by repeatedly reversing part of the list to move\n    the largest (or smallest) unsorted element to its final position.\n    \n    Args:\n    arr (list): The list to be sorted.\n    \n    Returns:\n    list: A new list with the elements sorted in ascending order.\n    \n    Examples:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"Helper function to reverse the first k elements of a list.\"\"\"\n        arr[:k] = arr[:k][::-1]\n        return arr\n\n    current_size = len(arr)\n    # Start from the complete array and one by one reduce current size by one\n    while current_size > 1:\n        # Find index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[:current_size]))\n        \n        # If the max is not at the end, bring it to the end by flipping twice\n        if max_index != current_size - 1:\n            # Flip max element to beginning\n            flip(arr, max_index + 1)\n            # Now flip the maximum element to its correct position at the end\n            flip(arr, current_size)\n        \n        current_size -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n    \n    The pancake sort algorithm works by repeatedly finding the largest unsorted \n    element, bringing it to the front of the list, and then flipping the portion \n    of the list to put this element in its final position at the end.\n\n    Args:\n    arr (List[int]): The list of integers to be sorted.\n\n    Returns:\n    List[int]: A new list with elements sorted in ascending order.\n\n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    # If the list is already sorted, return it\n    if arr == sorted(arr):\n        return arr\n\n    def flip(sub_list, k):\n        \"\"\"Helper function to reverse the first k elements of sub_list.\"\"\"\n        return sub_list[:k][::-1] + sub_list[k:]\n\n    n = len(arr)\n    for i in range(n):\n        # Find the maximum element in the unsorted part of the list\n        max_idx = arr.index(max(arr[:n-i]))\n        # If the maximum element is already at the end of the unsorted part, skip\n        if max_idx == n-i-1:\n            continue\n        # Bring the max element to the front by flipping\n        if max_idx != 0:\n            arr = flip(arr, max_idx+1)\n        # Move the max element to its final position by flipping all elements up to that position\n        arr = flip(arr, n-i)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Perform a pancake sort on the given list of elements.\n    \n    Pancake sort works by repeatedly finding the maximum element from the unsorted part,\n    flipping it to the beginning, and then flipping the portion from the beginning \n    to that element's index to put it at its correct position at the end.\n\n    Args:\n    arr (list): The list to be sorted.\n\n    Returns:\n    list: A sorted list of elements.\n\n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    def flip(sublist, k):\n        # Helper function to reverse the first k elements of sublist\n        i = 0\n        while i < k - 1:\n            sublist[i], sublist[k-1] = sublist[k-1], sublist[i]\n            i += 1\n            k -= 1\n\n    # Start from the complete array and one by one reduce current size by one\n    for curr_size in range(len(arr), 1, -1):\n        # Find index of the maximum element in arr[0..curr_size-1]\n        max_index = arr.index(max(arr[:curr_size]))\n        \n        # If the max element is not at the end, flip it to the beginning\n        if max_index != curr_size - 1:\n            # First flip max to the beginning\n            flip(arr, max_index + 1)\n            # Then flip max to its correct position\n            flip(arr, curr_size)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list in ascending order using the pancake sort algorithm.\n    \n    This function performs an in-place sorting where the largest unsorted element\n    is repeatedly brought to the end through a series of 'flip' operations.\n    \n    :param arr: List of comparable elements to be sorted.\n    :return: Sorted list in ascending order.\n    \"\"\"\n    # Get the length of the list\n    n = len(arr)\n    \n    # Start from the end of the list to the beginning\n    for i in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_index = arr.index(max(arr[:i]))\n        \n        # If the max element is not at the end of this unsorted portion\n        if max_index != i-1:\n            # Flip the max element to the beginning if necessary\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Flip the entire unsorted portion to put the max at the end\n            arr = flip(arr, i)\n    \n    return arr\ndef flip(arr, k):\n    \"\"\"\n    Flips the subarray up to index k-1 inclusive.\n    \n    :param arr: List to be modified.\n    :param k: Index until which to flip the list.\n    :return: Modified list after flipping.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts the given list using the pancake sort algorithm.\n    \n    The pancake sort algorithm works by repeatedly finding the maximum element \n    in the unsorted portion of the array, flipping it to the beginning of the \n    array, and then flipping it to its correct position at the end of the sorted portion.\n\n    Parameters:\n    arr (list): The list to be sorted.\n\n    Returns:\n    list: A new sorted list.\n\n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    def flip(arr, k):\n        left = 0\n        while left < k:\n            arr[left], arr[k] = arr[k], arr[left]\n            left += 1\n            k -= 1\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the array\n        max_index = arr.index(max(arr[:n]))\n        if max_index != n - 1:\n            # If the maximum element is not at the end, flip it to the front\n            if max_index != 0:\n                flip(arr, max_index)\n            # Flip the whole unsorted part to get the max at the right position\n            flip(arr, n - 1)\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n    \n    Pancake sort works by repeatedly flipping the largest unsorted pancake (element) \n    to the top and then flipping it down to its correct position.\n\n    :param arr: List of integers to be sorted\n    :return: Sorted list of integers\n    \"\"\"\n    \n    # Function to reverse the sublist from 0 to k\n    def flip(k):\n        start = 0\n        while start < k:\n            arr[start], arr[k] = arr[k], arr[start]\n            start += 1\n            k -= 1\n    \n    # Size of the current problem\n    size = len(arr)\n    \n    # Iterate through the array\n    for i in range(size, 1, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_index = arr.index(max(arr[:i]))\n        \n        # If max element is not at its position, we need to flip\n        if max_index != i - 1:\n            # First, flip the max element to the beginning\n            flip(max_index)\n            # Now flip it to the correct position from the beginning\n            flip(i - 1)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the Pancake Sort algorithm.\n\n    This method repeatedly brings the largest element to the top and then\n    reverses the first part of the list to sort the largest element to the end.\n\n    :param arr: List of comparable elements to be sorted.\n    :return: Sorted list of elements.\n\n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    def flip(arr, k):\n        # Helper function to reverse sub-list from start to k\n        left = 0\n        while left < k:\n            arr[left], arr[k] = arr[k], arr[left]\n            left += 1\n            k -= 1\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part\n        max_index = arr.index(max(arr[:n]))\n        \n        # If the max element is not already at the end\n        if max_index != n - 1:\n            # Flip the max element to the start if necessary\n            if max_index != 0:\n                flip(arr, max_index)\n            # Flip from the start to the end of the current unsorted part\n            flip(arr, n - 1)\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Perform pancake sorting on the input list.\n    \n    Pancake sort works by repeatedly flipping over the largest unsorted pancake\n    (element) to the top of the list, then flipping it down to its correct position.\n    \n    Args:\n    arr (list): A list of elements to be sorted.\n    \n    Returns:\n    list: Sorted list in ascending order.\n    \n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    def flip(arr, k):\n        # Flip the first k elements of the list\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find index of the maximum element in arr[0..n-1]\n        max_index = arr.index(max(arr[:n]))\n        if max_index != n-1:\n            # First, flip the maximum element to the beginning\n            flip(arr, max_index + 1)\n            # Then, flip the entire part to put the maximum at its correct position\n            flip(arr, n)\n        n -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n    \n    Pancake sort works by repeatedly reversing part of the array to move the largest\n    unsorted element to the end of the list.\n\n    Args:\n    arr (list): The list of integers to be sorted.\n\n    Returns:\n    list: A new sorted list of integers.\n\n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    \n    def flip(arr, k):\n        # Helper function to reverse the first k elements of the list\n        for i in range(k // 2):\n            arr[i], arr[k - i - 1] = arr[k - i - 1], arr[i]\n    \n    # Start with the entire list length\n    current_size = len(arr)\n    \n    # We continue sorting until the sorted portion grows to the full list\n    while current_size > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_index = arr.index(max(arr[:current_size]))\n        \n        # If the max element isn't at the end of the current unsorted list, we need to flip it\n        if max_index != current_size - 1:\n            # Bring the maximum element to the top by flipping to max_index + 1\n            if max_index != 0:\n                flip(arr, max_index + 1)\n            # Now flip the maximum to the end of the unsorted portion\n            flip(arr, current_size)\n        \n        current_size -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array in ascending order using the Pancake Sorting algorithm.\n    \n    Pancake Sorting is based on the following idea:\n    - Find the maximum element in the unsorted part of the array.\n    - If it's not already at the end, bring it to the beginning by flipping up to the first element,\n      then flip it to the end with a flip up to the current end of the unsorted part.\n\n    Args:\n    arr (list): The list of integers to be sorted.\n\n    Returns:\n    list: The sorted list in ascending order.\n\n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    def flip(arr, k):\n        # Flip the array up to index k\n        left, right = 0, k\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the max element in the unsorted part\n        max_index = arr.index(max(arr[:n]))\n        \n        # If the max element is not at the end of the unsorted part\n        if max_index != n - 1:\n            # First flip up to the maximum element\n            if max_index != 0:\n                flip(arr, max_index)\n            # Flip the max element to the end\n            flip(arr, n - 1)\n        n -= 1  # Reduce the size of the unsorted part\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list in ascending order using the pancake sort algorithm.\n    \n    This function repeatedly brings the largest unsorted element to the \n    top of the list, then flips the entire list to place this element \n    in its correct position at the bottom. \n\n    Args:\n    arr (list): The list to be sorted.\n\n    Returns:\n    list: The sorted list in ascending order.\n\n    Example:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n    def flip(sublist, k):\n        \"\"\"Helper function to flip the first k elements of a sublist.\"\"\"\n        return sublist[k::-1] + sublist[k+1:]\n    \n    n = len(arr)\n    while n > 1:\n        # Find index of the maximum element in the unsorted part\n        max_index = arr.index(max(arr[:n]))\n        if max_index != n - 1:\n            # If the max element is not at the end, flip it to the start\n            arr = flip(arr, max_index)\n            # Flip the entire list to put the max at its final position\n            arr = flip(arr, n - 1)\n        n -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        \"\"\"Helper function to flip (reverse) the first k elements in the list.\"\"\"\n        for i in range(k // 2):\n            arr[i], arr[k - i - 1] = arr[k - i - 1], arr[i]\n    \n    # Start from the complete array and one by one reduce current size by one\n    current_size = len(arr)\n    while current_size > 1:\n        # Find index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[:current_size]))\n        \n        # If the max element is not at the end already\n        if max_index != current_size - 1:\n            # Move max to the beginning\n            flip(arr, max_index + 1)\n            # Flip it to its correct position\n            flip(arr, current_size)\n        \n        # Reduce size of list to be sorted by one\n        current_size -= 1\n    \n    return arr", "matching_cluster_idx": 2}]}, "Mbpp/166": {"dps": 87.63999999999999, "dps_norm": 67.5, "pass@1": 93.0, "profiled": [{"solution": "def find_even_pair(numbers):\n    count = 0\n    n = len(numbers)\n    \n    # Iterate through all possible pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the XOR of two numbers is even\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Count the number of pairs of integers in the list that XOR to an even number.\n    \n    This function uses the property that two numbers XOR to an even number if they are either\n    both even or both odd. Since XOR of two even numbers or two odd numbers results in an even number.\n\n    :param numbers: List of integers to check for pairs\n    :return: Integer count of pairs that XOR to even\n\n    Examples:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    count = 0\n    length = len(numbers)\n    \n    # Count even and odd numbers in the list\n    even_count = sum(1 for x in numbers if x % 2 == 0)\n    odd_count = length - even_count\n    \n    # XOR of even number with even or odd with odd always results in even\n    # Total pairs are n*(n-1)/2, where n is either count of even or odd numbers\n    count += (even_count * (even_count - 1)) // 2\n    count += (odd_count * (odd_count - 1)) // 2\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in the list where the XOR operation results in an even number.\n    \n    An XOR operation results in an even number if both numbers are either:\n    - Both odd or\n    - Both even\n    \n    Args:\n    numbers (list of int): A list of integers to check for pairs.\n\n    Returns:\n    int: The count of pairs that XOR to an even number.\n\n    Example:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    count = 0\n    # A number XOR another number results in an even number if and only if they have the same parity\n    # Count odd numbers since an even result means they must both be even or both be odd\n    odd_count = sum(1 for num in numbers if num % 2 != 0)\n    even_count = len(numbers) - odd_count\n    \n    # Number of pairs from odd numbers\n    # Since they must be paired with another odd to make even, we're choosing 2 from odd_count\n    count += odd_count * (odd_count - 1) // 2  # n choose 2\n    \n    # Number of pairs from even numbers\n    # Any pair of even numbers XOR to zero, which is even\n    count += even_count * (even_count - 1) // 2\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in the list 'numbers' that XOR to an even number.\n\n    An XOR operation results in an even number if both operands are either:\n    - Both even (0 XOR 0 = 0)\n    - Both odd  (1 XOR 1 = 0)\n\n    Since XOR of two numbers is even when they have the same parity, this function\n    will count:\n    - All pairs where both numbers are even (even, even) -> Even result\n    - All pairs where both numbers are odd (odd, odd) -> Even result\n\n    Args:\n    numbers (list): A list of integers\n\n    Returns:\n    int: The number of pairs in the list that XOR to an even number.\n\n    Examples:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    # Count of even and odd numbers in the list\n    even_count = sum(1 for num in numbers if num % 2 == 0)\n    odd_count = len(numbers) - even_count\n\n    # Number of even pairs = (even choose 2) + (odd choose 2)\n    even_pairs = even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2\n    \n    return even_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Count the number of pairs of integers in the list that XOR to an even number.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The count of pairs that XOR to an even number.\n\n    Example:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    # Initialize count\n    even_pair_count = 0\n\n    # We'll use nested loops to consider each pair exactly once\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # XOR of two numbers will be even if both are even or both are odd\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                even_pair_count += 1\n\n    return even_pair_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Count the number of pairs of integers in nums where their XOR is even.\n    \n    An XOR operation results in an even number if and only if both operands\n    are either both even or both odd.\n    \n    Args:\n    nums (List[int]): A list of integers to check for pairs.\n\n    Returns:\n    int: The count of pairs that XOR to an even number.\n\n    Example:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    # Initialize the counter for even XOR pairs\n    even_pair_count = 0\n    \n    # Use nested loops to check all possible pairs\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            # XOR the pair\n            xor_result = nums[i] ^ nums[j]\n            # Check if XOR result is even (least significant bit is 0)\n            if xor_result & 1 == 0:\n                even_pair_count += 1\n    \n    return even_pair_count", "matching_cluster_idx": 0}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The count of pairs whose XOR results in an even number.\n\n    Example:\n    >>> assert find_even_pair([5, 4, 7, 2, 1]) == 4\n    \"\"\"\n    def is_even(x):\n        return x % 2 == 0\n\n    count = 0\n    n = len(numbers)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR operation, if the result is even, increment count\n            if is_even(numbers[i] ^ numbers[j]):\n                count += 1\n\n    return count", "matching_cluster_idx": 0}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in the list where their XOR results in an even number.\n    \n    :param numbers: List of integers to check for pairs.\n    :return: Integer representing the count of even XOR pairs.\n    \n    Example:\n    >>> assert find_even_pair([5, 4, 7, 2, 1]) == 4\n    \"\"\"\n    # Even numbers have their least significant bit as 0, and odd numbers as 1\n    # The XOR of two numbers is even if both numbers are either odd or even\n    even_count = 0\n    odd_count = 0\n    total_pairs = 0\n    \n    for num in numbers:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # An even number XORed with an even number results in an even number\n    # An odd number XORed with an odd number also results in an even number\n    total_pairs += even_count * (even_count - 1) // 2  # Combinations of even numbers\n    total_pairs += odd_count * (odd_count - 1) // 2   # Combinations of odd numbers\n    \n    return total_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Count the number of pairs of integers in the list that XOR to an even number.\n    \n    An integer XORed with itself results in 0, which is even. Also, XORing an even number\n    with an odd number results in an odd number, while XORing two even numbers or two odd numbers\n    results in an even number.\n\n    :param numbers: List[int] - A list of integers to check for XOR pairs\n    :return: int - Number of pairs that XOR to an even number\n    \n    Examples:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    # Count of even and odd numbers in the list\n    even_count = sum(1 for n in numbers if n % 2 == 0)\n    odd_count = len(numbers) - even_count\n    \n    # Each pair of even numbers or odd numbers will produce an even result when XORed\n    # Number of even-even pairs + odd-odd pairs\n    return (even_count * (even_count - 1)) // 2 + (odd_count * (odd_count - 1)) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in the given list that XOR to an even number.\n\n    An integer is even if its least significant bit is 0. When you XOR two numbers:\n    - If both numbers have their LSB as 0 or 1, the result will be even (0).\n    - If one has LSB 0 and the other 1, the result will be odd (1).\n    \n    Therefore, we can simply count all pairs where both numbers have the same \n    least significant bit, which is equivalent to having the same parity.\n\n    Args:\n    numbers (list): List of integers to check.\n\n    Returns:\n    int: The count of pairs that XOR to an even number.\n\n    Examples:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    for num in numbers:\n        if num & 1 == 0:  # Check if number is even (LSB is 0)\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # All even numbers XOR with all even numbers result in even\n    # and all odd numbers with all odd numbers result in even too.\n    return (even_count * (even_count - 1)) // 2 + (odd_count * (odd_count - 1)) // 2", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(arr):\n    count = 0\n    n = len(arr)\n    \n    # Using nested loops to compare each pair of elements\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR operation, the result is even if both numbers are even or odd\n            if not (arr[i] ^ arr[j]) & 1:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # XOR of two numbers is even if both numbers are either even or both are odd\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs in the list where the XOR of two numbers results in an even number.\n    \n    An XOR operation results in an even number when both operands are either both odd or both even.\n    This function uses this property to reduce the time complexity from O(n^2) to O(n) by counting\n    odd and even numbers.\n\n    :param numbers: List[int], a list of integers\n    :return: int, number of pairs whose XOR is even\n\n    Examples:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    >>> find_even_pair([1, 2, 3, 4, 5, 6])\n    15\n    \"\"\"\n    # Initialize counters for even and odd numbers\n    odd_count = sum(1 for n in numbers if n % 2 == 1)\n    even_count = len(numbers) - odd_count\n    \n    # Any number XOR itself is 0 (even), so we need to subtract these self-pairs\n    # Also, even XOR even or odd XOR odd will be even, hence we combine these counts\n    return (odd_count * (odd_count - 1) // 2) + (even_count * (even_count - 1) // 2)", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(arr):\n    \"\"\"\n    Counts the number of pairs of integers in the list that xor to an even number.\n    \n    The XOR operation results in an even number if:\n    - Both numbers are even\n    - Both numbers are odd\n    \n    Since even XOR even is even and odd XOR odd is even, this function \n    counts these pairs.\n\n    Args:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The count of pairs where XOR results in an even number.\n\n    Example:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    count = 0\n    n = len(arr)\n    \n    # Count of odd and even numbers\n    even_count = sum(1 for x in arr if x % 2 == 0)\n    odd_count = n - even_count\n    \n    # Count pairs of even numbers\n    count += even_count * (even_count - 1) // 2  # nC2 for even numbers\n    \n    # Count pairs of odd numbers\n    count += odd_count * (odd_count - 1) // 2  # nC2 for odd numbers\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The count of pairs where the XOR result is even.\n\n    Examples:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    # A number is even if the least significant bit is 0, which is also true for XOR\n    # if both numbers have the same parity (both even or both odd)\n    count = 0\n    \n    # We need to compare each number with every other number after it in the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # If the XOR of two numbers is even, then their least significant bits must be the same\n            # This is equivalent to checking if (a ^ b) & 1 == 0, but we can simply check if the numbers are of the same parity\n            if numbers[i] % 2 == numbers[j] % 2:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs in the list where the XOR result is an even number.\n    \n    :param numbers: List of integers\n    :return: Integer count of pairs with even XOR result\n\n    Here, XOR results in an even number if:\n    - Both numbers are even\n    - Both numbers are odd\n    Because XOR of even numbers with any number does not change parity.\n\n    Example:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    count = 0\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR of two numbers is even if both are even or both are odd\n            if numbers[i] % 2 == numbers[j] % 2:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    \"\"\"\n    Count the number of pairs of integers in the array that XOR to an even number.\n    \n    Args:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The count of pairs where XOR results in an even number.\n    \n    Example:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):  # Ensure each pair is counted only once\n            # XOR of two numbers is even if both numbers have the same parity (both even or both odd)\n            if (arr[i] % 2) == (arr[j] % 2): \n                count += 1\n    \n    # Note: The assertion would need an explanation or an adjustment in this function since \n    # the result might differ based on how you count pairs:\n    # - This function counts each pair once, but assert seems to count each pair twice.\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR operation results in even when both numbers are even or both are odd\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    :param lst: List of integers\n    :return: Integer count of pairs where (x ^ y) % 2 == 0\n\n    Example:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    \"\"\"\n    # Initialize counter for even XOR pairs\n    even_count = 0\n    \n    # Loop through all possible pairs\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # If XOR of two numbers is even, then:\n            # 1. Both numbers are even\n            # 2. Both numbers are odd\n            # Even numbers XOR to 0 (even), and odd numbers XOR to 0 (even)\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_count += 1\n    \n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs in the list where the XOR of the pair results in an even number.\n    \n    Args:\n    nums (list of int): List of integers to check.\n\n    Returns:\n    int: Number of pairs whose XOR is even.\n\n    Examples:\n    >>> find_even_pair([5, 4, 7, 2, 1])\n    4\n    >>> find_even_pair([1, 2, 3, 4])\n    4\n    \"\"\"\n    count = 0\n    \n    # We'll count pairs where either both numbers are even or both are odd\n    # since (even ^ even) or (odd ^ odd) results in an even number\n    even_count = sum(1 for num in nums if num % 2 == 0)\n    odd_count = len(nums) - even_count\n    \n    # Count even pairs\n    count += even_count * (even_count - 1) // 2  # number of ways to choose 2 from n even numbers\n    \n    # Count odd pairs\n    count += odd_count * (odd_count - 1) // 2  # number of ways to choose 2 from n odd numbers\n\n    return count", "matching_cluster_idx": 3}]}, "Mbpp/170": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/226": {"dps": 98.4108527131783, "dps_norm": 95.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters at odd index values from the given string.\n\n    This function iterates over the string with a step of 2, effectively\n    selecting characters at even indices (0-based indexing).\n\n    Parameters:\n    s (str): The input string to process.\n\n    Returns:\n    str: A new string with only the characters from even indices of the original string.\n\n    Examples:\n    >>> odd_values_string('abcdef')\n    'ace'\n    >>> odd_values_string('python')\n    'pto'\n    \"\"\"\n    # Use string slicing to get characters at even positions\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters at odd index positions in the given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: A string with only characters from even index positions of the original string.\n    \n    Examples:\n    >>> odd_values_string('abcdef')\n    'ace'\n    \"\"\"\n    # Use string slicing to keep characters at even indices (0, 2, 4, ...)\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from a string which are at odd index positions.\n\n    Args:\n    s (str): The input string to process.\n\n    Returns:\n    str: A new string containing only the characters from even indices.\n\n    Examples:\n    >>> odd_values_string('abcdef')\n    'ace'\n    >>> odd_values_string('python')\n    'pto'\n    \"\"\"\n    # Use string slicing with a step of 2 to get characters at even indices\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters at odd index values from the given string.\n\n    This function takes a string and returns a new string where all characters\n    at positions with odd index values are removed. Indexing starts from 0, so\n    the first character has an even index.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with only characters from even indices of the original string.\n\n    Examples:\n    >>> odd_values_string('abcdef')\n    'ace'\n    >>> odd_values_string('python')\n    'pto'\n    \"\"\"\n    # Use string slicing to get characters at even indices [start:end:step]\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string which are at odd index positions.\n\n    This function takes a string and returns a new string that only includes \n    characters at even indices (0, 2, 4, ...).\n\n    Parameters:\n    s (str): The input string to process.\n\n    Returns:\n    str: A string containing only the characters at even indices of the input.\n\n    Examples:\n    >>> odd_values_string('abcdef')\n    'ace'\n    >>> odd_values_string('computer')\n    'cmptr'\n    \"\"\"\n    # Use list comprehension to select characters at even indices\n    return ''.join([char for i, char in enumerate(s) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters at odd index positions from the input string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \n    Example:\n    >>> odd_values_string('abcdef')\n    'ace'\n    \"\"\"\n    # Use string slicing to get only even indexed characters\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove the characters which have odd index values from the given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: A string consisting of characters at even indices in the original string.\n    \n    Examples:\n    >>> odd_values_string('abcdef')\n    'ace'\n    >>> odd_values_string('12345')\n    '135'\n    \"\"\"\n    # Use string slicing with a step of 2 to get every other character starting from index 0\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string `s` that are at odd index positions.\n    \n    This function iterates over the string, selecting only characters at even indices.\n    This effectively removes every character at an odd index.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with only the characters from even index positions in the original string.\n\n    Examples:\n    >>> odd_values_string('abcdef')\n    'ace'\n    >>> odd_values_string('python')\n    'pto'\n    \"\"\"\n    # Use string slicing to get characters at even indices (step of 2)\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters at odd index positions from the given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \n    Example:\n    >>> odd_values_string('abcdef')\n    'ace'\n    \"\"\"\n    # Use string slicing with a step of 2 to get even index characters\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the given string that are at odd index positions.\n    \n    Args:\n    s (str): The input string to be processed.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n\n    Example:\n    >>> odd_values_string('abcdef')\n    'ace'\n    \"\"\"\n    # Use string slicing to keep only even-indexed characters\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters at odd index positions in the given string.\n\n    This function iterates through the string with a step of 2, \n    effectively selecting only characters at even indices (0, 2, 4, etc.).\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters from odd positions removed.\n\n    Example:\n    >>> odd_values_string('abcdef')\n    'ace'\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s: str) -> str:\n    \"\"\"\n    Remove characters with odd index values from the given string.\n\n    This function goes through the string and only keeps characters\n    that have an even index, thus removing all characters at odd indices.\n\n    Args:\n        s (str): The input string to process.\n\n    Returns:\n        str: A new string containing only characters with even indices from the original string.\n\n    Raises:\n        TypeError: If the input is not a string.\n\n    Examples:\n        >>> odd_values_string('abcdef')\n        'ace'\n        >>> odd_values_string('Hello World')\n        'HloWrd'\n    \"\"\"\n    # Check if the input is a string\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Use string slicing to get characters at even indices\n    # [start:end:step] where start defaults to 0, end to len(s), and step to 1.\n    # Here we use step of 2 to keep even indices\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string: str) -> str:\n    \"\"\"\n    Remove characters from the string at odd index positions.\n\n    This function iterates through the string, keeping only those characters \n    whose indices are even, effectively removing characters at odd indices.\n\n    Args:\n        input_string (str): The string from which characters will be removed.\n\n    Returns:\n        str: A new string with only the characters at even indices from the original string.\n\n    Example:\n        >>> odd_values_string('abcdef')\n        'ace'\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    # Check if the input is a string\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Use string slicing with a step of 2 to get even indexed characters\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that are at odd index positions.\n\n    This function iterates over the string in steps of 2, which effectively \n    skips all characters at odd indices.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with only characters from even indices.\n\n    Example:\n    >>> odd_values_string('abcdef')\n    'ace'\n    \"\"\"\n    # Use string slicing with step 2 to keep only even-indexed characters\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters at odd index values from the given string.\n    \n    Args:\n    s (str): The input string to process.\n    \n    Returns:\n    str: A new string where all characters at odd indices of the original string are removed.\n    \n    Example:\n    >>> odd_values_string('abcdef')\n    'ace'\n    \"\"\"\n    # Use string slicing to get characters at even indices (0, 2, 4, ...)\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters at odd index positions from the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at even indices from the original string.\n\n    Example:\n    >>> odd_values_string('abcdef')\n    'ace'\n    \"\"\"\n    # Use string slicing with step 2 to select every even-indexed character\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters at odd index positions from the given string.\n    \n    This function iterates through the string, selecting only characters\n    at even index positions (0, 2, 4, etc.), effectively removing those\n    at odd positions.\n\n    Args:\n    s (str): The input string to be processed.\n\n    Returns:\n    str: A new string with characters from odd indexes removed.\n\n    Examples:\n    >>> odd_values_string('abcdef')\n    'ace'\n    \"\"\"\n    # Use string slicing with a step of 2 to keep only even indices\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(text):\n    \"\"\"\n    Remove the characters at odd index positions from the given string.\n\n    This function iterates through the string, selecting only characters\n    at even indices (0, 2, 4, ...), thus effectively removing characters\n    at odd positions.\n\n    Args:\n    text (str): The input string to process.\n\n    Returns:\n    str: A new string containing only the characters from even indices of the input.\n\n    Examples:\n    >>> odd_values_string('abcdef')\n    'ace'\n    >>> odd_values_string('123456789')\n    '13579'\n    \"\"\"\n    # Use string slicing with step 2 to keep only even indices\n    return text[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from a string that have odd index values.\n\n    This function iterates through the string, keeping only characters at even indices.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with only characters from even indices in the original string.\n\n    Examples:\n    >>> odd_values_string('abcdef')\n    'ace'\n    >>> odd_values_string('python')\n    'pto'\n    \"\"\"\n    # Using string slicing to get every second character starting from index 0\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters at odd index positions from the given string.\n\n    This function constructs a new string by concatenating characters\n    from the input string `s` at even index positions.\n\n    Args:\n    s (str): The input string from which to remove characters.\n\n    Returns:\n    str: A new string containing only the characters from even indices.\n\n    Examples:\n    >>> odd_values_string('abcdef')\n    'ace'\n    >>> odd_values_string('python')\n    'pto'\n    \"\"\"\n    # Use string slicing with a step of 2 to get even index characters\n    return s[::2]", "matching_cluster_idx": 6}]}, "Mbpp/230": {"dps": 96.5079365079365, "dps_norm": 98.75, "pass@1": 97.0, "profiled": [{"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the given string with the specified character.\n\n    Args:\n    s (str): The input string to modify.\n    char (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by the character.\n\n    Examples:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    >>> replace_blank(\"  too  many  spaces  \", '-')\n    '--too--many--spaces--'\n    \"\"\"\n    # Replace all spaces with the given character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the given string with the specified character.\n\n    Args:\n        input_string (str): The string to modify.\n        char (str): A single character to replace spaces with.\n\n    Returns:\n        str: A new string with all spaces replaced by the character.\n\n    Raises:\n        ValueError: If 'char' is not a single character.\n\n    Example:\n        >>> replace_blank(\"hello people\", \"@\")\n        'hello@people'\n    \"\"\"\n    # Check if char is indeed a single character\n    if len(char) != 1:\n        raise ValueError(\"The second argument must be a single character.\")\n    \n    # Use str.replace method to replace all spaces with char\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the given string with the specified character.\n\n    Args:\n    s (str): The input string where spaces are to be replaced.\n    char (str): The character to replace spaces with. Should be a single character.\n\n    Returns:\n    str: A new string where spaces are replaced by the given character.\n\n    Raises:\n    ValueError: If `char` is not a single character.\n\n    Examples:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    >>> replace_blank(\"  test  \", '_')\n    '__test__'\n    \"\"\"\n    if len(char) != 1:\n        raise ValueError(\"The replacement character must be a single character.\")\n    \n    # Use string replace method to replace spaces with the character\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string: str, replace_char: str) -> str:\n    \"\"\"\n    Replace all blank spaces in the input string with the given character.\n\n    Args:\n    input_string (str): The string to process.\n    replace_char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: A new string with spaces replaced by the replace_char.\n\n    Examples:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    >>> replace_blank(\"one two three\", '*')\n    'one*two*three'\n    \"\"\"\n    # Use the string's replace method to substitute spaces with the given character\n    return input_string.replace(\" \", replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replace_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    Args:\n    input_string (str): The string where spaces are to be replaced.\n    replace_char (str): The single character to replace spaces with.\n\n    Returns:\n    str: A new string with spaces replaced by the given character.\n\n    Raises:\n    ValueError: If replace_char is not a single character.\n\n    Examples:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    >>> replace_blank(\"  world  \", '_')\n    '__world__'\n    \"\"\"\n    # Check if the replace_char is a single character\n    if len(replace_char) != 1:\n        raise ValueError(\"Replacement character must be a single character.\")\n\n    # Replace spaces with the given character\n    return input_string.replace(' ', replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the given string with the provided character.\n\n    Args:\n    input_string (str): The string where spaces need to be replaced.\n    replacement_char (str): The character to replace spaces with.\n\n    Returns:\n    str: A new string where all spaces are replaced by the replacement character.\n\n    Examples:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    \"\"\"\n    # Replace all spaces in the string with the given character\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(sentence, char):\n    \"\"\"\n    Replaces blank spaces in the given sentence with the specified character.\n\n    Args:\n    sentence (str): The string where spaces are to be replaced.\n    char (str): The character to replace the spaces with.\n\n    Returns:\n    str: A string where all blank spaces are replaced with the specified character.\n\n    Raises:\n    ValueError: If the char argument is not a single character.\n\n    Example:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    \"\"\"\n    # Check if char is a single character\n    if len(char) != 1:\n        raise ValueError(\"The replacement must be a single character.\")\n\n    # Replace space with the provided character\n    return sentence.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    Args:\n    input_string (str): The original string which might contain spaces.\n    replacement_char (str): A single character to replace spaces with.\n\n    Returns:\n    str: A new string where blank spaces are replaced by the replacement_char.\n\n    Examples:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    \"\"\"\n    # Check if replacement_char is a single character\n    if len(replacement_char) != 1:\n        raise ValueError(\"The replacement must be a single character.\")\n    \n    # Replace spaces with the given character\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string: str, replacement_char: str) -> str:\n    \"\"\"\n    Replaces blank spaces in the string with the given character.\n\n    Args:\n    input_string (str): The string in which spaces are to be replaced.\n    replacement_char (str): A single character to replace spaces with.\n\n    Returns:\n    str: A new string with spaces replaced by the replacement character.\n\n    Raises:\n    ValueError: If replacement_char is not a single character.\n\n    Examples:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    >>> replace_blank(\"no spaces\", '*')\n    'nospaces'\n    \"\"\"\n    if len(replacement_char) != 1:\n        raise ValueError(\"The replacement character must be exactly one character long.\")\n    \n    # Use string's replace method to substitute spaces with the replacement character\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the given string with the specified character.\n\n    Args:\n    s (str): The string to process.\n    char (str): A single character to replace the spaces with.\n\n    Returns:\n    str: A new string where all spaces are replaced by the given character.\n\n    Raises:\n    ValueError: If 'char' is not a single character.\n\n    Example:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    \"\"\"\n    # Check if char is indeed a single character\n    if len(char) != 1:\n        raise ValueError(\"The replacement must be a single character.\")\n\n    # Replace spaces with the given character and return the result\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the given string with a specified character.\n\n    Args:\n    s (str): The input string where spaces need to be replaced.\n    char (str): The character to replace the spaces with.\n\n    Returns:\n    str: A new string with all spaces replaced by the specified character.\n\n    Raises:\n    ValueError: If the provided 'char' is not a single character.\n\n    Examples:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    >>> replace_blank(\"test   case\", '+')\n    'test+++case'\n    \"\"\"\n    # Check if char is a single character\n    if len(char) != 1:\n        raise ValueError(\"The second argument must be a single character.\")\n    \n    # Use string replace method to swap spaces with the character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all spaces in the given string with the specified character.\n\n    Args:\n    s (str): The input string where spaces need to be replaced.\n    char (str): The character to replace spaces with. Should be a single character.\n\n    Returns:\n    str: The modified string with spaces replaced by the given character.\n\n    Raises:\n    ValueError: If 'char' is not a single character.\n\n    Example:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    \"\"\"\n    # Check if 'char' is a single character\n    if len(char) != 1:\n        raise ValueError(\"The replacement character must be a single character.\")\n    \n    # Replace spaces with the provided character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, replace_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the given character.\n\n    Args:\n    text (str): The original string which might contain spaces.\n    replace_char (str): The character to replace spaces with.\n\n    Returns:\n    str: A new string where all blank spaces have been replaced by replace_char.\n\n    Example:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    \"\"\"\n    # Use the replace method of str to substitute spaces with the given character\n    return text.replace(' ', replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the given string with the specified character.\n\n    Args:\n    s (str): The string in which to replace spaces.\n    char (str): The character to replace spaces with. This should be a single character.\n\n    Returns:\n    str: The string with all spaces replaced by the given character.\n\n    Raises:\n    ValueError: If `char` is not a single character.\n\n    Examples:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    \"\"\"\n    if len(char) != 1:\n        raise ValueError(\"The character to replace spaces with must be a single character.\")\n    \n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replace all blank spaces in the given string with the specified character.\n\n    Args:\n    s (str): The input string which may contain blank spaces.\n    char (str): A single character to replace the blank spaces with.\n\n    Returns:\n    str: A new string where all blank spaces are replaced by the specified character.\n\n    Raises:\n    ValueError: If the char argument is not a single character.\n\n    Examples:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    \"\"\"\n    # Check if the char is actually a single character\n    if len(char) != 1:\n        raise ValueError(\"The 'char' argument must be a single character.\")\n\n    # Use a list comprehension to build the new string efficiently\n    return ''.join([char if c.isspace() else c for c in s])", "matching_cluster_idx": 5}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the string 's' with the specified 'char'.\n    \n    Args:\n    s (str): The input string which might contain blank spaces.\n    char (str): A single character that will replace each blank space in 's'.\n\n    Returns:\n    str: A new string with blank spaces replaced by 'char'.\n\n    Raises:\n    ValueError: If 'char' is not a single character.\n\n    Example:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    \"\"\"\n    # Check if char is indeed a single character\n    if len(char) != 1:\n        raise ValueError(\"The replacement must be a single character\")\n    \n    # Replace all occurrences of ' ' with char\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replace all spaces in the string with the given character.\n\n    Args:\n        s (str): The input string to process.\n        char (str): The character to replace spaces with. \n\n    Returns:\n        str: A string with all spaces replaced by the given character.\n\n    Raises:\n        ValueError: If 'char' is more than one character long.\n\n    Examples:\n        >>> replace_blank(\"hello people\", '@')\n        'hello@people'\n        >>> replace_blank(\"a b c d\", '+')\n        'a+b+c+d'\n    \"\"\"\n    # Check if the provided character is indeed a single character\n    if len(char) != 1:\n        raise ValueError(\"The replacement character must be a single character.\")\n\n    # Use string's replace method to replace all spaces\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces blank spaces in the input string with the specified character.\n\n    Args:\n    input_string (str): The original string to modify.\n    replacement_char (str): A single character to replace spaces with.\n\n    Returns:\n    str: A new string where spaces are replaced with replacement_char.\n\n    Raises:\n    ValueError: If replacement_char is not a single character.\n\n    Example:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    \"\"\"\n    # Ensure replacement_char is indeed one character\n    if len(replacement_char) != 1:\n        raise ValueError(\"Replacement character must be a single character.\")\n    \n    # Replace spaces with the character and return the modified string\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the given string with the specified character.\n\n    Args:\n    s (str): The original string that might contain spaces to replace.\n    char (str): A single character to replace spaces with.\n\n    Returns:\n    str: A new string where all spaces are replaced by the given character.\n\n    Examples:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    >>> replace_blank(\"  spaces   \", '#')\n    '##spaces###'\n    \"\"\"\n    # Check if the character argument is indeed a single character\n    if len(char) != 1:\n        raise ValueError(\"The character to replace spaces must be exactly one character long.\")\n    \n    # Replace all occurrences of space with the given character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the given string with a specified character.\n\n    Args:\n    s (str): The input string which might contain spaces to be replaced.\n    char (str): A single character to replace the blank spaces with.\n\n    Returns:\n    str: A new string with all spaces replaced by the given character.\n\n    Examples:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    >>> replace_blank(\"  world  \", '*')\n    '**world**'\n    \"\"\"\n    # Check if char is actually a single character\n    if len(char) != 1:\n        raise ValueError(\"The second argument must be a single character.\")\n    \n    # Use string's replace method to substitute spaces with the given character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 71.03448275862068, "dps_norm": 74.5, "pass@1": 39.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    # Define a helper function to count sequences ending at each number\n    def count_sequences(k, current_length):\n        if current_length == 1:\n            return 1  # Base case: one way to complete a sequence of length 1\n        \n        # If we can't double the current number or exceed m, we stop counting here\n        if k == 0 or 2 * k > m:\n            return 0\n        \n        total = 0\n        # For every possible next number, count sequences\n        for i in range(2*k, m+1):\n            total += count_sequences(i, current_length - 1)\n        return total\n\n    # Start from 1 and go up to m, sum all possible start numbers\n    return sum(count_sequences(k, n) for k in range(1, m+1))", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of sequences of length n where each element is a positive integer,\n    greater than or equal to twice the previous element but less than or equal to m.\n\n    :param m: The upper bound for each element in the sequence.\n    :param n: The length of the sequence.\n    :return: The total number of possible sequences.\n    \"\"\"\n    # Memoization dictionary to store computed results for different parameters\n    memo = {}\n\n    def dfs(prev, depth):\n        # Base case: if we've built a sequence of length n, we count it\n        if depth == n:\n            return 1\n        \n        # Key for memoization\n        key = (prev, depth)\n        if key in memo:\n            return memo[key]\n        \n        total = 0\n        # Start from twice the previous number or from 1 if there was no previous number\n        start = max(1, prev * 2) if prev else 1\n        \n        # Loop through possible numbers up to m\n        for current in range(start, m + 1):\n            total += dfs(current, depth + 1)\n        \n        # Store the result for this state to avoid recalculation\n        memo[key] = total\n        return total\n\n    # Start the DFS with no previous number and at depth 0\n    return dfs(0, 0)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of sequences of length n where each element x[i] \n    satisfies 2 * x[i-1] <= x[i] <= m.\n\n    :param m: Upper bound for each element in the sequence.\n    :param n: Length of the sequence.\n    :return: Total number of valid sequences.\n\n    Example:\n    >>> get_total_number_of_sequences(10, 4)\n    4\n    \"\"\"\n    # Base case: if n is 1, we can choose any number from 1 to m\n    if n == 1:\n        return m\n\n    # Initialize memoization dictionary to avoid redundant calculations\n    memo = {}\n    \n    def count_sequences(current_num, remaining_length):\n        if remaining_length == 0:\n            return 1\n        key = (current_num, remaining_length)\n        \n        if key in memo:\n            return memo[key]\n        \n        # The next number can be from 2*current_num to m\n        total = 0\n        for next_num in range(max(1, current_num * 2), m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        \n        memo[key] = total\n        return total\n\n    # Start with 1 because we are looking for sequences of positive integers\n    return sum(count_sequences(i, n-1) for i in range(1, m + 1))", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Dynamic programming to count the number of sequences\n    # dp[i][j] represents the number of sequences of length j ending with i\n    dp = [[0 for _ in range(n)] for _ in range(m + 1)]\n    \n    # For length 1, any number from 1 to m can be a sequence of its own\n    for i in range(1, m + 1):\n        dp[i][0] = 1\n    \n    # Fill up the dp table\n    for j in range(1, n):  # for each length from 2 to n\n        for i in range(1, m + 1):  # for each possible current element\n            # Look for previous elements that are less than or equal to i//2\n            for prev in range(1, i // 2 + 1):\n                dp[i][j] += dp[prev][j - 1]\n    \n    # Sum up all possibilities for the last position\n    total = sum(dp[i][n - 1] for i in range(1, m + 1))\n    \n    return total", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of sequences of length n where each element is >= twice the previous \n    but <= m.\n\n    Args:\n    m (int): The maximum value for any element in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of valid sequences.\n\n    Example:\n    >>> get_total_number_of_sequences(10, 4)\n    4\n    \"\"\"\n    # Base case: if n is 1, any number from 1 to m is a valid sequence of length 1\n    if n == 1:\n        return m\n\n    # Initialize the dynamic programming table\n    # dp[i][j] means the number of sequences of length i ending with j\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Fill base case for length 1 sequences\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n\n    # Build up for sequences of length i from 2 to n\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            # For current number j, check all valid previous numbers (up to j // 2)\n            for prev in range(1, (j // 2) + 1):\n                dp[i][j] += dp[i-1][prev]\n\n    # Sum up all possibilities for sequences of length n\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    # Memoization dictionary to store computed results for different start values and lengths\n    memo = {}\n\n    def count_sequences(current: int, length: int) -> int:\n        # If we've computed this state before, return the memoized value\n        if (current, length) in memo:\n            return memo[(current, length)]\n        \n        # Base case: we've reached the desired length\n        if length == 1:\n            return 1\n        \n        # Total number of sequences starting from 'current'\n        total = 0\n        # The next number must be at least twice the current number and at most m\n        for next_num in range(current * 2, m + 1):\n            total += count_sequences(next_num, length - 1)\n        \n        # Memoize the result before returning\n        memo[(current, length)] = total\n        return total\n\n    # The starting number can be any integer from 1 to m\n    total_sequences = sum(count_sequences(i, n) for i in range(1, m + 1))\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Memoization dictionary to store computed results\n    memo = {}\n    \n    def sequence_count(current, remaining_length):\n        # Base case: if we've used up the required sequence length\n        if remaining_length == 0:\n            return 1\n        # Check if we've already computed this combination\n        if (current, remaining_length) in memo:\n            return memo[(current, remaining_length)]\n        \n        count = 0\n        # Loop through all possible next numbers\n        for next_num in range(max(2 * current, 1), m + 1):\n            count += sequence_count(next_num, remaining_length - 1)\n        \n        # Memoize the result for this state\n        memo[(current, remaining_length)] = count\n        return count\n    \n    # Initial call to the helper function\n    total = sum(sequence_count(i, n - 1) for i in range(1, m + 1))\n    return total", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    def dfs(current, last, length):\n        # Base case: if the sequence length equals n, we've found a valid sequence\n        if length == n:\n            return 1\n        total = 0\n        # Loop through all possible next numbers, starting from the smallest valid number\n        for next_num in range(last * 2, m + 1):\n            total += dfs(current + [next_num], next_num, length + 1)\n        return total\n\n    # Start the sequence with any number from 1 to m\n    return sum(dfs([x], x, 1) for x in range(1, m + 1))", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of sequences of length 'n' where each element is at least\n    twice the previous one but not greater than 'm'.\n    \n    :param m: Maximum allowed number in the sequence.\n    :param n: Length of the sequence to be considered.\n    :return: Number of valid sequences.\n    \"\"\"\n    # Base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return m\n\n    # Initialize memoization table\n    memo = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Fill in the base case for n=1\n    for i in range(1, m + 1):\n        memo[1][i] = 1\n\n    # Dynamic programming to fill the table\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):  # k can't be more than j/2\n                memo[i][j] += memo[i-1][k]\n\n    # Sum of all possibilities where the last number is in range [1, m]\n    return sum(memo[n][1:])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Find the number of possible sequences of length n where each element is \n    greater than or equal to twice the previous element and less than or equal to m.\n    \n    Args:\n    m (int): The upper bound for each element in the sequence.\n    n (int): The length of the sequence.\n    \n    Returns:\n    int: The total number of sequences that meet the criteria.\n    \n    Example:\n    >>> get_total_number_of_sequences(10, 4)\n    4\n    \"\"\"\n    # Base case: if n is 1, all numbers from 1 to m are valid\n    if n == 1:\n        return m\n    \n    # dp[i][j] represents the number of sequences of length i ending with j\n    dp = [[0 for _ in range(m + 1)] for _ in range(n)]\n    \n    # For sequences of length 1\n    for j in range(1, m + 1):\n        dp[0][j] = 1\n    \n    # Building up from sequence length 1 to n-1\n    for i in range(1, n):\n        for j in range(1, m + 1):\n            # j should be at least 2 times any previous number\n            # but we look only at the last position due to monotonicity\n            for k in range(1, (j // 2) + 1):\n                dp[i][j] += dp[i-1][k]\n    \n    # Sum all the possibilities for sequences of length n-1\n    return sum(dp[n-1])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    if n == 1:\n        return m  # All numbers from 1 to m are valid sequences of length 1\n\n    # dp[i][j] represents the number of valid sequences ending with number j and of length i\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # Initialize the base case for sequences of length 1\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n\n    # Fill the dp table\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            # j must be greater than or equal to twice any previous element\n            for prev in range(1, j // 2 + 1):\n                if prev <= m:\n                    dp[i][j] += dp[i-1][prev]\n    \n    # Sum up all possible last elements for sequences of length n\n    total = sum(dp[n][1:])\n    \n    return total", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of sequences where each element is between twice the \n    previous element and m, inclusive. \n\n    Args:\n    m (int): The upper limit for elements in the sequence.\n    n (int): The length of each sequence.\n\n    Returns:\n    int: The total number of valid sequences.\n\n    Example:\n    >>> get_total_number_of_sequences(10, 4)\n    4\n    \"\"\"\n    # Memoization for dynamic programming\n    memo = {}\n    \n    def count_sequences(i, last):\n        # Base case: if we've used all elements, count this sequence\n        if i == 0:\n            return 1\n        # If we have already computed for this state, return memoized result\n        if (i, last) in memo:\n            return memo[(i, last)]\n        \n        total = 0\n        # Start with twice the last number or 1, whichever is larger\n        start = max(last * 2, 1)\n        for j in range(start, m + 1):\n            total += count_sequences(i - 1, j)\n        \n        memo[(i, last)] = total\n        return total\n\n    # Start with the first element of the sequence where we can choose any number from 1 to m\n    return sum(count_sequences(n - 1, j) for j in range(1, m + 1))", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of sequences of length n where each element is:\n    - A positive integer\n    - Greater than or equal to twice the previous element\n    - Less than or equal to m\n    \n    Args:\n    m (int): The maximum value for any element in the sequence.\n    n (int): The length of the sequence to be generated.\n    \n    Returns:\n    int: The number of possible sequences satisfying the conditions.\n\n    Example:\n    >>> get_total_number_of_sequences(10, 4)\n    4\n    \"\"\"\n    # Use dynamic programming to solve this problem\n    # dp[i][j] stores the number of sequences ending with j of length i\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Base case: for sequences of length 1, all numbers from 1 to m are valid\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    \n    # Fill the dp table\n    for length in range(2, n + 1):\n        for current in range(1, m + 1):\n            for prev in range(1, current // 2 + 1):  # Check only numbers that can double up to current\n                dp[length][current] += dp[length-1][prev]\n\n    # Sum all possible last elements for sequences of length n\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Calculate the number of sequences where each element is at least twice the previous \n    element but not exceeding m.\n\n    :param m: Upper limit for each element in the sequence\n    :param n: Length of the sequence\n    :return: Number of possible sequences\n\n    Example:\n    >>> get_total_number_of_sequences(10, 4)\n    4\n    \"\"\"\n    \n    # Initialize memoization array where memo[i][j] represents the count \n    # for sequence length j ending with number i\n    memo = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    # Base case: an empty sequence or single number sequence\n    for i in range(1, m+1):\n        memo[i][1] = 1  # One way to create a sequence of length 1\n\n    # Dynamic Programming to build up our solution\n    for length in range(2, n + 1):\n        for current in range(1, m + 1):\n            for prev in range(1, current // 2 + 1):\n                memo[current][length] += memo[prev][length-1]\n\n    # Sum up all the sequences of length n\n    return sum(memo[i][n] for i in range(1, m + 1))", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of sequences of length n where each element\n    is a positive integer >= 2 * previous element and <= m.\n\n    :param m: Upper bound for sequence elements\n    :param n: Length of the sequences\n    :return: Total number of valid sequences\n    \"\"\"\n    # Memoization to store computed results\n    memo = {}\n\n    def count_sequences(index, prev):\n        # Base case: we've filled n elements\n        if index == n:\n            return 1\n        \n        # Memoization check\n        if (index, prev) in memo:\n            return memo[(index, prev)]\n\n        total = 0\n        # Start from twice the previous number or 1 if it's the first number\n        start = max(1, prev * 2)\n        \n        # Loop from start to m inclusive\n        for i in range(start, m + 1):\n            total += count_sequences(index + 1, i)\n        \n        # Memoize the result for this state\n        memo[(index, prev)] = total\n        return total\n\n    # Initial call with index at 0 and previous element as 0 to simulate the first element can be 1\n    return count_sequences(0, 0)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current, length, max_val):\n        if length == 0:\n            return 1\n        \n        total = 0\n        for next_val in range(current * 2, max_val + 1):\n            total += count_sequences(next_val, length - 1, max_val)\n        return total\n\n    # Start with any number from 1 to m for the first element\n    return sum(count_sequences(i, n - 1, m) for i in range(1, m + 1))", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n where each element is at least \n    twice the previous element and not greater than m.\n\n    Args:\n    m (int): The upper bound for each element in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of valid sequences.\n\n    Example:\n    >>> get_total_number_of_sequences(10, 4)\n    4\n    \"\"\"\n    # Memoization dictionary to store computed results\n    memo = {}\n\n    def count_sequences(current, length):\n        # Base case: we've reached the desired sequence length\n        if length == 0:\n            return 1\n        \n        # Check if this scenario has been computed before\n        if (current, length) in memo:\n            return memo[(current, length)]\n        \n        # Sum up all possible next elements\n        total = sum(count_sequences(next_element, length - 1) \n                    for next_element in range(2 * current, m + 1))\n\n        # Store result in memoization dictionary\n        memo[(current, length)] = total\n        return total\n    \n    # Start with any number from 1 to m as the first element\n    return sum(count_sequences(i, n - 1) for i in range(1, m + 1))", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of sequences of length n where each element is a positive integer \n    and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n    m (int): Upper limit for sequence elements.\n    n (int): Length of the sequence.\n\n    Returns:\n    int: Total number of sequences that satisfy the conditions.\n\n    Example:\n    >>> get_total_number_of_sequences(10, 4)\n    4\n    \"\"\"\n    # Memoization dictionary to store computed results\n    memo = {}\n\n    def count_sequences(prev, length):\n        # Base case: If length is 0, we've found a valid sequence\n        if length == 0:\n            return 1\n        # Use memoization to avoid redundant calculations\n        if (prev, length) in memo:\n            return memo[(prev, length)]\n\n        count = 0\n        # Start from 2 * prev or 1 if prev is 0 (first element in sequence)\n        start = max(1, prev * 2) if prev else 1\n        \n        # Continue up to m, calculating possible next elements\n        for next_val in range(start, m + 1):\n            count += count_sequences(next_val, length - 1)\n        \n        # Store the result of this calculation\n        memo[(prev, length)] = count\n        return count\n\n    # Start with the sequence length of n and no previous element (None)\n    return count_sequences(None, n)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of sequences of length n where each element is \n    a positive integer greater than or equal to twice the previous element but not \n    exceeding m.\n\n    :param m: Upper bound for elements in the sequence\n    :param n: Length of the sequence\n    :return: Total number of valid sequences\n\n    Example:\n    >>> assert get_total_number_of_sequences(10, 4) == 4\n    The function should return 4 for m=10 and n=4 because:\n    - Sequence [1, 2, 4, 8]\n    - Sequence [1, 2, 4, 9]\n    - Sequence [1, 2, 5, 10]\n    - Sequence [1, 2, 6, 10]\n    \"\"\"\n    \n    # Initialize dynamic programming array\n    # dp[i][j] will count the sequences ending at j with i elements\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Base case: one element sequence can be any number from 1 to m\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    \n    # Fill the dp table\n    for i in range(2, n + 1):  # for each sequence length\n        for j in range(1, m + 1):  # for each possible end number\n            for k in range(1, j // 2 + 1):  # check previous elements\n                if j >= 2 * k:\n                    dp[i][j] += dp[i-1][k]\n\n    # Sum up all the sequences of length n\n    total_sequences = sum(dp[n])\n    \n    return total_sequences", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    if n == 1:\n        # Base case: only m choices for a single element sequence\n        return m\n    \n    # Initialize the dynamic programming table\n    # dp[i][j] represents the number of sequences of length i ending with j\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Fill for sequences of length 1\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    \n    # Fill the table for sequences of length from 2 to n\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(2 * j, m + 1):\n                dp[i][k] += dp[i - 1][j]\n    \n    # Sum all the possibilities for sequences of length n\n    return sum(dp[n])", "matching_cluster_idx": 7}]}, "Mbpp/240": {"dps": 60.1829268292683, "dps_norm": 73.33333333333333, "pass@1": 91.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with all elements from the second list.\n    \n    Parameters:\n    list1 (list): The list whose last element will be replaced.\n    list2 (list): The list whose elements will replace the last element of list1.\n    \n    Returns:\n    list: A new list where the last element of list1 is replaced by list2's elements.\n    \n    Examples:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # If list1 is not empty, remove the last element\n    if list1:\n        new_list = list1[:-1]\n    else:\n        # If list1 is empty, start with an empty list\n        new_list = []\n    \n    # Extend the new list with all elements of list2\n    new_list.extend(list2)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    Args:\n    list1 (list): The list where the last element will be replaced.\n    list2 (list): The list containing elements to replace with.\n\n    Returns:\n    list: A new list where the last element of list1 has been substituted with all elements from list2.\n\n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    if not list1:  # If list1 is empty, return list2 as the new list\n        return list2.copy()\n    \n    # Replace the last element of list1 with elements of list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    Args:\n    list1 (list): The original list whose last element will be replaced.\n    list2 (list): The list containing elements to replace the last element of list1.\n\n    Returns:\n    list: A new list where the last element of list1 has been replaced by list2's elements.\n\n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # Create a copy of list1 to avoid modifying the original list\n    result = list1[:-1]  # Slice the list to exclude the last element\n    # Extend the result list with elements from list2\n    result.extend(list2)\n    return result", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n    \n    Parameters:\n    list1 (list): The first list, whose last element will be replaced.\n    list2 (list): The second list, whose elements will replace the last element of list1.\n    \n    Returns:\n    list: A new list where the last element of list1 is substituted with list2 elements.\n\n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # If list1 is empty, we simply return list2\n    if not list1:\n        return list2.copy()\n\n    # Replace the last element with all elements from list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements of list2.\n\n    Args:\n    list1 (list): The original list where the last element will be replaced.\n    list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list where the last element of list1 has been replaced by the elements of list2.\n\n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # If list1 is empty, return list2 as the entire result\n    if not list1:\n        return list2.copy()  # Return a copy to avoid modifying the input\n    \n    # Make a copy of list1 to avoid modifying the original\n    result = list1[:-1]  # Take all elements of list1 except the last one\n    \n    # Append all elements from list2 to the result\n    result.extend(list2)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of list1 with the elements of list2.\n    \n    Args:\n    list1 (list): The list whose last element will be replaced.\n    list2 (list): The list containing elements to replace with.\n    \n    Returns:\n    list: A new list with list1's elements up to the last one removed and list2's elements appended.\n    \n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # Check if list1 is not empty to avoid errors\n    if list1:\n        # Take all elements from list1 except the last one\n        # Then extend it with elements from list2\n        return list1[:-1] + list2\n    else:\n        # If list1 is empty, we just return a copy of list2\n        return list2.copy()", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of list1 with all elements from list2.\n    \n    :param list1: The original list whose last element will be replaced.\n    :param list2: The list whose elements will replace the last element of list1.\n    :return: A new list with the modification applied.\n    \"\"\"\n    # Check if list1 is not empty before attempting to replace its last element\n    if not list1:\n        return list2\n    \n    # Make a copy of list1 to not modify the original\n    result = list1[:-1]\n    # Extend the list with elements from list2\n    result.extend(list2)\n    return result", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n    list1 (list): The list where the last element will be replaced.\n    list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n\n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # Remove the last element from list1\n    if list1:\n        list1 = list1[:-1]\n    else:\n        return list2  # If list1 is empty, simply return list2\n    \n    # Append elements of list2 to the modified list1\n    return list1 + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    if not list1:  # If list1 is empty, return list2 as it is.\n        return list2\n    \n    # Remove the last element of list1\n    list1 = list1[:-1]\n    \n    # Concatenate list1 (without its last element) with list2\n    return list1 + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    \n    Args:\n    list1 (list): The list whose last element will be replaced.\n    list2 (list): The list whose elements will replace the last element of list1.\n    \n    Returns:\n    list: A new list with the replacement performed.\n    \n    Examples:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # Check if list1 is empty or has only one element\n    if len(list1) == 0:\n        return list2\n    if len(list1) == 1:\n        return list2\n    \n    # Slice the original list, removing the last element\n    result = list1[:-1]\n    \n    # Extend the list with elements from list2\n    result.extend(list2)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    Args:\n    list1 (list): The list whose last element will be replaced.\n    list2 (list): The list of elements to replace with.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by elements of list2.\n\n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # If list1 is empty, return list2 as it is or an empty list if both are empty\n    if not list1:\n        return list2\n\n    # Keep all elements from list1 except the last one\n    result = list1[:-1]\n    # Append all elements from list2\n    result.extend(list2)\n    return result", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of list1 with all elements of list2.\n\n    Args:\n    list1 (list): The list where the last element will be replaced.\n    list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n\n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # If list1 is not empty, remove the last element and extend with list2\n    if list1:\n        result = list1[:-1] + list2\n    else:\n        # If list1 is empty, simply return list2\n        result = list2.copy()\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements of list2.\n    \n    Args:\n    list1 (list): The list whose last element will be replaced.\n    list2 (list): The list whose elements will replace the last element of list1.\n    \n    Returns:\n    list: A new list where the last element of list1 is replaced by the elements of list2.\n\n    Raises:\n    ValueError: If list1 is empty or if list2 is empty when list1 has only one element.\n\n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list cannot be empty.\")\n    if len(list1) == 1 and not list2:\n        raise ValueError(\"When the first list has only one element, the second list must not be empty.\")\n    \n    # Create a new list with all elements from list1 except the last one\n    result = list1[:-1]\n    # Extend the result with all elements from list2\n    result.extend(list2)\n    return result", "matching_cluster_idx": 6}, {"solution": "def replace_list(first_list, second_list):\n    \"\"\"\n    Replaces the last element of the first list with all elements from the second list.\n    \n    Args:\n    first_list (list): The list whose last element will be replaced.\n    second_list (list): The list providing the new elements.\n    \n    Returns:\n    list: A new list where the last element of `first_list` is replaced by `second_list`.\n    \n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    if not first_list:  # If the first list is empty, return the second list\n        return second_list\n    return first_list[:-1] + second_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of list1 with the elements of list2.\n\n    Args:\n    list1 (list): The list which will have its last element replaced.\n    list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by list2's elements.\n\n    Examples:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # Remove the last element from list1\n    if list1:\n        list1.pop()\n    \n    # Extend list1 with all elements from list2\n    result = list1 + list2\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of list1 with all elements from list2.\n\n    This function modifies list1 by removing its last element and appending\n    all elements from list2 in order.\n\n    Parameters:\n    list1 (list): The list whose last element will be replaced.\n    list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list where the last element of list1 is substituted by the elements of list2.\n\n    Examples:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # Check if list1 is not empty to avoid index errors\n    if not list1:\n        return list2.copy()\n\n    # Replace the last element with list2 elements\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n    list1 (list): The list whose last element will be replaced.\n    list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by all elements from list2.\n\n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    if not list1:\n        return list2  # If list1 is empty, just return list2\n    \n    # Create a new list by excluding the last element of list1\n    result = list1[:-1] + list2\n    return result", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n    list1 (list): The first list which will have its last element replaced.\n    list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list where the last element of list1 is replaced by list2.\n\n    Examples:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # Check if list1 is not empty to avoid index out of range error\n    if list1:\n        # Replace the last element with the second list\n        result = list1[:-1] + list2\n    else:\n        # If list1 is empty, just return list2\n        result = list2\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    This function modifies list1 in-place but returns the modified list for consistency\n    with the assert statement provided.\n\n    Args:\n    list1 (list): The list where the last element will be replaced.\n    list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n    list: The modified list1 with list2 elements replacing the last element.\n\n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # If list1 is not empty, remove the last element\n    if list1:\n        list1.pop()\n    \n    # Extend list1 with all elements from list2\n    list1.extend(list2)\n    \n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of list1 with all elements of list2.\n\n    Args:\n    list1 (list): The first list whose last element is to be replaced.\n    list2 (list): The second list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list where the last element of list1 is replaced by list2's elements.\n\n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    # Remove the last element from list1\n    if list1:\n        list1 = list1[:-1]\n    # Extend list1 with list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}]}, "Mbpp/251": {"dps": 63.64942528735633, "dps_norm": 72.77777777777777, "pass@1": 75.0, "profiled": [{"solution": "def insert_element(original_list, element):\n    \"\"\"\n    Inserts a given element before each item in the list.\n\n    Args:\n    original_list (list): The original list where elements will be inserted.\n    element (Any): The element to be inserted before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each element of the original list.\n\n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Initialize an empty list to hold the result\n    result = []\n    \n    # Iterate over each item in the original list\n    for item in original_list:\n        # Append the new element first, then the current item from the list\n        result.extend([element, item])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts a given element before each element in the list.\n\n    Args:\n    lst (list): The original list of elements.\n    element (any): The element to be inserted before each list item.\n\n    Returns:\n    list: A new list with the element inserted before each original list item.\n\n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Create a new list to avoid modifying the original list\n    result = []\n    \n    # Iterate through the list, inserting the element before each original element\n    for item in lst:\n        result.extend([element, item])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Args:\n    lst (list): The original list where elements are to be inserted.\n    element: The element to be inserted before each item in the list.\n\n    Returns:\n    list: A new list with the specified element inserted before each original element.\n\n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Create a new list to hold the result\n    result = []\n    \n    # Iterate over each item in the original list\n    for item in lst:\n        # Append the element to insert\n        result.append(element)\n        # Then append the original list item\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(original_list, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Args:\n    original_list (list): The list to modify.\n    element: The element to insert before each item in the original list.\n\n    Returns:\n    list: A new list with the element inserted before each item in the original list.\n\n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Create a new list with element inserted before each original item\n    result = []\n    for item in original_list:\n        result.extend([element, item])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Args:\n    lst (list): The original list of elements.\n    element: The element to be inserted before each item in the list.\n\n    Returns:\n    list: A new list where the element has been inserted before each original element.\n\n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Initialize the result list\n    result = []\n    # Iterate over each item in the list\n    for item in lst:\n        # Append the element to insert first, then append the original item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Args:\n    lst (list): The original list where insertions will take place.\n    element: The element to insert before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n\n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # We'll create a new list to avoid modifying the original list\n    result = []\n    for item in lst:\n        result.append(element)  # Insert the element\n        result.append(item)    # Then append the original item\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts a given element before each element in the list.\n    \n    Parameters:\n    lst (list): The original list to modify.\n    element: The element to insert before each item in lst.\n    \n    Returns:\n    list: A new list with the element inserted before each original item.\n    \n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Create a new list where we'll insert elements\n    new_list = []\n    \n    # Iterate over the list with enumeration to keep track of each item\n    for i, item in enumerate(lst):\n        # Add the element before each original item\n        if i < len(lst):  # Avoid adding element after the last item\n            new_list.append(element)\n        new_list.append(item)\n    \n    return new_list", "matching_cluster_idx": 4}, {"solution": "def insert_element(original_list, element):\n    \"\"\"\n    Inserts a given element before each element in the provided list.\n\n    Args:\n    original_list (list): The original list to modify.\n    element (Any): The element to be inserted before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before every item in the original list.\n\n    Examples:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Create a new list by alternating the element with the items of the original list\n    result = [item for pair in zip([element]*len(original_list), original_list) for item in pair] + [element] if original_list else []\n    \n    # If the original list is not empty, we need to remove one extra 'element' at the end\n    if original_list:\n        result.pop()\n    return result", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Parameters:\n    lst (list): The original list to modify.\n    element: The element to be inserted before each item in lst.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n\n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Create a new list to hold our result to avoid modifying the input list\n    result = []\n    # Iterate over the original list\n    for item in lst:\n        # Append the element to insert, then the original item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Insert the given element before each element in the provided list.\n\n    Args:\n    lst (list): The original list where elements will be inserted.\n    element (Any): The element to be inserted before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each item from the original list.\n\n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Using list comprehension to create a new list\n    # Here, we generate pairs of the new element and the original list element,\n    # then flatten the list of tuples into a single list\n    return [item for pair in zip([element]*len(lst), lst) for item in pair]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in the provided list.\n    \n    Args:\n    lst (list): The original list where new elements will be inserted.\n    element: The element to be inserted before each item in the list.\n    \n    Returns:\n    list: A new list with the element inserted before each original item.\n    \n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Using list comprehension to create a new list where the element is inserted before each original element\n    return [item for pair in zip([element] * len(lst), lst) for item in pair]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Insert the given element before each element in the list.\n\n    Args:\n    lst (list): The original list where elements will be inserted.\n    element (Any): The element to insert before each list item.\n\n    Returns:\n    list: A new list with the element inserted before each original item.\n\n    Example:\n    >>> assert insert_element(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts a given element before each item in the provided list.\n\n    Args:\n    lst (list): The original list.\n    element (Any): The element to insert.\n\n    Returns:\n    list: A new list where the element is inserted before every element of the original list.\n\n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Use a list comprehension to build the new list with the element inserted before each item\n    return [item for pair in zip([element] * len(lst), lst) for item in pair]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Args:\n    lst (list): The list into which to insert the element.\n    element: The element to be inserted before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original item.\n\n    Examples:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # We'll create a new list since we don't want to modify the input list in-place\n    result = []\n    \n    # Iterate through the list\n    for item in lst:\n        # Append the element, then append the item\n        result.extend([element, item])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(original_list, element_to_insert):\n    \"\"\"\n    Insert an element before each element in the list.\n\n    This function takes a list and an element, and returns a new list where the element\n    has been inserted before each item in the original list.\n\n    Args:\n    original_list (list): The list in which to insert elements.\n    element_to_insert: The element to be inserted before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each item of the original list.\n\n    Examples:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    result = []\n    for item in original_list:\n        # Insert the element before each item in the list\n        result.append(element_to_insert)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Insert an element before each element in the list.\n\n    Args:\n    lst (list): The original list where elements will be inserted.\n    element: The element to insert before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each item in the original list.\n\n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Use list comprehension to build the new list with the element inserted\n    return [item for pair in zip([element] * len(lst), lst) for item in pair]", "matching_cluster_idx": 5}, {"solution": "def insert_element(original_list, element):\n    \"\"\"\n    Inserts an element before each item in the original list.\n\n    Args:\n    original_list (list): The list into which elements are to be inserted.\n    element (any): The element to be inserted before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n\n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Create a new list to avoid modifying the original one\n    result = []\n    for item in original_list:\n        # Add the element before each item from the original list\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(original_list, element):\n    \"\"\"\n    Inserts an element before each item in the given list.\n    \n    Args:\n    original_list (list): The list to modify.\n    element: The element to insert before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original item.\n    \n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Use list comprehension to create a new list with the element inserted before each item\n    return [item for sublist in [[element, x] for x in original_list] for item in sublist]", "matching_cluster_idx": 4}, {"solution": "def insert_element(original_list, element):\n    \"\"\"\n    Inserts an element before each element in the given list.\n\n    Args:\n    original_list (list): The list into which the element will be inserted.\n    element (any): The element to insert before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n\n    Examples:\n    >>> assert insert_element(['Red', 'Green', 'Black'] ,'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Create a new list with double the space for inserting elements\n    result = [None] * (len(original_list) * 2)\n    \n    # Place the insertion element before each original element\n    result[::2] = [element] * len(original_list)\n    result[1::2] = original_list\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each item in the list.\n\n    Args:\n    lst (list): The original list where elements are to be inserted.\n    element (Any): The element to insert into the list.\n\n    Returns:\n    list: A new list with the element inserted before each original list item.\n\n    Example:\n    >>> insert_element(['Red', 'Green', 'Black'], 'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    # Using list comprehension to create a new list with element inserted before each item\n    return [val for pair in zip([element] * len(lst), lst) for val in pair]", "matching_cluster_idx": 5}]}, "Mbpp/256": {"dps": 75.11415525114155, "dps_norm": 68.82352941176471, "pass@1": 82.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than the given non-negative number.\n    \n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The count of prime numbers less than n.\n\n    Examples:\n    >>> count_Primes_nums(5)\n    2\n    \"\"\"\n    if n < 2:\n        return 0\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Return the count of prime numbers less than n.\n    \n    Examples:\n    >>> count_Primes_nums(5)\n    2\n    >>> count_Primes_nums(10)\n    4\n    \"\"\"\n    if n < 2:\n        return 0\n    count = 0\n    for number in range(2, n):\n        if is_prime(number):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than n.\n\n    This function uses the Sieve of Eratosthenes to efficiently find all prime numbers\n    up to n-1.\n\n    Args:\n    n (int): A non-negative integer up to which we count primes.\n\n    Returns:\n    int: The count of primes less than n.\n\n    Examples:\n    >>> count_Primes_nums(5)\n    2\n    >>> count_Primes_nums(10)\n    4\n    \"\"\"\n    if n < 2:\n        return 0\n    \n    # Initialize all numbers as prime\n    primes = [True] * n\n    primes[0] = primes[1] = False  # 0 and 1 are not prime\n    \n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            # Mark multiples of i as not prime\n            for j in range(i*i, n, i):\n                primes[j] = False\n    \n    # Count how many numbers are still marked as prime\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n    \n    Args:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The count of prime numbers less than n.\n    \n    Raises:\n    ValueError: If n is negative.\n    \n    Example:\n    >>> count_Primes_nums(5)\n    2\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative number.\")\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Use Sieve of Eratosthenes for efficiency\n    if n < 2:\n        return 0\n    sieve = [True] * n\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            for j in range(i*i, n, i):\n                sieve[j] = False\n    \n    # Count primes\n    return sum(sieve) - 2  # Subtract 1 and 0", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n\n    # Initialize all numbers as potential primes\n    sieve = [True] * n\n    # 0 and 1 are not primes by definition\n    sieve[0] = sieve[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:  # If i is prime, mark its multiples as not prime\n            for j in range(i*i, n, i):\n                sieve[j] = False\n\n    # Count all true values in the sieve\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than the given non-negative number.\n\n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The count of prime numbers less than n.\n\n    Example:\n    >>> count_Primes_nums(5)\n    2\n    \"\"\"\n    # Adjust n to n-1 since we're looking for primes less than n\n    if n < 2:\n        return 0\n    \n    count = 0\n    for num in range(2, n):  # Start from 2, since 1 is not considered prime\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    # Check for divisibility up to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than n.\n    \n    :param n: Non-negative integer\n    :return: Number of primes less than n\n    \"\"\"\n    count = 0\n    for num in range(2, n):  # Start from 2 as per the definition of primes\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Function to count the number of primes less than n.\n\n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The count of prime numbers less than n.\n\n    Examples:\n    >>> count_Primes_nums(5)\n    2\n    >>> count_Primes_nums(10)\n    4\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    # Initialize all numbers as prime\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not primes\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count prime numbers\n    count = sum(is_prime)\n    return count", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than the given non-negative number n.\n    \n    :param n: A non-negative integer\n    :return: The count of prime numbers less than n\n\n    Example:\n    >>> assert count_Primes_nums(5) == 2\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Initialize all numbers as prime\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n\n    # Use Sieve of Eratosthenes to mark non-primes\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as not prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n\n    # Count primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than n.\n\n    Args:\n    n (int): A non-negative integer\n\n    Returns:\n    int: The count of prime numbers less than n\n\n    Example:\n    >>> count_Primes_nums(5)\n    2\n    \"\"\"\n    # We start counting from 2 because 1 is not considered prime\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number.\n    \n    Args:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The count of prime numbers less than n.\n    \n    Example:\n    >>> count_Primes_nums(5)\n    2\n    \"\"\"\n    count = 0\n    for i in range(2, n):  # Start from 2, the smallest prime number\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize all numbers as prime\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count prime numbers\n    count = sum(is_prime)\n    \n    return count", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than n.\n\n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: Number of prime numbers less than n.\n\n    Examples:\n    >>> count_Primes_nums(5)\n    2\n    >>> count_Primes_nums(10)\n    4\n    \"\"\"\n    if n < 2:\n        return 0\n    \n    # Initialize all numbers as potential primes\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n\n    # Use Sieve of Eratosthenes to mark non-primes\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as not prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than the given non-negative number.\n\n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The count of primes less than n.\n\n    Examples:\n    >>> count_Primes_nums(5)\n    2\n    \"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than n.\n\n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The count of primes less than n.\n\n    Example:\n    >>> count_Primes_nums(5)\n    2\n    \"\"\"\n    if n <= 2:\n        return 0  # There are no primes less than 2\n    \n    # Count primes from 2 up to but not including n\n    count = sum(is_prime(i) for i in range(2, n))\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Count the number of primes less than the given non-negative number.\n\n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The count of prime numbers less than n.\n\n    Example:\n    >>> count_Primes_nums(5)\n    2\n    \"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n <= 1:\n        return 0\n    \n    # Initialize all numbers as prime\n    sieve = [True] * n\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            # Mark multiples of i as not prime\n            for j in range(i*i, n, i):\n                sieve[j] = False\n\n    # Count prime numbers\n    count = sum(sieve[2:])\n    return count", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than n.\n\n    This function implements the Sieve of Eratosthenes algorithm to find primes.\n\n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The count of prime numbers less than n.\n\n    Examples:\n    >>> count_Primes_nums(5)\n    2\n    >>> count_Primes_nums(10)\n    4\n    \"\"\"\n    if n < 2:\n        return 0\n    \n    # Initialize all numbers as prime\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as not prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the primes\n    return sum(is_prime)", "matching_cluster_idx": 14}]}, "Mbpp/265": {"dps": 70.93023255813954, "dps_norm": 83.33333333333333, "pass@1": 37.0, "profiled": [{"solution": "def list_split(lst, n):\n    \"\"\"\n    Split a list into sublists where each sublist contains every nth element from the original list.\n\n    Args:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list of lists: A list where each sublist contains every nth element from lst.\n\n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Initialize an empty list to hold our sublists\n    result = [[] for _ in range(n)]\n    \n    # Cycle through the list elements, distributing them among sublists\n    for index, value in enumerate(lst):\n        # Determine which sublist this value should go into by using modulo operation\n        sublist_index = index % n\n        result[sublist_index].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists where each element from the original list \n    is placed into sublists based on its position modulo n.\n\n    Args:\n    input_list (list): The list to be split.\n    n (int): The number of groups to split the list into.\n\n    Returns:\n    list: A list of sublists where each sublist contains elements at positions \n          that are congruent to i mod n, where i is from 0 to n-1.\n\n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Initialize n empty lists within the result list\n    result = [[] for _ in range(n)]\n    \n    # Place each element into the appropriate sublist\n    for index, item in enumerate(input_list):\n        # Determine which sublist this item should go into\n        list_index = index % n\n        result[list_index].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Split the input list into n different lists, each containing elements from the original list \n    in the order they appear but separated by every nth element.\n\n    Args:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list: A list containing n sublists.\n\n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Initialize n empty lists to hold the results\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list and distribute elements into the sublists\n    for index, value in enumerate(lst):\n        # Determine which sublist the current item should go into\n        sublist_index = index % n\n        result[sublist_index].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the given list into n sublists, where each sublist contains elements from the input list\n    at positions corresponding to each of n different offsets.\n\n    Args:\n    lst (list): The list to be split.\n    n (int): The interval at which the list is split.\n\n    Returns:\n    list of list: A list of n sublists containing elements of the input list at every nth position.\n\n    Example:\n    >>> assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Initialize n empty lists to store the split results\n    result = [[] for _ in range(n)]\n    \n    # Iterate through the list, using modulo n to decide which sublist to add the element to\n    for i in range(len(lst)):\n        result[i % n].append(lst[i])\n    \n    # Return the list of sublists\n    return result\ntest_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nresult = list_split(test_list, 3)", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Split the input list into sublists where each element from the original list\n    is placed into one of n sublists according to its position.\n\n    Args:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create, where each nth element goes to the same sublist.\n\n    Returns:\n    list of lists: A list containing n sublists with elements from lst.\n\n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    # Initialize n empty lists\n    result = [[] for _ in range(n)]\n    \n    # Distribute elements across the sublists\n    for index, value in enumerate(lst):\n        # Determine which list this element should go into\n        result[index % n].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists where each sublist contains every nth element from the original list.\n\n    Args:\n    input_list (list): The list to be split.\n    n (int): The number determining the split interval.\n\n    Returns:\n    list of lists: A list containing sublists of elements from the input list.\n\n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Initialize the result with empty lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list, placing each element into its corresponding sublist\n    for i, item in enumerate(input_list):\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(items, n):\n    \"\"\"\n    Splits a list into sublists where each sublist contains every nth element starting from index 0 to n-1.\n    \n    Args:\n    items (list): The list to be split.\n    n (int): The number of sublists to create based on the interval.\n\n    Returns:\n    list of lists: A list where each element is a sublist containing elements from 'items' at every nth position.\n\n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Initialize the result with n empty lists\n    result = [[] for _ in range(n)]\n    \n    # Loop through each item in the list\n    for idx, item in enumerate(items):\n        # Determine which sublist this item should go into by taking the modulus of the index with n\n        list_index = idx % n\n        result[list_index].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into sublists where elements from the original list are grouped based on their position modulo n.\n\n    Args:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list of lists: A list where each sublist contains elements from 'lst' that are at positions 0, n, 2n, ... in 'lst'.\n\n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    # Initialize n lists to hold split elements\n    result = [[] for _ in range(n)]\n    \n    # Fill the result lists\n    for index, value in enumerate(lst):\n        # Determine which sublist the value should go into\n        result[index % n].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0\")\n    \n    # Initialize the result with empty lists\n    result = [[] for _ in range(n)]\n    \n    # Populate the result lists\n    for index, item in enumerate(input_list):\n        # Determine which sublist this item goes into\n        sublist_index = index % n\n        result[sublist_index].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits the input list into n sublists, where each sublist contains elements\n    from the original list at every nth position.\n\n    Args:\n    input_list (list): The list to be split.\n    n (int): The split interval.\n\n    Returns:\n    list of lists: A list containing n lists, where each internal list has \n                   elements from input_list at every nth position.\n\n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f'], 2)\n    [['a', 'c', 'e'], ['b', 'd', 'f']]\n    \"\"\"\n    # Check if n is greater than the length of the list to avoid infinite loops or empty lists\n    if n <= 0:\n        raise ValueError(\"n should be a positive integer\")\n    \n    # Pre-fill lists with an empty list to handle different lengths of input_list evenly\n    result = [[] for _ in range(n)]\n    \n    # Cycle through the list and append elements to appropriate sublists\n    for idx, item in enumerate(input_list):\n        # Use modulo to determine which sublist to append to\n        result[idx % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists where each sublist contains the nth elements from the original list.\n\n    Args:\n    input_list (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list of lists: Each sublist contains every nth element from the input_list.\n\n    Examples:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Initialize an empty list to hold the sublists\n    result = [[] for _ in range(n)]\n    \n    # Cycle through the list and distribute elements into appropriate sublists\n    for i, item in enumerate(input_list):\n        # Determine which sublist this element should go into\n        sublist_index = i % n\n        result[sublist_index].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into sublists where each sublist contains every nth element from the original list.\n    \n    Args:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list elements.\n\n    Returns:\n    list of lists: A list where each element is a list containing every nth item from the original list.\n\n    Examples:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Initialize an empty list of lists to hold our split sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with enumeration\n    for index, value in enumerate(lst):\n        # Determine which sublist this value should go into\n        bucket = index % n\n        # Append the value to the correct sublist\n        result[bucket].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits the given list into sublists where each sublist contains every nth element from the original list.\n\n    Args:\n    input_list (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list of lists: A list where each element is a sublist of the input list, \n                   where elements are grouped by their position modulo n.\n\n    Raises:\n    ValueError: If n is less than or equal to 0.\n\n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Check if n is valid\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0\")\n\n    # Create n empty lists\n    result = [[] for _ in range(n)]\n\n    # Populate each list with elements based on their index\n    for index, value in enumerate(input_list):\n        # Append value to the list at the index of (index % n)\n        result[index % n].append(value)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Initialize the result with empty lists\n    result = [[] for _ in range(n)]\n    \n    # Distribute elements from input_list into the result lists\n    for idx, item in enumerate(input_list):\n        # Use modulo to cycle through result lists\n        list_index = idx % n\n        result[list_index].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists based on every nth element.\n\n    Args:\n    lst (list): The list to split.\n    n (int): The interval for splitting.\n\n    Returns:\n    list of lists: Each sublist contains every nth element from the original list.\n\n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Initialize the output with empty sublists\n    result = [[] for _ in range(n)]\n    \n    # Fill each sublist with corresponding nth elements\n    for idx, item in enumerate(lst):\n        result[idx % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0\")\n    \n    # Create n number of empty lists\n    result = [[] for _ in range(n)]\n    \n    # Fill each list with every nth element from input_list\n    for idx, item in enumerate(input_list):\n        list_index = idx % n\n        result[list_index].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(items, n):\n    \"\"\"\n    Splits a list into sublists where each sublist contains every nth item from the original list.\n\n    :param items: List to be split\n    :param n: Integer determining how often to take an element from the original list for each new sublist\n    :return: List of lists where each inner list contains elements taken every nth position\n\n    Examples:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Pre-allocate empty lists for each sublist\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list, populating the sublists\n    for i, item in enumerate(items):\n        # Append the item to the appropriate sublist\n        result[i % n].append(item)\n    \n    return result\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a given list into sublists where elements are grouped by every nth position.\n\n    Args:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list of lists: Each sublist contains elements from lst that are positioned at multiples of n.\n\n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Initialize the result list\n    result = [[] for _ in range(n)]\n    \n    # Populate the result list\n    for i, value in enumerate(lst):\n        # Determine which sublist this item should go into by doing i % n\n        sublist_index = i % n\n        result[sublist_index].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, where each element from the original list \n    goes into a sublist based on its position modulo n.\n    \n    Args:\n    lst (list): The input list to be split.\n    n (int): The number of groups to split the list into.\n    \n    Returns:\n    list of lists: Each inner list contains elements from lst where their index mod n equals the list's index.\n    \n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Initialize n empty lists within the result list\n    result = [[] for _ in range(n)]\n    \n    # Populate each list based on the index of elements in lst\n    for index, item in enumerate(lst):\n        # Determine which list to append the item to by using the index modulo n\n        result[index % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists where each element from the original list\n    goes into one of the n lists according to its index modulo n.\n\n    Args:\n    lst (list): The input list to be split.\n    n (int): The number of lists to split into.\n\n    Returns:\n    list of lists: Each sublist contains elements from lst at indices where\n    index % n == i, where i is the sublist number starting from 0.\n\n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    # Initialize empty lists to hold the split results\n    result = [[] for _ in range(n)]\n    \n    # Distribute elements to their respective lists\n    for index, value in enumerate(lst):\n        list_index = index % n\n        result[list_index].append(value)\n    \n    return result", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.35, "dps_norm": 83.18181818181817, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n    \n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Examples:\n    >>> all_unique([1, 2, 3])\n    True\n    >>> all_unique([1, 2, 1, 3])\n    False\n    \"\"\"\n    # Convert the list to a set. If lengths are the same, all elements are unique\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Examples:\n    >>> all_unique([1, 2, 3])\n    True\n    >>> all_unique([1, 1, 3])\n    False\n    \"\"\"\n    # Convert the list to a set; sets in Python have unique elements\n    # If the length of the set equals the length of the original list,\n    # then all elements must be unique\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    This function uses a set to determine uniqueness, which provides\n    O(n) time complexity for the operation.\n\n    Args:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Examples:\n    >>> all_unique([1, 2, 3])\n    True\n    >>> all_unique([1, 2, 1])\n    False\n    \"\"\"\n    # If the length of the set of list elements equals the list length,\n    # then all elements are unique.\n    return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    This function iterates through the list once, comparing each element's\n    first occurrence index with its position to determine uniqueness.\n    \n    Parameters:\n    lst (list): The list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \n    Example:\n    >>> assert all_unique([1,2,3]) == True\n    >>> assert all_unique([1,2,1]) == False\n    \"\"\"\n    # Use a set to keep track of seen items for efficiency\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n    \n    Args:\n    lst (list): The list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Use a set for O(1) lookup time, checking if the length of the set \n    # equals the length of the list means all elements are unique\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Examples:\n    >>> all_unique([1, 2, 3])\n    True\n    >>> all_unique([1, 2, 2, 3])\n    False\n    \"\"\"\n    # Convert the list to a set. Sets do not allow duplicates,\n    # so if the length of the set is the same as the original list,\n    # all elements are unique.\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Example:\n    >>> all_unique([1, 2, 3])\n    True\n    >>> all_unique([1, 2, 2])\n    False\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then compare lengths\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n    \n    Args:\n    lst (list): The list to check for uniqueness of elements.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then compare lengths\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    This function determines if there are any duplicate elements in the list.\n    It uses a set for efficient lookup, which inherently cannot contain duplicate values.\n\n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Examples:\n    >>> all_unique([1, 2, 3])\n    True\n    >>> all_unique([1, 2, 1, 3])\n    False\n    \"\"\"\n    # Convert the list to a set. The length of the set will be less than the list if duplicates exist.\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Examples:\n    >>> assert all_unique([1,2,3]) == True\n    >>> assert all_unique([1,2,1,3]) == False\n    \"\"\"\n    # Convert the list to a set which automatically removes duplicates,\n    # then compare its length with the original list length\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    This function uses a set to check for uniqueness, which inherently does not\n    allow duplicate elements. By comparing the length of the list with the set \n    derived from the list, we can determine if all elements are unique.\n\n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Examples:\n    >>> assert all_unique([1, 2, 3]) == True\n    >>> assert all_unique([1, 2, 2, 3]) == False\n    \"\"\"\n    # Convert list to set and compare lengths. If lengths are equal, all elements are unique.\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Examples:\n    >>> all_unique([1, 2, 3])\n    True\n    >>> all_unique([1, 2, 1, 3])\n    False\n    \"\"\"\n    # Convert the list to a set. If the length is the same, all elements are unique\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n    \n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Example:\n    >>> all_unique([1, 2, 3])\n    True\n    >>> all_unique([1, 2, 1, 3])\n    False\n    \"\"\"\n    # Convert the list to a set. Since sets do not allow duplicate values, \n    # if the length of the set equals the length of the list, all elements are unique\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(elements: list) -> bool:\n    \"\"\"\n    Check if all elements in the provided list are unique.\n\n    This function uses a set for efficiency since lookup operations in sets\n    have average case O(1) complexity. It iterates through the list once,\n    checking if each element has already been encountered.\n\n    Args:\n        elements (list): The list of elements to check for uniqueness.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n\n    Examples:\n        >>> all_unique([1, 2, 3])\n        True\n        >>> all_unique([1, 2, 2, 3])\n        False\n    \"\"\"\n    # Set to track seen elements\n    seen = set()\n    \n    # Iterate over each element in the list\n    for item in elements:\n        # If the item is already in seen, it's not unique\n        if item in seen:\n            return False\n        # Add the current item to the set of seen elements\n        seen.add(item)\n    \n    # If we've made it here, all elements are unique\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    This function uses a set to efficiently check for duplicates,\n    since sets do not allow duplicate elements. If the length of the\n    set created from the list is equal to the length of the original\n    list, then all elements must be unique.\n\n    Args:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Examples:\n    >>> all_unique([1, 2, 3])\n    True\n    >>> all_unique([1, 2, 2, 3])\n    False\n    \"\"\"\n    # Convert list to set to remove duplicates, then compare lengths\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Examples:\n    >>> all_unique([1, 2, 3])\n    True\n    >>> all_unique([1, 2, 2])\n    False\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # Compare the length of the set with the length of the original list\n    return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The list to check for uniqueness of elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Examples:\n    >>> assert all_unique([1, 2, 3]) == True\n    >>> assert all_unique([1, 2, 1, 3]) == False\n    \"\"\"\n    # Using set to count unique elements\n    # If the length of the list is equal to the number of unique elements, all are unique\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Examples:\n    >>> all_unique([1,2,3])\n    True\n    >>> all_unique([1, 1, 2, 3])\n    False\n    \"\"\"\n    # Convert the list to a set. Sets cannot have duplicate values, so if \n    # the length of the set is equal to the length of the original list, \n    # all elements must be unique.\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    This function uses a set for comparison because sets in Python cannot have duplicate elements.\n    Thus, if the length of the list and the length of a set created from the list are the same,\n    it means all elements are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness of elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Examples:\n    >>> assert all_unique([1,2,3]) == True\n    >>> assert all_unique([1,2,1]) == False\n    \"\"\"\n    # Convert list to set and compare lengths\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n\n    Example:\n    >>> all_unique([1, 2, 3])\n    True\n    >>> all_unique([1, 2, 2, 3])\n    False\n    \"\"\"\n    # Convert list to a set, which automatically removes duplicates\n    # Then compare the length of the set with the original list\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 96.41025641025641, "dps_norm": 98.33333333333333, "pass@1": 93.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array using a modified merge sort algorithm.\n    \n    An inversion occurs when for two indices i and j, where i < j, arr[i] > arr[j].\n    \n    Args:\n    arr (list): The list in which to count inversions.\n    \n    Returns:\n    int: The number of inversions in the array.\n    \n    Example:\n    >>> assert get_Inv_Count([1,20,6,4,5]) == 5\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Divide array into two halves\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        # Total inversions = inversions in left + inversions in right + inversions during merge\n        return merged, inv_left + inv_right + inv_merge\n\n    def merge_and_count(left, right):\n        i = j = inv_count = 0\n        result = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                # Here, an inversion occurs for all remaining elements in 'left'\n                inv_count += len(left) - i\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv_count\n\n    _, count = merge_sort(arr)\n    return count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n    An inversion occurs when for any i < j, arr[i] > arr[j].\n    \n    Args:\n    arr (list): List of integers where inversions are to be counted.\n    \n    Returns:\n    int: The total number of inversions in the array.\n    \n    Example:\n    >>> get_Inv_Count([1, 20, 6, 4, 5])\n    5\n    \"\"\"\n    def merge_sort(arr, left, right):\n        if left >= right:\n            return 0\n        \n        mid = (left + right) // 2\n        inv_count = merge_sort(arr, left, mid)\n        inv_count += merge_sort(arr, mid + 1, right)\n        inv_count += merge(arr, left, mid, right)\n        return inv_count\n\n    def merge(arr, left, mid, right):\n        i = left      # starting index for left subarray\n        j = mid + 1   # starting index for right subarray\n        k = left      # starting index for temporary array\n        temp = [0] * len(arr)\n        count = 0\n        \n        # Merge the two parts while counting inversions\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                i += 1\n                k += 1\n            else:\n                # Here we count inversion, but not swap elements\n                temp[k] = arr[j]\n                j += 1\n                k += 1\n                count += (mid + 1) - i\n        \n        # Copy the remaining elements of left subarray, if there are any\n        while i <= mid:\n            temp[k] = arr[i]\n            k += 1\n            i += 1\n        \n        # Copy the remaining elements of right subarray, if there are any\n        while j <= right:\n            temp[k] = arr[j]\n            k += 1\n            j += 1\n        \n        # Copy back the merged elements to the original array\n        for i in range(left, right + 1):\n            arr[i] = temp[i]\n        \n        return count\n    \n    return merge_sort(arr, 0, len(arr) - 1)", "matching_cluster_idx": 3}, {"solution": "def merge_sort_and_count(arr):\n    \"\"\"\n    Sorts the array using merge sort and counts the number of inversions.\n    \n    An inversion occurs when for two indices i and j, i < j and arr[i] > arr[j].\n    \n    :param arr: List of integers to be sorted\n    :return: Tuple containing the sorted list and the number of inversions\n    \"\"\"\n    # Base case: if the array has 1 or fewer elements, it's already sorted\n    if len(arr) <= 1:\n        return arr, 0\n    \n    # Find the middle point to divide the array into two halves\n    mid = len(arr) // 2\n    \n    # Recursive calls\n    left, inv_left = merge_sort_and_count(arr[:mid])\n    right, inv_right = merge_sort_and_count(arr[mid:])\n    \n    # Merge the two halves while counting inversions\n    merged, inv_merge = merge(left, right)\n    \n    # Total inversions\n    inversions = inv_left + inv_right + inv_merge\n    \n    return merged, inversions\ndef merge(left, right):\n    \"\"\"\n    Merges two sorted arrays and counts split inversions.\n    \n    :param left: Left sorted subarray\n    :param right: Right sorted subarray\n    :return: Merged array and count of inversions\n    \"\"\"\n    result = []\n    inversions = 0\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            # All remaining elements in left will contribute to inversions\n            inversions += len(left) - i\n            result.append(right[j])\n            j += 1\n\n    # Append any remaining elements from left or right\n    result += left[i:]\n    result += right[j:]\n    \n    return result, inversions\ndef get_Inv_Count(arr):\n    \"\"\"\n    Wrapper function to count inversions in an array using merge sort.\n    \n    :param arr: List of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    _, count = merge_sort_and_count(arr)\n    return count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    \"\"\"Merge two sorted subarrays and count inversions.\"\"\"\n    i = left     # Starting index for left subarray\n    j = mid + 1  # Starting index for right subarray\n    k = left     # Starting index for temporary array\n    inv_count = 0\n\n    # Conditions are checked and accordingly they are merged in temp array\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            # Here an inversion is found, since arr[i] > arr[j] means\n            # all elements from i+1 to mid are greater than arr[j], hence count inv\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            k += 1\n            j += 1\n\n    # If remaining elements in left array, copy them\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n\n    # If remaining elements in right array, copy them\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n\n    # Copy back the merged elements from temp_arr to arr\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n\n    return inv_count\ndef get_Inv_Count(arr):\n    \"\"\"Count the number of inversions in an array.\"\"\"\n    # Get the size of given array\n    size = len(arr)\n    temp_arr = [0] * size\n    # Function to merge and count inversions\n    def _merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            \n            # Count inversions in left part\n            inv_count += _merge_sort_and_count(arr, temp_arr, left, mid)\n            # Count inversions in right part\n            inv_count += _merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            # Merge the two parts and count splits\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n    \n    return _merge_sort_and_count(arr, temp_arr, 0, size - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    \"\"\"Helper function to merge two sorted subarrays while counting inversions.\"\"\"\n    i = left    # Start index of left subarray\n    j = mid + 1 # Start index of right subarray\n    k = left    # Start index for placing elements in temp array\n    inv_count = 0\n\n    # Traverse both lists and in each iteration add smaller element to temp array\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            # Here's where an inversion occurs\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            k += 1\n            j += 1\n\n    # Copy remaining elements if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n\n    # Copy back the merged elements to original array\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n\n    return inv_count\ndef get_Inv_Count(arr):\n    \"\"\"\n    Count inversions in the array using the merge sort approach.\n    \n    Args:\n    arr (list): An array of integers.\n\n    Returns:\n    int: The number of inversions in the array.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    temp_arr = [0] * len(arr)\n    inv_count = _get_Inv_Count(arr, temp_arr, 0, len(arr) - 1)\n    return inv_count\ndef _get_Inv_Count(arr, temp_arr, left, right):\n    \"\"\"Recursive function to count inversions using divide-and-conquer.\"\"\"\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        # Count inversions in left half\n        inv_count += _get_Inv_Count(arr, temp_arr, left, mid)\n        # Count inversions in right half\n        inv_count += _get_Inv_Count(arr, temp_arr, mid + 1, right)\n        # Merge the two parts while counting split inversions\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n    \n    An inversion occurs when for two indices i and j, where i < j, \n    yet arr[i] > arr[j].\n    \n    Args:\n    arr (list): The input array of numbers.\n\n    Returns:\n    int: The count of inversions in the array.\n    \n    Example:\n    >>> get_Inv_Count([1,20,6,4,5])\n    5\n    \"\"\"\n    def merge_sort(arr, l, r):\n        inv_count = 0\n        if l < r:\n            # Find the middle point to divide the array into two halves\n            m = (l + r) // 2\n\n            # Count inversions in the left half\n            inv_count += merge_sort(arr, l, m)\n\n            # Count inversions in the right half\n            inv_count += merge_sort(arr, m + 1, r)\n\n            # Merge the two halves and count split inversions\n            inv_count += merge(arr, l, m, r)\n        return inv_count\n\n    def merge(arr, l, m, r):\n        # Temporary arrays to hold subarrays\n        left = arr[l:m+1]\n        right = arr[m+1:r+1]\n        i, j, k, swaps = 0, 0, l, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                # Here's an inversion\n                arr[k] = right[j]\n                j += 1\n                swaps += (m + 1) - (l + i)\n            k += 1\n\n        # Copy remaining elements of left[] if any\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        # Copy remaining elements of right[] if any\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n        return swaps\n\n    # Starting the merge sort from the beginning to the end of the array\n    return merge_sort(arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, left, mid, right):\n    left_part = arr[left:mid + 1]\n    right_part = arr[mid + 1:right + 1]\n    \n    i, j, k = 0, 0, left\n    inv_count = 0\n\n    while i < len(left_part) and j < len(right_part):\n        if left_part[i] <= right_part[j]:\n            arr[k] = left_part[i]\n            i += 1\n        else:\n            # Here, left_part[i] > right_part[j], hence an inversion\n            arr[k] = right_part[j]\n            j += 1\n            inv_count += len(left_part) - i\n            \n        k += 1\n\n    # Append remaining elements of left_part, if any\n    while i < len(left_part):\n        arr[k] = left_part[i]\n        i += 1\n        k += 1\n\n    # No need to append right_part because it would not contribute to inversions\n\n    return inv_count\ndef get_Inv_Count(arr, l=0, r=None):\n    \"\"\"\n    Count inversions in an array using a modified merge sort.\n\n    :param arr: List of integers to count inversions in.\n    :param l: Left index of the array (or subarray).\n    :param r: Right index of the array (or subarray).\n    :return: Number of inversions.\n    \"\"\"\n    if r is None:\n        r = len(arr) - 1\n    \n    # Base case: single element\n    if l >= r:\n        return 0\n\n    inv_count = 0\n    mid = (l + r) // 2\n\n    # Count inversions in left half\n    inv_count += get_Inv_Count(arr, l, mid)\n\n    # Count inversions in right half\n    inv_count += get_Inv_Count(arr, mid + 1, r)\n\n    # Count inversions while merging the two halves\n    inv_count += merge_and_count(arr, l, mid, r)\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_sort(arr, left=0, right=None):\n    \"\"\"\n    Perform merge sort on the array and count inversions.\n    \n    :param arr: List of integers to sort and count inversions on\n    :param left: Starting index of the subarray to sort\n    :param right: Ending index of the subarray to sort\n    :return: Tuple of the sorted list and number of inversions\n    \"\"\"\n    if right is None:\n        right = len(arr) - 1\n    count = 0\n    \n    if left < right:\n        # Calculate middle point\n        mid = (left + right) // 2\n        \n        # Sort first and second halves\n        count += merge_sort(arr, left, mid)\n        count += merge_sort(arr, mid + 1, right)\n        \n        # Merge the sorted halves\n        count += merge(arr, left, mid, right)\n    \n    return count\ndef merge(arr, left, mid, right):\n    \"\"\"\n    Merge two sorted subarrays of arr[].\n    \n    :param arr: List to merge\n    :param left: Start index of the left subarray\n    :param mid: End index of the left subarray\n    :param right: End index of the right subarray\n    :return: Number of inversions during merging\n    \"\"\"\n    # Create temporary arrays\n    L = arr[left:mid+1]\n    R = arr[mid+1:right+1]\n    \n    i, j, k = 0, 0, left\n    inversion_count = 0\n    \n    while i < len(L) and j < len(R):\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            # Here L[i] > R[j], which counts as inversion for all L[i] to L[mid]\n            inversion_count += len(L) - i\n            arr[k] = R[j]\n            j += 1\n        k += 1\n\n    # Copy remaining elements of L[] if any\n    while i < len(L):\n        arr[k] = L[i]\n        i += 1\n        k += 1\n\n    # Copy remaining elements of R[] if any\n    while j < len(R):\n        arr[k] = R[j]\n        j += 1\n        k += 1\n\n    return inversion_count\ndef get_Inv_Count(arr):\n    \"\"\"\n    Count the number of inversions in the given array.\n    \n    :param arr: List of integers\n    :return: Number of inversions\n    \"\"\"\n    return merge_sort(arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n    An inversion is defined when for any i < j, arr[i] > arr[j].\n    \n    Args:\n    arr (list): The input array to count inversions in.\n\n    Returns:\n    int: The number of inversions in the array.\n\n    Examples:\n    >>> get_Inv_Count([1,20,6,4,5])\n    5\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        # Initialize inversions count for this segment\n        inv_count = 0\n\n        i = left      # i is index for left subarray\n        j = mid + 1   # j is index for right subarray\n        k = left      # k is index for resultant merged subarray\n        \n        # While there are elements in the left and right runs\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                k += 1\n                i += 1\n            else:\n                # Here is an inversion, since left element is greater than right element\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                k += 1\n                j += 1\n\n        # Copy remaining elements\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n\n        while j <= right:\n            temp_arr[k] = arr[j]\n            k += 1\n            j += 1\n\n        # Copy back the merged elements to original array\n        for loop_var in range(left, right + 1):\n            arr[loop_var] = temp_arr[loop_var]\n\n        return inv_count\n\n    def _mergeSort(arr, temp_arr, left, right):\n        inv_count = 0\n        if right > left:\n            mid = (left + right)//2\n            \n            # Count inversions in left and right parts\n            inv_count += _mergeSort(arr, temp_arr, left, mid)\n            inv_count += _mergeSort(arr, temp_arr, mid + 1, right)\n\n            # Merge the two parts\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Create a temporary array for merge sort\n    temp_arr = [0] * len(arr)\n    return _mergeSort(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count(arr, l, r):\n    count = 0\n    if l < r:\n        m = (l + r) // 2\n        # Count inversions in left and right halves\n        count += merge_sort_and_count(arr, l, m)\n        count += merge_sort_and_count(arr, m + 1, r)\n        # Merge the sorted halves while counting split inversions\n        count += merge(arr, l, m, r)\n    return count\ndef merge(arr, l, m, r):\n    n1 = m - l + 1\n    n2 = r - m\n    L = [arr[l + i] for i in range(n1)]\n    R = [arr[m + 1 + i] for i in range(n2)]\n    \n    i, j, k = 0, 0, l\n    inversions = 0\n    \n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            # Here's where we count inversions\n            arr[k] = R[j]\n            inversions += (n1 - i)  # Number of remaining elements in L\n            j += 1\n        k += 1\n    \n    # Copy the remaining elements of L[], if any\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    \n    # Copy the remaining elements of R[], if there are any\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    \n    return inversions\ndef get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    \n    An inversion occurs when for two indices i and j, where i < j, \n    arr[i] > arr[j].\n\n    Args:\n    arr (list): The input array of integers.\n\n    Returns:\n    int: Number of inversions.\n\n    Examples:\n    >>> get_Inv_Count([1, 20, 6, 4, 5])\n    5\n    \"\"\"\n    return merge_sort_and_count(arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Count the number of inversions in an array.\n    \n    An inversion is defined as a pair (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n    arr (list): The list to check for inversions.\n\n    Returns:\n    int: The number of inversions in the array.\n\n    Example:\n    >>> get_Inv_Count([1,20,6,4,5])\n    5\n    \"\"\"\n    def merge_sort(arr, l, r):\n        inv_count = 0\n        \n        if l < r:\n            m = (l + r) // 2\n            \n            # Count inversions in the left half\n            inv_count += merge_sort(arr, l, m)\n            # Count inversions in the right half\n            inv_count += merge_sort(arr, m + 1, r)\n            # Count split inversions\n            inv_count += merge(arr, l, m, r)\n\n        return inv_count\n\n    def merge(arr, l, m, r):\n        # Temporary arrays\n        L = arr[l:m + 1]\n        R = arr[m + 1:r + 1]\n        i = j = 0\n        k = l\n        inv_count = 0\n\n        # Merge the two halves back into the original array while counting split inversions\n        while i < len(L) and j < len(R):\n            if L[i] <= R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                # Here L[i] > R[j], which means all remaining elements in L \n                # form an inversion with R[j]\n                arr[k] = R[j]\n                inv_count += len(L) - i\n                j += 1\n            k += 1\n\n        # Copy remaining elements of L[] if any\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        # Copy remaining elements of R[] if any\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\n        return inv_count\n\n    # Start the merge sort from the entire array\n    return merge_sort(arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    \"\"\"Merge two sorted subarrays of arr[] and count the number of inversions.\"\"\"\n    inv_count = 0\n    i = left\n    j = mid + 1\n    k = left\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            # Here's the key: if arr[i] > arr[j], then all elements from i to mid\n            # will also be greater than arr[j], hence count as inversions\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            k += 1\n            j += 1\n    \n    # Copy remaining elements if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n    \n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n\n    # Copy back the merged elements to original array\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n\n    return inv_count\ndef _merge_sort_and_count(arr, temp_arr, left, right):\n    \"\"\"Recursive function to sort and count inversions.\"\"\"\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        \n        inv_count += _merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += _merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        \n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n    return inv_count\ndef get_Inv_Count(arr):\n    \"\"\"Count the number of inversions in the array.\"\"\"\n    temp_arr = [0] * len(arr)\n    return _merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_sort(arr):\n    \"\"\"Helper function to count inversions using merge sort.\"\"\"\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left, inv_left = merge_sort(arr[:mid])\n    right, inv_right = merge_sort(arr[mid:])\n\n    merged, inv_merge = merge(left, right)\n    return merged, inv_left + inv_right + inv_merge\ndef merge(left, right):\n    \"\"\"Merge two sorted lists and count split inversions.\"\"\"\n    result = []\n    inversions = 0\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            # Here we count inversions: any element in left[i:] should be counted as an inversion with right[j]\n            inversions += len(left) - i  \n\n    # Append remaining elements, if any\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result, inversions\ndef get_Inv_Count(arr):\n    \"\"\"Count the number of inversions in the given array.\"\"\"\n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count(arr):\n    \"\"\" \n    Recursively sorts the array and counts inversions using merge sort.\n    \n    Args:\n    arr (list): The list to sort and count inversions in.\n\n    Returns:\n    tuple: A tuple where the first element is the sorted array and \n           the second is the number of inversions.\n    \"\"\"\n    # Base case: if array has 1 or fewer elements, it's sorted and has no inversions\n    if len(arr) <= 1:\n        return arr, 0\n    \n    # Find the middle point to divide the array into two halves\n    mid = len(arr) // 2\n    left, inv_left = merge_sort_and_count(arr[:mid])\n    right, inv_right = merge_sort_and_count(arr[mid:])\n    \n    # Count inversions when merging\n    merged, inv_merge = merge(left, right)\n    \n    return merged, inv_left + inv_right + inv_merge\ndef merge(left, right):\n    \"\"\"\n    Merges two sorted arrays and counts split inversions.\n    \n    Args:\n    left (list): Left sorted sublist\n    right (list): Right sorted sublist\n    \n    Returns:\n    tuple: Merged sorted list and the number of split inversions\n    \"\"\"\n    result = []\n    i, j = 0, 0\n    inversions = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            # Here we count the inversions for elements in 'left' that are greater than current 'right[j]'\n            inversions += len(left) - i\n            result.append(right[j])\n            j += 1\n    \n    result += left[i:]\n    result += right[j:]\n    \n    return result, inversions\ndef get_Inv_Count(arr):\n    \"\"\" \n    Wrapper function to count inversions in the array.\n    \n    Args:\n    arr (list): List to count inversions in.\n    \n    Returns:\n    int: Number of inversions in the array.\n    \"\"\"\n    _, inversions = merge_sort_and_count(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, inv_left = merge_sort_and_count(arr[:mid])\n    right, inv_right = merge_sort_and_count(arr[mid:])\n    \n    merged, inv_merge = merge_and_count(left, right)\n    \n    return merged, inv_left + inv_right + inv_merge\ndef merge_and_count(left, right):\n    result = []\n    inversions = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            # Here we count inversions, since all remaining elements in left are greater than right[j]\n            inversions += len(left) - i\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result, inversions\ndef get_Inv_Count(arr):\n    \"\"\"Counts the number of inversions in the given array.\n    \n    An inversion is when for an index i < j, arr[i] > arr[j].\n    \n    Args:\n    arr (list): The input array of integers.\n    \n    Returns:\n    int: The number of inversions in the array.\n    \n    Examples:\n    >>> assert get_Inv_Count([1, 20, 6, 4, 5]) == 5\n    \"\"\"\n    _, count = merge_sort_and_count(arr)\n    return count", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count(arr, temp_arr, left, right):\n    \"\"\"\n    Helper function to perform merge sort and count inversions.\n    \n    :param arr: The array to be sorted and inversion counted.\n    :param temp_arr: Temporary array for merging.\n    :param left: Start index of the sub-array in arr[].\n    :param right: End index of the sub-array in arr[].\n    :return: Number of inversions in the sub-array.\n    \"\"\"\n    inv_count = 0\n    \n    if left < right:\n        mid = (left + right) // 2\n        \n        # Count inversions in left and right parts\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n        # Merge the two parts and count splits inversions\n        inv_count += merge(arr, temp_arr, left, mid + 1, right)\n    \n    return inv_count\ndef merge(arr, temp_arr, left, mid, right):\n    \"\"\"\n    Merge two sorted subarrays and count split inversions.\n    \n    :param arr: The original array where elements will be sorted.\n    :param temp_arr: Array for temporary storage.\n    :param left: Start index of left subarray.\n    :param mid: End index of left subarray and start -1 of right subarray.\n    :param right: End index of right subarray.\n    :return: Number of split inversions found while merging.\n    \"\"\"\n    i = left     # i is index for left subarray\n    j = mid      # j is index for right subarray\n    k = left     # k is index for resultant merged subarray\n    inv_count = 0\n\n    while i <= mid - 1 and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i)\n            k += 1\n            j += 1\n\n    # Copy the remaining elements of left subarray\n    while i <= mid - 1:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n\n    # Copy the remaining elements of right subarray\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n\n    # Copy back the merged elements to original array\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n\n    return inv_count\ndef get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array.\n    \n    :param arr: List of integers to check for inversions.\n    :return: Integer representing the number of inversions.\n    \"\"\"\n    temp_arr = [0]*len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge(arr, temp_arr, left, mid, right):\n    \"\"\"Helper function to merge two sorted arrays and count split inversions.\"\"\"\n    inv_count = 0\n    \n    i = left      # i is index for left subarray\n    j = mid       # j is index for right subarray\n    k = left      # k is index for resultant merged subarray\n    \n    while (i <= mid - 1) and (j <= right):\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            # Here an inversion is found as arr[i] > arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i)\n            k += 1\n            j += 1\n    \n    # Copy the remaining elements of left subarray (if any)\n    while i <= mid - 1:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n    \n    # Copy the remaining elements of right subarray (if any)\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n    \n    # Copy back the merged elements to original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef get_Inv_Count(arr):\n    \"\"\"\n    Count the number of inversions in an array using the merge sort approach.\n    \n    An inversion occurs when for two numbers `a[i]` and `a[j]` where `i < j` but `a[i] > a[j]`.\n    \n    :param arr: List of integers where inversions are to be counted\n    :return: Number of inversions in the list\n    \"\"\"\n    # Allocate temporary array of same size as arr\n    temp_arr = [0]*len(arr)\n    \n    # Start with full array\n    return _mergeSort(arr, temp_arr, 0, len(arr) - 1)\ndef _mergeSort(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right)//2\n        \n        # Inversion count will be sum of\n        # inversions in left-part, right-part\n        # and number of inversions in merging\n        inv_count += _mergeSort(arr, temp_arr, left, mid)\n        inv_count += _mergeSort(arr, temp_arr, mid + 1, right)\n        \n        # Merge the two parts\n        inv_count += merge(arr, temp_arr, left, mid + 1, right)\n    \n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    \"\"\" Helper function for get_Inv_Count to merge two sorted arrays while counting inversions \"\"\"\n    i, j, k, inv_count = left, mid + 1, left, 0\n\n    # While there are elements in the left and right runs\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            # Here's an inversion\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            k += 1\n            j += 1\n\n    # Copy remaining elements\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n\n    # Copy back the merged elements to original array\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n    \n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    \"\"\" Recursive function to sort and count inversions \"\"\"\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        # Count inversions in left half\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n\n        # Count inversions in right half\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n        # Count inversions while merging left and right halves\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n    \n    return inv_count\ndef get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array using modified merge sort.\n\n    An inversion is counted each time we find a[i] > a[j] where i < j.\n\n    :param arr: List of integers where inversions need to be counted\n    :return: Total number of inversions\n    \"\"\"\n    # Temporary array for merge sort\n    temp_arr = [0]*len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(left, right):\n    result = []\n    inversions = 0\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            # Here's where we count inversions\n            result.append(right[j])\n            j += 1\n            inversions += len(left) - i\n\n    result += left[i:]\n    result += right[j:]\n    \n    return result, inversions\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, inv_left = merge_sort_and_count(arr[:mid])\n    right, inv_right = merge_sort_and_count(arr[mid:])\n    \n    merged, split_inv = merge_and_count(left, right)\n    \n    return merged, (inv_left + inv_right + split_inv)\ndef get_Inv_Count(arr):\n    \"\"\"\n    Count the number of inversions in the given array.\n\n    An inversion is counted when for two indices i and j, i < j and arr[i] > arr[j].\n\n    :param arr: List[int], the array to check for inversions\n    :return: int, the number of inversions\n    \n    Example:\n    >>> assert get_Inv_Count([1,20,6,4,5]) == 5\n    \"\"\"\n    _, count = merge_sort_and_count(arr)\n    return count\ntest_array = [1, 20, 6, 4, 5]\nresult = get_Inv_Count(test_array)", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count(arr, left, right):\n    \"\"\"\n    Recursively sorts the array and counts inversions using merge sort technique.\n\n    Args:\n    arr (list): The array to be sorted and inversions counted.\n    left (int): Starting index of the portion of the array to sort.\n    right (int): Ending index of the portion of the array to sort.\n\n    Returns:\n    tuple: A tuple containing the number of inversions and the sorted array.\n    \"\"\"\n    count = 0\n    if left < right:\n        mid = (left + right) // 2\n        \n        # Count inversions for the left and right half\n        inv_left, arr[left:mid+1] = merge_sort_and_count(arr, left, mid)\n        inv_right, arr[mid+1:right+1] = merge_sort_and_count(arr, mid + 1, right)\n        \n        # Count split inversions while merging\n        inv_merge, merged = merge_and_count(arr, left, mid, right)\n        \n        count = inv_left + inv_right + inv_merge\n        return count, merged\n    return 0, arr[left:right+1] if left != right else arr[left:left+1]\ndef merge_and_count(arr, left, mid, right):\n    \"\"\"\n    Merges two sorted subarrays of arr[] and counts split inversions.\n\n    Args:\n    arr (list): The array containing two sorted subarrays to be merged.\n    left (int): Starting index of first subarray.\n    mid (int): Ending index of first subarray and starting - 1 of the second.\n    right (int): Ending index of the second subarray.\n\n    Returns:\n    tuple: Number of inversions and the merged array.\n    \"\"\"\n    # Temporary arrays for left and right halves\n    left_arr = arr[left:mid+1]\n    right_arr = arr[mid+1:right+1]\n    \n    i, j, k = 0, 0, left\n    inv_count = 0\n    \n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            arr[k] = left_arr[i]\n            i += 1\n        else:\n            # Here an inversion occurs for all remaining elements in left_arr\n            inv_count += len(left_arr) - i\n            arr[k] = right_arr[j]\n            j += 1\n        k += 1\n\n    # Copy remaining elements of left_arr, if any\n    while i < len(left_arr):\n        arr[k] = left_arr[i]\n        i += 1\n        k += 1\n    \n    # Copy remaining elements of right_arr, if any (no inversions)\n    while j < len(right_arr):\n        arr[k] = right_arr[j]\n        j += 1\n        k += 1\n    \n    return inv_count, arr[left:right+1]\ndef get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n\n    Args:\n    arr (list): The input array to count inversions in.\n\n    Returns:\n    int: The number of inversions.\n\n    Example:\n    >>> assert get_Inv_Count([1,20,6,4,5]) == 5\n    \"\"\"\n    inversions, _ = merge_sort_and_count(arr, 0, len(arr) - 1)\n    return inversions", "matching_cluster_idx": 5}]}, "Mbpp/308": {"dps": 91.6896551724138, "dps_norm": 70.83333333333333, "pass@1": 85.0, "profiled": [{"solution": "def large_product(list1, list2, num_products):\n    # Generate all possible products by combining elements from list1 and list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort products in descending order and take the top num_products elements\n    sorted_products = sorted(set(products), reverse=True)[:num_products]\n    \n    return sorted_products", "matching_cluster_idx": 4}, {"solution": "from itertools import product\ndef large_product(list1, list2, n):\n    \"\"\"\n    Find the n largest products from all possible products of elements from two lists.\n\n    Args:\n    list1 (list): First list of numbers.\n    list2 (list): Second list of numbers.\n    n (int): Number of largest products to return.\n\n    Returns:\n    list: A list containing the n largest products.\n\n    Example:\n    >>> large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3)\n    [60, 54, 50]\n    \"\"\"\n    # Generate all possible products\n    all_products = [x * y for x, y in product(list1, list2)]\n    \n    # Use set to remove duplicates (in case there are identical products), \n    # then convert back to list and sort in descending order\n    sorted_products = sorted(set(all_products), reverse=True)\n    \n    # Return the n largest products\n    return sorted_products[:n]", "matching_cluster_idx": 4}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    # Remove duplicates and sort in descending order\n    sorted_products = sorted(set(products), reverse=True)\n    # Return the 'n' largest products or all if less than n products\n    return sorted_products[:n]", "matching_cluster_idx": 4}, {"solution": "from itertools import product\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the specified number of largest products from two given lists, \n    selecting one factor from each list.\n\n    Args:\n    list1 (List[int]): The first list of integers.\n    list2 (List[int]): The second list of integers.\n    n (int): The number of largest products to return.\n\n    Returns:\n    List[int]: A list containing the n largest products sorted in descending order.\n\n    Raises:\n    ValueError: If n is greater than the number of possible products.\n\n    Example:\n    >>> large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3)\n    [60, 54, 50]\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x, y in product(list1, list2)]\n    \n    # Check if n is valid\n    if n > len(products):\n        raise ValueError(\"n cannot exceed the number of possible products\")\n    \n    # Sort the products in descending order and return the n largest\n    return sorted(set(products), reverse=True)[:n]", "matching_cluster_idx": 4}, {"solution": "from itertools import product\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], k: int) -> List[int]:\n    \"\"\"\n    Find the k largest products of elements from list1 and list2.\n\n    This function generates all possible products by taking one element from\n    each list and returns the k largest of these products in descending order.\n\n    Args:\n    list1 (List[int]): The first list of integers.\n    list2 (List[int]): The second list of integers.\n    k (int): The number of largest products to return.\n\n    Returns:\n    List[int]: A list containing the k largest products.\n\n    Example:\n    >>> large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3)\n    [60, 54, 50]\n\n    Note:\n    - If k is larger than the possible number of products, all products will be returned.\n    - This function assumes k is positive and both lists have at least one element.\n    \"\"\"\n    # Generate all possible products\n    all_products = [x * y for x, y in product(list1, list2)]\n    \n    # Sort these products in descending order and take the k largest\n    return sorted(all_products, reverse=True)[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the largest products from two lists by selecting one factor from each list.\n    \n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param n: Number of largest products to find\n    :return: List of n largest products\n    \"\"\"\n    # Calculate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # If we need more products than what's possible, return unique products sorted in descending order\n    if n > len(products):\n        return sorted(set(products), reverse=True)\n    \n    # Return the n largest unique products\n    return sorted(set(products), reverse=True)[:n]", "matching_cluster_idx": 4}, {"solution": "from itertools import product\ndef large_product(list1, list2, n):\n    # Generate all possible products from two lists\n    products = [a * b for a, b in product(list1, list2)]\n    \n    # Sort the list in descending order and pick the top n products\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the n largest products from two lists, where one factor is chosen from each list.\n\n    Args:\n    list1 (list): First list of integers.\n    list2 (list): Second list of integers.\n    n (int): Number of largest products to return.\n\n    Returns:\n    list: A list containing the n largest products in descending order.\n\n    Examples:\n    >>> large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3)\n    [60, 54, 50]\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # If n is greater than possible combinations, adjust n\n    n = min(n, len(products))\n    \n    # Sort products in descending order and get the top n\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom itertools import product\ndef large_product(list1: List[int], list2: List[int], k: int) -> List[int]:\n    \"\"\"\n    Find the k largest products by multiplying each element from list1 with each from list2.\n\n    Args:\n    list1 (List[int]): The first list of integers.\n    list2 (List[int]): The second list of integers.\n    k (int): The number of largest products to return.\n\n    Returns:\n    List[int]: A list containing k largest products sorted in descending order.\n\n    Raises:\n    ValueError: If k is greater than the total possible number of products.\n\n    Example:\n    >>> large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3)\n    [60, 54, 50]\n    \"\"\"\n    # Check if k is valid\n    if k > len(list1) * len(list2):\n        raise ValueError(\"k is greater than the possible number of products\")\n\n    # Generate all products\n    products = [a * b for a, b in product(list1, list2)]\n    \n    # Get the k largest products by sorting the list in descending order and taking k elements\n    return sorted(products, reverse=True)[:k]", "matching_cluster_idx": 3}, {"solution": "from itertools import product\nfrom operator import mul\ndef large_product(list1, list2, n):\n    # Generate all possible products between elements of list1 and list2\n    products = [a * b for a, b in product(list1, list2)]\n    \n    # Get unique products by converting to a set, then back to a list\n    unique_products = list(set(products))\n    \n    # Sort these unique products in descending order\n    sorted_products = sorted(unique_products, reverse=True)\n    \n    # Return the n largest products\n    return sorted_products[:n]", "matching_cluster_idx": 4}, {"solution": "from typing import List\nfrom itertools import product\ndef large_product(list1: List[int], list2: List[int], num_products: int) -> List[int]:\n    \"\"\"\n    Find the 'num_products' number of largest products from two lists.\n\n    Args:\n    list1 (List[int]): First list of integers\n    list2 (List[int]): Second list of integers\n    num_products (int): Number of largest products to return\n\n    Returns:\n    List[int]: A list containing 'num_products' largest products in descending order.\n\n    Examples:\n    >>> large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)\n    [60, 54, 50]\n    \"\"\"\n    # Generate all possible products of numbers from list1 and list2\n    all_products = [a * b for a, b in product(list1, list2)]\n    \n    # Sort these products in descending order and take the top num_products\n    # Use sorted with a negative sign to sort in descending order\n    sorted_products = sorted(all_products, key=lambda x: -x)\n    \n    # Ensure we don't return more products than exist\n    return sorted_products[:min(num_products, len(sorted_products))]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists.\n\n    Args:\n    list1 (list): The first list of integers.\n    list2 (list): The second list of integers.\n    n (int): The number of largest products to find.\n\n    Returns:\n    list: A list containing the n largest products, where each product is \n          from multiplying one number from list1 with one from list2.\n\n    Example:\n    >>> large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3)\n    [60, 54, 50]\n    \"\"\"\n    # Create a list of tuples (product, (i, j)) where i and j are indices from list1 and list2 respectively\n    products = [(list1[i] * list2[j], (i, j)) for i in range(len(list1)) for j in range(len(list2))]\n    \n    # Sort by product in descending order\n    sorted_products = sorted(products, key=lambda x: x[0], reverse=True)\n    \n    # Take the top n products, ensuring uniqueness\n    result = []\n    seen = set()\n    for prod, (i, j) in sorted_products:\n        if len(result) >= n:\n            break\n        # Check if we have already used this product or any of the factors\n        if prod not in seen:\n            seen.add(prod)\n            result.append(prod)\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    # Flatten the list of products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first 'n' elements or fewer if not enough unique products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num_products):\n    # Create all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Remove duplicates by converting to a set, then back to a list for sorting\n    unique_products = list(set(products))\n    unique_products.sort(reverse=True)\n    \n    # Return the specified number of largest products\n    return unique_products[:num_products]", "matching_cluster_idx": 4}, {"solution": "def large_product(list1, list2, num_products):\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort products in descending order and take the top 'num_products'\n    return sorted(products, reverse=True)[:num_products]", "matching_cluster_idx": 3}, {"solution": "from itertools import product\ndef large_product(list1, list2, n):\n    # Create all possible products of one number from list1 and one number from list2\n    all_products = [a * b for a, b in product(list1, list2)]\n    \n    # Sort products in descending order\n    sorted_products = sorted(all_products, reverse=True)\n    \n    # Return the n largest products\n    return sorted_products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num_products):\n    # Use a list comprehension with product to generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort these products in descending order and return the top 'num_products'\n    return sorted(products, reverse=True)[:num_products]", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\nfrom itertools import product\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the specified number of largest products from two given lists, \n    selecting one factor from each list.\n\n    Args:\n    list1 (List[int]): The first list of integers.\n    list2 (List[int]): The second list of integers.\n    n (int): Number of largest products to return.\n\n    Returns:\n    List[int]: A list containing the n largest products sorted in descending order.\n\n    Example:\n    >>> large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3)\n    [60, 54, 50]\n    \"\"\"\n    # Generate all possible products by taking one element from each list\n    all_products = [a * b for a, b in product(list1, list2)]\n    \n    # Sort these products in descending order and select the top n\n    sorted_products = sorted(all_products, reverse=True)[:n]\n    \n    # Remove duplicates while maintaining order (because we're looking for unique products)\n    result = []\n    for prod in sorted_products:\n        if prod not in result:\n            result.append(prod)\n    \n    # If fewer than n unique products, fill the remainder with None or stop at result's length\n    return result + [None] * (n - len(result))", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the n largest products from two lists by pairing one element from each list.\n    \n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param n: Number of largest products to return\n    :return: List containing the n largest products in descending order\n    \n    Example:\n    >>> large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3)\n    [60, 54, 50]\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort products in descending order\n    products.sort(reverse=True)\n    \n    # Return the n largest products, but avoid IndexError if n > len(products)\n    return products[:min(n, len(products))]", "matching_cluster_idx": 3}, {"solution": "from itertools import product\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    # Generate all possible products by multiplying every number in list1 with every number in list2\n    products = [x * y for x, y in product(list1, list2)]\n    \n    # Sort these products in descending order and take the top n\n    top_n_products = sorted(products, reverse=True)[:n]\n    \n    return top_n_products", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 94.15492957746478, "dps_norm": 98.84615384615384, "pass@1": 82.0, "profiled": [{"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Find the maximum sum possible by using the given equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    :param n: Integer to compute the maximum sum for\n    :param memo: Dictionary to store computed values for memoization (default is an empty dict)\n    :return: Maximum sum according to the given equation\n    \n    This function uses dynamic programming with memoization to avoid redundant calculations.\n    \"\"\"\n    # If n is already computed, return the memoized value\n    if n in memo:\n        return memo[n]\n    \n    # Base case\n    if n <= 1:\n        return n\n    \n    # Recursive computation with memoization\n    # We use integer division here to ensure n/2, n/3, etc., give us whole numbers\n    max_sum = max(n, get_max_sum(n//2, memo) + \n                       get_max_sum(n//3, memo) + \n                       get_max_sum(n//4, memo) + \n                       get_max_sum(n//5, memo))\n    \n    # Store the result before returning\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum based on the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    :param n: The number for which to calculate the maximum sum.\n    :param memo: A dictionary used for memoization to store previously calculated results.\n    :return: The maximum sum according to the equation.\n    \"\"\"\n    # Base case: if n is in the memo dictionary, return the stored value\n    if n in memo:\n        return memo[n]\n    \n    # If n is less than or equal to 1, the sum is n itself\n    if n <= 1:\n        return n\n\n    # Recursive calculation with memoization\n    result = max(get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + \n                 get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo), \n                 n)\n    \n    # Store the result in the memo dictionary before returning\n    memo[n] = result\n    \n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Finds the maximum sum possible by using the given equation:\n    f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    :param n: The number to compute the maximum sum for.\n    :param memo: A dictionary for memoization to store already computed values.\n    :return: The maximum sum that can be obtained.\n\n    Example:\n    >>> get_max_sum(60)\n    106\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n\n    # Compute f(n) using the recursive equation\n    result = max(n, \n                 get_max_sum(n // 2, memo) +\n                 get_max_sum(n // 3, memo) +\n                 get_max_sum(n // 4, memo) +\n                 get_max_sum(n // 5, memo))\n    \n    # Memoize the result\n    memo[n] = result\n    return result", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n):\n    @lru_cache(maxsize=None)\n    def f(x):\n        # Base case: if x is 1 or less, return x\n        if x <= 1:\n            return x\n        \n        # Recursive case: calculate max sum\n        return max(x, f(x//2) + f(x//3) + f(x//4) + f(x//5))\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum possible by splitting n using the equation f(n) = max(f(n/2) + f(n/3) + f(n/4) + f(n/5), n).\n    \n    :param n: Integer to find the maximum sum for\n    :param memo: Dictionary to store results for memoization\n    :return: Maximum sum for n\n    \"\"\"\n    # Base case: if n is 0, return 0\n    if n == 0:\n        return 0\n    \n    # If n is less than or equal to 1, it's either itself or 0\n    if n <= 1:\n        return n\n    \n    # Check if the result has been memoized\n    if n in memo:\n        return memo[n]\n    \n    # Split n into possible parts\n    part1 = get_max_sum(n // 2, memo) if n > 1 else 0\n    part2 = get_max_sum(n // 3, memo) if n > 2 else 0\n    part3 = get_max_sum(n // 4, memo) if n > 3 else 0\n    part4 = get_max_sum(n // 5, memo) if n > 4 else 0\n    \n    # Compute the maximum sum between splitting or taking n itself\n    max_sum = max((part1 + part2 + part3 + part4), n)\n    \n    # Memoize the result\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def memoize(func):\n    \"\"\"Decorator for memoization to optimize recursive calls.\"\"\"\n    cache = {}\n    def memoized_func(n):\n        if n not in cache:\n            cache[n] = func(n)\n        return cache[n]\n    return memoized_func\n\n@memoize\ndef get_max_sum(n):\n    \"\"\"\n    Calculate the maximum sum for a given number n according to the equation:\n    f(n) = max(f(n/2) + f(n/3) + f(n/4) + f(n/5), n)\n    \n    :param n: An integer for which to find the maximum sum\n    :return: The maximum sum achievable according to the given formula\n    \n    >>> get_max_sum(60)\n    106\n    >>> get_max_sum(10)\n    12\n    \"\"\"\n    # Base case\n    if n <= 1:\n        return n\n    else:\n        # Calculate recursive calls, use int() to ensure integer division\n        sub_sums = [get_max_sum(n // i) for i in [2, 3, 4, 5] if n // i >= 1]\n        \n        # Sum of the sub-solutions if any exist, otherwise return n\n        sum_sub = sum(sub_sums) if sub_sums else 0\n        return max(n, sum_sub)\n\nif __name__ == \"__main__\":\n    print(get_max_sum(60))  # Should print 106\n    import doctest\n    doctest.testmod()", "matching_cluster_idx": 11}, {"solution": "def get_max_sum(n, memo = {}):\n    # Base case: if n is 0 or negative, return 0\n    if n <= 0:\n        return 0\n    \n    # Check if we've already computed f(n)\n    if n in memo:\n        return memo[n]\n    \n    # Recursive case: find max of current n or sum of recursive calls\n    max_sum = max(\n        n,\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    \n    # Memoize the result\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum using the equation f(n) = max( f(n/2) + f(n/3) + f(n/4) + f(n/5), n ).\n    \n    This function uses memoization to improve performance by storing previously computed results.\n\n    Args:\n    n (int): The number for which to compute the maximum sum.\n    memo (dict): Memoization dictionary to store already calculated values. Default is an empty dict.\n\n    Returns:\n    int: The maximum sum as defined by the function.\n\n    Example:\n    >>> assert get_max_sum(60) == 106\n    \"\"\"\n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n    \n    # Check if we've already calculated this value\n    if n in memo:\n        return memo[n]\n    \n    # Compute the value recursively\n    result = max(n, \n                 get_max_sum(n//2, memo) + \n                 get_max_sum(n//3, memo) + \n                 get_max_sum(n//4, memo) + \n                 get_max_sum(n//5, memo))\n    \n    # Store the result in the memo dictionary before returning\n    memo[n] = result\n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Calculate the maximum sum according to the formula:\n    f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Args:\n    n (int): The number for which to calculate the maximum sum.\n    memo (dict): Memoization dictionary to store previously computed results.\n    \n    Returns:\n    int: The maximum sum achievable for the given n.\n    \n    Example:\n    >>> get_max_sum(60)\n    106\n    \"\"\"\n    # Base case: if n is small or memoized, return n or the memoized value\n    if n < 1 or n in memo:\n        return memo.get(n, n)\n    \n    # Recursive calculation using memoization\n    max_sum = max(\n        n, \n        get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo)\n    )\n    # Store the result in memo\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum possible by using the equation:\n    f(n) = max(f(n/2) + f(n/3) + f(n/4) + f(n/5), n)\n    \n    Args:\n    n (int): The number to compute the maximum sum for.\n\n    Returns:\n    int: The maximum sum according to the given equation.\n\n    This function uses memoization to optimize repeated calculations.\n    \"\"\"\n    # Memoization dictionary to store computed values\n    memo = {0: 0}\n\n    def recurse(num):\n        if num not in memo:\n            # If n is divisible by at least one of 2, 3, 4, or 5, compute the max sum\n            if num // 2 > 0 or num // 3 > 0 or num // 4 > 0 or num // 5 > 0:\n                memo[num] = max(num, \n                                 recurse(num // 2) + recurse(num // 3) + \n                                 recurse(num // 4) + recurse(num // 5))\n            else:\n                # If n is not divisible by 2, 3, 4, or 5, return n itself\n                memo[num] = num\n        return memo[num]\n\n    return recurse(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum possible using the equation:\n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n\n    This function uses memoization to optimize the recursive computation\n    by storing already computed results.\n\n    Args:\n    n (int): The number to start the calculation from.\n    memo (dict): Memoization dictionary to store computed results.\n\n    Returns:\n    int: The maximum sum for n.\n\n    Example:\n    >>> get_max_sum(60)\n    106\n    \"\"\"\n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n\n    # Check if this computation has been done before\n    if n in memo:\n        return memo[n]\n\n    # Calculate the sum of function calls with smaller divisions\n    sub_sum = (get_max_sum(n // 2, memo) + \n               get_max_sum(n // 3, memo) + \n               get_max_sum(n // 4, memo) + \n               get_max_sum(n // 5, memo))\n\n    # Store the result in memo and return the maximum of the two options\n    memo[n] = max(sub_sum, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    \n    if n <= 1:\n        return n\n    if n in memo:\n        return memo[n]\n    \n    # Calculate sum using the given equation\n    sum_using_equation = (\n        get_max_sum(n // 2, memo) + \n        get_max_sum(n // 3, memo) + \n        get_max_sum(n // 4, memo) + \n        get_max_sum(n // 5, memo)\n    )\n    \n    # The max of either just returning n or applying the equation\n    max_sum = max(n, sum_using_equation)\n    \n    # Memoize the result\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Finds the maximum sum possible using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    :param n: Integer for which the maximum sum is calculated\n    :param memo: Dictionary for memoization to store already computed values\n    :return: Maximum sum for n according to the given equation\n\n    Example:\n    >>> get_max_sum(60)\n    106\n    \"\"\"\n    # Base case when n is 0 or 1\n    if n <= 1:\n        return n\n    \n    # If we've already computed this value, return it\n    if n in memo:\n        return memo[n]\n\n    # Recursive calculation for each division\n    sums = [get_max_sum(n//i, memo) for i in [2, 3, 4, 5]]\n    \n    # Sum the recursive calls\n    total = sum(sums)\n    \n    # Choose the maximum between the sum of divisions and n itself\n    result = max(n, total)\n    \n    # Memoize the result\n    memo[n] = result\n    \n    return result", "matching_cluster_idx": 11}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum possible for the function f(n) where:\n    f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n\n    Args:\n    n (int): The number for which to calculate the maximum sum.\n    memo (dict): Memoization dictionary to store results for previously computed values.\n\n    Returns:\n    int: The maximum sum for f(n).\n\n    Example:\n    >>> assert get_max_sum(60) == 106\n    \"\"\"\n    # Base case when n is less than or equal to 1\n    if n <= 1:\n        return n\n    \n    # If n is already in memo, return the memoized value\n    if n in memo:\n        return memo[n]\n\n    # Calculate potential sum by recursively calling the function\n    # and ensure integer division by using floor division (//)\n    potential_sum = (get_max_sum(n // 2) + \n                     get_max_sum(n // 3) + \n                     get_max_sum(n // 4) + \n                     get_max_sum(n // 5))\n\n    # Compute the maximum between the potential sum and n itself\n    result = max(potential_sum, n)\n\n    # Memoize the result\n    memo[n] = result\n\n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store computed results\n    memo = {}\n    \n    def f(x):\n        # Base case: if x is already computed or x is less than or equal to 1\n        if x <= 1 or x in memo:\n            return x if x not in memo else memo[x]\n        \n        # Recursive computation with memoization\n        val = max(x, f(x//2) + f(x//3) + f(x//4) + f(x//5))\n        memo[x] = val  # Cache the result\n        return val\n    \n    # Call the helper function f with n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Compute the maximum sum possible from the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n    n (int): The number to calculate the maximum sum for.\n    memo (dict): Memoization dictionary to store previously computed results.\n\n    Returns:\n    int: The maximum sum achievable.\n\n    Example:\n    >>> get_max_sum(60)\n    106\n    \"\"\"\n    # Base case: if n is 0, return 0\n    if n == 0:\n        return 0\n    \n    # Check if n has already been calculated\n    if n in memo:\n        return memo[n]\n\n    # Calculate f(n/2) + f(n/3) + f(n/4) + f(n/5)\n    sum_parts = [\n        get_max_sum(n // 2, memo),\n        get_max_sum(n // 3, memo),\n        get_max_sum(n // 4, memo),\n        get_max_sum(n // 5, memo)\n    ]\n\n    # Store the result in memo before returning\n    memo[n] = max(sum(sum_parts), n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Find the maximum sum for a given n using the equation:\n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    :param n: The number for which to calculate the maximum sum.\n    :param memo: Memoization dictionary to store already computed results.\n    :return: The maximum sum that can be obtained.\n    \"\"\"\n    # Base case: if n is in memo, return the memoized result\n    if n in memo:\n        return memo[n]\n    \n    # Base case for smallest inputs\n    if n <= 1:\n        return n\n    \n    # Calculating potential sums\n    sum_without_n = sum(get_max_sum(n // d, memo) for d in (2, 3, 4, 5))\n    \n    # The result is either the sum of divisions or n itself, whichever is larger\n    result = max(sum_without_n, n)\n    \n    # Memoize the result for future use\n    memo[n] = result\n    \n    return result", "matching_cluster_idx": 11}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n ).\n    \n    Args:\n    n (int): The input number to calculate the maximum sum for.\n    memo (dict): A dictionary to memoize results of subproblems to avoid redundant calculations.\n\n    Returns:\n    int: The maximum sum possible for the given n.\n\n    Example:\n    >>> get_max_sum(60)\n    106\n    \"\"\"\n    # Base case: if n is 0 or 1, return n\n    if n <= 1:\n        return n\n    \n    # Check if we've already computed this value\n    if n in memo:\n        return memo[n]\n    \n    # Recursive computation with memoization\n    # Here we take the integer part of the division to ensure we deal with integer indices for memo\n    sum_result = (get_max_sum(n // 2, memo) +\n                  get_max_sum(n // 3, memo) +\n                  get_max_sum(n // 4, memo) +\n                  get_max_sum(n // 5, memo))\n    \n    # Store the result for future use and return the max of n and the sum of its factors\n    memo[n] = max(n, sum_result)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum possible by using the equation f(n) = max(f(n/2) + f(n/3) + f(n/4) + f(n/5), n).\n\n    This function uses memoization to optimize performance by storing previously calculated results.\n    \n    :param n: The number for which to compute the maximum sum.\n    :param memo: A dictionary for memoization, initially empty.\n    :return: The maximum sum achievable for n.\n    \"\"\"\n    # Base case: if n is 0 or 1, the max sum is n itself\n    if n <= 1:\n        return n\n    \n    # If we have calculated f(n) before, return the memoized result\n    if n in memo:\n        return memo[n]\n\n    # Recursive calculation with memoization\n    sum_parts = 0\n    for i in [2, 3, 4, 5]:\n        # Since n might not be divisible by i, we use integer division and addition\n        sum_parts += get_max_sum(n // i, memo)\n    \n    # The maximum of either the sum or n itself\n    max_sum = max(sum_parts, n)\n    \n    # Store this value before returning\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculate the maximum sum possible for a given number using the equation:\n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n\n    Args:\n    n (int): The number for which to calculate the maximum sum.\n    memo (dict): Memoization dictionary to store already computed results.\n\n    Returns:\n    int: The maximum sum achievable from n.\n\n    Example:\n    >>> get_max_sum(60)\n    106\n    \"\"\"\n    # Base case: if n is small or already computed\n    if n <= 1:\n        return n\n    if n in memo:\n        return memo[n]\n    \n    # Recursive calculation\n    # Since n can be non-integer in intermediate calculations, we use integer division\n    sum_parts = (get_max_sum(n // 2, memo) + \n                 get_max_sum(n // 3, memo) + \n                 get_max_sum(n // 4, memo) + \n                 get_max_sum(n // 5, memo))\n    \n    # Store the result in memo before returning to prevent redundant calculations\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 93.75478927203065, "dps_norm": 73.75, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    # Dictionary to store character counts\n    char_count = {}\n    \n    # First pass: Count occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Second pass: Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to count occurrences of each character\n    char_count = {}\n    \n    # First pass: Count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Second pass: Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If we've gone through the entire string and found no character with count 1\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    This function finds the first non-repeated character in the given string.\n\n    Parameters:\n    s (str): The input string where to find the first non-repeating character.\n\n    Returns:\n    str or None: The first non-repeating character if exists, otherwise None.\n\n    Examples:\n    >>> first_non_repeating_character(\"abcabc\")\n    None\n    >>> first_non_repeating_character(\"aabbccdeeff\")\n    'd'\n    >>> first_non_repeating_character(\"aabbc\")\n    'c'\n    \"\"\"\n    # Dictionary to store count of each character\n    char_count = {}\n    \n    # Populate the dictionary with character counts\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no character is found with count 1\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str | None:\n    \"\"\"\n    Find the first non-repeating character in a string.\n\n    This function scans the string to count occurrences of each character,\n    then finds the first character with a count of 1.\n\n    Args:\n    s (str): The input string to analyze.\n\n    Returns:\n    str | None: The first non-repeating character or None if no such character exists.\n\n    Example:\n    >>> first_non_repeating_character(\"abcabc\")\n    None\n    >>> first_non_repeating_character(\"abacddbec\")\n    'c'\n    \"\"\"\n    # Use a dictionary to count occurrences of each character\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no character repeats only once, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n\n    Args:\n    s (str): The input string to search for non-repeating characters.\n\n    Returns:\n    str or None: The first non-repeating character if found, otherwise None.\n\n    Examples:\n    >>> first_non_repeating_character(\"abcabc\")\n    None\n    >>> first_non_repeating_character(\"abc\")\n    'a'\n    >>> first_non_repeating_character(\"aabbcc\")\n    None\n    \"\"\"\n    # Dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If we've gone through all characters without finding a non-repeated one\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n    s (str): The string to search for the first non-repeated character.\n\n    Returns:\n    str or None: The first non-repeated character, or None if no such character exists.\n\n    Examples:\n    >>> first_non_repeating_character(\"abcabc\")\n    None\n    >>> first_non_repeating_character(\"abcacba\")\n    'c'\n    \"\"\"\n    # Dictionary to count occurrences of each character\n    char_count = {}\n    \n    # First pass: Count all characters\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Second pass: Find the first character with count == 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If we've gone through the entire string without finding a non-repeated character, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to count the occurrences of each character\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n\n    Args:\n    s (str): The input string to analyze.\n\n    Returns:\n    str or None: The first non-repeated character or None if there is no such character.\n    \n    Example:\n    >>> first_non_repeating_character(\"abcabc\")\n    None\n    >>> first_non_repeating_character(\"abc\")\n    'a'\n    >>> first_non_repeating_character(\"zxvczbtxyzvy\")\n    'c'\n    \"\"\"\n    # Dictionary to store the count of each character\n    char_count = {}\n\n    # Count the occurrence of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str | None:\n    # Dictionary to store character counts\n    char_count = {}\n    \n    # First pass: Count occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Second pass: Find the first character with count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeating character in the given string.\n    \n    Args:\n    s (str): The string to search for the first non-repeating character.\n\n    Returns:\n    str or None: The first non-repeated character or None if no such character exists.\n    \n    Examples:\n    >>> first_non_repeating_character(\"abcabc\")\n    None\n    >>> first_non_repeating_character(\"abc\")\n    'a'\n    >>> first_non_repeating_character(\"aabb\")\n    None\n    \"\"\"\n    # Dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If we've gone through all characters without finding a non-repeat, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import OrderedDict\ndef first_non_repeating_character(s):\n    # Create an OrderedDict to keep track of character counts and positions\n    char_count = OrderedDict()\n    \n    # First pass: Count each character and store the position of first occurrence\n    for index, char in enumerate(s):\n        if char in char_count:\n            char_count[char] = (char_count[char][0] + 1, char_count[char][1])\n        else:\n            char_count[char] = (1, index)\n\n    # Second pass: Find the first character with a count of 1\n    for char, (count, index) in char_count.items():\n        if count == 1:\n            return char\n    \n    return None", "matching_cluster_idx": 3}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to count occurrences of each character\n    char_count = {}\n    \n    # First pass: count each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Second pass: find the first character with count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If we get here, no non-repeating character was found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str | None:\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n\n    Args:\n    s (str): The string to search for non-repeated characters.\n\n    Returns:\n    str or None: Returns the first non-repeated character or None if there isn't one.\n\n    Examples:\n    >>> first_non_repeating_character(\"abcabc\")\n    None\n    >>> first_non_repeating_character(\"abcdeeaabbdd\")\n    'c'\n    \"\"\"\n    # Dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str | None:\n    \"\"\"\n    Find the first non-repeating character in the string.\n\n    This function iterates through the string twice:\n    - Once to count each character's occurrences.\n    - Once to find the first character with a count of 1.\n\n    Args:\n    s (str): The input string to analyze.\n\n    Returns:\n    str | None: The first non-repeating character if found, or None if there is no such character.\n\n    Examples:\n    >>> first_non_repeating_character(\"abcabc\")\n    None\n    >>> first_non_repeating_character(\"abcdeef\")\n    'd'\n    >>> first_non_repeating_character(\"abcdeff\")\n    'a'\n    \"\"\"\n    # Count occurrences of each character\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a string.\n    \n    This function iterates through the string twice:\n    - First to count the occurrences of each character.\n    - Then to find the first character with a count of 1.\n\n    Args:\n    s (str): The input string to analyze.\n\n    Returns:\n    str: The first non-repeated character or None if there isn't one.\n    \n    Examples:\n    >>> first_non_repeating_character(\"abcabc\")\n    None\n    >>> first_non_repeating_character(\"aabbccddeeff\")\n    None\n    >>> first_non_repeating_character(\"abcdef\")\n    'a'\n    >>> first_non_repeating_character(\"\")\n    None\n    \"\"\"\n    # Dictionary to hold character counts\n    char_count = {}\n    \n    # Count each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n\n    This function returns the first character in the string that does not\n    appear again, or None if every character is repeated or if the string\n    is empty.\n\n    Args:\n    s (str): The string to analyze.\n\n    Returns:\n    str or None: The first non-repeating character or None if not found.\n\n    Examples:\n    >>> first_non_repeating_character(\"abcabc\")\n    None\n    >>> first_non_repeating_character(\"abcdef\")\n    'a'\n    >>> first_non_repeating_character(\"aabbcc\")\n    None\n    >>> first_non_repeating_character(\"abcdeabcd\")\n    'e'\n    \"\"\"\n    # Dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first character with count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If we didn't find any non-repeating character, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n\n    This function uses a dictionary to count occurrences of each character.\n    It then looks for the first character with a count of 1.\n\n    Args:\n    s (str): The input string to analyze.\n\n    Returns:\n    str: The first non-repeating character, or None if there isn't one.\n\n    Example:\n    >>> first_non_repeating_character(\"abcabc\")\n    None\n    >>> first_non_repeating_character(\"abcdeabc\")\n    'e'\n    \"\"\"\n    # Dictionary to count character occurrences\n    char_count = {}\n\n    # Count each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store the count of each character\n    char_count = {}\n    \n    # First pass: Count occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Second pass: Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no character appears only once, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in the given string.\n\n    Args:\n    s (str): The string to search for a non-repeating character.\n\n    Returns:\n    str: The first non-repeating character, or None if all characters are repeated or if the string is empty.\n    \"\"\"\n    # Dictionary to keep count of characters\n    char_count = {}\n    \n    # Count occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character was found, return None\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a given tuple.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    element: The element to look for.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n\n    Example:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'x')\n    False\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a given tuple.\n\n    Args:\n    tup (tuple): The tuple to search within.\n    element: The element to look for.\n\n    Returns:\n    bool: True if the element is found, False otherwise.\n\n    Example:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if an element exists within a given tuple.\n\n    Args:\n    - tuplex (tuple): The tuple to search in.\n    - element: The element to look for in the tuple.\n\n    Returns:\n    - bool: True if the element is found in the tuple, False otherwise.\n\n    Examples:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'z')\n    False\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    element (Any): The element to look for.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n\n    Examples:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'z')\n    False\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Checks if a given element exists in the provided tuple.\n\n    Args:\n    tup (tuple): The tuple in which to look for the element.\n    elem (Any): The element to search for.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n\n    Examples:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 5)\n    False\n    \"\"\"\n    # Use the 'in' operator which has been optimized for searching within collections like tuples\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if an element exists within a given tuple.\n\n    Args:\n    tuplex (tuple): The tuple to search through.\n    element: The element to look for in the tuple.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n\n    Example:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    elem (any): The element to look for.\n\n    Returns:\n    bool: True if elem is found in tup, False otherwise.\n\n    Examples:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    \"\"\"\n    # Convert tuple to list for easier element access or use tuple's 'in' operator\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if a given element exists in the tuple.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    element (Any): The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n\n    Examples:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    >>> check_tuplex((\"apple\", \"banana\", \"cherry\"), 'kiwi')\n    False\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n    tup (tuple): The tuple to search through.\n    element (any): The element to look for.\n\n    Returns:\n    bool: True if the element is found, False otherwise.\n\n    Examples:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'x')\n    False\n    \"\"\"\n    # Check if the element is in the tuple\n    if element in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if a given element exists in the tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search through.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element is found, False otherwise.\n\n    Examples:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'z')\n    False\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if a given element exists within the tuple.\n\n    Args:\n    tup (tuple): The tuple to search within.\n    element (Any): The element to look for.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n\n    Examples:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'q')\n    False\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    element: The element to look for.\n\n    Returns:\n    bool: True if the element is in the tuple, False otherwise.\n\n    Examples:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    >>> check_tuplex((\"j\", \"u\", \"n\", \"i\", \"p\", \"e\", \"r\"), 'p')\n    True\n    >>> check_tuplex((\"j\", \"u\", \"n\", \"i\", \"p\", \"e\", \"r\"), 't')\n    False\n    \"\"\"\n    # Directly use the 'in' keyword to check for element presence in the tuple\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if an element exists within a given tuple.\n\n    Args:\n    tuplex (tuple): The tuple to search within.\n    element (Any): The element to look for in the tuple.\n\n    Returns:\n    bool: True if element is found in tuplex, False otherwise.\n\n    Examples:\n    >>> assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r') == True\n    >>> assert check_tuplex((1, 2, 3), 4) == False\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    elem (any): The element to look for.\n\n    Returns:\n    bool: True if elem is in tup, False otherwise.\n\n    Example:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Args:\n    tup (tuple): The tuple to search through.\n    element (Any): The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n\n    Example:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search through.\n    elem (any): The element to search for.\n\n    Returns:\n    bool: True if elem is found in tup, False otherwise.\n\n    Examples:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    \"\"\"\n    # Use the 'in' operator to check if the element exists in the tuple\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if a specific element exists within a tuple.\n\n    Args:\n    tuplex (tuple): The tuple in which to search for the element.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n\n    Examples:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    >>> check_tuplex((1, 2, 3), 4)\n    False\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if a given element exists within the tuple.\n\n    Parameters:\n    - tup: tuple, the tuple to search through\n    - element: any type, the element to search for\n\n    Returns:\n    - bool: True if element is found in the tuple, False otherwise.\n\n    Examples:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r')\n    True\n    >>> check_tuplex((\"a\", \"b\", \"c\"), 'd')\n    False\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Args:\n    tup (tuple): The tuple to check against.\n    elem (Any): The element to find in the tuple.\n\n    Returns:\n    bool: True if the element is in the tuple, False otherwise.\n\n    Examples:\n    >>> assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r') == True\n    >>> assert check_tuplex((1, 2, 3), 4) == False\n    \"\"\"\n    # Use the 'in' operator to check for membership\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a given tuple.\n\n    Args:\n    tup (tuple): The tuple to search through.\n    element: The element to look for.\n\n    Returns:\n    bool: True if the element is in the tuple, False otherwise.\n\n    Examples:\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'r')\n    True\n    >>> check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'b')\n    False\n    \"\"\"\n    # Check if the element exists in the tuple\n    return element in tup", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 62.91925465838509, "dps_norm": 81.11111111111111, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any value common between two sequences.\n\n    Args:\n    seq1 (sequence): The first sequence to compare.\n    seq2 (sequence): The second sequence to compare.\n\n    Returns:\n    bool: True if there is an overlapping value, False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3], [4,3,2])\n    True\n    \"\"\"\n    # Convert both sequences to sets for efficient lookup\n    set1, set2 = set(seq1), set(seq2)\n    # Check if intersection of sets is not empty\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any overlapping between two sequences.\n\n    This function converts both sequences into sets for efficient lookup and then\n    checks for any intersection. \n\n    Args:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check.\n\n    Returns:\n    bool: True if there are any common elements, False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3,4,5], [4,5,6,7])\n    True\n    \"\"\"\n    # Convert sequences to sets for O(1) average time complexity on look-up operations\n    set1, set2 = set(seq1), set(seq2)\n    \n    # If there's any intersection, the function returns True, otherwise False\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value from seq1 exists in seq2.\n\n    Args:\n    seq1 (list): The first sequence of values.\n    seq2 (list): The second sequence of values to check against.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n\n    Example:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3], [3,4,5])\n    True\n    \"\"\"\n    # Convert seq2 to a set for O(1) lookup time\n    set2 = set(seq2)\n    \n    # Check if any element from seq1 is in set2\n    return any(item in set2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value from seq1 exists in seq2.\n\n    This function takes two sequences and checks if there is any element in seq1\n    that is also present in seq2. If such an element is found, it returns True;\n    otherwise, it returns False.\n\n    Args:\n    seq1 (sequence): The first sequence to check from.\n    seq2 (sequence): The second sequence to check against.\n\n    Returns:\n    bool: True if there is an overlap, False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5],[6,7,8,9])\n    False\n    >>> overlapping([1,2,3],[2,4,6])\n    True\n    \"\"\"\n    # Convert seq2 to a set for efficient lookup\n    set_seq2 = set(seq2)\n    \n    # Check if any item from seq1 is in the set of seq2\n    return any(item in set_seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any common element between two sequences.\n\n    Parameters:\n    seq1 (sequence): The first sequence of values.\n    seq2 (sequence): The second sequence of values.\n\n    Returns:\n    bool: True if there's any overlap, False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3], [3,4,5])\n    True\n    \"\"\"\n    # Convert sequences to sets for efficient lookup\n    set1 = set(seq1)\n    set2 = set(seq2)\n\n    # Check if the intersection of the two sets has any elements\n    return bool(set1 & set2)", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n\n    Args:\n    seq1 (iterable): The first sequence to check from.\n    seq2 (iterable): The second sequence to check against.\n\n    Returns:\n    bool: True if any element from seq1 is found in seq2, False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3], [3,4,5])\n    True\n    \"\"\"\n    # Convert sequences to sets for O(1) average time complexity for membership test\n    set2 = set(seq2)\n    # Check if any element from seq1 is in set2\n    return any(item in set2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there are any common elements between two sequences.\n\n    Args:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n\n    Examples:\n    >>> overlapping([1, 2, 3, 4, 5], [6, 7, 8, 9])\n    False\n    >>> overlapping([1, 2, 3], [3, 4, 5])\n    True\n    \"\"\"\n    # Convert both sequences to sets for faster lookup\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Use set intersection to check for overlap\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any overlap between two sequences.\n\n    Parameters:\n    seq1 (list or tuple): The first sequence to check.\n    seq2 (list or tuple): The second sequence to check.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3], [3,4,5])\n    True\n    \"\"\"\n    # Convert sequences to sets for efficient lookup\n    set1 = set(seq1)\n    set2 = set(seq2)\n\n    # Use set intersection to check for overlapping elements\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n\n    Args:\n    seq1 (sequence): First sequence to check from.\n    seq2 (sequence): Second sequence to check against.\n\n    Returns:\n    bool: True if there's an overlap, False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5],[6,7,8,9])\n    False\n    >>> overlapping([1, 2, 3], [3, 4, 5])\n    True\n    \"\"\"\n    # Convert seq2 to a set for O(1) lookup time\n    set2 = set(seq2)\n    \n    # Check if any element from seq1 is in the set of seq2\n    for item in seq1:\n        if item in set2:\n            return True\n    \n    # If no elements from seq1 are in seq2, return False\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any overlap between elements in two sequences.\n\n    Args:\n    seq1 (list or tuple): The first sequence.\n    seq2 (list or tuple): The second sequence.\n\n    Returns:\n    bool: True if there is an overlap, False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3], [3,4,5])\n    True\n    \"\"\"\n    # Convert both sequences to sets for O(1) lookup time\n    set1, set2 = set(seq1), set(seq2)\n    \n    # Check if any element from set2 exists in set1 or vice versa\n    return not (set1.isdisjoint(set2))", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n\n    Args:\n    seq1 (iterable): The first sequence to check values from.\n    seq2 (iterable): The second sequence to check against.\n\n    Returns:\n    bool: True if there is any overlapping value, False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3,4,5], [4,5,6,7,8])\n    True\n    \"\"\"\n    # Convert sequences to sets for faster lookup\n    set1, set2 = set(seq1), set(seq2)\n    # Use the intersection to find common elements\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value from seq1 exists in seq2.\n\n    Args:\n    seq1 (iterable): The first sequence of items to check from.\n    seq2 (iterable): The second sequence to check against.\n\n    Returns:\n    bool: True if there is an overlap, False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3], [3,4,5])\n    True\n    \"\"\"\n    # Convert sequences to sets for efficient look-up\n    set1, set2 = set(seq1), set(seq2)\n    \n    # Use set intersection to find common elements\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any value present in both sequences.\n\n    Args:\n    seq1 (list): The first sequence to check.\n    seq2 (list): The second sequence to check.\n\n    Returns:\n    bool: True if any value from seq1 exists in seq2, False otherwise.\n\n    Example:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    \"\"\"\n    # Convert seq2 to a set for O(1) lookup time\n    set_seq2 = set(seq2)\n    \n    # Use any() with a generator expression to check if any element \n    # from seq1 is in set_seq2. This is more efficient than nested loops.\n    return any(item in set_seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any overlap between elements of two sequences.\n\n    Args:\n    seq1 (sequence): The first sequence to check for overlap.\n    seq2 (sequence): The second sequence to check for overlap.\n\n    Returns:\n    bool: True if any element from seq1 is found in seq2, False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3], [3,4,5])\n    True\n    \"\"\"\n    # Convert sequences to sets for efficient lookup\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Check for overlap by using set intersection\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any element in seq1 exists in seq2.\n\n    This function determines if there is any overlap between the two given sequences.\n    \n    Args:\n    seq1 (sequence): The first sequence to check for overlap.\n    seq2 (sequence): The second sequence to check against.\n\n    Returns:\n    bool: True if any element of seq1 exists in seq2, otherwise False.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3], [3,4,5])\n    True\n    \"\"\"\n    # Convert sequences to sets for efficient lookup\n    set2 = set(seq2)\n    # Check if any item from seq1 is in set2\n    return any(item in set2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any overlap between two sequences.\n\n    This function returns True if there is at least one common element between seq1 and seq2,\n    otherwise it returns False.\n\n    Args:\n    seq1 (sequence): The first sequence to compare. Can be any iterable like list, tuple, etc.\n    seq2 (sequence): The second sequence to compare.\n\n    Returns:\n    bool: True if there's an overlap, False otherwise.\n\n    Examples:\n    >>> overlapping([1, 2, 3, 4, 5], [6, 7, 8, 9])\n    False\n    >>> overlapping([1, 2, 3], [3, 4, 5])\n    True\n    \"\"\"\n    # Convert sequences to sets for efficiency in membership testing\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Use set intersection to check for common elements\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any overlapping value between two sequences.\n    \n    Args:\n    seq1 (iterable): The first sequence of elements.\n    seq2 (iterable): The second sequence of elements.\n    \n    Returns:\n    bool: True if there's any common element between seq1 and seq2, False otherwise.\n    \n    Example:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3], [3,4,5])\n    True\n    \"\"\"\n    # Convert sequences to sets for faster lookup\n    set1, set2 = set(seq1), set(seq2)\n    \n    # Use set intersection to check for overlapping elements\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (sequence): The first sequence to check from.\n    seq2 (sequence): The sequence to check against.\n\n    Returns:\n    bool: True if there's any overlapping value, False otherwise.\n\n    Example:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3,4], [5,4,6])\n    True\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there are any overlapping elements between two sequences.\n\n    Args:\n    seq1 (list or iterable): The first sequence of elements.\n    seq2 (list or iterable): The second sequence of elements.\n\n    Returns:\n    bool: True if there's any overlapping element, False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3], [3,4,5])\n    True\n    \"\"\"\n    # Convert both sequences to sets for faster lookup\n    set1, set2 = set(seq1), set(seq2)\n    \n    # Use intersection to find common elements\n    if set1.intersection(set2):\n        return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in the first sequence exists in the second sequence.\n\n    Args:\n    seq1 (list): The first sequence of numbers or items to check for overlap.\n    seq2 (list): The second sequence to check against.\n\n    Returns:\n    bool: True if there is an overlap, False otherwise.\n\n    Examples:\n    >>> overlapping([1,2,3,4,5], [6,7,8,9])\n    False\n    >>> overlapping([1,2,3], [3,4,5])\n    True\n    \"\"\"\n    # Convert lists to sets for O(1) lookup time\n    set2 = set(seq2)\n    \n    # Check if any item from seq1 exists in set2\n    for item in seq1:\n        if item in set2:\n            return True\n    \n    return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 88.47736625514403, "dps_norm": 92.85714285714286, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenate elements of a tuple into a single string separated by a delimiter.\n\n    Args:\n    elements (tuple): A tuple containing elements to concatenate. These can be of any type that can be converted to string.\n    delimiter (str): The string to use as a separator between elements. Defaults to '-'.\n\n    Returns:\n    str: A string with all elements of the tuple concatenated.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert each element to a string and join them with the delimiter\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter=\"-\"):\n    \"\"\"\n    Concatenate each element of a tuple with a specified delimiter.\n    \n    Args:\n    elements (tuple): The tuple containing elements to be concatenated.\n    delimiter (str): The string used to join the elements. Default is '-'.\n    \n    Returns:\n    str: A string with all elements concatenated with the given delimiter.\n\n    Raises:\n    TypeError: If the elements argument is not a tuple.\n\n    Examples:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    >>> concatenate_tuple((\"hello\", \"world\"), \",\")\n    'hello,world'\n    \"\"\"\n    # Check if the input is a tuple\n    if not isinstance(elements, tuple):\n        raise TypeError(\"Input must be a tuple\")\n\n    # Convert all elements to string and join them\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple with a specified delimiter.\n\n    Args:\n    elements (tuple): A tuple containing elements to be concatenated.\n    delimiter (str): The string used to separate elements in the result. Defaults to '-'.\n\n    Returns:\n    str: A string where each element from the tuple is concatenated using the delimiter.\n\n    Examples:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    >>> concatenate_tuple((\"Python\", \"is\", \"awesome\"), ' ')\n    'Python is awesome'\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    \"\"\"\n    Concatenates each element of the provided tuple into a single string with '-' as a delimiter.\n\n    Args:\n    tup (tuple): The tuple containing elements to concatenate.\n\n    Returns:\n    str: A string where all elements from the tuple are joined by '-'.\n\n    Raises:\n    TypeError: If tup is not a tuple.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"The argument must be a tuple\")\n\n    # Convert all elements to string to ensure concatenation works even with numbers\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates all elements of a tuple into a single string, \n    separated by a given delimiter.\n\n    Args:\n    tup (tuple): The tuple whose elements are to be concatenated.\n    delimiter (str): The string to use as a delimiter. Default is '-'.\n\n    Returns:\n    str: A string where all tuple elements are concatenated with the delimiter.\n\n    Examples:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    >>> concatenate_tuple((\"Hello\", \"World\"), ',')\n    'Hello,World'\n    \"\"\"\n    # Convert all items in the tuple to strings since some might be numbers or other types\n    str_items = [str(item) for item in tup]\n    \n    # Use the delimiter to join the string elements\n    return delimiter.join(str_items)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple into a string using a specified delimiter.\n\n    Args:\n    tup (tuple): The input tuple whose elements are to be concatenated.\n    delimiter (str): The string to be used as a delimiter for concatenation. Defaults to '-'.\n\n    Returns:\n    str: A string where all tuple elements are concatenated with the delimiter.\n\n    Raises:\n    TypeError: If tup is not a tuple.\n\n    Examples:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    >>> concatenate_tuple((1, 2, 3), \"+\")\n    '1+2+3'\n    \"\"\"\n    # Check if the input is indeed a tuple\n    if not isinstance(tup, tuple):\n        raise TypeError(\"The function expects a tuple as input.\")\n\n    # Convert all elements to string and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a single string with a specified delimiter.\n\n    Args:\n    input_tuple (tuple): The tuple containing elements to concatenate.\n    delimiter (str): The delimiter used to separate elements in the resulting string. Default is '-'.\n\n    Returns:\n    str: A string where each element from the tuple is joined by the delimiter.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert all elements to string and join them with the delimiter\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    \"\"\"\n    Concatenate each element of the given tuple using a delimiter.\n\n    Args:\n    - tup (tuple): A tuple containing elements to be concatenated.\n    - delimiter (str): The string used to join the elements. Defaults to \"-\".\n\n    Returns:\n    - str: A string where all elements from the tuple are concatenated with the delimiter.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert all tuple elements to string and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenate all elements of a tuple with a specified delimiter.\n\n    Args:\n    input_tuple (tuple): The tuple whose elements are to be concatenated.\n    delimiter (str): The string to use as a separator. Defaults to '-'.\n\n    Returns:\n    str: A string where all elements from the tuple are joined by the delimiter.\n\n    Raises:\n    TypeError: If the input is not a tuple or if any element can't be cast to str.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    try:\n        # Convert all elements to strings before joining\n        return delimiter.join(map(str, input_tuple))\n    except TypeError:\n        # This will catch issues with trying to join elements that are not iterable or are None\n        raise TypeError(\"All elements in the tuple must be convertible to string.\")", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    \"\"\"\n    Concatenate each element of the tuple by a delimiter.\n\n    Args:\n    tup (tuple): A tuple of elements to concatenate.\n\n    Returns:\n    str: A string where each element from the tuple is joined by '-'.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert all elements to strings and join with '-' delimiter\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenate elements of a tuple into a single string with a specified delimiter.\n\n    Args:\n    elements (tuple): The tuple containing elements to be concatenated.\n    delimiter (str): The string used to separate the elements. Defaults to '-'.\n\n    Returns:\n    str: A string where all elements are concatenated using the delimiter.\n\n    Raises:\n    TypeError: If elements is not a tuple.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Check if the input is a tuple\n    if not isinstance(elements, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    \n    # Convert each element to string and join them with the delimiter\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenate all elements of a tuple with a specified delimiter.\n\n    Args:\n    elements (tuple): A tuple containing elements to be concatenated.\n    delimiter (str): The string to use as a separator. Defaults to '-'.\n\n    Returns:\n    str: A string with all elements from the tuple joined by the delimiter.\n\n    Raises:\n    TypeError: If the input is not a tuple.\n\n    Examples:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    >>> concatenate_tuple((\"Hello\", \"World\"), delimiter=' ')\n    'Hello World'\n    \"\"\"\n    # Check if the input is indeed a tuple\n    if not isinstance(elements, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    \n    # Convert all elements to strings before joining\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates elements of a tuple into a single string with a delimiter.\n\n    Args:\n    tup (tuple): The input tuple whose elements are to be concatenated.\n    delimiter (str): The string to use as a separator. Default is '-'.\n\n    Returns:\n    str: A string where each element of the tuple is joined by the delimiter.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert all tuple elements to strings\n    string_elements = map(str, tup)\n    # Join the string elements with the delimiter\n    return delimiter.join(string_elements)", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple with a specified delimiter.\n    \n    Args:\n    elements (tuple): A tuple containing elements to concatenate.\n    delimiter (str): The string to use as a delimiter. Defaults to '-'.\n\n    Returns:\n    str: A string with all elements from the tuple concatenated by the delimiter.\n    \n    Examples:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    >>> concatenate_tuple((\"Hello\", \"World\"), \" \")\n    'Hello World'\n    \"\"\"\n    # Convert all tuple elements to strings, join with the delimiter\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    \"\"\"\n    Concatenate each element of a tuple into a string, with elements separated by hyphens.\n\n    This function assumes all elements in the tuple can be converted to strings.\n\n    Args:\n    tup (tuple): A tuple of elements to be concatenated.\n\n    Returns:\n    str: A string where each element from the tuple is concatenated with '-' in between.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert all elements to strings and join them with a hyphen\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(elements, delimiter=\"-\"):\n    \"\"\"\n    Concatenate each element of a tuple with a given delimiter.\n\n    Args:\n    elements (tuple): A tuple of elements to concatenate.\n    delimiter (str): The delimiter to use for concatenation. Default is \"-\".\n\n    Returns:\n    str: A string where each element from the tuple is joined by the delimiter.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates elements of a tuple into a string separated by a delimiter.\n\n    Parameters:\n    - input_tuple: tuple, the tuple to concatenate.\n    - delimiter: str, the string to use as a separator (default is '-').\n\n    Returns:\n    - str: A string with all elements of the tuple joined by the delimiter.\n\n    Examples:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    >>> concatenate_tuple((\"A\", \"B\", \"C\"), \":\")\n    'A:B:C'\n    \"\"\"\n    # Convert all elements to strings, since tuple might contain non-string elements\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tpl, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a single string with the given delimiter.\n\n    Args:\n    tpl (tuple): The tuple containing elements to concatenate.\n    delimiter (str): The string to use as a separator. Defaults to '-'.\n\n    Returns:\n    str: A string of all elements from the tuple joined by the delimiter.\n\n    Examples:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert all items to string before joining since tuple might contain non-string items\n    return delimiter.join(map(str, tpl))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenate each element of a tuple with a specified delimiter.\n\n    Args:\n    input_tuple (tuple): A tuple containing elements to be concatenated.\n    delimiter (str): The string used to join elements. Defaults to \"-\".\n\n    Returns:\n    str: A string where elements of the tuple are joined by the delimiter.\n\n    Examples:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert all elements to strings since join() requires string elements\n    string_elements = [str(item) for item in input_tuple]\n    # Use the string join method to concatenate the elements\n    return delimiter.join(string_elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple into a single string, separated by a given delimiter.\n\n    Args:\n    elements (tuple): A tuple containing elements to be concatenated.\n    delimiter (str): The delimiter to use for concatenation. Default is '-'.\n\n    Returns:\n    str: A string where all elements from the tuple are concatenated with the delimiter.\n\n    Example:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n    'ID-is-4-UTS'\n    \"\"\"\n    # Convert all elements to string since we're string-joining them\n    string_elements = map(str, elements)\n    # Use join method which is efficient for string concatenation in Python\n    return delimiter.join(string_elements)", "matching_cluster_idx": 6}]}, "Mbpp/424": {"dps": 47.021660649819495, "dps_norm": 77.0, "pass@1": 98.0, "profiled": [{"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n    strings_tuple (tuple): A tuple of strings from which to extract the rear index element.\n\n    Returns:\n    list: A list containing the last character of each string in the tuple.\n\n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use a list comprehension to get the last character of each string\n    return [string[-1] for string in strings_tuple if string]  # Check if string is not empty to avoid IndexError", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n\n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use list comprehension to get the last character of each string\n    # We use str[-1] to access the last element of each string\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the provided tuple.\n\n    Args:\n    strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list where each element is the last character of the corresponding string in the input tuple.\n\n    Examples:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use a list comprehension to get the last character of each string\n    # The negative index [-1] accesses the last character\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n    strings_tuple (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string in the tuple.\n\n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use a list comprehension to get the last character of each string\n    return [string[-1] for string in strings_tuple if string]  # Ensure string isn't empty", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in a tuple.\n\n    Args:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n\n    Examples:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    return [s[-1] for s in strings if s]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in a given tuple of strings.\n\n    Args:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list where each element is the last character of the corresponding string in the input tuple.\n\n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use list comprehension to get the last character of each string\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in a given tuple.\n\n    Args:\n    tuple_of_strings (tuple): A tuple containing strings from which to extract the last character.\n\n    Returns:\n    list: A list where each element is the last character of the corresponding string in the input tuple.\n\n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use list comprehension to get the last character of each string\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the last character from each string in the provided tuple.\n\n    Args:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string in the tuple.\n\n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use a list comprehension to get the last character of each string\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in a given tuple.\n\n    Args:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list where each element is the last character of the corresponding string from the input tuple.\n\n    Examples:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use list comprehension to get the last character of each string in the tuple\n    return [s[-1] if s else '' for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string within the provided tuple.\n\n    Args:\n    strings_tuple (tuple of str): A tuple containing strings.\n\n    Returns:\n    list of str: A list with the last character of each string from the tuple.\n\n    Examples:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use list comprehension to get the last character of each string\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n    tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list where each element is the last character of the corresponding string in the input tuple.\n\n    Examples:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use list comprehension to create a new list with the last character of each string\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the last character from each string in the provided tuple.\n\n    Args:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string in the tuple.\n\n    Examples:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use a list comprehension to get the last character of each string\n    # The slice [-1] returns the last character of the string\n    return [s[-1] for s in strings if s]  # This also handles empty strings by ignoring them", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n    \n    Args:\n    tuple_of_strings (tuple): A tuple where each element is a string.\n\n    Returns:\n    list: A list of characters, each being the last character from the strings in the input tuple.\n\n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use list comprehension to get the last character of each string\n    return [s[-1] for s in tuple_of_strings if s]  # Ensures the string is not empty to avoid IndexError", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the rear (last) index element from each string in the given tuple.\n\n    Args:\n    strings (tuple): A tuple containing strings from which to extract the last character.\n\n    Returns:\n    list: A list containing the last character of each string in the tuple.\n\n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use list comprehension to get the last character of each string\n    # The [len(s)-1] will always point to the last character since indexing starts at 0\n    return [s[-1] for s in strings if isinstance(s, str) and len(s) > 0]", "matching_cluster_idx": 1}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the rear (last) character from each string in a tuple.\n\n    Args:\n    strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n\n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    return [s[-1] for s in strings if s]  # Check if string is not empty to avoid IndexError", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n    strings (tuple of str): A tuple containing strings.\n\n    Returns:\n    list of str: A list where each element is the last character of the corresponding string in the input tuple.\n\n    Examples:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use a list comprehension to get the last character of each string\n    return [s[-1] for s in strings if s]  # Ensures the string is not empty before slicing", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n\n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use list comprehension to create a new list with the last character of each string\n    return [s[-1] for s in strings if isinstance(s, str)]", "matching_cluster_idx": 2}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the rear index element (last character) of each string in the provided tuple.\n\n    Args:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string in the tuple.\n\n    Examples:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use list comprehension to get the last character of each string\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(string_tuple):\n    \"\"\"\n    Extracts the last character from each string in the provided tuple.\n    \n    Args:\n    string_tuple (tuple): A tuple containing strings.\n    \n    Returns:\n    list: A list of the last character from each string in the tuple.\n    \n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use a list comprehension to get the last character of each string\n    return [s[-1] for s in string_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in a tuple.\n\n    This function iterates over each string in the provided tuple\n    and extracts the last character of each string.\n\n    Args:\n    tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list where each element is the last character of the corresponding string from the input tuple.\n\n    Example:\n    >>> extract_rear(('Mers', 'for', 'Vers'))\n    ['s', 'r', 's']\n    \"\"\"\n    # Use list comprehension to create a list of the last characters\n    return [string[-1] for string in tuple_of_strings if string]  # Check if string is not empty", "matching_cluster_idx": 3}]}, "Mbpp/425": {"dps": 90.1775147928994, "dps_norm": 94.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists in `nested_list` that contain the `element`.\n\n    Args:\n    nested_list (list of list): A list containing sublists.\n    element (Any): The element to search for in each sublist.\n\n    Returns:\n    int: The number of sublists containing the element.\n\n    Examples:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    # Use a list comprehension to filter sublists containing the element, \n    # then count them with len()\n    return len([sublist for sublist in nested_list if element in sublist])", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, target):\n    \"\"\"\n    Count the number of sublists in a nested list that contain a particular element.\n\n    Args:\n    nested_list (list): A list containing sublists.\n    target: The element to search for within sublists.\n\n    Returns:\n    int: The count of sublists containing the target element.\n\n    Example:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    # Use a list comprehension with any() to check for the presence of the target in each sublist\n    return sum(1 for sublist in nested_list if any(item == target for item in sublist))", "matching_cluster_idx": 1}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists in `nested_list` that contain `element`.\n\n    Args:\n    nested_list (List[List]): A list of lists where we need to search for the element.\n    element: The element to search for within the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n\n    Example:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    # Use a list comprehension to filter sublists containing the element, then count them\n    return sum(1 for sublist in nested_list if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists that contain a specific element.\n\n    Args:\n    lst (list of lists): The list of sublists to search through.\n    element: The element to look for within the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n\n    Examples:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    >>> count_element_in_list([['a', 'b'], ['b', 'c'], ['a', 'd']], 'a')\n    2\n    \"\"\"\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count how many sublists in 'lst' contain 'element'.\n\n    This function iterates over each sublist in the provided list 'lst'\n    and checks if 'element' is in any of them.\n\n    Args:\n    lst (list of list): A list containing sublists to be checked.\n    element (Any): The element to search for in sublists.\n\n    Returns:\n    int: The count of sublists containing 'element'.\n\n    Examples:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    >>> count_element_in_list([[], [3, 4], [3, 5]], 3)\n    2\n    \"\"\"\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists within 'lst' that contain the 'element'.\n\n    Parameters:\n    lst (list of lists): The list of lists to search through.\n    element (Any): The element to search for in each sublist.\n\n    Returns:\n    int: The number of sublists containing the element.\n\n    Example:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    # Use a list comprehension with any() to count sublists containing the element\n    return sum(1 for sublist in lst if any(item == element for item in sublist))", "matching_cluster_idx": 1}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists within lst that contain the specified element.\n\n    Args:\n    lst (list): A list of lists where we will search for the element.\n    element: The element to search for in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n\n    Examples:\n    >>> assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3\n    \"\"\"\n    # Use sum with a generator expression to count sublists with the element\n    # 1 is returned for True if the element is in the sublist, 0 otherwise\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Args:\n    nested_list (list of lists): A list where each element is a list.\n    element (Any): The element to search for within the sublists.\n\n    Returns:\n    int: Number of sublists that contain the element.\n\n    Example:\n    >>> assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3\n    \"\"\"\n    # Use list comprehension to filter sublists containing the element and count them\n    return sum(1 for sublist in nested_list if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    \"\"\"\n    Counts the number of sublists in `lists` that contain `element`.\n\n    Args:\n    lists (list of list): A list containing sublists to search through.\n    element: The element to look for in each sublist.\n\n    Returns:\n    int: The count of sublists containing the element.\n\n    Example:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    # Use list comprehension to count sublists with the element\n    return sum(1 for sublist in lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, target):\n    \"\"\"\n    Count the number of sublists that contain a specific element.\n\n    Args:\n    lists (List[List[int]]): A list of lists containing integers.\n    target (int): The element to search for in each sublist.\n\n    Returns:\n    int: The count of sublists containing the target element.\n\n    Examples:\n    >>> assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3\n    >>> assert count_element_in_list([[], [], [7], [1]], 7) == 1\n    >>> assert count_element_in_list([[], [], [7], [1]], 8) == 0\n    \"\"\"\n    # Use a list comprehension to count sublists with the target\n    return sum(1 for sublist in lists if target in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    \"\"\"\n    Count the number of sublists in `lists` that contain the `element`.\n\n    Args:\n    lists (list of list): A list where each item is a sublist.\n    element (any): The element to search for within sublists.\n\n    Returns:\n    int: The count of sublists containing `element`.\n\n    Example:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    return sum(1 for sublist in lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    \"\"\"\n    Count the number of sublists that contain a given element.\n\n    Args:\n    lists (List[List]): A list of lists where we will search for the element.\n    element: The element to search for in each sublist.\n\n    Returns:\n    int: The count of sublists containing the element.\n\n    Example:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    return sum(1 for sublist in lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists that contain the given element.\n\n    Args:\n    nested_list (list): A list of lists to search through.\n    element (Any): The element to search for within the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n\n    Example:\n    >>> assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3\n    \"\"\"\n    # Use a list comprehension to filter lists containing the element and count them\n    return sum(1 for sublist in nested_list if element in sublist)\nnested_list = [[1, 3], [5, 7], [1, 11], [1, 15, 7]]", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists in nested_list that contain the given element.\n    \n    :param nested_list: List of lists where each sublist might contain the element to be counted.\n    :param element: The element to look for within each sublist.\n    :return: Integer count of sublists containing the element.\n    \n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    # Count how many sublists contain the element\n    return sum(1 for sublist in nested_list if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists in a nested list that contain a specific element.\n\n    Args:\n    nested_list (list of lists): The list containing sublists to search through.\n    element (Any): The element to search for in each sublist.\n\n    Returns:\n    int: Number of sublists containing the element.\n\n    Example:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    # Use list comprehension to count sublists with the element\n    return sum(1 for sublist in nested_list if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    \"\"\"\n    Counts the number of sublists that contain a specified element.\n\n    Args:\n    lists (list of list): A list of lists where we search for the element.\n    element (Any): The element to search for within the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n\n    Example:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    # Use list comprehension to count sublists containing the element\n    return sum(1 for sublist in lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    \"\"\"\n    Count how many sublists in 'lists' contain the 'element'.\n\n    Args:\n    lists (List[list]): A list of lists where the search will be performed.\n    element (Any): The element to search for within the sublists.\n\n    Returns:\n    int: Number of sublists that contain the given element.\n\n    Examples:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    return sum(element in sublist for sublist in lists)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, target):\n    \"\"\"\n    Count the number of sublists in the nested list that contain the target element.\n\n    Args:\n    nested_list (list of lists): A list containing sublists.\n    target: The element to search for within the sublists.\n\n    Returns:\n    int: The count of sublists that contain the target.\n\n    Example:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    # Use a list comprehension to check if the target exists in each sublist,\n    # then sum the boolean results where True counts as 1 and False as 0.\n    return sum(target in sublist for sublist in nested_list)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists in a nested list that contain a specific element.\n\n    Args:\n    nested_list (list of list): A list containing sublists of integers.\n    element (int): The element to look for in each sublist.\n\n    Returns:\n    int: The count of sublists containing the element.\n\n    Example:\n    >>> assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3\n    \"\"\"\n    # Use a list comprehension to count sublists with the element\n    return sum(1 for sublist in nested_list if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    \"\"\"\n    Count how many sublists contain a specific element.\n\n    Args:\n    lists (List[List[int]]): A list of lists of integers.\n    element (int): The element to search for in the sublists.\n\n    Returns:\n    int: The number of sublists that contain the specified element.\n\n    Example:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    # Use list comprehension to find sublists containing the element,\n    # then count these sublists\n    return sum(1 for sublist in lists if element in sublist)", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.29752066115702, "dps_norm": 55.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array in ascending order using the shell sort algorithm.\n\n    This function implements the shell sort, an extension of Insertion Sort that allows \n    the exchange of items that are far apart. It starts by sorting pairs of elements \n    far apart from each other, then progressively reducing the gap between elements \n    to be compared.\n\n    Args:\n    arr (list): The list to be sorted.\n\n    Returns:\n    list: The sorted list.\n\n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    # Start with a large gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            # Add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct \n            # location for temp is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n                \n            # Put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Perform shell sort on the given array.\n    \n    This function implements the shell sort algorithm, which is an \n    in-place comparison sort. It starts by sorting pairs of elements \n    far apart from each other, then progressively reduces the gap \n    between elements to be compared.\n\n    Args:\n    arr (list): The list to be sorted.\n\n    Returns:\n    list: The sorted list.\n\n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            # Compare with elements separated by 'gap'\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            arr[j] = temp\n        gap //= 2  # Decrease the gap\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Perform Shell Sort on the given list.\n    \n    Shell sort is a generalization of insertion sort that allows the exchange\n    of items that are far apart. The idea is to arrange the list so that,\n    looking at every h-th element in the list, you get a sorted sequence.\n\n    Args:\n    arr (list): The list of elements to be sorted.\n\n    Returns:\n    list: A new list with elements sorted in ascending order.\n\n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    # Start with a large gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            # Add arr[i] to the elements that have been gap sorted\n            # Save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct \n            # location for temp is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Performs shell sort on the input array.\n    \n    Shell sort is an in-place comparison sort. It can be seen as an improvement\n    over insertion sort where the elements are initially sorted at a larger interval\n    or gap, then progressively decreasing the interval.\n    \n    Args:\n    arr (list): The array of numbers to be sorted.\n\n    Returns:\n    list: The sorted array.\n\n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    # Start with a large gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            # Add a[i] to the elements that have been gap sorted\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n                \n            # Place temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            # Store current value to insert\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for temp is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Place temp in its correct location\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Perform shell sort on the given array.\n\n    This function uses the shell sort algorithm which is an extension\n    of insertion sort that allows the exchange of items that are far\n    apart. It first sorts elements that are far apart from each other\n    and successively reduces the interval between the elements to be \n    sorted.\n\n    Args:\n    arr (list): The list to be sorted.\n\n    Returns:\n    list: A new list with the elements sorted in ascending order.\n\n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        for i in range(gap, n):\n            # Add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct \n            # location for a[i] is found\n            while  j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sort an array using the Shell Sort algorithm.\n    \n    Shell sort is an in-place comparison sort. It can be seen as either a generalization \n    of sorting by exchange (bubble sort) or sorting by insertion (insertion sort).\n    The method starts by sorting pairs of elements far apart from each other, then \n    progressively reducing the gap between elements to be compared.\n    \n    Args:\n    arr (list): The list of integers to be sorted.\n\n    Returns:\n    list: A new sorted list from the input array.\n\n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    # Initialize the gap size\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            # Add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for a[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Place temp (the original a[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Implement shell sort algorithm to sort the given list in ascending order.\n    \n    Args:\n    arr (list): The list to be sorted.\n\n    Returns:\n    list: A new list sorted in ascending order.\n\n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    # Start with a large gap and reduce it until it becomes 1\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            # Add a[i] to the elements that have been gap sorted\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for a[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Place temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for temp is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for temp is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Perform shell sort on the given array.\n    \n    Shell sort is an in-place comparison sort. It starts by sorting pairs\n    of elements far apart from each other, then progressively reduces the\n    gap between elements to be compared.\n    \n    Args:\n    arr (list): The list of integers to be sorted.\n    \n    Returns:\n    list: The sorted list in ascending order.\n    \n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    # Initialize the gap size\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        # Perform insertion sort for the elements at each gap\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for temp is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sort the given array using the Shell Sort algorithm.\n    \n    Args:\n    arr (list): The list to be sorted.\n    \n    Returns:\n    list: A new sorted list.\n    \n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    # Start with a large gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            # Add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct \n            # location for a[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Implement Shell Sort to sort the given array in ascending order.\n    \n    Shell sort is an in-place comparison sort. It can be seen as either a generalization of sorting \n    by exchange (bubble sort) or sorting by insertion (insertion sort). The method starts by sorting \n    pairs of elements far apart from each other, then progressively reducing the gap between elements \n    to be compared.\n    \n    :param arr: List to be sorted\n    :return: Sorted list in ascending order\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            # Add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for a[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Place temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sort the given array using the Shell Sort algorithm.\n    \n    Shell Sort is an in-place comparison sort. It can be seen as either a \n    generalization of sorting by exchange (bubble sort) or sorting by insertion (insertion sort).\n    \n    Args:\n    arr (list): The input list to be sorted.\n    \n    Returns:\n    list: A new sorted list using the shell sort method.\n    \n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    n = len(arr)\n    # Start with a large gap, then reduce the gap in each iteration\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            # Store the current value to insert\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier elements until the correct location for temp is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Place temp in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    This function implements the Shell Sort, an extension of Insertion Sort \n    that allows the exchange of items that are far apart, reducing the time \n    it takes to sort large lists. \n\n    Args:\n    arr (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list.\n\n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            arr[j] = temp\n        # Reducing the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n    \n    Shell Sort is an in-place comparison sort. It starts by sorting pairs of elements\n    far apart from each other, then progressively reducing the gap between elements\n    to be compared. This function uses the original interval sequence proposed by \n    Donald Shell: n/2, n/4, ..., until the gap is 1.\n\n    :param arr: List to be sorted.\n    :return: Sorted list.\n    \"\"\"\n    # Get the length of the array\n    n = len(arr)\n    \n    # Initialize the gap as half the length of the list\n    gap = n // 2\n    \n    # Continue sorting while gap > 0\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct \n            # location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sort the given array using the shell sort algorithm.\n    \n    Args:\n    arr (list): The list of integers to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    # Start with a large gap and gradually decrease to 1\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # Store the current value to be compared\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for temp is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Place temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sort the given array using the Shell sort algorithm.\n    \n    Shell sort is an in-place comparison sort. It can be seen as either a generalization \n    of sorting by exchange (bubble sort) or sorting by insertion (insertion sort). \n    This function sorts the array in ascending order.\n    \n    Args:\n    arr (list): The list of integers to be sorted.\n    \n    Returns:\n    list: The sorted list in ascending order.\n    \n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    # Start with a large gap and decrease it until gap is 1\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        # Perform insertion sort for elements at each gap\n        for i in range(gap, n):\n            # Store current value to insert in the correct position\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for temp is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Place temp in its correct location\n            arr[j] = temp\n        \n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sort the given array using the Shell Sort algorithm.\n\n    Args:\n    arr (list): The list of integers to be sorted.\n\n    Returns:\n    list: A new list with the elements sorted in ascending order.\n\n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    n = len(arr)\n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            # Add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct \n            # location for a[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Perform shell sort on the given array.\n    \n    Shell sort is an in-place comparison sort. It can be seen as either a generalization of sorting by \n    exchange (bubble sort) or sorting by insertion (insertion sort). The method starts by sorting pairs \n    of elements far apart from each other, then progressively reducing the gap between elements to be compared.\n    \n    Args:\n    arr (list): The list to be sorted.\n    \n    Returns:\n    list: A new sorted list using the shell sort algorithm.\n    \n    Example:\n    >>> shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])\n    [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    \"\"\"\n    # Make a copy of the list to keep the function non-destructive\n    n = len(arr)\n    arr = arr[:]  # Creating a copy of the original array\n    \n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            # Add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct \n            # location for a[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Place temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 65.63829787234042, "dps_norm": 62.0, "pass@1": 89.0, "profiled": [{"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n    arr (list): A list of numbers to compare against.\n    num (int or float): The number to check for greater than condition.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3, 4, 5], 6)\n    True\n    \"\"\"\n    # If all elements in the array are less than num, then num is greater than all elements\n    return all(elem < num for elem in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n    arr (list): A list of numbers to check against.\n    num (int or float): The number to compare with the elements of the array.\n\n    Returns:\n    bool: True if 'num' is greater than all elements in 'arr', False otherwise.\n\n    Example:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3, 4, 5], 6)\n    True\n    \"\"\"\n    # Use the all() function to check if all elements in arr are less than num\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n    array (list): A list of integers to compare against.\n    number (int): The number to check.\n\n    Returns:\n    bool: True if the number is greater than every element in the array, False otherwise.\n\n    Example:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3], 4)\n    True\n    \"\"\"\n    # Use all() with a generator expression for efficiency\n    # all() will short-circuit at the first element that doesn't meet the condition\n    return all(number > elem for elem in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Parameters:\n    array (list): A list of integers to compare against.\n    num (int): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in array, False otherwise.\n\n    Example:\n    >>> check_greater([1, 2, 3, 4, 5], 6)\n    True\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    \"\"\"\n    # Using all() with a generator expression to check if num is greater than each element\n    return all(num > elem for elem in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n    arr (list): The list of integers to compare against.\n    num (int): The number to check for greater than condition.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3, 4, 5], 6)\n    True\n    \"\"\"\n    # Use the all function with a generator expression to check if num is greater than all elements\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in the given array.\n\n    Args:\n    arr (list): The list of integers to compare against.\n    num (int): The number to be checked against the array elements.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3], 4)\n    True\n    \"\"\"\n    # Use all() function with a generator to check if all elements are less than num\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if a given number is greater than all elements in the array.\n\n    Parameters:\n    arr (list): The list of integers to compare against.\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if 'num' is greater than all elements in 'arr', False otherwise.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3], 4)\n    True\n    \"\"\"\n    # Check if the array is empty to avoid errors\n    if not arr:\n        return True  # By convention, num is greater than elements of an empty list\n\n    # Use the all() function with a generator expression to check if num > every element\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n    arr (list of int): The list of integers to compare against.\n    num (int): The number to check for being greater.\n\n    Returns:\n    bool: True if num is greater than every element in arr, False otherwise.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3], 5)\n    True\n    \"\"\"\n    # Use all() with a generator expression for efficiency\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n    arr (list of int): The list of integers to compare against.\n    num (int): The number to compare with the array elements.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3, 4, 5], 6)\n    True\n    \"\"\"\n    # Using all() with a generator expression to check if all elements are less than num\n    return all(elem < num for elem in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, number):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n    arr (list of int): The list of integers to compare against.\n    number (int): The number to check if it's greater than all elements.\n\n    Returns:\n    bool: True if the number is greater than all elements, False otherwise.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3], 5)\n    True\n    \"\"\"\n    # We can use all() with a generator expression for efficiency\n    return all(number > elem for elem in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n    arr (list): A list of numbers to compare against.\n    num (int or float): The number to check for being greater.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3], 4)\n    True\n    \"\"\"\n    # Use all() with a generator expression to check if num is greater than each element\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n    arr (list of int): The array of integers to compare against.\n    num (int): The number to check.\n\n    Returns:\n    bool: True if 'num' is greater than every element in 'arr', False otherwise.\n\n    Example:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3], 5)\n    True\n    \"\"\"\n    # Use the all() function with a generator expression to check if all elements are less than num\n    return all(elem < num for elem in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number 'num' is greater than all elements in 'arr'.\n    \n    Args:\n    arr (list): List of integers to compare against.\n    num (int): The number to be checked.\n    \n    Returns:\n    bool: True if 'num' is greater than all elements in 'arr', False otherwise.\n    \n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3], 4)\n    True\n    \"\"\"\n    # Use all() to check if num is greater than all elements in arr\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check against the array elements.\n\n    Returns:\n    bool: True if 'num' is greater than all elements in 'arr', False otherwise.\n\n    Example:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    \"\"\"\n    # Using the all() function with a generator expression for efficiency\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n    arr (list): A list of integers to compare against.\n    num (int): The number to compare with elements of the array.\n\n    Returns:\n    bool: True if num is greater than all elements, False otherwise.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3, 4, 5], 6)\n    True\n    \"\"\"\n    # If the list is empty, return True as any number would be greater than no elements\n    if not arr:\n        return True\n    \n    # Use max() to find the largest element in the array and compare it with num\n    return num > max(arr)", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, number):\n    \"\"\"\n    Check if the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int): The array of integers to compare against.\n    number (int): The number to check if it's greater than all elements in arr.\n\n    Returns:\n    bool: True if the number is greater than all elements, False otherwise.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 6)\n    True\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    \"\"\"\n    # Using all() with a generator expression to check if all elements are less than number\n    return all(x < number for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, number):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    :param arr: List of integers to compare against.\n    :param number: The number to be compared.\n    :return: Boolean indicating if the number is greater than all elements in the array.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([10, 20], 30)\n    True\n    \"\"\"\n    # If the array is empty, the number is considered greater by default\n    if not arr:\n        return True\n    \n    # Use the built-in all() function with a generator expression for efficiency\n    return all(number > elem for elem in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n    arr (list): An array of numbers to compare against.\n    num (int): The number to check if it's greater than all elements in arr.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3], 4)\n    True\n    \"\"\"\n    # Use the all() function with a generator expression to check if num is greater than each element\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the number 'num' is greater than all elements in the given array.\n\n    Args:\n    arr (list): A list of numbers to compare against.\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n\n    Example:\n    >>> assert check_greater([1, 2, 3, 4, 5], 4) == False\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Check if the entered number is greater than all elements in the array.\n\n    Args:\n    array (list): A list of integers to compare against.\n    number (int): The number to check if it's greater than all elements in the array.\n\n    Returns:\n    bool: True if the number is greater than all elements, False otherwise.\n\n    Examples:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    >>> check_greater([1, 2, 3, 4, 5], 6)\n    True\n    \"\"\"\n    # If any element in the array is greater than or equal to number, return False\n    return all(number > item for item in array)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": 94.48529411764706, "dps_norm": 87.5, "pass@1": 16.0, "profiled": [{"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A string with only characters from even indices of the input string.\n\n    Example:\n    >>> remove_odd(\"python\")\n    'yhn'\n    \"\"\"\n    # Use string slicing with a step of 2 to get characters at even indices\n    # Here we start from index 1 because we want to keep the second character (index 1 in 0-indexing)\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n    \n    Args:\n    s (str): The input string to process.\n    \n    Returns:\n    str: A new string with only characters from even indices of the original string.\n    \n    Examples:\n    >>> remove_odd(\"python\")\n    'yhn'\n    \"\"\"\n    # Use list comprehension to keep only characters at even indices (0, 2, 4, ...)\n    return ''.join([char for index, char in enumerate(s) if index % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove all characters at odd indices from the string.\n    \n    Args:\n    s (str): The input string from which odd-indexed characters are to be removed.\n\n    Returns:\n    str: A new string with only characters at even indices from the original string.\n\n    Example:\n    >>> remove_odd(\"python\")\n    'yhn'\n    \"\"\"\n    # Use string slicing with a step of 2 to keep characters at even indices (0, 2, 4, ...)\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Remove all characters at odd indices from the string.\n\n    This function iterates through the string, keeping only the characters\n    that appear at even indices (0-based index), effectively removing all \n    characters that would be at an odd position.\n\n    Args:\n    s (str): The input string from which to remove characters.\n\n    Returns:\n    str: A new string with only the characters from even indices of the original string.\n\n    Raises:\n    TypeError: If the input is not a string.\n\n    Examples:\n    >>> remove_odd(\"python\")\n    'yhn'\n    >>> remove_odd(\"abcdef\")\n    'bdf'\n    \"\"\"\n    # Check if the input is a string to avoid type errors\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Use string slicing to keep every second character starting from index 1\n    # This has the effect of removing characters at odd positions\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove all characters at odd indices from the string.\n\n    Args:\n    s (str): The input string to process.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n\n    Example:\n    >>> remove_odd(\"python\")\n    'yhn'\n    \"\"\"\n    # Since indexing in Python starts at 0, 'odd' index here means \n    # the index where i % 2 != 0, which would typically be considered 'even' \n    # in mathematical terms. However, the function name and intent here consider \n    # 0 as an even position, hence we remove characters where (i + 1) % 2 == 0.\n    return ''.join([char for i, char in enumerate(s) if (i + 1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters from a string at odd indices (1-based indexing).\n    \n    This function iterates through the string, keeping only the characters\n    at even indices (0, 2, 4, etc. when considering 0-based indexing).\n    \n    Args:\n        s (str): The input string from which to remove odd-indexed characters.\n    \n    Returns:\n        str: A new string containing only the characters at even indices of the original string.\n    \n    Example:\n        >>> remove_odd(\"python\")\n        'yhn'\n    \"\"\"\n    # Use string slicing with a step of 2 to keep every second character starting from index 1\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters from a string at odd indices.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters removed from odd indices.\n\n    Example:\n    >>> remove_odd(\"python\")\n    'yhn'\n    \"\"\"\n    # Use string slicing with a step of 2 to keep only even-indexed characters\n    # Start from index 1 (which is the second character, index 0 is the first) \n    # to get characters from odd positions in the original string\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove odd indexed characters from the string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n\n    Example:\n    >>> remove_odd(\"python\")\n    'yhn'\n    \"\"\"\n    # Use string slicing to get only the characters at even indices\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Remove odd-indexed characters from the given string.\n\n    This function iterates over the string by index, keeping only\n    characters at even indices.\n\n    Args:\n        s (str): The input string to process.\n\n    Returns:\n        str: A new string with characters at odd indices removed.\n\n    Example:\n        >>> remove_odd(\"python\")\n        'yhn'\n    \"\"\"\n    # Use string slicing with step 2 to get every second character\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Remove characters from the string at odd indices.\n\n    This function filters out characters that are located at odd positions \n    (1-based indexing) in the given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string containing only characters from even indices.\n\n    Example:\n    >>> remove_odd(\"python\")\n    'yhn'\n    \"\"\"\n    # Use string slicing to keep characters at even indices (remember Python uses 0-based indexing)\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at odd indices in a string.\n\n    Args:\n    s (str): The input string to process.\n\n    Returns:\n    str: A new string with characters at odd positions removed.\n\n    Example:\n    >>> remove_odd(\"python\")\n    'yhn'\n    \"\"\"\n    # Use string slicing to get every second character starting from index 1 (which is considered odd here)\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters from the string at odd indices.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \n    Example:\n    >>> remove_odd(\"python\")\n    'yhn'\n    \"\"\"\n    # Use string slicing with a step of 2 to get every other character starting from index 1\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at odd indices in the string.\n    \n    Args:\n    s (str): The input string from which odd characters will be removed.\n    \n    Returns:\n    str: A string with characters at odd indices removed.\n\n    Examples:\n    >>> remove_odd(\"python\")\n    'yhn'\n    >>> remove_odd(\"\")  # Empty string should return empty string\n    ''\n    \"\"\"\n    # If the string length is odd, we'll need to keep the last character\n    if len(s) % 2:\n        return s[1::2]  # Start at index 1, take every 2nd char, include last\n    else:\n        # For even length, we can slice directly without including the last char\n        return s[1::2]  # Start at index 1, take every 2nd char", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    This function iterates through the string and keeps characters\n    whose indices are even (0-based indexing).\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n\n    Examples:\n    >>> remove_odd(\"python\")\n    'yhn'\n    \"\"\"\n    # Use string slicing with a step of 2 to keep every other character (even indices)\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove all characters at odd indices from the given string.\n\n    This function goes through the string and keeps only characters at even indices.\n    \n    Args:\n    s (str): The input string from which to remove characters.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n\n    Examples:\n    >>> remove_odd(\"python\")\n    'yhn'\n    >>> remove_odd(\"abcdef\")\n    'bdf'\n    \"\"\"\n    # Use string slicing to keep every second character, starting from index 1 (which is considered odd)\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at odd indices from the input string.\n\n    Args:\n    s (str): The input string from which characters at odd positions will be removed.\n\n    Returns:\n    str: A new string containing only characters from even indices in the original string.\n\n    Examples:\n    >>> remove_odd(\"python\")\n    'yhn'\n    >>> remove_odd(\"test\")\n    't'\n    \"\"\"\n    return s[1::2]  # Start from index 1, take every second character", "matching_cluster_idx": 4}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 48.0, "profiled": [{"solution": "def count_Occurrence(elements_tuple, items_list):\n    \"\"\"\n    Count the occurrences of elements in the list within the tuple.\n    \n    :param elements_tuple: Tuple of elements to search through.\n    :param items_list: List of items to count occurrences of.\n    :return: Integer count of all occurrences of list items in the tuple.\n    \"\"\"\n    # Use a generator expression to count occurrences for each item in items_list\n    # and sum them up\n    return sum(\n        elements_tuple.count(item) for item in items_list\n    )", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Counts the occurrences of elements from list_input within tuple_input.\n    \n    Args:\n    tuple_input (tuple): The tuple to search in.\n    list_input (list): List of elements to count in the tuple.\n    \n    Returns:\n    int: Total count of occurrences of all elements from list_input in tuple_input.\n    \n    Example:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n    3\n    \"\"\"\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, elements):\n    \"\"\"\n    Count the occurrence of all elements from the list in the given tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to search in.\n    elements (list): The list of elements to count in the tuple.\n    \n    Returns:\n    int: Total count of elements from the list found in the tuple.\n    \"\"\"\n    # Use a list comprehension to count occurrences for each element in elements\n    return sum(tup.count(e) for e in elements)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrences of all elements in the list within the given tuple.\n\n    Args:\n    tup (tuple): The tuple in which elements are to be counted.\n    lst (list): The list containing elements to be searched in the tuple.\n\n    Returns:\n    int: Total number of occurrences of elements from lst in tup.\n\n    Example:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n    3\n    \"\"\"\n    # Convert tuple to list for easier manipulation\n    tup_list = list(tup)\n    # Count occurrences by summing the count of each element in lst\n    return sum(tup_list.count(item) for item in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrences of all elements from lst in tup.\n\n    Args:\n    tup (tuple): The tuple to search within.\n    lst (list): The list containing elements to count.\n\n    Returns:\n    int: Total count of occurrences of elements from lst in tup.\n\n    Example:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n    3\n    \"\"\"\n    # Initialize a counter for total occurrences\n    total_count = 0\n    \n    # For each item in lst, count its occurrences in tup\n    for item in lst:\n        total_count += tup.count(item)\n    \n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrences of all elements in the list within the tuple.\n\n    :param tup: Tuple containing elements to check against.\n    :param lst: List of elements whose occurrences are to be counted.\n    :return: Integer representing the total count of occurrences.\n\n    Example:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n    3\n    \"\"\"\n    # Convert the tuple to a list for easier manipulation if needed\n    tup_list = list(tup)\n    \n    # Use a list comprehension to count occurrences of each element in lst\n    return sum(tup_list.count(item) for item in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements from the list in the tuple.\n\n    Parameters:\n    - tup: A tuple where elements are to be searched.\n    - lst: A list containing elements to look for in the tuple.\n\n    Returns:\n    - Integer representing the total count of occurrences of list elements in the tuple.\n\n    Example:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n    3\n    \"\"\"\n    # Convert tuple to list for easier manipulation if necessary\n    tuple_elements = list(tup)\n    \n    # Use sum with a generator expression to count occurrences\n    # This is an efficient way to sum up occurrences without creating intermediate lists\n    count = sum(\n        tuple_elements.count(item) \n        for item in lst\n    )\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(elements, search_list):\n    \"\"\"\n    Count the occurrences of elements from search_list in the tuple elements.\n\n    Args:\n    elements (tuple): The tuple in which occurrences are to be counted.\n    search_list (list): List of elements to count occurrences for.\n\n    Returns:\n    int: Total count of occurrences of all elements from search_list in the tuple.\n\n    Examples:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n    3\n    \"\"\"\n    # Convert tuple to list for ease of counting\n    count = sum(elements.count(item) for item in search_list)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the total occurrences of elements from 'lst' within 'tup'.\n\n    Parameters:\n    tup (tuple): The tuple to search in.\n    lst (list): The list of elements to look for.\n\n    Returns:\n    int: The total count of occurrences of elements from lst in tup.\n\n    Examples:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'])\n    3\n    \"\"\"\n    # Use a list comprehension to count occurrences for each element in lst,\n    # then sum all these counts\n    return sum(tup.count(item) for item in lst if item in tup)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of elements from a list within a tuple.\n\n    Args:\n    tup (tuple): A tuple where elements are to be searched.\n    lst (list): A list containing elements to count in the tuple.\n\n    Returns:\n    int: The total count of all occurrences of elements from lst in tup.\n\n    Example:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n    3\n    \"\"\"\n    # Convert tuple to list for easy manipulation, although this could be done with collections.Counter\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrences of all elements from the list in the tuple.\n\n    Args:\n    tup (tuple): The tuple in which elements are to be counted.\n    lst (list): List containing elements whose occurrences are to be counted in the tuple.\n\n    Returns:\n    int: Total count of all specified elements in the tuple.\n\n    Example:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n    3\n    \"\"\"\n    # Initialize counter to 0\n    count = 0\n    \n    # Convert tuple to a list for easier element checking\n    tup_list = list(tup)\n    \n    # Count occurrences of each element in the list within the tuple\n    for item in lst:\n        count += tup_list.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrences of all elements from lst in tup.\n\n    Parameters:\n    - tup: A tuple whose elements are to be searched.\n    - lst: A list whose elements we want to count in tup.\n\n    Returns:\n    - An integer representing the total count of occurrences.\n\n    Example:\n    >>> assert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3\n    \"\"\"\n    # Convert tuple to list for easier manipulation\n    tuple_list = list(tup)\n    # Use sum with a generator expression to count occurrences\n    return sum(tuple_list.count(item) for item in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrences of elements from lst in tup.\n\n    Args:\n    tup (tuple): The tuple in which we are counting occurrences.\n    lst (list): The list of elements to count.\n\n    Returns:\n    int: Total count of elements from lst found in tup.\n\n    Examples:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'])\n    3\n    \"\"\"\n    # Convert the tuple to a list for easier manipulation if necessary\n    tup_list = list(tup)\n    # Use sum with a generator expression to count occurrences\n    # count(elt) counts how many times 'elt' appears in tup_list\n    return sum(tup_list.count(elt) for elt in lst if elt in tup_list)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(elements, search_list):\n    \"\"\"\n    Count the occurrence of elements in 'search_list' within the tuple 'elements'.\n    \n    Args:\n    elements (tuple): A tuple containing elements to be searched.\n    search_list (list): A list of elements whose occurrences are to be counted.\n    \n    Returns:\n    int: Total count of all elements from 'search_list' found in 'elements'.\n    \n    Example:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n    3\n    \"\"\"\n    # Convert the tuple to a list for easier manipulation\n    elements_list = list(elements)\n    \n    # Use sum with a generator expression to count occurrences\n    # For each item in search_list, count how many times it appears in elements_list\n    total_count = sum(elements_list.count(item) for item in search_list)\n    \n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(target_tuple, search_list):\n    \"\"\"\n    Count the occurrences of elements from search_list in target_tuple.\n    \n    This function iterates through each element in the search_list and \n    counts how many times each element appears in the target_tuple.\n\n    Args:\n    target_tuple (tuple): The tuple in which to count occurrences.\n    search_list (list): The list of items to look for in the tuple.\n\n    Returns:\n    int: Total number of occurrences of all elements from search_list in target_tuple.\n\n    Example:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n    3\n    \"\"\"\n    # Initialize the count\n    total_count = 0\n    \n    # Convert tuple to list for efficient element counting\n    target_list = list(target_tuple)\n    \n    # Count each element's occurrences\n    for item in search_list:\n        total_count += target_list.count(item)\n    \n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Convert tuple to list for easier manipulation\n    tup_list = list(tup)\n    count = 0\n    \n    # Count occurrences of each element from lst in tup_list\n    for item in lst:\n        count += tup_list.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    lst (list): List of elements to count.\n\n    Returns:\n    int: The total count of occurrences of all elements from lst in tup.\n\n    Example:\n    >>> assert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3\n    \"\"\"\n    # Convert the tuple to a list for easier manipulation if needed\n    tup_list = list(tup)\n    count = sum(tup_list.count(item) for item in lst)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Count the occurrences of elements from the list in the tuple.\n\n    Parameters:\n    tuple_input (tuple): A tuple containing elements to be searched.\n    list_input (list): A list of elements to search for in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements from the list in the tuple.\n\n    Example:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n    3\n    \"\"\"\n    # Initialize the count\n    count = 0\n    \n    # Convert tuple to list for easier manipulation\n    tuple_list = list(tuple_input)\n    \n    # Iterate through each element in the list_input\n    for element in list_input:\n        # Count occurrences of the element in the tuple\n        count += tuple_list.count(element)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_to_check):\n    \"\"\"\n    Count the occurrences of elements from list_to_check within tuple_input.\n\n    Args:\n    tuple_input (tuple): A tuple where occurrences are to be counted.\n    list_to_check (list): A list of elements whose occurrences in the tuple are to be counted.\n\n    Returns:\n    int: The total number of occurrences of all elements from list_to_check in tuple_input.\n\n    Example:\n    >>> assert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3\n    \"\"\"\n    # Use a list comprehension to sum up occurrences of each item in list_to_check\n    return sum(tuple_input.count(item) for item in list_to_check)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, elements):\n    \"\"\"\n    Count the total occurrences of elements from a list within a given tuple.\n\n    Args:\n    tup (tuple): The tuple to search through.\n    elements (list): List of elements to count in the tuple.\n\n    Returns:\n    int: The total number of occurrences of all elements from the list in the tuple.\n\n    Examples:\n    >>> assert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3\n    \"\"\"\n    # Initialize a counter for occurrences\n    count = 0\n    \n    # For each element in the list, count how many times it appears in the tuple\n    for item in elements:\n        # Add the count of each item in the tuple to the total count\n        count += tup.count(item)\n    \n    return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/456": {"dps": 85.58333333333333, "dps_norm": 97.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverse each string in the given list of string values.\n\n    Args:\n    strings (list of str): A list of strings to be reversed.\n\n    Returns:\n    list of str: A new list where each string from the original list is reversed.\n\n    Examples:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n    strings (list): A list of strings to reverse.\n\n    Returns:\n    list: A list where each string from the input is reversed.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    # Use list comprehension to create a new list with reversed strings\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    Reverse each string in the given list of strings.\n\n    Args:\n    lst (list): A list containing strings to be reversed.\n\n    Returns:\n    list: A new list where each string from the input list is reversed.\n\n    Examples:\n    >>> reverse_string_list(['Red', 'Green'])\n    ['deR', 'neerG']\n    \"\"\"\n    # Use list comprehension to create a new list with reversed strings\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n    strings (list of str): The list of strings to be reversed.\n\n    Returns:\n    list of str: A new list where each string is reversed.\n\n    Examples:\n    >>> reverse_string_list(['Red', 'Green', 'Blue'])\n    ['deR', 'neerG', 'eulB']\n    \"\"\"\n    # Use list comprehension to create a new list with each string reversed\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n    strings (list of str): A list where each element is a string to be reversed.\n\n    Returns:\n    list of str: A new list with each string reversed.\n\n    Examples:\n    >>> reverse_string_list(['Red', 'Green', 'Blue'])\n    ['deR', 'neerG', 'eulB']\n    \"\"\"\n    # Use list comprehension to create a new list with reversed strings\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n    strings (list): A list of strings to reverse.\n\n    Returns:\n    list: A list where each string from the input has been reversed.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    # Use list comprehension to reverse each string in the list\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n    strings (list of str): A list containing string values to be reversed.\n\n    Returns:\n    list of str: A new list where each string from the input list is reversed.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue'])\n    ['deR', 'neerG', 'eulB']\n    \"\"\"\n    # Using list comprehension to create a new list with reversed strings\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n    \n    Args:\n    strings (list): A list containing string values.\n    \n    Returns:\n    list: A list with each string reversed.\n    \n    Examples:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    # Use list comprehension to create a new list where each string is reversed\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n\n    Args:\n    strings (list of str): A list containing string values.\n\n    Returns:\n    list of str: A new list where each string from the input list is reversed.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    # Use list comprehension to create a new list with reversed strings\n    return [''.join(reversed(s)) for s in strings]", "matching_cluster_idx": 3}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n    strings (list): A list of strings to reverse.\n\n    Returns:\n    list: A new list where each string from the input is reversed.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    # Use list comprehension to reverse each string in the list\n    return [''.join(reversed(s)) for s in strings]", "matching_cluster_idx": 3}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list.\n\n    Args:\n    strings (list of str): A list of strings to be reversed.\n\n    Returns:\n    list of str: A new list where each string is reversed.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green'])\n    ['deR', 'neerG']\n    \"\"\"\n    return [''.join(reversed(s)) for s in strings]", "matching_cluster_idx": 3}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n\n    Args:\n    strings (list): A list of string elements to be reversed.\n\n    Returns:\n    list: A new list with each string reversed.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    # Use list comprehension to reverse each string in the list\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    Args:\n    strings (list of str): A list containing string elements to be reversed.\n\n    Returns:\n    list of str: A new list with each string from the input reversed.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue'])\n    ['deR', 'neerG', 'eulB']\n    \"\"\"\n    # Use list comprehension to create a new list with reversed strings\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverse each string in the provided list of strings.\n\n    Args:\n    strings (list of str): A list containing string elements.\n\n    Returns:\n    list: A new list where each string from the input list is reversed.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    # Using list comprehension to reverse each string in the list\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in a list of strings.\n\n    Args:\n    strings (list of str): A list of strings to be reversed.\n\n    Returns:\n    list of str: A new list where each string is the reverse of the corresponding string in the input list.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue'])\n    ['deR', 'neerG', 'eulB']\n    \"\"\"\n    # Using a list comprehension for efficiency and readability\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n    \n    Args:\n    strings (list): A list containing string values to be reversed.\n    \n    Returns:\n    list: A new list with each string from the input list reversed.\n    \n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue'])\n    ['deR', 'neerG', 'eulB']\n    \"\"\"\n    # Use list comprehension to create a new list with each string reversed\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n    strings (list of str): A list of strings to be reversed.\n\n    Returns:\n    list of str: A list where each string from the input has been reversed.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    # Use list comprehension to reverse each string in the list\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    This function takes a list of strings and returns a new list where each\n    string is reversed. \n\n    Args:\n    strings (list of str): A list containing string elements to be reversed.\n\n    Returns:\n    list of str: A new list where each string from the input list is reversed.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue'])\n    ['deR', 'neerG', 'eulB']\n    \"\"\"\n    # Use list comprehension to reverse each string in the list\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n    strings (list): A list of strings to be reversed.\n\n    Returns:\n    list: A new list where each string has been reversed.\n\n    Examples:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    return [string[::-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n    strings (list of str): A list of strings to be reversed.\n\n    Returns:\n    list of str: A new list where each string from the input list is reversed.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    # Use a list comprehension to reverse each string in the list\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 49.375, "dps_norm": 79.0, "pass@1": 97.0, "profiled": [{"solution": "def Extract(lists):\n    \"\"\"\n    Extracts the first element of each sublist from a list of lists.\n\n    Args:\n    lists (List[List]): A list containing sublists of any length.\n\n    Returns:\n    List: A new list where each element is the first item of the corresponding sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use a list comprehension to get the first element of each sublist\n    return [sublist[0] for sublist in lists if sublist]  # Check if sublist exists to avoid index errors", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extracts the first element from each sublist within a list of lists.\n\n    Args:\n    sublists (list of list): A list where each element is a list.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n\n    Raises:\n    IndexError: If any sublist is empty.\n\n    Examples:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    >>> Extract([])\n    []\n    \"\"\"\n    return [sublist[0] for sublist in sublists if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n    lists (list of list): A list containing sublists.\n\n    Returns:\n    list: A new list where each element is the first item of the corresponding sublist.\n\n    Examples:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use list comprehension to get the first item from each sublist\n    return [sublist[0] for sublist in lists if sublist]  # Check for non-empty lists to avoid IndexError", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extract the first element of each sublist within a list of lists.\n\n    Args:\n    sublists (list of list): A list containing sublists from which to extract the first element.\n\n    Returns:\n    list: A list of the first elements from each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use a list comprehension to get the first element of each sublist\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist within the given list.\n\n    Parameters:\n    lst (list): A list containing sublists.\n\n    Returns:\n    list: A list of the first elements from each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use list comprehension to get the first element of each sublist\n    return [item[0] for item in lst if item]  # The condition 'if item' checks if the sublist is not empty", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extracts the first element from each sublist in the given list of sublists.\n\n    Args:\n    sublists (list): A list of lists, where each inner list might have varying lengths.\n\n    Returns:\n    list: A list containing the first element from each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use a list comprehension to get the first element of each sublist\n    return [sublist[0] for sublist in sublists if sublist]  # The if condition checks for non-empty sublists to avoid errors", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    This function extracts the first element from each sublist within a list of lists.\n    \n    :param lst: A list containing sublists from which to extract first elements.\n    :return: A list of first elements from each sublist.\n    \"\"\"\n    # Use list comprehension to get the first element of each sublist\n    # The expression checks if the sublist has at least one element to avoid IndexError\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extracts the first element from each sublist in the given list of lists.\n\n    Args:\n    sublists (list of lists): A list where each element is itself a list.\n\n    Returns:\n    list: A new list containing the first element of each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use list comprehension to get the first element of each sublist\n    return [sublist[0] for sublist in sublists if sublist]  # Ensure sublist is not empty", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist in the given list of lists.\n    \n    Parameters:\n    lst (list): A list of lists from which to extract the first elements.\n    \n    Returns:\n    list: A list containing the first element of each sublist. If a sublist is empty,\n          None will be appended for that position.\n    \n    Examples:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    >>> Extract([])\n    []\n    >>> Extract([[]])\n    [None]\n    \"\"\"\n    return [sublist[0] if sublist else None for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist in the given list.\n\n    Args:\n    lst (list): A list of lists from which to extract the first elements.\n\n    Returns:\n    list: A list containing the first elements of each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use a list comprehension to get the first item from each sublist\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist in the given list.\n\n    Args:\n    lst (list of list): A list containing sublists from which the first elements are to be extracted.\n\n    Returns:\n    list: A new list containing only the first element of each sublist.\n\n    Raises:\n    ValueError: If any element in 'lst' is not a list or if any sublist is empty.\n\n    Examples:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    try:\n        # Using list comprehension to get the first element of each sublist\n        return [sublist[0] for sublist in lst if len(sublist) > 0]\n    except TypeError:\n        raise ValueError(\"All elements in the list must be lists, and cannot be empty.\")", "matching_cluster_idx": 2}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extract the first element from each sublist in a list of lists.\n\n    Args:\n    sublists (List[List[Any]]): A list containing sublists from which we extract the first item.\n\n    Returns:\n    List[Any]: A list containing the first element of each sublist.\n\n    Examples:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use list comprehension to get the first element of each sublist\n    return [sublist[0] for sublist in sublists if sublist]  # Check if sublist is not empty to avoid IndexError", "matching_cluster_idx": 3}, {"solution": "def Extract(nested_list):\n    \"\"\"\n    Extracts the first element from each sublist in the given nested list.\n\n    Args:\n    nested_list (list of lists): A list containing sublists from which the first element will be extracted.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    return [sublist[0] for sublist in nested_list if sublist]  # Ensure sublist exists and is not empty", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n    lists (list): A list where each element is a list or iterable.\n\n    Returns:\n    list: A new list containing the first element of each sublist.\n\n    Raises:\n    ValueError: If any sublist is empty.\n\n    Examples:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use list comprehension to get the first element of each sublist\n    # The try/except block handles potential IndexErrors if a sublist is empty\n    result = []\n    for sublist in lists:\n        try:\n            result.append(next(iter(sublist)))  # Efficient way to get first element\n        except StopIteration:\n            raise ValueError(\"Encountered an empty sublist\")\n    return result", "matching_cluster_idx": 1}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extracts the first element from each sublist within a list of lists.\n\n    This function iterates through each sublist in the provided list and\n    collects the first element of each sublist.\n\n    Args:\n    sublists (list of lists): A list containing zero or more sublists.\n\n    Returns:\n    list: A list where each element is the first item from each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n\n    Raises:\n    IndexError: If any sublist within `sublists` is empty.\n    \"\"\"\n    return [sublist[0] for sublist in sublists if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist in the given list of lists.\n\n    Args:\n    lst (List[List]): A list containing sublists from which first elements are to be extracted.\n\n    Returns:\n    List: A list where each element is the first element of the corresponding sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use list comprehension to get the first item from each sublist\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist within a list of lists.\n    \n    Parameters:\n    lst (list): A list containing sublists.\n    \n    Returns:\n    list: A list where each element is the first item of the corresponding sublist in the input.\n    \n    Examples:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use list comprehension to get the first element of each sublist\n    return [sublist[0] for sublist in lst if sublist]  # Check if sublist is not empty", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    \"\"\"\n    Extracts the first element from each sublist within a list of lists.\n\n    This function takes a list of lists and returns a new list containing\n    only the first element of each sublist. If a sublist is empty, None is used.\n\n    Parameters:\n    lists (list of list): A list containing one or more sublists.\n\n    Returns:\n    list: A list with the first elements of each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n\n    >>> Extract([])\n    []\n    \"\"\"\n    return [sublist[0] if sublist else None for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    \"\"\"\n    Extracts the first element from each sublist.\n\n    Args:\n    lists (List[List]): A list of lists from which to extract first elements.\n\n    Returns:\n    List: A list containing the first element of each sublist.\n\n    Examples:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use a list comprehension to get the first element from each sublist\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lists):\n    \"\"\"\n    Extracts the first element from each sublist in the given list of lists.\n\n    Args:\n    lists (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n    List[int]: A list with the first element of each sublist.\n\n    Examples:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n\n    Raises:\n    ValueError: If the list contains non-list elements or if any sublist is empty.\n    \"\"\"\n    try:\n        return [sublist[0] for sublist in lists if len(sublist) > 0]\n    except (IndexError, TypeError):\n        raise ValueError(\"Invalid input: Each sublist must be non-empty and contain indexable elements.\")", "matching_cluster_idx": 2}]}, "Mbpp/474": {"dps": 50.24390243902439, "dps_norm": 64.28571428571429, "pass@1": 98.0, "profiled": [{"solution": "def replace_char(s: str, char_to_replace: str, char_to_insert: str) -> str:\n    \"\"\"\n    Replaces all occurrences of a specified character in a string with another character.\n\n    Args:\n    s (str): The original string where characters need to be replaced.\n    char_to_replace (str): The character in the string to be replaced.\n    char_to_insert (str): The character that will replace char_to_replace.\n\n    Returns:\n    str: A new string with the replacements made.\n\n    Raises:\n    ValueError: If either char_to_replace or char_to_insert is not a single character.\n\n    Examples:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    \"\"\"\n    # Check if inputs are single characters\n    if len(char_to_replace) != 1 or len(char_to_insert) != 1:\n        raise ValueError(\"Both char_to_replace and char_to_insert must be single characters.\")\n    \n    # Use a list comprehension for efficiency in building the new string\n    return ''.join(char_to_insert if char == char_to_replace else char for char in s)", "matching_cluster_idx": 3}, {"solution": "def replace_char(s: str, old: str, new: str) -> str:\n    \"\"\"\n    Replace all occurrences of a character with another in the given string.\n\n    Args:\n    s (str): The input string to modify.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n\n    Returns:\n    str: A new string with the characters replaced.\n\n    Example:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    \"\"\"\n    # Check if 'old' is actually in the string to avoid unnecessary replacements\n    if old not in s:\n        return s\n    \n    # Convert string to list for easier manipulation\n    chars = list(s)\n    \n    # Iterate through the list and replace the characters\n    for i, char in enumerate(chars):\n        if char == old:\n            chars[i] = new\n    \n    # Join the list back into a string\n    return ''.join(chars)", "matching_cluster_idx": 2}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n\n    Args:\n    s (str): The original string.\n    old_char (str): The character to be replaced. Must be a single character.\n    new_char (str): The character to replace with. Must be a single character.\n\n    Returns:\n    str: A new string with the specified character replaced.\n\n    Raises:\n    ValueError: If old_char or new_char is not a single character.\n    \"\"\"\n    if len(old_char) != 1 or len(new_char) != 1:\n        raise ValueError(\"Both old_char and new_char must be single characters.\")\n\n    # Create a list from the string to mutate it\n    chars = list(s)\n    \n    # Iterate over the list to replace the character\n    for i in range(len(chars)):\n        if chars[i] == old_char:\n            chars[i] = new_char\n    \n    # Join the list back into a string and return\n    return ''.join(chars)", "matching_cluster_idx": 2}, {"solution": "def replace_char(s: str, old: str, new: str) -> str:\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n\n    Args:\n        s (str): The input string to modify.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n\n    Returns:\n        str: The string with replacements made.\n\n    Raises:\n        ValueError: If either 'old' or 'new' are not single characters.\n\n    Examples:\n        >>> replace_char(\"polygon\", 'y', 'l')\n        'pollgon'\n    \"\"\"\n    # Check if 'old' and 'new' are single characters\n    if len(old) != 1 or len(new) != 1:\n        raise ValueError(\"The parameters 'old' and 'new' must be single characters.\")\n\n    # Replace the character\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of 'old_char' with 'new_char' in the string 's'.\n\n    Args:\n    s (str): The original string.\n    old_char (str): The character to be replaced. Assumed to be a single character.\n    new_char (str): The character to replace with. Assumed to be a single character.\n\n    Returns:\n    str: A new string with replacements made.\n\n    Raises:\n    ValueError: If either old_char or new_char is not a single character.\n    \"\"\"\n    # Check if old_char and new_char are single characters\n    if not (len(old_char) == len(new_char) == 1):\n        raise ValueError(\"Both old_char and new_char must be single characters.\")\n    \n    # Use the str.replace method to replace all occurrences\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of char_to_replace with replacement_char in the string s.\n    \n    Args:\n    s (str): The original string to modify.\n    char_to_replace (str): The character to be replaced. Must be a single character.\n    replacement_char (str): The character to replace with. Must be a single character.\n    \n    Returns:\n    str: A new string with replacements made.\n    \n    Raises:\n    ValueError: If char_to_replace or replacement_char are not single characters.\n    \"\"\"\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"Both char_to_replace and replacement_char must be single characters.\")\n    \n    # Create a new string where each character is checked and replaced if necessary\n    return ''.join(replacement_char if c == char_to_replace else c for c in s)", "matching_cluster_idx": 3}, {"solution": "def replace_char(s, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n\n    Args:\n    s (str): The original string where characters will be replaced.\n    char_to_replace (str): The character in the string to be replaced.\n    replacement_char (str): The character to replace with.\n\n    Returns:\n    str: A new string with the specified character replaced.\n\n    Example:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    \"\"\"\n    # Check if both characters are of length 1 to ensure they are single characters\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"Both characters must be single characters.\")\n    \n    # Use list comprehension to build a new string, replacing when necessary\n    return ''.join([replacement_char if c == char_to_replace else c for c in s])", "matching_cluster_idx": 3}, {"solution": "def replace_char(s: str, char_to_replace: str, replacement_char: str) -> str:\n    \"\"\"\n    Replaces all occurrences of `char_to_replace` with `replacement_char` in the string `s`.\n    \n    Args:\n    s (str): The input string where characters are to be replaced.\n    char_to_replace (str): The character that needs to be replaced. Must be a single character.\n    replacement_char (str): The character to replace with. Must be a single character.\n    \n    Returns:\n    str: A new string with the specified character replacements.\n    \n    Raises:\n    ValueError: If either `char_to_replace` or `replacement_char` is not a single character.\n    \n    Example:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    \"\"\"\n    # Check if the input characters are indeed single characters\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"Both char_to_replace and replacement_char must be single characters.\")\n    \n    # Using a list for efficient string manipulation in Python\n    result = list(s)\n    for i, char in enumerate(s):\n        if char == char_to_replace:\n            result[i] = replacement_char\n    return ''.join(result)", "matching_cluster_idx": 2}, {"solution": "def replace_char(input_string: str, char_to_replace: str, replacement_char: str) -> str:\n    \"\"\"\n    Replace all occurrences of char_to_replace with replacement_char in the input_string.\n\n    Args:\n    input_string (str): The string where characters will be replaced.\n    char_to_replace (str): The character to be replaced. Must be a single character.\n    replacement_char (str): The character to replace with. Must be a single character.\n\n    Returns:\n    str: A new string where all instances of char_to_replace are substituted with replacement_char.\n\n    Raises:\n    ValueError: If either char_to_replace or replacement_char is not a single character.\n\n    Examples:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    >>> replace_char(\"abbabaa\", 'b', 'c')\n    'accacaa'\n    \"\"\"\n    # Check if the provided characters for replacement are indeed single characters\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"Replacement characters must be single characters.\")\n    \n    # Use string translation for efficient character replacement\n    return input_string.translate(str.maketrans(char_to_replace, replacement_char))", "matching_cluster_idx": 5}, {"solution": "def replace_char(s, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of char_to_replace with replacement_char in string s.\n\n    Args:\n    s (str): The original string.\n    char_to_replace (str): The character to be replaced, should be a single character string.\n    replacement_char (str): The character to replace with, should be a single character string.\n\n    Returns:\n    str: A new string with the specified character replaced.\n\n    Raises:\n    ValueError: If either char_to_replace or replacement_char is not a single character.\n\n    Example:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    \"\"\"\n    # Check if the chars to replace and replace with are exactly one character long\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"Both the character to replace and the replacement must be single characters.\")\n    \n    # Using list comprehension for efficiency in string manipulation\n    return ''.join([replacement_char if c == char_to_replace else c for c in s])", "matching_cluster_idx": 3}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n    \n    Args:\n    s (str): The input string to modify.\n    old (str): The character to be replaced. Must be a single character.\n    new (str): The character to replace with. Must be a single character.\n    \n    Returns:\n    str: A new string with the specified character replaced.\n    \n    Raises:\n    ValueError: If old or new is not a single character.\n\n    Examples:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    \"\"\"\n    if len(old) != 1 or len(new) != 1:\n        raise ValueError(\"Both 'old' and 'new' must be single characters.\")\n    \n    # Use a list comprehension for efficiency in building the new string\n    return ''.join(new if c == old else c for c in s)", "matching_cluster_idx": 3}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a specified character in a string with another character.\n\n    Args:\n    input_string (str): The original string where characters are to be replaced.\n    char_to_replace (str): The character in the string to be replaced. Should be a single character.\n    replacement_char (str): The character to replace with. Should also be a single character.\n\n    Returns:\n    str: A new string with all occurrences of char_to_replace replaced by replacement_char.\n\n    Raises:\n    ValueError: If either char_to_replace or replacement_char are not single characters.\n\n    Examples:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    >>> replace_char(\"book\", 'o', 'e')\n    'beek'\n    \"\"\"\n    # Ensure that char_to_replace and replacement_char are single characters\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"Both char_to_replace and replacement_char must be single characters.\")\n    \n    # Use list comprehension to create a new string with characters replaced\n    return ''.join([replacement_char if char == char_to_replace else char for char in input_string])", "matching_cluster_idx": 3}, {"solution": "def replace_char(s: str, old_char: str, new_char: str) -> str:\n    \"\"\"\n    Replaces all occurrences of 'old_char' in 's' with 'new_char'.\n\n    Args:\n    s (str): The original string in which characters will be replaced.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: A new string with all instances of old_char replaced by new_char.\n\n    Raises:\n    ValueError: If old_char or new_char are not single characters.\n\n    Examples:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    \"\"\"\n    # Check if old_char and new_char are single characters\n    if len(old_char) != 1 or len(new_char) != 1:\n        raise ValueError(\"Both old_char and new_char must be single characters\")\n\n    # Use list comprehension for efficiency\n    return ''.join(new_char if char == old_char else char for char in s)", "matching_cluster_idx": 3}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a specified character in a string with another character.\n\n    Args:\n    string (str): The original string where the character replacement will occur.\n    char_to_replace (str): A single character that will be replaced.\n    replacement_char (str): A single character that will replace the old one.\n\n    Returns:\n    str: A new string where 'char_to_replace' is substituted with 'replacement_char'.\n\n    Raises:\n    ValueError: If either 'char_to_replace' or 'replacement_char' is not a single character.\n\n    Examples:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    \"\"\"\n    # Ensure char_to_replace and replacement_char are single characters\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"Both char_to_replace and replacement_char must be single characters.\")\n    \n    # Convert string to list for in-place modifications which are more efficient in Python 3\n    char_list = list(string)\n    for i, char in enumerate(char_list):\n        if char == char_to_replace:\n            char_list[i] = replacement_char\n            \n    # Join the list back into a string\n    return ''.join(char_list)", "matching_cluster_idx": 2}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of a specified character with another in a string.\n\n    This function scans through each character in the input string and replaces\n    any instances of 'old_char' with 'new_char'. \n\n    Args:\n        input_string (str): The string in which characters will be replaced.\n        old_char (str): The character to be replaced. Must be a single character.\n        new_char (str): The character to replace with. Must be a single character.\n\n    Returns:\n        str: A new string with the specified character replacements.\n\n    Raises:\n        ValueError: If either old_char or new_char is not a single character.\n\n    Examples:\n        >>> replace_char(\"polygon\", 'y', 'l')\n        'pollgon'\n    \"\"\"\n    # Check if both old_char and new_char are single characters\n    if len(old_char) != 1 or len(new_char) != 1:\n        raise ValueError(\"Both old_char and new_char must be single characters.\")\n\n    # Use a list comprehension to build a new string with replaced characters\n    return ''.join(char if char != old_char else new_char for char in input_string)", "matching_cluster_idx": 3}, {"solution": "def replace_char(s: str, char_to_replace: str, replacement: str) -> str:\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character or string.\n\n    Args:\n    s (str): The original string.\n    char_to_replace (str): The character to be replaced. Must be a single character.\n    replacement (str): The string to replace the character with.\n\n    Returns:\n    str: The string with the specified character replaced.\n\n    Raises:\n    ValueError: If char_to_replace is not a single character.\n\n    Examples:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    \"\"\"\n    # Ensure char_to_replace is a single character\n    if len(char_to_replace) != 1:\n        raise ValueError(\"The character to replace must be a single character.\")\n    \n    # Replace all instances of char_to_replace with replacement\n    return s.replace(char_to_replace, replacement)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string: str, char_to_replace: str, replacement: str) -> str:\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n\n    Args:\n    string (str): The original string.\n    char_to_replace (str): The character to be replaced in the string.\n    replacement (str): The character to replace with.\n\n    Returns:\n    str: A new string with characters replaced.\n\n    Examples:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    >>> replace_char(\"abcdef\", 'a', 'z')\n    'zbcdef'\n    \"\"\"\n    # Check if both char_to_replace and replacement are single characters\n    if len(char_to_replace) != 1 or len(replacement) != 1:\n        raise ValueError(\"The replacement parameters must be single characters.\")\n\n    # Use string translation for efficiency\n    translation_table = str.maketrans(char_to_replace, replacement)\n    return string.translate(translation_table)", "matching_cluster_idx": 5}, {"solution": "def replace_char(original_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n\n    Args:\n    original_string (str): The string in which characters are to be replaced.\n    char_to_replace (str): The character to be replaced. Should be a single character.\n    replacement_char (str): The character to replace with. Should be a single character.\n\n    Returns:\n    str: A new string with the specified characters replaced.\n\n    Raises:\n    ValueError: If `char_to_replace` or `replacement_char` are not single characters.\n\n    Example:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    \"\"\"\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"Both characters to replace and replacement should be single characters.\")\n    \n    # Use a list to collect the characters for efficiency\n    new_chars = list(original_string)\n    \n    # Replace the characters\n    for i in range(len(new_chars)):\n        if new_chars[i] == char_to_replace:\n            new_chars[i] = replacement_char\n    \n    # Join the list back into a string and return\n    return ''.join(new_chars)", "matching_cluster_idx": 2}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of 'old_char' in string 's' with 'new_char'.\n\n    Args:\n    s (str): The input string to process.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: A new string with all instances of 'old_char' replaced by 'new_char'.\n\n    Example:\n    >>> replace_char(\"polygon\", 'y', 'l')\n    'pollgon'\n    \"\"\"\n    # Convert string to list since strings are immutable in Python\n    chars = list(s)\n    \n    # Replace each character that matches old_char with new_char\n    for i in range(len(chars)):\n        if chars[i] == old_char:\n            chars[i] = new_char\n    \n    # Join the list back into a string\n    return ''.join(chars)", "matching_cluster_idx": 2}, {"solution": "def replace_char(s, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of `char_to_replace` with `replacement_char` in string `s`.\n    \n    Args:\n    s (str): The input string where characters are to be replaced.\n    char_to_replace (str): A single character that will be replaced in `s`.\n    replacement_char (str): A single character that will replace `char_to_replace`.\n    \n    Returns:\n    str: A new string with characters replaced.\n    \n    Raises:\n    ValueError: If `char_to_replace` or `replacement_char` are not single characters.\n    \"\"\"\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"Both char_to_replace and replacement_char must be single characters.\")\n    \n    return s.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 78.84228187919463, "dps_norm": 86.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    if not arr:  # If the array is empty, return 0 or handle accordingly\n        return 0\n    \n    # Find the max and min value in the list\n    # Python's built-in functions can do this efficiently\n    max_val = max(arr)\n    min_val = min(arr)\n    \n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest values in the given array.\n\n    Args:\n    arr (list): A list of numbers where the smallest and largest numbers are to be summed.\n\n    Returns:\n    int or float: The sum of the smallest and largest numbers in the array.\n\n    Raises:\n    ValueError: If the array has fewer than two elements.\n\n    Example:\n    >>> big_sum([1, 2, 3])\n    4\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"The array must contain at least two elements.\")\n    \n    # Finding the smallest and largest values\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Returning their sum\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n\n    Args:\n    arr (list): A list of numbers.\n\n    Returns:\n    int or float: The sum of the largest and smallest number in the array.\n\n    Raises:\n    ValueError: If the input array has fewer than 2 elements.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([-10, 5, 0, 15])\n    5\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"Array must have at least two elements.\")\n\n    # Find max and min using Python's built-in functions\n    max_val = max(arr)\n    min_val = min(arr)\n\n    # Return their sum\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in the given array.\n    \n    :param arr: List of numbers\n    :return: Integer or float sum of min and max value in arr\n    :raises ValueError: If the array is empty or contains non-numeric values\n    \n    Example:\n    >>> big_sum([1,2,3])\n    4\n    \"\"\"\n    # Check if array is empty or contains only one element\n    if len(arr) < 2:\n        raise ValueError(\"The array should contain at least two elements.\")\n    \n    # Attempt to find min and max; this will raise TypeError if non-numeric types are included\n    try:\n        min_val = min(arr)\n        max_val = max(arr)\n    except TypeError:\n        raise ValueError(\"All elements in the array must be numeric.\")\n    \n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n\n    Returns:\n    int or float: The sum of the maximum and minimum values in the list.\n\n    Raises:\n    ValueError: If the array is empty.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    \"\"\"\n    # Check if the array is not empty\n    if not arr:\n        raise ValueError(\"The array cannot be empty.\")\n\n    # Find the max and min values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n\n    # Sum the max and min values\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in the given array.\n    \n    Parameters:\n    arr (list): A list of numbers.\n    \n    Returns:\n    int or float: The sum of the smallest and largest numbers in the list.\n    \n    Raises:\n    ValueError: If the input list is empty or contains non-numeric values.\n    \n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([-1, 0, 10, 15])\n    14\n    \"\"\"\n    # Check if the array is empty\n    if not arr:\n        raise ValueError(\"The array must not be empty.\")\n    \n    # Check if all elements are numeric\n    if not all(isinstance(x, (int, float)) for x in arr):\n        raise ValueError(\"All elements must be numeric.\")\n\n    # Find min and max values using built-in functions for efficiency\n    smallest = min(arr)\n    largest = max(arr)\n\n    # Return the sum of these values\n    return smallest + largest", "matching_cluster_idx": 1}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n\n    Args:\n    arr (list): A list of numbers.\n\n    Returns:\n    int: The sum of the maximum and minimum values in the list.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([-1, 2, 100])\n    99\n    \"\"\"\n    # Check if the array is empty to avoid errors\n    if not arr:\n        return None\n    \n    # Find the maximum value in the array\n    max_val = max(arr)\n    \n    # Find the minimum value in the array\n    min_val = min(arr)\n    \n    # Return the sum of the largest and smallest value\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # Handle empty list case\n    # Use min() and max() to find smallest and largest values\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest value in the given array.\n    \n    Parameters:\n    arr (list): A list of numbers.\n    \n    Returns:\n    int or float: The sum of the largest and smallest number in the array.\n    \n    Raises:\n    ValueError: If the array is empty.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array cannot be empty.\")\n    \n    # Using max() and min() to find the largest and smallest elements\n    largest = max(arr)\n    smallest = min(arr)\n    \n    # Return the sum of the two\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest value in a given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n\n    Returns:\n    int or float: The sum of the largest and smallest number in arr.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([-1, 2, 100, -100])\n    0\n    \"\"\"\n    # Check if the array is empty to avoid errors\n    if not arr:\n        raise ValueError(\"The array must not be empty\")\n    \n    # Using built-in functions to find max and min in one pass through the list\n    largest = max(arr)\n    smallest = min(arr)\n    \n    # Return the sum of the largest and smallest numbers\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n\n    Returns:\n    int or float: The sum of the maximum and minimum values in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([10, -1, 5, 3])\n    9\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array cannot be empty.\")\n    \n    # Using min and max functions for clarity, though this is not the most efficient for very large lists\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in the given array.\n\n    Args:\n    arr (list): A list of numbers.\n\n    Returns:\n    int or float: The sum of the maximum and minimum values in the list.\n\n    Raises:\n    ValueError: If the array has fewer than two elements.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([5, 7, -2])\n    3\n    \"\"\"\n    # Check if array has at least 2 elements\n    if len(arr) < 2:\n        raise ValueError(\"The array should contain at least two elements.\")\n    \n    # Use min and max functions to find the smallest and largest numbers\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in the given array.\n    \n    Parameters:\n    arr (list): A list of numbers.\n    \n    Returns:\n    int or float: Sum of the largest and smallest number in the array.\n    \n    Raises:\n    ValueError: If the array has fewer than 2 elements.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([-1, 0, 1])\n    0\n    \"\"\"\n    # Check if the array has at least two elements\n    if len(arr) < 2:\n        raise ValueError(\"The array must contain at least two elements.\")\n    \n    # Using built-in functions to find max and min\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest values in a given array.\n    \n    This function assumes the array has at least one element.\n    If the array is empty, it will raise an IndexError.\n\n    Args:\n    arr (list): A list of numbers from which to find the sum of the max and min values.\n\n    Returns:\n    int or float: The sum of the maximum and minimum values in the array.\n\n    Raises:\n    ValueError: If the array has no numeric values.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([0, 0, 1, 10])\n    10\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must not be empty\")\n    \n    # Check if all elements can be compared for size\n    if not all(isinstance(x, (int, float)) for x in arr):\n        raise ValueError(\"All elements in the array must be numeric\")\n\n    # Calculate the sum of maximum and minimum value\n    return max(arr) + min(arr)", "matching_cluster_idx": 1}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest values in the given array.\n    \n    Args:\n    arr (list): A list of numbers.\n    \n    Returns:\n    int or float: The sum of the smallest and largest numbers in the list.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([-1, 0, 100])\n    99\n    \"\"\"\n    # Check if the list is empty\n    if not arr:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Find max and min in one pass through the list to optimize time complexity\n    max_val = min_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n        elif num < min_val:\n            min_val = num\n    \n    # Return the sum of the smallest and largest\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest values in the given array.\n\n    Args:\n    arr (list): A list of numbers.\n\n    Returns:\n    int or float: The sum of the smallest and largest number in the array.\n\n    Raises:\n    ValueError: If the array has less than 2 elements.\n\n    Example:\n    >>> big_sum([1, 2, 3])\n    4\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"The array must contain at least two elements.\")\n    \n    # Find the minimum and maximum in a single pass through the array\n    min_val, max_val = arr[0], arr[0]\n    for num in arr[1:]:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    \n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n\n    Args:\n    arr (list): An array of numbers.\n\n    Returns:\n    int or float: The sum of the largest and smallest number in the array.\n\n    Raises:\n    ValueError: If the array is empty or contains non-numeric values.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([-10, 5, 0, 20])\n    10\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array cannot be empty.\")\n    \n    # Filter out non-numeric values to avoid TypeError in min/max functions\n    numeric_arr = [item for item in arr if isinstance(item, (int, float))]\n    \n    if not numeric_arr:\n        raise ValueError(\"No numeric values found in the array.\")\n    \n    min_val = min(numeric_arr)\n    max_val = max(numeric_arr)\n    \n    return min_val + max_val", "matching_cluster_idx": 1}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n\n    Args:\n    arr (list): A list of numbers.\n\n    Returns:\n    int or float: The sum of the largest and smallest number in the array.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([-5, 0, 5, 10])\n    5\n    \"\"\"\n    # Check if the array has at least one element\n    if not arr:\n        raise ValueError(\"The array must not be empty.\")\n\n    # Find the minimum and maximum using built-in functions\n    minimum = min(arr)\n    maximum = max(arr)\n\n    # Return the sum of minimum and maximum\n    return minimum + maximum", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # Return 0 for an empty array to handle edge cases\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest values in the given array.\n    \n    Args:\n    arr (list): A list of numbers.\n    \n    Returns:\n    int or float: The sum of the maximum and minimum values in the array.\n    \n    Raises:\n    ValueError: If the array is empty.\n    \n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([-1, 0, 1])\n    0\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must not be empty.\")\n    \n    # Use built-in functions to find max and min\n    max_value = max(arr)\n    min_value = min(arr)\n    \n    # Return the sum of largest and smallest\n    return max_value + min_value", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        s (str): The string to convert.\n\n    Returns:\n        str: The lowercase version of the input string.\n\n    Examples:\n        >>> is_lower(\"InValid\")\n        'invalid'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    s (str): The input string to convert.\n\n    Returns:\n    str: The string converted to lower case.\n\n    Example:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    \"\"\"\n    # Convert the string to lower case using str.lower()\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    s (str): The string to convert.\n\n    Returns:\n    str: The string converted to lower case.\n\n    Examples:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    >>> is_lower(\"UPPERCASE\")\n    'uppercase'\n    >>> is_lower(\"AlReAdY lOwEr\")\n    'already lower'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    s (str): The string to be converted.\n\n    Returns:\n    str: The lowercase version of the input string.\n\n    Example:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n    \n    Args:\n    s (str): The input string to convert.\n    \n    Returns:\n    str: The lower case version of the input string.\n    \n    Example:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Parameters:\n    s (str): The input string to be converted to lower case.\n    \n    Returns:\n    str: A lower case version of the input string.\n    \n    Examples:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    \"\"\"\n    # Convert the string to lowercase using Python's built-in method\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lowercase.\n\n    Args:\n    s (str): The input string which needs to be converted.\n\n    Returns:\n    str: The lowercase version of the input string.\n\n    Example:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    This function takes any string and returns its lowercase version.\n\n    Args:\n    s (str): The input string which needs to be converted to lowercase.\n\n    Returns:\n    str: The lowercase version of the input string.\n\n    Example:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    This function takes a string input and returns its lowercase version.\n\n    Args:\n    s (str): The string to convert to lowercase.\n\n    Returns:\n    str: The lowercase version of the input string.\n\n    Examples:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    >>> is_lower(\"123UPPER\")\n    '123upper'\n    \"\"\"\n    # Convert the entire string to lowercase\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    This function takes a string and converts all its characters to lower case.\n\n    Parameters:\n    s (str): The input string to be converted to lower case.\n\n    Returns:\n    str: A new string where all characters are in lower case.\n\n    Example:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    s (str): The input string to be converted to lower case.\n\n    Returns:\n    str: The string converted to lower case.\n\n    Example:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    This function takes a string and returns it in lowercase. It is named 'is_lower'\n    due to the assertion context but functions as a lowercase converter.\n\n    Args:\n        s (str): The input string to be converted.\n\n    Returns:\n        str: The string in lowercase.\n\n    Examples:\n        >>> is_lower(\"InValid\")\n        'invalid'\n        >>> is_lower(\"UPPERCASE-LOWERCASE\")\n        'uppercase-lowercase'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    This function takes a string and converts all its characters to lowercase.\n\n    Args:\n    s (str): The input string to be converted.\n\n    Returns:\n    str: The lowercase version of the input string.\n\n    Examples:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    >>> is_lower(\"CaMeLcAsE\")\n    'camelcase'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n\n    This function takes a string, converts all characters to lower case,\n    and returns the resulting string.\n\n    Parameters:\n    s (str): The input string to be converted.\n\n    Returns:\n    str: The lowercase version of the input string.\n\n    Example:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string to be converted to lower case.\n\n    Returns:\n        str: The string in lower case.\n\n    Examples:\n        >>> is_lower(\"InValid\")\n        'invalid'\n        >>> is_lower(\"VALID\")\n        'valid'\n        >>> is_lower(\"MiXeD\")\n        'mixed'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lowercase.\n\n    Args:\n        s (str): The string to be converted to lowercase.\n\n    Returns:\n        str: A new string with all characters converted to lowercase.\n\n    Examples:\n        >>> is_lower(\"InValid\")\n        'invalid'\n        >>> is_lower(\"THIS IS A TEST\")\n        'this is a test'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    s (str): The string to be converted to lowercase.\n\n    Returns:\n    str: The lowercase version of the input string.\n\n    Example:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    \"\"\"\n    # Convert the string to lowercase using Python's built-in str.lower() method\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        s (str): The string to be converted.\n\n    Returns:\n        str: The string in lower case.\n\n    Example:\n        >>> is_lower(\"InValid\")\n        'invalid'\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    s (str): The input string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n\n    Example:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    \"\"\"\n    # Convert the string to lower case using Python's built-in string method\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    s (str): The input string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n\n    Example:\n    >>> is_lower(\"InValid\")\n    'invalid'\n    \"\"\"\n    # Convert the string to lower case\n    return s.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 80.35519125683061, "dps_norm": 80.45454545454545, "pass@1": 93.0, "profiled": [{"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a string.\n    \n    Args:\n    s (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings, where each string was between double quotes in the original input.\n\n    Examples:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    # Using regex to find all content between quotation marks\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s: str) -> list[str]:\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the given string.\n\n    This function uses a regular expression to find all quoted strings within\n    the provided text, ignoring quotes that are not properly paired.\n\n    Args:\n        s (str): The input string to extract quoted values from.\n\n    Returns:\n        list[str]: A list of strings that were between quotation marks.\n\n    Examples:\n        >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n        ['Python', 'PHP', 'Java']\n    \"\"\"\n    # Pattern explanation:\n    # - (?<!\\\\) : Negative lookbehind to ensure the quote isn't escaped\n    # - \" : Match an opening quote\n    # - (.*?) : Capture anything non-greedy, stopping before the next quote\n    # - \" : Match a closing quote\n    pattern = r'(?<!\\\\)\"([^\"]*)\"'\n    \n    # Find all matches of the pattern in the string\n    matches = re.findall(pattern, s)\n    \n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a given string.\n    \n    Args:\n    text (str): The string containing quoted values.\n    \n    Returns:\n    list: A list of strings, each string being the value inside a quote.\n    \n    Example:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    # Use regex to find all occurrences of text between quotation marks\n    # The pattern r'\"(.*?)\"' looks for anything in between double quotes, \n    # with .*? being non-greedy to match until the first closing quote.\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a given string.\n    \n    Args:\n    text (str): A string containing quoted values.\n    \n    Returns:\n    list: A list of strings where each string was within quotes in the original text.\n    \n    Examples:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    # Use regex to find all occurrences of text within quotes\n    matches = re.findall(r'\"([^\"]*)\"', text)\n    return matches", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    \"\"\"\n    Extract values enclosed in double quotes from the given string.\n\n    Args:\n    s (str): A string containing values in quotes.\n\n    Returns:\n    list: A list of strings where each string was enclosed in double quotes in the input.\n\n    Example:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    import re\n    # Find all strings between double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Regular expression to find all quoted strings\n    pattern = r'\"([^\"]*)\"'\n    # Use re.findall to extract all matches\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts string values enclosed in double quotes from the given input string.\n\n    Args:\n    input_string (str): A string potentially containing quoted values.\n\n    Returns:\n    list: A list of strings found between the quotation marks.\n\n    Examples:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    # Use regex to find all quoted strings\n    pattern = r'\"([^\"]*)\"'\n    # Find all matches; group(1) retrieves the content inside the quotes\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a given string.\n\n    Args:\n    input_string (str): A string containing quoted values.\n\n    Returns:\n    list: A list of strings where each string was originally inside double quotes.\n\n    Example:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    # Regular expression to find all text between double quotes\n    pattern = r'\"([^\"]*)\"'\n    # Use re.findall to get all matches\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values that are enclosed in double quotes from the given string.\n    \n    Args:\n    input_string (str): A string containing values enclosed in quotation marks.\n    \n    Returns:\n    list: A list of strings where each string was enclosed by quotes in the input.\n    \n    Examples:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    # Use regex to find all quoted substrings\n    # The pattern looks for anything between double quotes, ignoring commas within quotes\n    quoted_values = re.findall(r'\"([^\"]*)\"', input_string)\n    return quoted_values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from the given string.\n    \n    This function uses a regular expression to find all sequences of characters \n    that are enclosed within double quotes. It will match any content within \n    quotes, ignoring quotes within quotes, which might not be accounted for \n    in simple parsing.\n\n    Args:\n    string (str): The string from which to extract values.\n\n    Returns:\n    list: A list of strings where each string was originally between double quotes.\n\n    Example:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    # The regex pattern matches anything (.*?) between double quotes, \n    # being non-greedy to avoid matching too much\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts all values enclosed in quotation marks from a given string.\n\n    This function looks for text enclosed by double quotes and returns\n    them as a list, assuming no nested quotes are present within the string.\n\n    Args:\n    input_string (str): A string containing quoted values.\n\n    Returns:\n    list: A list of strings where each string was inside quotes in the input.\n\n    Example:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    # Use regular expression to find all substrings between double quotes\n    # The pattern captures anything that's not a quote or newline between quotes\n    pattern = r'\"([^\"\\n]*)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 7}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed in quotation marks from a string.\n    \n    Args:\n    s (str): A string containing quoted values.\n    \n    Returns:\n    list: A list of strings where each string is a value that was between quotes in the input string.\n    \n    Examples:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    # Use regex to find all patterns that start and end with quotes, potentially with commas or spaces in between\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regex to find all quoted strings in the input\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extract values enclosed in double quotes from the given text.\n\n    This function uses regular expressions to find all substrings \n    that are enclosed by double quotes.\n\n    Args:\n    text (str): A string potentially containing quoted values.\n\n    Returns:\n    list: A list of strings where each string is a value found \n          between two double quotes.\n\n    Example:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    # The regex pattern '\".*?\"' looks for any characters (non-greedily) \n    # between double quotes. The brackets around it in r'(\".*?\")' \n    # allow us to extract the contents without the quotes.\n    pattern = r'(\".*?\")'\n    \n    # Find all matches and strip the quotes from each match\n    matches = re.findall(pattern, text)\n    return [match.strip('\"') for match in matches]", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values that are enclosed between double quotation marks from a given string.\n\n    This function uses regex to find all substrings that are enclosed by double quotes\n    and returns them as a list, excluding the quotes themselves.\n\n    Args:\n    input_string (str): The input string from which to extract quoted values.\n\n    Returns:\n    list: A list of strings representing the quoted values.\n\n    Raises:\n    ValueError: If the input is not a string.\n\n    Example:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise ValueError(\"Input must be a string\")\n    \n    # Regular expression to find everything inside quotation marks\n    pattern = r'\"(.*?)\"'\n    \n    # Use re.findall to find all non-overlapping matches of pattern in string\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    \"\"\"\n    Extracts values enclosed in quotation marks from a given string.\n    \n    Args:\n    s (str): The input string containing values in quotes.\n    \n    Returns:\n    list: A list of strings where each string was between quotation marks in the input.\n    \n    Example:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    import re\n    # This regex pattern looks for anything between double quotes, \n    # excluding the quotes themselves\n    pattern = re.compile(r'\"([^\"]*)\"')\n    # Find all matches and return them as a list\n    return pattern.findall(s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed in double quotes from a given string.\n    \n    Args:\n    s (str): The string containing quoted values.\n    \n    Returns:\n    list: A list of strings that were between quotes.\n    \n    Example:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    # Use regex to find all substrings between double quotes\n    # The pattern looks for \" followed by any number of non-quote characters then another \"\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extract values between quotation marks from a string.\n\n    This function uses regex to find all occurrences of text enclosed in double quotes.\n    \n    Args:\n    string (str): A string containing quoted values.\n\n    Returns:\n    list: A list of strings that were between quotation marks.\n\n    Examples:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    # The regex pattern looks for text between double quotes\n    pattern = r'\"([^\"]*)\"'\n    \n    # Find all matches in the string\n    matches = re.findall(pattern, string)\n    \n    # Return the list of matches found\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from the given string.\n\n    This function uses a regular expression to find all occurrences of text\n    that is between double quotes in the input string.\n\n    Args:\n        input_string (str): The string from which to extract quoted values.\n\n    Returns:\n        list: A list of strings found within double quotes.\n\n    Example:\n        >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n        ['Python', 'PHP', 'Java']\n    \"\"\"\n    # Use regular expression to find all quoted strings\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, input_string)\n    \n    # Return the matches as a list\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from the input string.\n    \n    Args:\n    input_string (str): A string containing values inside double quotes.\n    \n    Returns:\n    list: A list of strings where each string is a value from between the quotes.\n    \n    Example:\n    >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n    ['Python', 'PHP', 'Java']\n    \"\"\"\n    # Use regex to find all occurrences of quoted strings\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/578": {"dps": 77.4126984126984, "dps_norm": 68.18181818181819, "pass@1": 98.0, "profiled": [{"solution": "def interleave_lists(*args):\n    if not all(isinstance(lst, list) for lst in args):\n        raise ValueError(\"All arguments must be lists\")\n    if not all(len(lst) == len(args[0]) for lst in args):\n        raise ValueError(\"All lists must have the same length\")\n    \n    result = []\n    for i in range(len(args[0])):\n        for lst in args:\n            result.append(lst[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Parameters:\n    list1, list2, list3 (list): Lists of numbers or any elements that can be interleaved.\n    \n    Returns:\n    list: A new list with elements from all input lists interleaved.\n    \n    Raises:\n    ValueError: If the lists are not of the same length.\n    \n    Example:\n    >>> interleave_lists([1, 2, 3], [10, 20, 30], [100, 200, 300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    \"\"\"\n    # Check if all lists are of the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    # Using zip to interleave the lists\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of equal length into a single flat list.\n    \n    Args:\n    list1 (list): The first list to interleave.\n    list2 (list): The second list to interleave.\n    list3 (list): The third list to interleave.\n    \n    Returns:\n    list: A new list containing elements from list1, list2, and list3 interleaved.\n    \n    Raises:\n    ValueError: If the lists are not of the same length.\n    \n    Example:\n    >>> interleave_lists([1,2,3],[10,20,30],[100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    # Use zip to pair up elements from all three lists\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of equal length into a single flat list.\n\n    Args:\n    list1, list2, list3 (list): The lists to be interleaved. Assumes all lists are of the same length.\n\n    Returns:\n    list: A new list with elements from list1, list2, and list3 interleaved.\n\n    Example:\n    >>> interleave_lists([1,2,3], [10,20,30], [100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    \"\"\"\n    # Ensure that all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length\")\n\n    # Use zip to pair up the elements from each list and flatten with a list comprehension\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must be of the same length\")\n\n    # Use zip to pair elements from all three lists, then flatten the result\n    interleaved = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n    list1, list2, list3 (list): Lists to be interleaved. All should have the same length.\n\n    Returns:\n    list: A new list with elements from list1, list2, and list3 interleaved.\n\n    Raises:\n    ValueError: If the lists do not have the same length.\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length\")\n\n    # Use zip to combine the lists, then flatten them with a list comprehension\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*lists):\n    \"\"\"\n    Interleave multiple lists of the same length into one flat list.\n\n    Parameters:\n    *lists : tuple of list\n        Lists to be interleaved. Each list must have the same length.\n\n    Returns:\n    list: A new list with elements from each input list interleaved.\n\n    Raises:\n    ValueError: If lists have different lengths or if no lists are provided.\n\n    Example:\n    >>> interleave_lists([1,2,3], [10,20,30], [100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    \"\"\"\n    # Check if there are any lists to interleave\n    if not lists:\n        raise ValueError(\"No lists provided to interleave.\")\n    \n    # Get the length of the first list to check consistency\n    reference_length = len(lists[0])\n    \n    # Check if all lists have the same length\n    if not all(len(lst) == reference_length for lst in lists):\n        raise ValueError(\"All lists must have the same length.\")\n\n    # Using list comprehension to interleave the lists\n    return [item for items in zip(*lists) for item in items]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*args):\n    \"\"\"\n    Interleaves multiple lists into a single flat list.\n    \n    This function takes any number of lists of equal length and interleaves their elements.\n    \n    Parameters:\n    *args : List arguments to interleave\n\n    Returns:\n    list: A new list where elements from input lists are interleaved in order.\n\n    Raises:\n    ValueError: If the lists do not have the same length.\n    \"\"\"\n    if len(set(len(arg) for arg in args)) != 1:\n        raise ValueError(\"All lists must have the same length.\")\n    \n    # Determine the length of the lists\n    list_length = len(args[0])\n    \n    # Generate the interleaved list\n    result = [args[i][j] for j in range(list_length) for i in range(len(args))]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of equal length into a single flat list.\n\n    Args:\n    list1 (list): The first list to interleave.\n    list2 (list): The second list to interleave.\n    list3 (list): The third list to interleave.\n\n    Returns:\n    list: A new list where elements from list1, list2, and list3 are interleaved.\n\n    Raises:\n    ValueError: If lists are not of equal length.\n\n    Example:\n    >>> interleave_lists([1,2,3], [10,20,30], [100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must have the same length.\")\n\n    # Interleave the lists\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n    list1 (list): First list of elements.\n    list2 (list): Second list of elements.\n    list3 (list): Third list of elements.\n\n    Returns:\n    list: A single list with elements from list1, list2, and list3 interleaved.\n\n    Example:\n    >>> interleave_lists([1,2,3],[10,20,30],[100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    \"\"\"\n    # Use zip to group corresponding elements and itertools.chain to flatten\n    from itertools import chain\n    return list(chain.from_iterable(zip(list1, list2, list3)))", "matching_cluster_idx": 8}, {"solution": "def interleave_lists(*lists):\n    \"\"\"\n    Interleave three lists of the same length into one flat list.\n\n    Args:\n    *lists: Variable length argument for three lists.\n\n    Returns:\n    list: A new list where elements from the input lists are interleaved.\n\n    Example:\n    >>> interleave_lists([1,2,3], [10,20,30], [100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n\n    Raises:\n    ValueError: If not exactly three lists are provided or if they are not of equal length.\n    \"\"\"\n    if len(lists) != 3:\n        raise ValueError(\"Exactly three lists must be provided.\")\n\n    # Check if all lists have the same length\n    if not all(len(lst) == len(lists[0]) for lst in lists[1:]):\n        raise ValueError(\"All lists must have the same length.\")\n\n    # Interleave the lists\n    result = []\n    for items in zip(*lists):\n        result.extend(items)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def interleave_lists(*lists):\n    \"\"\"\n    Interleaves multiple lists into a single flat list.\n    \n    Args:\n    *lists: Variable length argument list of lists to interleave. Assumes all lists have the same length.\n    \n    Returns:\n    list: A new list with elements from each input list interleaved in order.\n    \n    Raises:\n    ValueError: If not all lists have the same length or if no lists are provided.\n    \n    Examples:\n    >>> interleave_lists([1,2,3],[10,20,30],[100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    \"\"\"\n    # Check if at least one list is provided\n    if not lists:\n        raise ValueError(\"At least one list must be provided\")\n    \n    # Verify that all lists have the same length\n    length = len(lists[0])\n    if not all(len(lst) == length for lst in lists):\n        raise ValueError(\"All lists must have the same length\")\n    \n    # Use zip to interleave elements from all lists\n    return [item for sublist in zip(*lists) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    This function takes three lists and combines them by taking one element\n    from each list in turn until all elements are used.\n\n    Args:\n    list1 (list): First list to interleave.\n    list2 (list): Second list to interleave.\n    list3 (list): Third list to interleave.\n\n    Returns:\n    list: A new list with elements interleaved from the input lists.\n\n    Raises:\n    ValueError: If the input lists do not all have the same length.\n\n    Example:\n    >>> interleave_lists([1,2,3], [10,20,30], [100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must have the same length\")\n\n    # Use zip to pair up elements from all three lists and then flatten the result\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of equal length into one flat list.\n\n    Args:\n    list1 (list): First list to interleave.\n    list2 (list): Second list to interleave.\n    list3 (list): Third list to interleave.\n\n    Returns:\n    list: A new list where elements from all input lists are interleaved.\n\n    Raises:\n    ValueError: If the lists provided are not of the same length.\n    \"\"\"\n    # Check if all lists have the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must have the same length\")\n\n    # Use list comprehension with zip to interleave the lists\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single list.\n\n    Args:\n    list1 (list): The first list of elements.\n    list2 (list): The second list of elements.\n    list3 (list): The third list of elements.\n\n    Returns:\n    list: A single list containing interleaved elements from list1, list2, and list3.\n\n    Raises:\n    ValueError: If the lists do not have the same length.\n\n    Example:\n    >>> interleave_lists([1,2,3], [10,20,30], [100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must have the same length\")\n\n    # Use zip to interleave the lists\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n    list1 (list): First list to interleave.\n    list2 (list): Second list to interleave.\n    list3 (list): Third list to interleave.\n\n    Returns:\n    list: A new list where elements from list1, list2, and list3 are interleaved.\n\n    Raises:\n    ValueError: If the lists do not have the same length.\n\n    Example:\n    >>> interleave_lists([1,2,3],[10,20,30],[100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length\")\n\n    # Use zip to interleave lists and then flatten the result\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*args):\n    \"\"\"\n    Interleave multiple lists of the same length into a single flat list.\n\n    This function takes any number of lists as arguments, provided they are all of equal length.\n    It then interleaves their elements in order.\n\n    Parameters:\n    *args : Variable length argument list of lists\n        Each list must be of the same length.\n\n    Returns:\n    list: A new list containing all elements from the input lists interleaved.\n\n    Raises:\n    ValueError: If the lists provided are not all the same length.\n\n    Example:\n    >>> interleave_lists([1,2,3], [10,20,30], [100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    \"\"\"\n    if not all(len(lst) == len(args[0]) for lst in args):\n        raise ValueError(\"All lists must have the same length\")\n\n    result = []\n    for i in range(len(args[0])):\n        for lst in args:\n            result.append(lst[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(*lists):\n    \"\"\"\n    Interleaves multiple lists of the same length into a single flat list.\n\n    This function takes any number of lists and interleaves their elements in order.\n    If the lists are not of the same length, it will stop at the end of the shortest list.\n\n    Args:\n    *lists (tuple): Variable number of lists to be interleaved.\n\n    Returns:\n    list: A new list containing interleaved elements from input lists.\n\n    Examples:\n    >>> interleave_lists([1,2,3], [10,20,30], [100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    >>> interleave_lists([1], [2], [3])\n    [1, 2, 3]\n    \"\"\"\n    # Use the length of the shortest list to avoid IndexError\n    min_length = min(len(lst) for lst in lists)\n    \n    # Create the interleaved list using a list comprehension\n    return [item for i in range(min_length) for item in [lst[i] for lst in lists]]", "matching_cluster_idx": 4}, {"solution": "def interleave_lists(*lists):\n    \"\"\"\n    Interleave multiple lists of the same length into a single flat list.\n    \n    Args:\n    *lists: Variable length argument list of lists to interleave.\n\n    Returns:\n    list: A new list where elements from each input list are interleaved.\n\n    Raises:\n    ValueError: If lists do not all have the same length.\n\n    Example:\n    >>> interleave_lists([1,2,3], [10,20,30], [100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    \"\"\"\n    # Check if all lists are of the same length\n    if len(set(map(len, lists))) != 1:\n        raise ValueError(\"All lists must have the same length\")\n    \n    # Unpack each list to get the i-th element from all lists\n    return [elem for i in range(len(lists[0])) for elem in (lst[i] for lst in lists)]", "matching_cluster_idx": 3}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of equal length into a single flat list.\n\n    Args:\n    list1 (list): First list to interleave.\n    list2 (list): Second list to interleave.\n    list3 (list): Third list to interleave.\n\n    Returns:\n    list: A single list where elements from list1, list2, and list3 are interleaved.\n\n    Raises:\n    ValueError: If the lists do not have the same length.\n\n    Example:\n    >>> interleave_lists([1,2,3], [10,20,30], [100,200,300])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300]\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must be of equal length\")\n\n    # Use list comprehension to interleave lists\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 44.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the given list at the nth element and moves the first part to the end.\n    \n    Parameters:\n    arr (list): The list to be split.\n    n (int): The position to split at (0-indexed).\n    \n    Returns:\n    list: A new list with the first part moved to the end.\n    \n    Examples:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    # If n is greater than or equal to the length of the array,\n    # we can just return the original array\n    if n >= len(arr):\n        return arr\n    \n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part appended to the end\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits a list at the nth element and appends the first part to the end.\n    \n    Args:\n    lst (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: A new list where elements before index n are moved to the end.\n    \n    Examples:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    # If n is greater than the list length, no operation is needed\n    if n >= len(lst):\n        return lst\n    \n    # Split the list into two parts\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split a list at the nth element and append the first part to the end of the list.\n\n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: A new list where elements up to index n are moved to the end.\n\n    Example:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    # Check if n is within the list bounds\n    if n > len(arr):\n        raise ValueError(\"The split index is out of range of the list.\")\n    \n    # Split the list and concatenate in reverse order\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split the given list at the nth element and add the first part to the end.\n\n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: A new list with the split and re-arranged elements.\n\n    Examples:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    >>> split_Arr([1, 2, 3, 4], 0)\n    [1, 2, 3, 4]\n    \"\"\"\n    # Check if n is within the bounds of the list\n    if n < 0 or n >= len(arr):\n        return arr[:]  # Return a copy of the list if n is out of range\n    \n    # Slice the array at n and rearrange\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split the given list at the nth element and move the first part to the end.\n\n    Parameters:\n    arr (list): The input list to be split and rearranged.\n    n (int): The position at which to split the list.\n\n    Returns:\n    list: A new list where the first n elements of arr are moved to the end.\n\n    Example:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    # If n is out of bounds, return the original list or handle error\n    if n < 0 or n > len(arr):\n        return arr  # or raise ValueError(\"n out of range for the given list size\")\n\n    # Slice the list at position n, move the first part to the end\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and moves the first part to the end.\n\n    Args:\n    lst (list): The input list to be split.\n    n (int): The index at which to split the list (0-indexed).\n\n    Returns:\n    list: A new list with the part before n at the end.\n\n    Examples:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    # Check if n is within the bounds of the list\n    if n >= len(lst):\n        return lst  # If n is out of bounds, return the list unchanged\n\n    # Split the list into two parts\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split the array at the nth element and add the first part to the end.\n\n    Args:\n    arr (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: A new list with the first part moved to the end.\n\n    Examples:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    if n > len(arr) or n < 0:\n        raise ValueError(\"The split index n must be within the list bounds.\")\n    \n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list `arr` at the nth element and moves the first part to the end.\n\n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list. \n\n    Returns:\n    list: A new list with the first part of `arr` moved to the end.\n\n    Example:\n    >>> split_Arr([12, 10, 5, 6, 52, 36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    # Check if n is within the bounds of the list\n    if n < 0 or n >= len(arr):\n        return arr  # Return the array as is if n is out of bounds\n    \n    # Split the list\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n    \n    Args:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: A new list where elements before index n are moved to the end.\n    \n    Example:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    # Check if n is within the bounds of the array\n    if n >= len(arr) or n < 0:\n        return arr  # Return the original list if n is out of bounds\n    \n    # Slice the list at position n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n\n    Parameters:\n    lst (list): The list to split and rearrange.\n    n (int): The index to split at. If n is greater than or equal to the length of the list, \n             the list will be returned unchanged.\n\n    Returns:\n    list: A new list where the first n elements are moved to the end.\n\n    Examples:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    >>> split_Arr([1, 2, 3], 0)\n    [1, 2, 3]\n    \"\"\"\n    # If n is larger than or equal to the list length, return the list as is\n    if n >= len(lst):\n        return lst\n    \n    # Split the list at n, the [:n] part becomes the end\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Args:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: A new list with the first n elements moved to the end.\n\n    Raises:\n    ValueError: If n is less than 0 or greater than the list length.\n\n    Examples:\n    >>> split_Arr([12, 10, 5, 6, 52, 36], 2)\n    [5, 6, 52, 36, 12, 10]\n    >>> split_Arr([1, 2, 3], 3)\n    [1, 2, 3]\n    \"\"\"\n    if n < 0 or n > len(arr):\n        raise ValueError(\"The split index n must be between 0 and the length of the array inclusive.\")\n    \n    # If n equals the length of the list, no rotation is needed\n    if n == len(arr):\n        return arr.copy()\n\n    # Split the list and concatenate the two parts\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the given list at the nth element and moves the first part to the end.\n    \n    :param arr: List to be split and rearranged\n    :param n: Index at which to split the list (0-indexed)\n    :return: A new list where elements before index n are appended at the end\n    \n    Examples:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    if n <= 0:\n        return arr[:]  # Return a copy of the original list if n is 0 or negative\n    \n    # Split the list into two parts and concatenate them\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the array at the nth element and appends the first part to the end.\n\n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: A new list where the part from index 0 to n-1 is moved to the end.\n\n    Raises:\n    IndexError: If n is out of range for the given list.\n\n    Example:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    # Check if n is within the valid range\n    if n > len(arr) or n < 0:\n        raise IndexError(\"Index out of range\")\n\n    # Split the list and rearrange\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the given array at the nth element and moves the first part to the end.\n    \n    Args:\n    arr (list): The list to be split.\n    n (int): The position to split at. If n is greater than or equal to the length of arr or negative, \n             it will be adjusted to len(arr) % n to ensure it works within bounds.\n    \n    Returns:\n    list: A new list with the first part appended at the end.\n    \"\"\"\n    # Adjust n if it's out of bounds\n    n = n % len(arr) if n else 0  # If n is 0 or equal to length, treat as no split needed\n    \n    # If n is at the end or beginning, return the array as is\n    if n == 0 or n == len(arr):\n        return arr\n    \n    # Split the array\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and moves the first part to the end.\n\n    Args:\n    lst (list): The input list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: A new list with elements before index n moved to the end.\n\n    Example:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    # Ensure n is within the list bounds\n    n = min(n, len(lst))\n    \n    # Use list slicing to perform the split and re-arrangement\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the given list at the nth element and appends the first part to the end.\n\n    Args:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: A new list with the first part moved to the end.\n\n    Examples:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    # If n is out of range or at the end, return the original array\n    if n < 0 or n >= len(arr):\n        return arr\n    # Split the array at index n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the given list at the nth element and moves the first part to the end.\n    \n    Args:\n    arr (list): The list to be split and rearranged.\n    n (int): The index at which to split the list. Note that the element at index n will be included in the second part.\n    \n    Returns:\n    list: A new list where the elements from index 0 to n-1 are moved to the end.\n\n    Examples:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    # If n is greater than or equal to the length of the array, \n    # or if n is less than or equal to 0, return the array as is\n    if n <= 0 or n >= len(arr):\n        return arr\n    \n    # Split the list and concatenate the parts\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split the list at the nth element and move the first part to the end.\n\n    Args:\n    arr (list): The list to be split and rearranged.\n    n (int): The index where the list should be split. If n is 0 or greater than \n             the length of the list, it will be adjusted to wrap around.\n\n    Returns:\n    list: A new list with the first n elements moved to the end.\n\n    Examples:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    >>> split_Arr([1, 2, 3], 4)\n    [1, 2, 3]\n    \"\"\"\n    # Handle negative index or index out of range\n    n = n % len(arr) if arr else 0\n    \n    # Split the array and concatenate the parts in reverse order\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Split a list at the nth element and append the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: A new list with the first 'n' elements moved to the end.\n\n    Examples:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    # Check if n is within the bounds of the list\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the range of the list length\")\n    \n    # If n is equal to list length or 0, return list as is or empty list respectively\n    if n == len(lst) or n == 0:\n        return lst\n    \n    # Slice the list and rearrange\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and moves the first part to the end.\n\n    Args:\n    arr (list): The input list to be split.\n    n (int): The position to split the list.\n\n    Returns:\n    list: A new list with the elements before n moved to the end.\n\n    Examples:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr[:]  # Return a copy of the original list if n is out of bounds\n    \n    # Slice the list into two parts and concatenate them\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    lst (list): The input list to be converted.\n\n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n\n    Examples:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    # Use tuple constructor to convert list to tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    # Directly convert the list to a tuple\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a given list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted into a tuple.\n\n    Returns:\n    tuple: A tuple containing the elements from the input list.\n\n    Examples:\n    >>> assert list_tuple([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    # Use the built-in tuple() function to convert the list to a tuple\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    This function takes a list as input and returns a tuple containing the same elements.\n    \n    Args:\n    lst (list): The list to be converted into a tuple.\n\n    Returns:\n    tuple: A tuple with the elements from lst.\n\n    Example:\n    >>> list_tuple([1, 2, 3])\n    (1, 2, 3)\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    This function takes a list as input and returns a tuple with the same elements.\n\n    Args:\n    input_list (list): The list to be converted into a tuple.\n\n    Returns:\n    tuple: A tuple containing all elements from the input list.\n\n    Example:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    lst (list): The list to be converted into a tuple.\n\n    Returns:\n    tuple: A tuple containing the elements of the input list in the same order.\n\n    Examples:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a given list to a tuple.\n\n    Args:\n    lst (list): The list to be converted.\n\n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n\n    Example:\n    >>> list_tuple([1, 2, 3])\n    (1, 2, 3)\n    \"\"\"\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a given list to a tuple.\n    \n    Parameters:\n    lst (list): The list to be converted.\n    \n    Returns:\n    tuple: A tuple containing all elements of the input list.\n    \n    Example:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    This function takes a list as input and returns a tuple containing\n    the same elements in the same order.\n\n    Args:\n    lst (list): The input list to be converted.\n\n    Returns:\n    tuple: A tuple with the elements of the input list.\n\n    Examples:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Args:\n    input_list (list): The list to be converted.\n    \n    Returns:\n    tuple: A tuple containing all elements of the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a given list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: A tuple containing the elements of the input list.\n\n    Example:\n    >>> assert list_tuple([5, 10, 7, 4, 15, 3])==(5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a given list to a tuple.\n\n    Args:\n    input_list (list): A list of any hashable items to be converted.\n\n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n\n    Examples:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: A tuple representation of the input list.\n\n    Example:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    # Simply use the built-in tuple function to convert list to tuple\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    This function takes a list as an argument and returns a tuple\n    with the same elements in the same order.\n\n    Args:\n    lst (list): The input list to be converted.\n\n    Returns:\n    tuple: A tuple containing the elements of the input list.\n\n    Examples:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    # Directly convert list to tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    This function takes any list as input and returns a tuple \n    containing all elements from the list in the same order.\n\n    Parameters:\n    input_list (list): The list to convert into a tuple.\n\n    Returns:\n    tuple: A tuple with elements in the same order as the input list.\n\n    Examples:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    # Directly convert the list to tuple using the tuple constructor\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a given list to a tuple.\n\n    This function takes a list of any type of elements and returns \n    a tuple containing those elements in the same order.\n\n    Parameters:\n    lst (list): The input list to be converted.\n\n    Returns:\n    tuple: A tuple containing the elements of the list.\n\n    Examples:\n    >>> list_tuple([5, 10, 7])\n    (5, 10, 7)\n    \"\"\"\n    # Using tuple constructor to convert list to tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a given list to a tuple.\n\n    Args:\n    lst (list): The list to be converted.\n\n    Returns:\n    tuple: A tuple containing all elements from the input list.\n\n    Examples:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a given list to a tuple.\n\n    Args:\n    lst (list): The list to be converted into a tuple.\n\n    Returns:\n    tuple: A tuple containing all elements from the input list.\n\n    Example:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    # Directly convert the list to tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    This function takes any list and returns its elements in a tuple.\n\n    Args:\n    lst (list): The list to be converted to a tuple.\n\n    Returns:\n    tuple: A tuple containing all elements from the input list.\n\n    Examples:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: A tuple containing all elements from the input list in the same order.\n\n    Example:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    # Convert list to tuple using the tuple constructor\n    return tuple(input_list)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 84.19724770642202, "dps_norm": 90.83333333333333, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(numbers):\n    \"\"\"\n    Find the difference between the largest and smallest value in the given list.\n\n    Args:\n    numbers (list of int): A list of integers.\n\n    Returns:\n    int: The difference between the max and min values in the list.\n\n    Raises:\n    ValueError: If the list has fewer than 2 elements.\n\n    Example:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers for comparison.\")\n    \n    # Use built-in functions to find the maximum and minimum\n    max_val = max(numbers)\n    min_val = min(numbers)\n    \n    # Return the difference\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in the list.\n\n    Args:\n    numbers (list of int or float): A list containing numbers.\n\n    Returns:\n    int or float: The difference between max and min values in the list.\n\n    Raises:\n    ValueError: If the list has fewer than two elements or if the list contains no numeric types.\n\n    Example:\n    >>> big_diff([1,2,3,4])\n    3\n    \"\"\"\n    # Check if the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Filter out non-numeric values if any, or raise an error if all are non-numeric\n    numeric_values = [num for num in numbers if isinstance(num, (int, float))]\n    if not numeric_values:\n        raise ValueError(\"The list must contain numeric values.\")\n\n    return max(numeric_values) - min(numeric_values)", "matching_cluster_idx": 1}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Find the difference between the largest and smallest value in the given list.\n\n    Args:\n    numbers (list of int or float): A list containing numerical values.\n\n    Returns:\n    int or float: The difference between the maximum and minimum values in the list.\n\n    Raises:\n    ValueError: If the list is empty or contains non-numeric values.\n\n    Example:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Check for non-numeric values\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise ValueError(\"All elements must be numbers.\")\n    \n    # Find the maximum and minimum values\n    max_num = max(numbers)\n    min_num = min(numbers)\n    \n    # Return the difference\n    return max_num - min_num", "matching_cluster_idx": 2}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Find the difference between the largest and smallest values in a given list.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The difference between the max and min values in the list.\n    \n    Raises:\n    ValueError: If the list is empty or does not contain numbers.\n\n    Example:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list cannot be empty.\")\n\n    # Check if all elements are numbers\n    if not all(isinstance(item, (int, float)) for item in lst):\n        raise ValueError(\"All list elements must be numbers.\")\n\n    return max(lst) - min(lst)", "matching_cluster_idx": 2}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int or float: The difference between the largest and smallest number in the list.\n                   Returns 0 if the list is empty or contains non-numeric values.\n\n    Example:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    >>> big_diff([10, 5, -3, 100, 40])\n    103\n    >>> big_diff([])\n    0\n    \"\"\"\n    try:\n        # Check if the list is empty or has only one element\n        if len(numbers) <= 1:\n            return 0\n        \n        # Convert to float for accuracy with decimal numbers\n        max_val = float(max(numbers))\n        min_val = float(min(numbers))\n        \n        # Return the difference between the max and min values\n        return max_val - min_val\n    except (ValueError, TypeError):  # Catches non-numeric types or empty list\n        return 0", "matching_cluster_idx": 4}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n\n    Parameters:\n    numbers (list of int): A list of integer numbers.\n\n    Returns:\n    int: The difference between the maximum and minimum values in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    >>> big_diff([10])\n    0\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"The list must not be empty.\")\n\n    # Use built-in functions to find min and max\n    smallest = min(numbers)\n    largest = max(numbers)\n\n    # Calculate the difference\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    Args:\n    numbers (list of int): A list containing numbers.\n\n    Returns:\n    int: The difference between the maximum and minimum values in the list.\n         If the list has less than two elements, it returns 0.\n\n    Example:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    >>> big_diff([5, 5, 5])\n    0\n    >>> big_diff([])\n    0\n    \"\"\"\n    if len(numbers) < 2:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0  # If the list is empty, return 0 to avoid errors\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a list.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int or float: The difference between the maximum and minimum values in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    >>> big_diff([1])\n    0\n    >>> big_diff([5, 10])\n    5\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Find the max and min of the list\n    largest = max(numbers)\n    smallest = min(numbers)\n    \n    # Return the difference\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest numbers in a list.\n    \n    :param numbers: List of integers\n    :return: Integer difference between max and min or 0 if list is empty or has only one element\n    :raises ValueError: If the list contains non-numeric types\n    \"\"\"\n    # Check if the list is empty or contains only one element\n    if len(numbers) <= 1:\n        return 0\n    \n    # Try to find max and min, this will also verify if all elements are numbers\n    try:\n        max_value = max(numbers)\n        min_value = min(numbers)\n    except TypeError:\n        raise ValueError(\"The list should only contain numbers.\")\n    \n    # Return the difference\n    return max_value - min_value", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    Parameters:\n    numbers (list of int or float): A list of numbers.\n\n    Returns:\n    int or float: The difference between the maximum and minimum values in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Find the maximum value in the list\n    max_val = max(numbers)\n    \n    # Find the minimum value in the list\n    min_val = min(numbers)\n    \n    # Return the difference\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Find the difference between the largest and smallest value in the given list.\n    \n    Args:\n    numbers (list of int): A list of integers where we find the max and min.\n    \n    Returns:\n    int: The difference between the max and min values in the list.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \n    Examples:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    >>> big_diff([10, 15, 3, 8])\n    12\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n\n    # Find the maximum and minimum values in the list\n    max_val = max(numbers)\n    min_val = min(numbers)\n    \n    # Return the difference\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in the list.\n    \n    :param nums: List of integers\n    :return: Integer representing the difference between max and min values\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Find the difference between the largest and smallest value in the given list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The difference between the maximum and minimum values. If the list is empty, returns 0.\n\n    Raises:\n    TypeError: If the list contains elements that cannot be compared (e.g., different types).\n\n    Examples:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    >>> big_diff([10])\n    0\n    >>> big_diff([])\n    0\n    \"\"\"\n    # Check if the list is empty\n    if not lst:\n        return 0\n    \n    try:\n        # Using built-in functions for efficiency\n        return max(lst) - min(lst)\n    except TypeError:\n        # If elements cannot be compared, raise a more descriptive error\n        raise TypeError(\"All elements in the list must be of comparable types.\")", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n\n    Args:\n    numbers (list of int/float): A list of numbers.\n\n    Returns:\n    int/float: The difference between the largest and smallest number. \n               Returns 0 if the list is empty or has less than two elements.\n\n    Examples:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    >>> big_diff([5])\n    0\n    >>> big_diff([])\n    0\n    \"\"\"\n    if len(numbers) < 2:\n        return 0\n    \n    # Find the maximum and minimum values in the list\n    max_value = max(numbers)\n    min_value = min(numbers)\n\n    # Calculate and return the difference\n    return max_value - min_value", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a list.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int or float: The difference between the maximum and minimum values in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    >>> big_diff([4, 1, 9, 3])\n    8\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Finds the difference between the largest and smallest value in a given list.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The difference between the maximum and minimum values in the list.\n         Returns 0 if the list has less than 2 elements.\n\n    Raises:\n    TypeError: If the list contains non-numeric elements.\n\n    Example:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    \"\"\"\n    # Check if the list has less than 2 elements\n    if len(lst) < 2:\n        return 0\n    \n    # Try to find the max and min, handling potential TypeError\n    try:\n        return max(lst) - min(lst)\n    except TypeError:\n        raise TypeError(\"The list contains non-numeric elements.\")", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Find the difference between the largest and smallest values in a given list.\n\n    Args:\n    numbers (list of int): A list of integers.\n\n    Returns:\n    int: The difference between the maximum and minimum numbers in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Example:\n    >>> big_diff([1,2,3,4])\n    3\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    # Using Python's built-in functions to find max and min\n    max_value = max(numbers)\n    min_value = min(numbers)\n    \n    return max_value - min_value", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The difference between the max and min values in the list.\n\n    Examples:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    >>> big_diff([10, 20, 30, 15, 25])\n    20\n    \"\"\"\n    # Check if the list is empty or has only one element\n    if len(lst) < 2:\n        return 0\n    \n    # Return the difference between max and min\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest numbers in a list.\n\n    Args:\n    numbers (list of int): A list of integers.\n\n    Returns:\n    int: The difference between the maximum and minimum values in the list.\n\n    Examples:\n    >>> big_diff([1,2,3,4])\n    3\n    >>> big_diff([10,5,7,25])\n    20\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0\n    \n    # Use built-in max() and min() for finding the largest and smallest\n    max_num = max(numbers)\n    min_num = min(numbers)\n    \n    # Return the difference\n    return max_num - min_num", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 55.800000000000004, "dps_norm": 60.5, "pass@1": 30.0, "profiled": [{"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    The function computes (n choose k) * (n choose k-1) for k from 1 to n, and sums these products.\n\n    Args:\n    n (int): The upper limit for the binomial coefficients.\n\n    Returns:\n    int: The sum of the products of consecutive binomial coefficients.\n\n    Raises:\n    ValueError: If n is less than or equal to 0.\n\n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n should be a positive integer.\")\n\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Compute (n choose k)\n    for k in range(1, n + 1):\n        # Calculate binomial coefficient directly\n        # This is the same as: math.comb(n, k) but we'll do it without importing math\n        coef_k = 1\n        for i in range(1, k + 1):\n            coef_k = coef_k * (n - (k - i)) // i\n        \n        # Since we want product of consecutive coefficients, but we've only calculated one:\n        # (n choose k) * (n choose k-1) = ((n choose k) * (k/(n-k+1))) when k is not 0 or n\n        if k > 1:  # k-1 would be valid for binomial coefficient\n            # We can derive (n choose k-1) from (n choose k)\n            # However, this is not strictly necessary since our formula simplifies:\n            # (n choose k) * (n choose k-1) = (n choose k)^2 * (n-k+1)/k\n            # But we've already computed n choose k once, so:\n            total_sum += coef_k * (coef_k * k // (n - k + 1))\n        else:\n            # When k=1, directly calculate (n choose 0) which is always 1\n            total_sum += n\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    This function computes the sum for each k from 0 to n of (n choose k) * (n choose k+1).\n    \n    Args:\n    n (int): The value to calculate the binomial coefficient combinations for.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n\n    Examples:\n    >>> sum_Of_product(3)\n    15\n    \n    Note:\n    This uses the `math.comb` function available in Python 3.8+, otherwise, \n    you would need to implement or find another binomial coefficient function.\n    \"\"\"\n    total = 0\n    for k in range(n + 1):\n        # Calculating nCk * nCk+1. However, we directly use comb(n,k+1) since:\n        # nCk * nCk+1 = n! / (k!(n-k)!) * n! / ((k+1)! (n-k-1)!) = nCk * (n-k)/(k+1)\n        total += comb(n, k) * comb(n, k + 1)\n    return total", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n    n (int): The value for which to compute the binomial coefficient products.\n\n    Returns:\n    int: The sum of the products of consecutive binomial coefficients.\n\n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    # Calculate binomial coefficient \n    def binomial_coeff(n, k):\n        if k > n - k:\n            k = n - k\n        res = 1\n        for i in range(k):\n            res *= (n - i)\n            res //= (i + 1)\n        return res\n\n    total = 0\n    # For each i from 0 to n, multiply binomial(n, i) with binomial(n, i+1)\n    for i in range(n + 1):\n        total += binomial_coeff(n, i) * (binomial_coeff(n, i + 1) if i < n else 0)\n    \n    return total", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient n choose k.\n    \"\"\"\n    if k > n - k:\n        k = n - k\n    result = 1\n    for i in range(1, k + 1):\n        result = result * (n - i + 1) // i\n    return result\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n    For example, if n = 3, this function computes:\n    (C(3,0) * C(3,1)) + (C(3,1) * C(3,2)) + (C(3,2) * C(3,3))\n    \n    :param n: The number of rows to consider in Pascal's triangle\n    :return: The sum of products of consecutive binomial coefficients\n    \n    Example:\n    >>> assert sum_Of_product(3) == 15\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    total_sum = 0\n    for k in range(n):\n        product = binomial_coefficient(n, k) * binomial_coefficient(n, k+1)\n        total_sum += product\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n\n    The formula for the binomial coefficient is:\n    C(n,k) = n! / (k! * (n-k)!)\n    \n    For each k from 0 to n-1, this function calculates:\n    C(n, k) * C(n, k+1)\n    \n    And then sums these products.\n\n    :param n: The number to compute binomial coefficients for.\n    :return: The sum of products of consecutive binomial coefficients.\n\n    Example:\n    For n = 3:\n    C(3,0) * C(3,1) + C(3,1) * C(3,2) + C(3,2) * C(3,3) = 1*3 + 3*3 + 3*1 = 3 + 9 + 3 = 15\n    \"\"\"\n    # Helper function to calculate binomial coefficient\n    def binomial_coeff(n, k):\n        if k > n - k:\n            k = n - k\n        result = 1\n        for i in range(1, k + 1):\n            result *= (n - k + i)\n            result //= i\n        return result\n    \n    # Summing the products of consecutive binomial coefficients\n    total = 0\n    for k in range(n):\n        total += binomial_coeff(n, k) * binomial_coeff(n, k+1)\n    \n    return total", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient (n choose k).\n    \n    Args:\n    n (int): Total number of items.\n    k (int): Number of items to choose.\n    \n    Returns:\n    int: The binomial coefficient value.\n    \"\"\"\n    if k > n - k:  # Use symmetry of Pascal's triangle for efficiency\n        k = n - k\n    \n    result = 1\n    for i in range(1, k + 1):\n        result *= (n - i + 1)\n        result //= i\n    return result\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n    \n    This function computes:\n    sum(C(n,0) * C(n,1) + C(n,1) * C(n,2) + ... + C(n, n-1) * C(n,n))\n\n    Args:\n    n (int): The total number for binomial calculation.\n\n    Returns:\n    int: Sum of the product of consecutive binomial coefficients.\n    \n    Examples:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    # We only go up to n-1 because we're dealing with C(n,i) * C(n,i+1)\n    return sum(binomial_coefficient(n, i) * binomial_coefficient(n, i + 1) for i in range(n))", "matching_cluster_idx": 3}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of products of consecutive binomial coefficients for 'n'.\n    \n    Binomial coefficient C(n, k) = n! / (k! * (n-k)!)\n    \n    Parameters:\n    n (int): The number for which to compute binomial coefficients.\n\n    Returns:\n    int: The sum of products C(n,k) * C(n,k+1) for k from 0 to n-1.\n    \n    Example:\n    >>> sum_Of_product(3)\n    15  # because (3,0) * C(3,1) + C(3,1) * C(3,2) + C(3,2) * C(3,3) = 3 + 6 + 6 = 15\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    # Precompute factorial to speed up binomial calculation\n    factorial = [1]\n    for i in range(1, n + 1):\n        factorial.append(factorial[-1] * i)\n    \n    def binomial_coeff(n, k):\n        return factorial[n] // (factorial[k] * factorial[n-k])\n    \n    total_sum = 0\n    for k in range(n):\n        # Calculate C(n,k) * C(n,k+1)\n        product = (binomial_coeff(n, k) * binomial_coeff(n, k + 1))\n        total_sum += product\n    \n    return total_sum", "matching_cluster_idx": 6}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient (n choose k).\n    This function uses an efficient algorithm to compute the result directly.\n    \"\"\"\n    if k > n - k:\n        k = n - k\n    res = 1\n    for i in range(k):\n        res *= (n - i)\n        res //= (i + 1)\n    return res\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients up to n.\n    \n    The sum is calculated as:\n    binom(n, 0) * binom(n, 1) + binom(n, 1) * binom(n, 2) + ... + binom(n, n-1) * binom(n, n)\n    \n    :param n: Integer, the upper limit for the binomial coefficient calculation\n    :return: Integer, the sum of product of consecutive binomial coefficients\n    \"\"\"\n    total = 0\n    for i in range(n):\n        # Calculate current binomial coefficient and the next one\n        current = binomial_coefficient(n, i)\n        next_coeff = binomial_coefficient(n, i+1)\n        total += current * next_coeff\n    \n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n    \n    For example:\n    - For n = 3, the binomial coefficients are [1, 3, 3, 1].\n      The product of consecutive pairs are [1*3, 3*3, 3*1] which sum up to 3 + 9 + 3 = 15\n    \n    Args:\n    n (int): The upper limit for calculating binomial coefficients.\n\n    Returns:\n    int: Sum of products of consecutive binomial coefficients.\n\n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    # Function to generate binomial coefficients\n    def binomial_coeff(n, k):\n        if k > n - k:\n            k = n - k\n        res = 1\n        for i in range(k):\n            res *= (n - i)\n            res //= (i + 1)\n        return res\n\n    # Generate binomial coefficients for n\n    coeffs = [binomial_coeff(n, k) for k in range(n + 1)]\n    \n    # Sum of product of consecutive coefficients\n    return sum(coeffs[i] * coeffs[i+1] for i in range(len(coeffs) - 1))", "matching_cluster_idx": 7}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    This function calculates the sum of products of consecutive binomial coefficients.\n    \n    For example:\n    - For n = 3:\n      - Binomial coefficients: [1, 3, 3, 1]\n      - Products of consecutive pairs: [1*3, 3*3, 3*1] = [3, 9, 3]\n      - Sum: 3 + 9 + 3 = 15\n    \n    Args:\n    n (int): The number for which binomial coefficients are calculated.\n    \n    Returns:\n    int: The sum of the products of consecutive binomial coefficients.\n    \n    >>> sum_Of_product(3)\n    15\n    >>> sum_Of_product(5)\n    260\n    \"\"\"\n    \n    # Helper function to calculate binomial coefficients\n    def binomial_coeff(n, k):\n        if k > n - k:  # Use the smaller number for efficiency\n            k = n - k\n        result = 1\n        for i in range(1, k+1):\n            result = result * (n - i + 1) // i\n        return result\n\n    # Generate binomial coefficients for n\n    coefs = [binomial_coeff(n, k) for k in range(n + 1)]\n    \n    # Calculate the sum of the product of consecutive coefficients\n    total = sum(coefs[i] * coefs[i + 1] for i in range(n))\n    \n    return total", "matching_cluster_idx": 7}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    For a given n, this function computes:\n    sum(comb(n, k) * comb(n, k + 1) for k in range(n))\n    \n    :param n: Integer representing the binomial coefficient base\n    :return: Sum of products of consecutive binomial coefficients\n    \n    Examples:\n    >>> sum_Of_product(3)\n    15\n    >>> sum_Of_product(2)\n    2\n    >>> sum_Of_product(1)\n    0\n    \"\"\"\n    # Edge case: when n is less than 1, sum should be 0\n    if n < 1:\n        return 0\n    \n    # Using math.comb for binomial coefficient calculation\n    return sum(comb(n, k) * comb(n, k + 1) for k in range(n))", "matching_cluster_idx": 5}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient C(n,k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    result = 1\n    for i in range(1, k + 1):\n        result = result * (n - i + 1) // i\n    return result\ndef sum_Of_product(n):\n    \"\"\"\n    Finds the sum of the product of consecutive binomial coefficients.\n    For example, sum_Of_product(3) should yield:\n    C(3,0)*C(3,1) + C(3,1)*C(3,2) + C(3,2)*C(3,3) = 3 + 6 + 3 = 12\n    \"\"\"\n    total = 0\n    for k in range(n + 1):\n        if k < n:\n            # Product of binomial coefficients for consecutive indices\n            product = binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n            total += product\n    return total", "matching_cluster_idx": 3}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients up to n.\n    \n    This function computes (n choose k) * (n choose k+1) for k from 0 to n-1,\n    then sums these products.\n\n    :param n: The upper limit for n choose k calculations\n    :return: The sum of the product of consecutive binomial coefficients\n\n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    def binomial_coeff(n, k):\n        \"\"\"Compute n choose k.\"\"\"\n        # Using this method to avoid potential overflow for larger numbers\n        if k > n - k:\n            k = n - k\n        res = 1\n        for i in range(k):\n            res *= (n - i)\n            res //= (i + 1)\n        return res\n    \n    # Sum of products of consecutive binomial coefficients\n    total = 0\n    for k in range(n):\n        total += binomial_coeff(n, k) * binomial_coeff(n, k + 1)\n    \n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of products of consecutive binomial coefficients for n choose k.\n    \n    This function computes the sum where each term is a product of two consecutive\n    binomial coefficients (n choose k) * (n choose k+1) for k from 0 to n-1.\n\n    Args:\n    n (int): The number for which to calculate binomial coefficients.\n\n    Returns:\n    int: Sum of the products of consecutive binomial coefficients.\n\n    Examples:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    # Handle edge cases\n    if n < 0:\n        return 0\n\n    # Initialize the result\n    total_sum = 0\n    \n    # n choose k calculation\n    for k in range(n):\n        # Binomial coefficient can be computed as n!/(k!(n-k)!),\n        # but here we'll simplify using the combinatorial identity:\n        # n choose k * n choose k+1 = n choose k+1 * (n-k)/(k+1)\n        # Starting with n choose 0 = 1\n        if k == 0:\n            binomial_k = 1\n        else:\n            # Use the relationship for efficiency\n            binomial_k = binomial_k * (n - k + 1) // k\n        \n        # Calculate the product with the next binomial coefficient\n        # Since the next binomial coefficient will be calculated in the next iteration,\n        # we simply multiply by it\n        product = binomial_k * (binomial_k * (n - k) // (k + 1))\n        total_sum += product\n\n    return total_sum", "matching_cluster_idx": 8}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k) = n! / (k!(n-k)!)\n    \n    :param n: Total number of items\n    :param k: Number of items to choose from n\n    :return: The binomial coefficient C(n,k)\n    \"\"\"\n    if k > n:\n        return 0\n    res = 1\n    for i in range(k):\n        res *= (n - i)\n        res //= (i + 1)\n    return res\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the products of consecutive binomial coefficients.\n    \n    :param n: The upper limit for binomial coefficient calculation\n    :return: Sum of products of consecutive binomial coefficients for C(n,k) and C(n,k+1) where k goes from 0 to n-1\n    \n    Examples:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    total = 0\n    for k in range(n):\n        # Calculate C(n,k) * C(n,k+1)\n        product = binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n        total += product\n    return total", "matching_cluster_idx": 3}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the products of consecutive binomial coefficients for n.\n\n    :param n: The number for which to compute the sum\n    :return: The sum of products of consecutive binomial coefficients\n\n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    # Start with C(n,0)\n    current = 1\n    total_sum = 0\n    \n    # Loop through k from 0 to n\n    for k in range(n + 1):\n        # If we're not at n, we multiply with the next coefficient\n        if k != n:\n            # The next coefficient can be calculated as:\n            # C(n, k+1) = C(n, k) * (n - k) / (k + 1)\n            next_coeff = (current * (n - k)) // (k + 1)\n            total_sum += current * next_coeff\n        current = next_coeff if k != n else 1  # Reset to C(n, 0) for the next iteration\n\n    return total_sum", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of products of consecutive binomial coefficients.\n\n    This function calculates C(n,0) * C(n,1) + C(n,1) * C(n,2) + ... + C(n,n-1) * C(n,n),\n    where C(n,k) is the binomial coefficient.\n\n    Args:\n    n (int): The number for which to compute the sum.\n\n    Returns:\n    int: The sum of products of consecutive binomial coefficients.\n\n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    def binomial_coefficient(n, k):\n        \"\"\"Helper function to compute binomial coefficient C(n,k).\"\"\"\n        if k > n - k:\n            k = n - k\n        res = 1\n        for i in range(k):\n            res *= (n - i)\n            res //= (i + 1)\n        return res\n\n    # Sum the product of consecutive binomial coefficients\n    total_sum = sum(binomial_coefficient(n, i) * binomial_coefficient(n, i+1) for i in range(n))\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient n choose k\"\"\"\n    if k > n - k:\n        k = n - k\n    res = 1\n    for i in range(1, k + 1):\n        res *= (n - k + i)\n        res //= i\n    return res\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the products of consecutive binomial coefficients.\n    \n    The binomial coefficient is defined as C(n,k) = n!/(k!(n-k)!).\n    Here we sum the products C(n,0)*C(n,1) + C(n,1)*C(n,2) + ... + C(n,n-1)*C(n,n)\n\n    Args:\n    n (int): The upper number in the binomial expansion.\n\n    Returns:\n    int: The sum of product of consecutive binomial coefficients.\n\n    Examples:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    sum_product = 0\n    for i in range(n):\n        sum_product += binomial_coefficient(n, i) * binomial_coefficient(n, i + 1)\n    return sum_product", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the products of consecutive binomial coefficients.\n\n    :param n: The number to generate binomial coefficients up to n.\n    :return: Sum of products of consecutive binomial coefficients.\n\n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    # Initialize variables for the product sum and current coefficient\n    product_sum = 0\n    prev_coeff = 1  # Binomial coefficient at k=0 is always 1\n    \n    # Loop through to calculate binomial coefficients\n    for k in range(1, n + 1):\n        # Using the recurrence relation for binomial coefficient calculation:\n        # C(n,k) = C(n,k-1) * (n-k+1) / k\n        curr_coeff = prev_coeff * (n - k + 1) // k\n        \n        # Sum of products of current and previous coefficients\n        product_sum += prev_coeff * curr_coeff\n        \n        # Update previous coefficient for next iteration\n        prev_coeff = curr_coeff\n    \n    return product_sum", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of products of consecutive binomial coefficients.\n\n    The binomial coefficient (n choose k) is given by:\n    C(n,k) = n! / (k! * (n-k)!)\n\n    This function calculates:\n    C(n,0)*C(n,1) + C(n,1)*C(n,2) + ... + C(n,n-1)*C(n,n)\n\n    Args:\n    n (int): The number of items.\n\n    Returns:\n    int: The sum of products of consecutive binomial coefficients.\n\n    Examples:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    def binomial_coeff(n, k):\n        \"\"\"Helper function to calculate binomial coefficient C(n,k)\"\"\"\n        if k > n - k:  # take advantage of symmetry for efficiency\n            k = n - k\n        result = 1\n        for i in range(1, k + 1):\n            result = result * (n - i + 1) // i  # Use integer division to avoid float inaccuracy\n        return result\n\n    total_sum = 0\n    for i in range(n):\n        total_sum += binomial_coeff(n, i) * binomial_coeff(n, i+1)\n\n    return total_sum", "matching_cluster_idx": 4}]}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 95.0, "profiled": [{"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverses the order of words in a given string.\n    \n    Args:\n    sentence (str): A string where words are separated by spaces.\n    \n    Returns:\n    str: The sentence with its words in reverse order.\n\n    Example:\n    >>> reverse_words(\"python program\")\n    'program python'\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Reverse the list of words\n    words.reverse()\n    \n    # Join the reversed list back into a string\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverses the order of words in the given sentence.\n    \n    This function takes a string where words are separated by spaces,\n    reverses the order of these words, and returns the new string.\n    \n    Args:\n    sentence (str): The original sentence to reverse words in.\n    \n    Returns:\n    str: A string with the words in reverse order.\n    \n    Example:\n    >>> reverse_words(\"python program\")\n    \"program python\"\n    \"\"\"\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Reverse the list of words\n    words.reverse()\n    \n    # Join the words back into a string\n    reversed_sentence = ' '.join(words)\n    \n    return reversed_sentence", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n    sentence (str): A string containing words separated by spaces.\n\n    Returns:\n    str: A string with the words in reverse order.\n\n    Examples:\n    >>> reverse_words(\"python program\")\n    'program python'\n    \"\"\"\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Reverse the list of words\n    words.reverse()\n    \n    # Join the reversed list back into a string with spaces in between\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverse the order of words in a given string.\n\n    This function takes a string with words separated by spaces and returns\n    a new string where the order of the words is reversed.\n\n    Args:\n    sentence (str): A string containing words to be reversed.\n\n    Returns:\n    str: A string with the words in reverse order.\n\n    Examples:\n    >>> reverse_words(\"hello world\")\n    'world hello'\n    >>> reverse_words(\"  multiple   spaces   here  \")\n    'here spaces multiple'\n    \"\"\"\n    # Split the string into words, stripping extra spaces, then reverse the list of words\n    words = sentence.split()\n    reversed_words = words[::-1]\n    \n    # Join the reversed list of words into a string with a single space between each word\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverse the order of words in a string separated by spaces.\n\n    Args:\n    sentence (str): The input string with words to be reversed.\n\n    Returns:\n    str: A new string where the order of the words is reversed.\n\n    Example:\n    >>> reverse_words(\"python program\")\n    \"program python\"\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Reverse the list of words\n    words.reverse()\n    \n    # Join the words back into a string with a space separator\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Reverse the list of words and join them back with space\n    return ' '.join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverses the order of words in a given sentence.\n    \n    Args:\n    sentence (str): A string containing words separated by spaces.\n    \n    Returns:\n    str: A new string with the words in reverse order.\n    \n    Examples:\n    >>> reverse_words(\"python program\")\n    'program python'\n    \"\"\"\n    # Split the sentence into words, reverse the list, and join back with spaces\n    return ' '.join(sentence.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverse the order of words in the given sentence.\n    \n    Args:\n    sentence (str): A string containing words separated by spaces.\n    \n    Returns:\n    str: A new string with words in reverse order.\n    \n    Examples:\n    >>> reverse_words(\"python program\")\n    'program python'\n    >>> reverse_words(\"the quick brown fox\")\n    'fox brown quick the'\n    \"\"\"\n    # Split the sentence into words, reverse them, and join them back\n    # We use split() to handle multiple spaces if present\n    words = sentence.split()\n    return ' '.join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverse the order of words in a string where words are separated by spaces.\n    \n    Args:\n    sentence (str): The input string with words separated by spaces.\n\n    Returns:\n    str: A string where the order of words is reversed.\n\n    Examples:\n    >>> reverse_words(\"python program\")\n    'program python'\n    >>> reverse_words(\"Hello World\")\n    'World Hello'\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Reverse the list of words\n    words.reverse()\n    \n    # Join the words back into a single string with a space separator\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverses the order of words in the given string.\n\n    This function takes a string of words separated by spaces, \n    reverses their order, and returns the result as a string.\n\n    Parameters:\n    sentence (str): A string containing words separated by spaces.\n\n    Returns:\n    str: The words in reverse order.\n\n    Example:\n    >>> reverse_words(\"hello world\")\n    'world hello'\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Reverse the list of words\n    words.reverse()\n    \n    # Join the reversed list into a string\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverse the order of words in a given string separated by spaces.\n    \n    Args:\n    sentence (str): The input string containing words to be reversed.\n    \n    Returns:\n    str: A string with words in reverse order.\n    \n    Examples:\n    >>> reverse_words(\"python program\")\n    'program python'\n    >>> reverse_words(\"one two three four\")\n    'four three two one'\n    \"\"\"\n    # Split the sentence into words, reverse the list of words, and join them back with spaces\n    words = sentence.split()\n    reversed_sentence = ' '.join(reversed(words))\n    return reversed_sentence", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    This function takes a string where words are separated by spaces,\n    and returns a new string with the order of these words reversed.\n\n    Args:\n        sentence (str): A string containing words separated by spaces.\n\n    Returns:\n        str: A string where the order of the words from the input string is reversed.\n\n    Example:\n        >>> reverse_words(\"hello world\")\n        'world hello'\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Reverse the list of words and join them back into a string\n    return ' '.join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverse the order of words in the given sentence.\n\n    This function takes a string with words separated by spaces and returns\n    a new string where the order of the words is reversed.\n\n    Args:\n        sentence (str): A string containing words to be reversed.\n\n    Returns:\n        str: The string with words in reversed order.\n\n    Example:\n        >>> reverse_words(\"python program\")\n        \"program python\"\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Reverse the list of words\n    words.reverse()\n    # Join the words back into a string with space in between\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverses the order of words in the given sentence.\n    \n    This function takes a string of words separated by spaces and \n    returns a new string where the order of words is reversed.\n\n    Args:\n    sentence (str): A string containing words separated by spaces.\n\n    Returns:\n    str: A new string with the words in reverse order.\n\n    Example:\n    >>> reverse_words(\"hello world\")\n    'world hello'\n    >>> reverse_words(\"a b c d\")\n    'd c b a'\n    \"\"\"\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Reverse the list of words\n    words.reverse()\n    \n    # Join the reversed list back into a string\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverses the order of words in a given sentence.\n\n    This function takes a string where words are separated by spaces and \n    returns a new string with the words in reverse order.\n\n    Args:\n    sentence (str): A string containing words to be reversed.\n\n    Returns:\n    str: A string with words in reverse order.\n\n    Example:\n    >>> reverse_words(\"python program\")\n    'program python'\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    reversed_sentence = \" \".join(reversed_words)\n    \n    return reversed_sentence", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverses the order of words in the given sentence.\n    \n    Args:\n    sentence (str): A string containing words separated by spaces.\n    \n    Returns:\n    str: A string with the words in reverse order.\n\n    Examples:\n    >>> reverse_words(\"python program\")\n    'program python'\n    >>> reverse_words(\"hello world\")\n    'world hello'\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Reverse the list of words and join them back with spaces\n    reversed_sentence = \" \".join(words[::-1])\n    \n    return reversed_sentence", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverses the order of words in the given sentence.\n    \n    Args:\n    sentence (str): A string containing words separated by spaces.\n    \n    Returns:\n    str: A string with the words in reverse order.\n    \n    Example:\n    >>> reverse_words(\"python program\")\n    \"program python\"\n    \"\"\"\n    # Split the string into a list of words\n    words = sentence.split()\n    # Reverse the list of words\n    words.reverse()\n    # Join the words back into a single string separated by spaces\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    This function takes a string of words separated by spaces and \n    returns a new string where the order of the words is reversed.\n\n    Args:\n    sentence (str): The input string containing words to be reversed.\n\n    Returns:\n    str: A string with the words in reverse order.\n\n    Example:\n    >>> reverse_words(\"hello world\")\n    'world hello'\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Reverse the list of words and join them back with space\n    return ' '.join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverse the order of words in the given sentence.\n\n    This function splits the input sentence into words based on spaces,\n    reverses the order of these words, and then joins them back together.\n\n    Args:\n    sentence (str): The input string to have its words reversed.\n\n    Returns:\n    str: A new string with the words in reverse order.\n\n    Examples:\n    >>> reverse_words(\"python program\")\n    \"program python\"\n    >>> reverse_words(\"Hello world how are you\")\n    \"you are how world Hello\"\n    \"\"\"\n    # Split the sentence into words, reverse them, and join them with a space\n    return ' '.join(sentence.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string.\n\n    This function takes a string with words separated by spaces and reverses\n    their order while keeping the words themselves intact.\n\n    Args:\n    input_string (str): A string containing words separated by spaces.\n\n    Returns:\n    str: A new string with the order of words reversed.\n\n    Examples:\n    >>> reverse_words(\"python program\")\n    \"program python\"\n    >>> reverse_words(\"one two three\")\n    \"three two one\"\n    \"\"\"\n    # Split the string into words, reverse the list of words, and then join them back\n    return ' '.join(input_string.split()[::-1])", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 60.7608695652174, "dps_norm": 59.28571428571429, "pass@1": 77.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list and return the new list.\n\n    Args:\n    lst (list): The input list from which to remove an element.\n    k (int): The index (1-based) of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Raises:\n    ValueError: If k is not within the range of the list indices (1 to length of list).\n    \"\"\"\n    # Check if k is valid\n    if k < 1 or k > len(lst):\n        raise ValueError(f\"k must be between 1 and {len(lst)} inclusive.\")\n    \n    # Convert k to zero-based indexing\n    k_zero_based = k - 1\n    \n    # Return new list excluding the k'th element\n    return lst[:k_zero_based] + lst[k_zero_based+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the given list.\n    \n    Parameters:\n    lst (list): The input list from which an element will be removed.\n    k (int): The position (1-indexed) of the element to remove.\n    \n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    ValueError: If k is less than 1 or greater than the length of the list.\n\n    Examples:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    >>> remove_kth_element([], 1)\n    []\n    >>> remove_kth_element([1], 1)\n    []\n    \"\"\"\n    # Check if k is valid\n    if k < 1 or k > len(lst):\n        raise ValueError(\"k must be between 1 and the length of the list inclusive\")\n\n    # Convert k to a 0-indexed position\n    k -= 1\n    \n    # Create a new list excluding the k-th element\n    return lst[:k] + lst[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list.\n\n    Args:\n    lst (list): The input list from which an element needs to be removed.\n    k (int): The position of the element to remove (1-indexed).\n\n    Returns:\n    list: A new list with the k'th element removed. If k is out of range,\n          the original list is returned unmodified.\n\n    Examples:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    # Check if k is within the list bounds\n    if 1 <= k <= len(lst):\n        # Convert to 0-based index and slice the list accordingly\n        return lst[:k-1] + lst[k:]\n    return lst  # Return the original list if k is out of range", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list.\n\n    Parameters:\n    lst (list): The input list from which to remove an element.\n    k (int): The position of the element to remove (1-indexed).\n\n    Returns:\n    list: A new list with the k'th element removed. If k is out of range, the original list is returned.\n\n    Example:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1],3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    # Check if k is within the bounds of the list\n    if k < 1 or k > len(lst):\n        return lst  # If k is out of bounds, return the original list\n    \n    # Use list slicing to create a new list without the k'th element\n    # Remember, list indices are 0-based, so we adjust k\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list and return the new list.\n    \n    Parameters:\n    lst (list): The input list from which an element will be removed.\n    k (int): The index (1-based) of the element to remove.\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \n    Example:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    # Convert k to 0-based index\n    k = k - 1\n    if k < 0 or k >= len(lst):\n        raise ValueError(\"k is out of range for the given list\")\n    \n    # Use list slicing to exclude the k-th element\n    return lst[:k] + lst[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the given list.\n    \n    Args:\n    lst (list): The input list from which to remove an element.\n    k (int): The index of the element to remove (1-indexed).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \n    Raises:\n    ValueError: If k is less than 1 or greater than the length of the list.\n    \"\"\"\n    # Adjust for 1-indexed position to 0-indexed\n    k = k - 1\n    \n    # Check if k is within the list bounds\n    if k < 0 or k >= len(lst):\n        raise ValueError(\"k must be between 1 and the length of the list, inclusive.\")\n    \n    # Use list comprehension to build a new list excluding the kth element\n    return lst[:k] + lst[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the given list.\n    \n    Parameters:\n    lst (list): The list from which to remove an element.\n    k (int): The position (1-indexed) of the element to remove.\n    \n    Returns:\n    list: A new list with the k'th element removed.\n\n    Raises:\n    ValueError: If k is out of range or list is empty.\n\n    Examples:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1],3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list cannot be empty.\")\n    if k < 1 or k > len(lst):\n        raise ValueError(f\"k={k} is out of range for list length {len(lst)}\")\n    \n    # Convert k to 0-indexed for slicing\n    k_index = k - 1\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from the given list.\n\n    Args:\n    input_list (list): The input list from which to remove an element.\n    k (int): The index of the element to remove (1-indexed).\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Raises:\n    ValueError: If k is out of the list's range or invalid.\n    \"\"\"\n    # Convert k to 0-based index\n    if k < 1 or k > len(input_list):\n        raise ValueError(\"k is out of range for the list length\")\n    \n    # Python uses 0-based indexing, so we subtract 1 from k\n    index_to_remove = k - 1\n    \n    # Create a new list by slicing out the k'th element\n    return input_list[:index_to_remove] + input_list[index_to_remove + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the given list.\n\n    Parameters:\n    lst (list): The input list from which to remove an element.\n    k (int): The index (1-based) of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed. If k is out of range,\n          returns a list with the original elements unchanged.\n\n    Examples:\n    >>> remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    >>> remove_kth_element([], 5)\n    []\n    >>> remove_kth_element([1, 2, 3], 0)\n    [1, 2, 3]\n    \"\"\"\n    # Check if k is valid\n    if k <= 0 or k > len(lst):\n        return lst[:]  # Return a copy of the original list\n    \n    # Convert 1-based index to 0-based for Python list indexing\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k-th element from the given list.\n\n    Args:\n    lst (list): The input list from which an element will be removed.\n    k (int): The index of the element to remove (1-indexed).\n\n    Returns:\n    list: A new list with the k-th element removed. If k is out of range, returns the list unchanged.\n\n    Example:\n    >>> remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    # Adjust k for 1-indexing to 0-indexing\n    k = k - 1\n    # Check if k is within the bounds of the list\n    if 0 <= k < len(lst):\n        return lst[:k] + lst[k+1:]\n    else:\n        # Return the list unchanged if k is out of range\n        return lst", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the given list.\n    \n    Args:\n    lst (list): The input list from which to remove an element.\n    k (int): The index of the element to remove (1-indexed).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \n    Example:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    # Check if k is within the bounds of the list length\n    if k < 1 or k > len(lst):\n        raise ValueError(\"k must be between 1 and the length of the list inclusive.\")\n    \n    # Python uses 0-based indexing, so adjust k to fit\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the given list and return the resulting list.\n\n    Parameters:\n    lst (list): The input list from which to remove an element.\n    k (int): The index of the element to be removed (1-indexed).\n\n    Returns:\n    list: A new list with the k'th element removed. If k is out of range or invalid, \n          the list remains unchanged.\n\n    Example:\n    >>> remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    # Check if k is valid, list is non-empty, and k is within the list bounds\n    if not lst or k < 1 or k > len(lst):\n        return lst  # Return the list unchanged if conditions are not met\n    \n    # Convert k to a zero-based index by subtracting 1\n    zero_based_index = k - 1\n    \n    # Return a new list with the k'th element removed\n    return lst[:zero_based_index] + lst[zero_based_index+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns a new list.\n\n    Args:\n    lst (list): The input list from which to remove an element.\n    k (int): The position (1-indexed) of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Raises:\n    ValueError: If k is less than or equal to 0, or if k is greater than the list length.\n\n    Example:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        raise ValueError(\"k must be a positive integer not greater than the length of the list\")\n    \n    # Since list indices are 0-based, we subtract 1 from k\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k-th element from the list.\n    \n    Args:\n    lst (list): The list from which an element needs to be removed.\n    k (int): The index (1-based) of the element to remove.\n    \n    Returns:\n    list: A new list with the k-th element removed.\n    \n    Raises:\n    IndexError: If k is out of the list bounds or if k is less than or equal to 0.\n    \"\"\"\n    # Adjust k to be zero-based index\n    if k <= 0 or k > len(lst):\n        raise IndexError(\"Index out of bounds for list with length \" + str(len(lst)))\n    \n    # Remove k-th element (k is now 0-based)\n    del lst[k - 1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the given list and returns a new list with the remaining elements.\n\n    Args:\n    lst (list): The original list from which to remove an element.\n    k (int): The index of the element to be removed (1-indexed).\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Raises:\n    IndexError: If k is out of range for the list size.\n\n    Example:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1],3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    # Adjust k since list indices are 0-based\n    adjusted_k = k - 1\n    \n    # Check if k is valid\n    if adjusted_k < 0 or adjusted_k >= len(lst):\n        raise IndexError(\"k is out of range for list\")\n    \n    # Use list slicing to create a new list without the k'th element\n    return lst[:adjusted_k] + lst[adjusted_k + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the given list.\n\n    Args:\n    lst (list): The list from which to remove an element.\n    k (int): The index (1-based) of the element to be removed.\n\n    Returns:\n    list: A new list with the k'th element removed. If k is out of bounds, the original list is returned unchanged.\n\n    Examples:\n    >>> remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    # Check if k is valid\n    if k < 1 or k > len(lst):\n        return lst\n    \n    # Convert 1-based index to 0-based for Python lists\n    k = k - 1\n    # Create a new list excluding the k'th element\n    return lst[:k] + lst[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k-th element from the given list.\n    \n    Args:\n    lst (list): The input list from which to remove an element.\n    k (int): The index of the element to remove. Note: k is 1-indexed.\n\n    Returns:\n    list: A new list with the k-th element removed.\n    \n    Raises:\n    ValueError: If k is not positive or greater than the list length.\n    \"\"\"\n    # Convert k to 0-indexed\n    k = k - 1\n    \n    # Check if k is within the bounds of the list\n    if k < 0 or k >= len(lst):\n        raise ValueError(\"k is out of bounds for the list length.\")\n    \n    # Create a new list excluding the k-th element\n    return lst[:k] + lst[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the given list.\n    \n    Parameters:\n    lst (list): The input list from which an element will be removed.\n    k (int): The index of the element to remove (1-indexed).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \n    Raises:\n    IndexError: If k is less than 1 or greater than the length of the list.\n    \n    Examples:\n    >>> remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    >>> remove_kth_element(['a', 'b', 'c', 'd'], 2)\n    ['a', 'c', 'd']\n    \"\"\"\n    # Adjust k to 0-indexed\n    if not (1 <= k <= len(lst)):\n        raise IndexError(\"k is out of the valid range for list indices.\")\n    \n    # Create a new list with the element at k-1 removed\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k-th element from the list.\n\n    Parameters:\n    input_list (list): The input list from which an element is to be removed.\n    k (int): The position of the element to remove (1-indexed).\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is less than 1 or greater than the list length.\n\n    Example:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    # Convert k to a 0-based index\n    index = k - 1\n    \n    # Check if k is valid\n    if index < 0 or index >= len(input_list):\n        raise IndexError(\"k is out of bounds for the given list length.\")\n    \n    # Use list slicing to remove the k-th element\n    return input_list[:index] + input_list[index+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the given list.\n    \n    Args:\n    lst (list): The list from which to remove an element.\n    k (int): The position of the element to remove (1-indexed).\n    \n    Returns:\n    list: A new list with the k'th element removed. If k is out of range, \n          the original list is returned unchanged.\n    \n    Examples:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    # Check if k is within the list bounds, remember k is 1-indexed\n    if k < 1 or k > len(lst):\n        return lst.copy()  # Return a copy to ensure immutability principle\n    \n    # Use list slicing to remove the k'th element, \n    # where k is converted to 0-indexed by subtracting 1\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": 82.93363078639152, "dps_norm": 93.93939393939394, "pass@1": 11.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of a matrix.\n\n    Args:\n    matrix (List[List[int]]): A matrix represented as a list of lists.\n    n (int): The column index for which to find the max value.\n\n    Returns:\n    int: The maximum value in the nth column.\n\n    Raises:\n    IndexError: If n is out of range for the given matrix.\n\n    Examples:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    >>> max_of_nth([[1,2,3],[4,5,6]], 1)\n    5\n    \"\"\"\n    if not matrix or n >= len(matrix[0]):\n        raise IndexError(\"Column index out of range\")\n\n    # Use list comprehension to extract nth column and then find the max\n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        raise IndexError(\"Column index out of range or matrix is inconsistent\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Find the maximum value in the n'th column of a matrix.\n\n    Args:\n    matrix (List[List[int]]): A list of lists representing a matrix.\n    n (int): The index of the column to search (0-based index).\n\n    Returns:\n    int: The maximum value found in the specified column.\n\n    Raises:\n    ValueError: If n is out of range or if the matrix is empty.\n\n    Examples:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    >>> max_of_nth([[1, 2], [3, 4]], 0)\n    3\n    \"\"\"\n    # Check if the matrix is empty or n is out of range\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid matrix or column index out of range\")\n\n    # Using list comprehension to get the n'th element from each row\n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        # This would catch an error if any row is shorter than the others\n        raise ValueError(\"Matrix has inconsistent row lengths\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Finds the maximum value in the nth column of a matrix.\n\n    Args:\n    matrix (List[List[int]]): A matrix represented as a list of lists of integers.\n    n (int): The column index (0-based) to find the maximum value in.\n\n    Returns:\n    int: The maximum value in the nth column.\n\n    Raises:\n    IndexError: If the matrix is empty or n is out of bounds.\n    \"\"\"\n    # Check if matrix is empty or if n is out of range\n    if not matrix or n >= len(matrix[0]):\n        raise IndexError(\"Matrix is empty or column index out of range\")\n\n    # Extract the nth element from each row and find the max\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Find the maximum value in the n-th column of a matrix.\n\n    Args:\n    matrix (List[List[int]]): A matrix represented as a list of lists where each inner list is a row.\n    n (int): The column index to look for the maximum value. Zero-based index.\n\n    Returns:\n    int: The maximum value found in the specified column.\n\n    Raises:\n    IndexError: If the matrix is empty or if n is out of range.\n\n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    if not matrix or any(len(row) <= n for row in matrix):\n        raise IndexError(\"Column index out of range or matrix is empty\")\n\n    # Extract the n-th column from all rows\n    nth_column = [row[n] for row in matrix]\n    \n    # Return the maximum value from this list\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n'th column in a matrix.\n\n    Args:\n    matrix (List[List[int]]): A list of lists representing a matrix where each inner list is a row.\n    n (int): The column index (0-indexed) for which to find the maximum.\n\n    Returns:\n    int: The maximum value found in the specified column.\n\n    Raises:\n    IndexError: If the column index `n` is out of bounds for the matrix.\n\n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    if not matrix or n >= len(matrix[0]):\n        raise IndexError(\"Column index is out of range for the given matrix.\")\n    \n    # Since list index starts at 0, we don't need to adjust n\n    return max(row[n] for row in matrix if len(row) > n)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Transpose the matrix so we can access columns as rows\n    if not matrix or not matrix[0]:\n        return None  # Handling edge cases where matrix might be empty or has no columns\n    \n    if n >= len(matrix[0]):\n        return None  # n is out of bounds\n    \n    # Transpose the matrix\n    transposed = list(zip(*matrix))\n    \n    # Get the n-th column which is now a row due to transposition\n    nth_column = transposed[n]\n    \n    # Return the max value of this column\n    return max(nth_column)", "matching_cluster_idx": 2}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value from the nth column of the given matrix.\n\n    :param matrix: A list of lists representing a matrix.\n    :param n: The column index to check (0-indexed).\n    :return: The maximum value in the nth column.\n\n    :raises ValueError: If the column index is out of range or if the matrix is empty.\n    \"\"\"\n    # Check if matrix is empty or if n is greater than or equal to the number of columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid matrix or column index\")\n\n    # Extract the nth column\n    nth_column = [row[n] for row in matrix]\n\n    # Return the max value from this column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Find the maximum value in the nth column of the given matrix.\n    \n    Args:\n    matrix (List[List[int]]): A list of lists representing a matrix of integers.\n    n (int): The column index to find the maximum from.\n    \n    Returns:\n    int: The maximum value in the specified column.\n\n    Raises:\n    ValueError: If the matrix is empty or if n is out of range.\n    \n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    # Check if the matrix is empty or if n exceeds the number of columns\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid input: either matrix is empty or n is out of bounds\")\n    \n    # Initialize max to negative infinity to ensure any number from the matrix will be larger\n    max_value = float('-inf')\n    \n    # Iterate through each row of the matrix\n    for row in matrix:\n        # Since list indexing starts at 0, we check if n is not less than the list length\n        if n < len(row):\n            max_value = max(max_value, row[n])\n    \n    return max_value", "matching_cluster_idx": 4}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n    \n    :param matrix: A list of lists representing a matrix\n    :param n: The column index to find the maximum value from\n    :return: The maximum value in the specified column or None if column doesn't exist\n    :raises IndexError: If the matrix is empty or n is out of bounds for any row\n    \"\"\"\n    try:\n        # Check if matrix is empty\n        if not matrix:\n            raise IndexError(\"The matrix is empty\")\n        \n        # Extract the n-th element from each row\n        nth_column = [row[n] for row in matrix]\n        \n        # Return the max value in this column\n        return max(nth_column)\n    except IndexError:\n        return None", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value from the nth column of a matrix.\n\n    :param matrix: List of lists representing a matrix\n    :param n: Column index (0-indexed)\n    :return: Maximum value in the nth column\n\n    :raises IndexError: If n is out of range for any row in the matrix\n\n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    # Check if n is within the valid range for all rows\n    if not matrix or any(n >= len(row) for row in matrix):\n        raise IndexError(\"Column index n out of range\")\n    \n    # Use list comprehension with max() to find the maximum in the nth column\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Find the maximum value in the n'th column of a matrix.\n\n    Args:\n    matrix (List[List[int]]): A matrix represented as a list of lists where each inner list has the same length.\n    n (int): The column index to find the maximum value from (0-indexed).\n\n    Returns:\n    int: The maximum value in the specified column.\n\n    Raises:\n    ValueError: If n is out of range or if the matrix is empty or inconsistent.\n\n    Examples:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    # Check if matrix is empty or inconsistent\n    if not matrix or not all(len(row) > n for row in matrix):\n        raise ValueError(\"Matrix is empty or column index is out of range\")\n    \n    # Use a list comprehension to extract the n'th column, then find max\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 53.26388888888888, "dps_norm": 61.875, "pass@1": 93.0, "profiled": [{"solution": "def replace_spaces(sentence):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n    \n    Args:\n    sentence (str): The input string to be modified.\n\n    Returns:\n    str: The modified string with whitespaces and underscores swapped.\n\n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Hello_World')\n    'Hello World'\n    \"\"\"\n    # Use a dictionary to map spaces to underscores and vice versa for translation\n    return sentence.translate(str.maketrans({' ': '_', '_': ' '}))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n\n    Args:\n    input_string (str): The string to modify.\n\n    Returns:\n    str: A new string with spaces and underscores swapped.\n\n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Python_is_awesome')\n    'Python is awesome'\n    \"\"\"\n    # Create a dictionary for mapping space to underscore and vice versa\n    replace_dict = {' ': '_', '_': ' '}\n    # Use a list comprehension with a conditional to map each character\n    return ''.join(replace_dict.get(char, char) for char in input_string)", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces all whitespaces with underscores and vice versa in the input string.\n\n    Args:\n    input_string (str): The string to modify.\n\n    Returns:\n    str: A new string with whitespaces replaced by underscores and underscores by whitespaces.\n\n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    \"\"\"\n    # Create a new string by mapping each character to its replacement\n    return ''.join('_' if char == ' ' else ' ' if char == '_' else char for char in input_string)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces spaces with underscores and vice versa in a given string.\n    \n    :param s: The string to process\n    :return: A new string with whitespaces replaced by underscores and underscores by whitespaces\n    \"\"\"\n    # Use a list comprehension with a conditional to swap spaces and underscores\n    return ''.join(\n        '_' if char == ' ' else ' ' if char == '_' else char \n        for char in s\n    )", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace spaces with underscores and vice versa in the given string.\n\n    Args:\n    input_string (str): The string to process.\n\n    Returns:\n    str: A new string where spaces are replaced with underscores and \n         underscores are replaced with spaces.\n\n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Jumanji_The_Jungle')\n    'Jumanji The Jungle'\n    \"\"\"\n    # Use a dictionary to map characters and the str.translate method for efficiency\n    translation_table = str.maketrans({chr(32): '_', '_': chr(32)})\n    return input_string.translate(translation_table)", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace spaces with underscores and vice versa in the given string.\n\n    Args:\n    input_string (str): The input string containing spaces or underscores.\n\n    Returns:\n    str: A new string with spaces replaced by underscores and underscores by spaces.\n\n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Hello_World')\n    'Hello World'\n    \"\"\"\n    # Create a translation table for replacing characters\n    translation = str.maketrans({' ': '_', '_': ' '})\n    # Use the translation table to replace characters in the string\n    return input_string.translate(translation)", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace all spaces with underscores and vice versa in the given string.\n\n    Args:\n    input_string (str): The string to be modified.\n\n    Returns:\n    str: A string where spaces are replaced by underscores and underscores by spaces.\n\n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('This_is_Sparta')\n    'This is Sparta'\n    \"\"\"\n    # Use a list comprehension with a conditional replacement\n    result = ''.join(\n        '_' if char == ' ' else ' ' if char == '_' else char\n        for char in input_string\n    )\n    return result", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces whitespaces with underscores and underscores with whitespaces in the given string.\n\n    Args:\n    s (str): The input string containing spaces or underscores.\n\n    Returns:\n    str: The string with spaces and underscores swapped.\n\n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('This_is_a_test')\n    'This is a test'\n    \"\"\"\n    # Use a list comprehension for efficiency, replacing each character\n    return ''.join('_' if char == ' ' else ' ' if char == '_' else char for char in s)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with an underscore and vice versa in a given string.\n\n    Args:\n    input_string (str): The string to process.\n\n    Returns:\n    str: A string where whitespaces and underscores have been swapped.\n\n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    \"\"\"\n    # Create a translation table\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Use the translation table to swap spaces and underscores\n    return input_string.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in a string.\n\n    Args:\n    s (str): The input string to modify.\n\n    Returns:\n    str: A string where each space is replaced with an underscore and each underscore with a space.\n\n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Python_Programming')\n    'Python Programming'\n    \"\"\"\n    # Create a dictionary to map replacements\n    replacements = {' ': '_', '_': ' '}\n    \n    # Use a list comprehension for efficiency to create a new string\n    return ''.join(replacements.get(char, char) for char in s)", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace spaces with underscores and vice versa in the given text.\n\n    This function will:\n    - Convert spaces to underscores\n    - Convert underscores to spaces\n\n    Args:\n    text (str): The string to modify.\n\n    Returns:\n    str: The modified string with spaces and underscores swapped.\n\n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Already_Swapped')\n    'Already Swapped'\n    \"\"\"\n    # Create a translation table\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    \n    # Use the translation table to replace characters\n    return text.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n    \n    :param input_string: str, the input string to process\n    :return: str, the modified string where spaces are replaced by underscores and vice versa\n    \"\"\"\n    result = []\n    for char in input_string:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with an underscore and vice versa in the given string.\n\n    Args:\n    input_string (str): The string in which to replace characters.\n\n    Returns:\n    str: A new string where spaces are replaced by underscores and underscores by spaces.\n\n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Python_is_fun')\n    'Python is fun'\n    \"\"\"\n    # Use a translation table to swap spaces and underscores\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    return input_string.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces all spaces with underscores in the string and vice versa.\n    \n    Args:\n    input_string (str): The input string to modify.\n    \n    Returns:\n    str: A string where spaces have been replaced by underscores and underscores by spaces.\n    \n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Snake_Eyes')\n    'Snake Eyes'\n    \"\"\"\n    # Use a list comprehension for efficient character transformation\n    return ''.join(['_' if char == ' ' else ' ' if char == '_' else char for char in input_string])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces spaces with underscores and underscores with spaces in the given string.\n    \n    Args:\n    s (str): The string to be modified.\n\n    Returns:\n    str: A new string where all spaces are replaced by underscores and vice versa.\n    \n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Hello_World')\n    'Hello World'\n    \"\"\"\n    # Use a list comprehension to create a new string\n    # Replace '_' with a temporary character to handle swapping\n    # Then replace ' ' with '_' and finally the temporary character with ' '\n    temp = s.replace('_', chr(0))  # Replace underscore with a null character temporarily\n    result = ''.join('_' if char == ' ' else ' ' if char == chr(0) else char for char in temp)\n    return result", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with an underscore and underscores with a whitespace in the given string.\n\n    Args:\n    input_string (str): The string to be transformed.\n\n    Returns:\n    str: A new string with spaces and underscores swapped.\n\n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Python_is_Cool')\n    'Python is Cool'\n    \"\"\"\n    # Use a list comprehension for efficiency, replacing spaces with underscore and vice versa\n    return ''.join('_' if char == ' ' else ' ' if char == '_' else char for char in input_string)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s: str) -> str:\n    \"\"\"\n    Replaces all spaces with underscores and vice versa in the given string.\n\n    Args:\n    s (str): The input string to be modified.\n\n    Returns:\n    str: A new string where spaces and underscores are swapped.\n\n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    \"\"\"\n    # Define translation table for swapping spaces and underscores\n    translation = str.maketrans({' ': '_', '_': ' '})\n    return s.translate(translation)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n\n    This function scans through each character in the string. If the character\n    is a space, it's replaced with an underscore, and if it's an underscore,\n    it's replaced with a space.\n\n    Args:\n    s (str): The input string to be modified.\n\n    Returns:\n    str: A new string where spaces and underscores have been swapped.\n\n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Python_is_Awesome')\n    'Python is Awesome'\n    \"\"\"\n    # Use list comprehension for efficient character replacement\n    return ''.join('_' if c == ' ' else ' ' if c == '_' else c for c in s)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces all whitespaces in the string with underscores or underscores with whitespaces.\n\n    Args:\n    s (str): The input string to process.\n\n    Returns:\n    str: A string where spaces and underscores have been swapped.\n\n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Jumanji_The_Jungle')\n    'Jumanji The Jungle'\n    \"\"\"\n    # Use a dictionary to map characters\n    mapping = {' ': '_', '_': ' '}\n    # Use a list comprehension to build the new string\n    # If a character is not in our mapping, it remains unchanged\n    return ''.join(mapping.get(char, char) for char in s)", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n    text (str): The string in which to replace characters.\n\n    Returns:\n    str: A new string with spaces and underscores switched.\n\n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Jumanji_The_Jungle')\n    'Jumanji The Jungle'\n    \"\"\"\n    # Dictionary to map space to underscore and vice versa\n    translation = str.maketrans({' ': '_', '_': ' '})\n    return text.translate(translation)", "matching_cluster_idx": 6}]}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def move_zero(arr):\n    \"\"\"\n    Moves all zeroes in the given list to the end while maintaining the order of the other elements.\n    \n    :param arr: List[int] - The input list which might contain zeros.\n    :return: List[int] - A new list with all zeroes at the end.\n    \n    Examples:\n    >>> move_zero([1,0,2,0,3,4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # Count number of zeros\n    zero_count = arr.count(0)\n    \n    # Filter out zeros and concatenate with zeros at the end\n    result = [num for num in arr if num != 0] + [0] * zero_count\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of the list while maintaining the order of other elements.\n\n    Args:\n    lst (list): The input list which might contain zeroes.\n\n    Returns:\n    list: A new list with all zeroes moved to the end.\n\n    Example:\n    >>> move_zero([1,0,2,0,3,4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # Use list comprehension to get all non-zero elements\n    non_zeroes = [num for num in lst if num != 0]\n    \n    # Calculate how many zeroes we need to append\n    zero_count = len(lst) - len(non_zeroes)\n    \n    # Construct the result list with non-zero elements followed by zeroes\n    return non_zeroes + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the list while maintaining the order of the other elements.\n    \n    :param lst: List with integers, might contain zeroes\n    :return: List with zeroes moved to the end\n    \"\"\"\n    # Create a list of non-zero elements\n    non_zero = [element for element in lst if element != 0]\n    \n    # Count the number of zeros\n    zeros_count = lst.count(0)\n    \n    # Concatenate non-zero elements with the right amount of zeros\n    result = non_zero + [0] * zeros_count\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Moves all zeroes to the end of the list while maintaining the relative order of other elements.\n\n    Args:\n    arr (list): The input list containing integers.\n\n    Returns:\n    list: A new list with all zeros moved to the end.\n\n    Example:\n    >>> move_zero([1, 0, 2, 0, 3, 4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # List to store non-zero elements\n    result = []\n    \n    # Counter for zero occurrences\n    zero_count = 0\n    \n    # Iterate through each element in the list\n    for item in arr:\n        if item != 0:\n            result.append(item)\n        else:\n            zero_count += 1\n    \n    # Append zeros at the end\n    result.extend([0] * zero_count)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of the list while maintaining the order of the other elements.\n    \n    :param lst: List containing elements where zeroes need to be moved to the end\n    :return: A new list with zeroes at the end\n    \"\"\"\n    # Create two lists: one for non-zero elements and one for zeroes\n    non_zeroes = [num for num in lst if num != 0]\n    zeroes = [0] * lst.count(0)\n    \n    # Combine the lists\n    return non_zeroes + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeros to the end of the list while maintaining the order of other elements.\n\n    Args:\n    nums (list): The input list which might contain zeros.\n\n    Returns:\n    list: A new list where all zeros are moved to the end.\n\n    Example:\n    >>> move_zero([1,0,2,0,3,4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for num in nums if num != 0)\n    \n    # Create a new list with all non-zero elements first\n    result = [num for num in nums if num != 0]\n    \n    # Append zeros at the end\n    result.extend([0] * (len(nums) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Moves all zeroes to the end of the list while maintaining the order of other elements.\n    \n    Args:\n    arr (list): The input list that might contain zeroes.\n\n    Returns:\n    list: A new list with all zeroes at the end.\n    \n    Example:\n    >>> move_zero([1,0,2,0,3,4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # Initialize two pointers\n    # 'non_zero' will track the position where the next non-zero should be placed\n    non_zero = 0\n    # Traverse through the list\n    for i in range(len(arr)):\n        if arr[i] != 0:\n            # If current element is not zero, place it at position 'non_zero' and increment\n            arr[non_zero], arr[i] = arr[i], arr[non_zero]\n            non_zero += 1\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list, preserving the order of the other elements.\n\n    Args:\n    lst (list): The list to modify.\n\n    Returns:\n    list: A new list with all zeroes moved to the end.\n\n    Example:\n    >>> move_zero([1,0,2,0,3,4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # Create a list with all non-zero elements\n    non_zero = [item for item in lst if item != 0]\n    # Count the number of zeroes\n    zero_count = len(lst) - len(non_zero)\n    # Extend the list with zeros at the end\n    result = non_zero + [0] * zero_count\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Initialize two pointers\n    # 'write_pos' keeps track of where to write the next non-zero element\n    # 'read_pos' scans through the list\n    write_pos = 0\n    read_pos = 0\n    \n    # Iterate through the list with 'read_pos'\n    for read_pos in range(len(lst)):\n        if lst[read_pos] != 0:\n            # If the element is not zero, move it to 'write_pos'\n            lst[write_pos], lst[read_pos] = lst[read_pos], lst[write_pos]\n            write_pos += 1\n    \n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeros to the end of the list while maintaining the order of other elements.\n    \n    Args:\n    lst (list): The input list containing any number of items where zeros need to be moved.\n\n    Returns:\n    list: A new list with all non-zero elements at the beginning in their original order,\n          followed by all the zeros.\n\n    Example:\n    >>> move_zero([1,0,2,0,3,4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # Count the number of zeros in the list\n    zero_count = lst.count(0)\n    \n    # Filter out the zeros and keep the order of other elements\n    non_zero_list = [num for num in lst if num != 0]\n    \n    # Add the counted number of zeros at the end\n    return non_zero_list + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Moves all zero elements to the end of the list while maintaining the order of the non-zero elements.\n\n    Args:\n    arr (list): A list containing elements to be rearranged.\n\n    Returns:\n    list: A new list with all zeros at the end.\n\n    Example:\n    >>> move_zero([1,0,2,0,3,4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # Create a list of only non-zero elements\n    non_zero = [item for item in arr if item != 0]\n    \n    # Calculate how many zeros there were\n    zero_count = len(arr) - len(non_zero)\n    \n    # Extend the list with zeros\n    non_zero.extend([0] * zero_count)\n    \n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the list in-place.\n    \n    This function rearranges the elements of the input list such that all non-zero\n    elements appear before all zero elements. The relative order of non-zero\n    elements is preserved.\n\n    Args:\n    nums (list): The list containing integers to be rearranged.\n\n    Returns:\n    list: The rearranged list with all zeroes at the end.\n\n    Example:\n    >>> move_zero([1,0,2,0,3,4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # Count the number of zeroes\n    zero_count = nums.count(0)\n    \n    # Remove all zeroes from the list\n    nums[:] = [num for num in nums if num != 0]\n    \n    # Append zeroes back to the end of the list\n    nums.extend([0] * zero_count)\n    \n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of the other elements.\n    \n    Args:\n    arr (list): The input list containing numbers.\n    \n    Returns:\n    list: A new list with all zeros moved to the end.\n    \n    Example:\n    >>> move_zero([1,0,2,0,3,4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # Initialize two pointers\n    # 'non_zero' to keep track of where to put the next non-zero element\n    # 'current' to traverse through the list\n    non_zero = 0\n    current = 0\n    \n    # Traverse the list\n    while current < len(arr):\n        # If the current element is not zero, move it to the position 'non_zero'\n        if arr[current] != 0:\n            arr[non_zero], arr[current] = arr[current], arr[non_zero]\n            non_zero += 1\n        current += 1\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Moves all zeroes to the end of the given list while maintaining the order of the other elements.\n\n    Args:\n    arr (list): The input list which might contain zeroes.\n\n    Returns:\n    list: A new list with all zeroes moved to the end.\n\n    Example:\n    >>> move_zero([1,0,2,0,3,4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # Count the number of zeros in the array\n    zero_count = arr.count(0)\n    \n    # Filter out the zeros, then append zeros at the end\n    result = [x for x in arr if x != 0]\n    result.extend([0] * zero_count)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of the list while preserving the order of the other elements.\n\n    Args:\n    lst (list): The list to process.\n\n    Returns:\n    list: A new list with all zeroes at the end.\n\n    Example:\n    >>> move_zero([1,0,2,0,3,4])\n    [1,2,3,4,0,0]\n    \"\"\"\n    # List to hold non-zero elements\n    non_zero = [item for item in lst if item != 0]\n    \n    # Count of zeros in the original list\n    zero_count = lst.count(0)\n    \n    # Extend the non-zero list with the zeros\n    result = non_zero + [0] * zero_count\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Moves all zeroes to the end of the given list while maintaining the order of other elements.\n    \n    Args:\n    arr (list): The list containing numbers where zeroes need to be moved to the end.\n\n    Returns:\n    list: A new list with all non-zero elements first, followed by zeroes.\n\n    Example:\n    >>> move_zero([1, 0, 2, 0, 3, 4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # Initialize two pointers\n    next_non_zero = 0  # Index to place next non-zero number\n    \n    # Traverse the array\n    for i in range(len(arr)):\n        # If current number is non-zero\n        if arr[i] != 0:\n            # Swap the current number with the element at next_non_zero index\n            arr[next_non_zero], arr[i] = arr[i], arr[next_non_zero]\n            # Move the next_non_zero pointer forward\n            next_non_zero += 1\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Moves all zero elements to the end of the list while maintaining the order of other elements.\n    \n    Args:\n    arr (list): The list containing integers including zeros.\n    \n    Returns:\n    list: A new list where all zeros have been moved to the end.\n    \n    Example:\n    >>> move_zero([1,0,2,0,3,4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # Create two lists, one for non-zero elements and one for zeros\n    non_zeros = [item for item in arr if item != 0]\n    zeros = [0] * arr.count(0)\n    \n    # Combine non-zero elements followed by zeros\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list while maintaining the order of other elements.\n    \n    :param nums: List[int] - The input list containing integers with zeroes.\n    :return: List[int] - The list with all zeroes moved to the end.\n    \n    Example:\n    >>> move_zero([1, 0, 2, 0, 3, 4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    # Create a new list to store non-zero elements\n    result = [num for num in nums if num != 0]\n    \n    # Extend this list with the number of zeros found in the original list\n    result.extend([0] * nums.count(0))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of the list while maintaining the order of the other elements.\n\n    Args:\n    lst (list): The input list containing any type of elements, where some might be zero.\n\n    Returns:\n    list: A new list where all non-zero elements are at the beginning in their original order,\n          followed by all zeros.\n\n    Examples:\n    >>> move_zero([1,0,2,0,3,4])\n    [1, 2, 3, 4, 0, 0]\n    >>> move_zero([0,1,0,3,12])\n    [1, 3, 12, 0, 0]\n    \"\"\"\n    # Filter out non-zero elements and extend with zeros\n    # This uses list comprehension for non-zero elements followed by zeros\n    return [x for x in lst if x != 0] + [0] * lst.count(0)", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Moves all zero elements to the end of the list while preserving the order of the other elements.\n    \n    :param arr: List of integers potentially containing zeros\n    :return: List with all zeros at the end\n    \"\"\"\n    # Count of zeros to be moved\n    zero_count = 0\n    result = []\n\n    # First pass: Move non-zero elements to the result list\n    for num in arr:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n    \n    # Append zeros to the result\n    result.extend([0] * zero_count)\n    \n    return result", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 89.75609756097562, "dps_norm": 49.166666666666664, "pass@1": 41.0, "profiled": [{"solution": "def pair_xor_Sum(nums, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate XOR of pair (i, j) and add to the total\n            total_sum += nums[i] ^ nums[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs in the list.\n    \n    :param arr: List of integers\n    :param n: Size of the list (though this can be calculated from arr, we use it as given for efficiency)\n    :return: Integer sum of all pair-wise XOR operations\n    \"\"\"\n    # Initialize result\n    result = 0\n    \n    # Perform XOR sum for all pairs where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR of pair (arr[i], arr[j]) and add to result\n            result += arr[i] ^ arr[j]\n    \n    # Since each pair is counted twice in the above nested loop, we divide by 2\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute XOR for each pair and add to total\n            xor_value = nums[i] ^ nums[j]\n            total_xor_sum += xor_value\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculate the sum of XOR of all possible pairs in a list.\n\n    :param nums: List of integers to consider for XOR operations.\n    :param n: The number of elements in nums, provided for efficiency.\n    :return: The sum of XOR operations between all pairs.\n\n    Examples:\n    >>> pair_xor_Sum([5,9,7,6], 4)\n    47\n    \"\"\"\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR the pair of numbers and add to total\n            total += nums[i] ^ nums[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the list.\n\n    This function computes the XOR sum for every possible pair of numbers in the list\n    and returns the total sum.\n\n    Args:\n    nums (list of int): List of integers to calculate XOR from.\n    n (int): Length of the list (provided for consistency with the assertion, \n             although in practice, len(nums) could be used).\n\n    Returns:\n    int: The sum of XOR operations for all pairs.\n\n    Examples:\n    >>> pair_xor_Sum([5, 9, 7, 6], 4)\n    47\n    \"\"\"\n    total = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            # XOR of pair\n            xor = nums[i] ^ nums[j]\n            total += xor\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculate the sum of XOR operations for all pairs in the given array.\n\n    This function computes (arr[i] XOR arr[j]) for all possible pairs (i,j)\n    where i < j. \n\n    Args:\n    arr (List[int]): List of integers to operate on.\n    n (int): The number of elements to consider from the list.\n\n    Returns:\n    int: Sum of all XOR operations of pairs.\n\n    Example:\n    >>> pair_xor_Sum([5,9,7,6], 4)\n    47\n    \"\"\"\n    if n <= 1:\n        return 0  # No pairs can be formed if there are less than 2 elements\n\n    total_xor_sum = 0\n    \n    # For all pairs, compute XOR and sum them\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]\n    \n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Parameters:\n    - arr: List of integers\n    - n: Length of the list\n    \n    Returns:\n    - Integer sum of XOR operations for all pairs\n    \n    Example:\n    >>> assert pair_xor_Sum([5,9,7,6],4) == 47\n    \"\"\"\n    if n < 2:\n        return 0\n    \n    # Initialize sum of XOR\n    xor_sum = 0\n    \n    # Generate all pairs and calculate their XOR\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs in the array.\n\n    This function computes the XOR sum for each pair of numbers in the list and \n    then returns the total sum of these XOR values.\n\n    Args:\n    arr (list): A list of integers.\n    n (int): The length of the list, provided for consistency with the test case.\n\n    Returns:\n    int: The sum of XOR operations for all pairs.\n\n    Example:\n    >>> pair_xor_Sum([5,9,7,6], 4)\n    47\n    \"\"\"\n    # Total sum of XORs\n    xor_sum = 0\n    \n    # Generate all pairs and calculate XOR for each\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR of current pair\n            pair_xor = arr[i] ^ arr[j]\n            # Add to total sum\n            xor_sum += pair_xor\n\n    return xor_sum", "matching_cluster_idx": 1}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs in the given list.\n\n    :param arr: List of integers\n    :param n: Number of elements in the list\n    :return: Sum of XOR of all possible pairs\n\n    Example:\n    >>> assert pair_xor_Sum([5,9,7,6],4) == 47\n    \"\"\"\n    # Initialize sum to zero\n    xor_sum = 0\n    \n    # Nested loop to iterate over all pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR the two numbers and add to sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XOR of all possible pairs in the list.\n    \n    :param arr: List of integers\n    :param n: Number of elements in the list\n    :return: Integer representing the sum of XOR of all pairs\n    \"\"\"\n    # If the number of elements is 1, return 0 since there's no pair\n    if n <= 1:\n        return 0\n    \n    # Initialize sum\n    total = 0\n    \n    # Nested loops to compare each number with every other number\n    for i in range(n):\n        for j in range(i+1, n):\n            # XOR of the current pair\n            xor = arr[i] ^ arr[j]\n            total += xor\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the list.\n\n    :param numbers: List of integers to compute the XOR sum from.\n    :param n: The number of elements in the list.\n    :return: The sum of XOR operations of all possible pairs.\n    \"\"\"\n    total_sum = 0\n    # Iterate through all pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR the pair and add to total\n            total_sum += numbers[i] ^ numbers[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculate the sum of XOR for all pairs in the given list.\n\n    This function computes the sum of all pairwise XOR operations within \n    the list. The complexity is O(n^2) where n is the length of the array.\n\n    Args:\n    arr (List[int]): List of integers to process.\n    n (int): The number of elements in the list, expected to be equal to len(arr).\n\n    Returns:\n    int: The sum of XOR of all pairs of numbers in the list.\n\n    Example:\n    >>> assert pair_xor_Sum([5,9,7,6], 4) == 47\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR of each pair\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XOR of all possible pairs from the given list.\n\n    :param arr: List of integers to calculate from.\n    :param n: Length of the list, assumed to be provided for performance optimization.\n    :return: Sum of XOR of all pairs.\n\n    Example:\n    >>> assert pair_xor_Sum([5,9,7,6],4) == 47\n    \"\"\"\n    total_xor = 0\n    # Calculate the XOR sum for every pair in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor += arr[i] ^ arr[j]\n    \n    return total_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculates the sum of XOR operations for all possible pairs in the given list.\n\n    :param numbers: List of integers to perform XOR operations on.\n    :param n: Length of the list, assumed to match len(numbers) for efficiency.\n    :return: The sum of XOR results of all possible pairs.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR of numbers[i] and numbers[j]\n            xor_sum += numbers[i] ^ numbers[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XOR for all pairs in the given list.\n\n    This function computes the sum of XOR operations for each possible \n    pair within the list, where n is the length of the list, not a divisor.\n\n    Args:\n    arr (list of int): The list of integers for which XOR pairs will be calculated.\n    n (int): The length of the list.\n\n    Returns:\n    int: The sum of XOR for all pairs.\n\n    Example:\n    >>> pair_xor_Sum([5,9,7,6], 4)\n    47\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            # XOR the two numbers and add to total sum\n            total_sum += arr[i] ^ arr[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs in the list.\n\n    Parameters:\n    numbers (list of int): The list of numbers to process.\n    n (int): The number of elements in the list.\n\n    Returns:\n    int: The sum of XOR operations for all pairs.\n\n    Example:\n    >>> pair_xor_Sum([5,9,7,6], 4)\n    47\n    \"\"\"\n    # Initialize sum to zero\n    total_sum = 0\n    \n    # Outer loop for the first element in each pair\n    for i in range(n - 1):\n        # Inner loop for the second element in each pair\n        for j in range(i + 1, n):\n            # XOR the pair and add to total\n            total_sum += numbers[i] ^ numbers[j]\n    \n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculate the sum of XOR for all pairs in the list.\n\n    This function uses bitwise operations to efficiently compute the sum of XOR for every\n    possible pair in the list.\n\n    Args:\n    arr (list): A list of integers.\n    n (int): The length of the list, should match len(arr).\n\n    Returns:\n    int: The sum of XOR for all pairs.\n\n    Example:\n    >>> pair_xor_Sum([5, 9, 7, 6], 4)\n    47\n    \"\"\"\n    total = 0\n    \n    # Iterate through all unique pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i+1, n):\n            # Compute XOR of the pair and add to the total\n            xor_val = arr[i] ^ arr[j]\n            total += xor_val\n\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculate the sum of XOR for all pairs in the given list.\n\n    This function computes the XOR of each pair from the list and sums these values.\n    The time complexity is O(n^2) where n is the length of nums.\n\n    Args:\n    nums (list of int): List of integers to process.\n    n (int): Length of the list, provided for consistency with the assert statement.\n\n    Returns:\n    int: The sum of XOR operations of all pairs.\n\n    Examples:\n    >>> pair_xor_Sum([5,9,7,6],4)\n    47\n    \"\"\"\n    total_sum = 0\n    # Iterate through all possible pairs with i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += nums[i] ^ nums[j]  # XOR operation\n    \n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculate the sum of XOR for all pairs of numbers in the given list.\n    \n    :param numbers: List of integers to compute XOR pairs from.\n    :param n: Length of the list.\n    :return: Integer sum of all XOR operations between pairs.\n    \n    Example:\n    >>> assert pair_xor_Sum([5,9,7,6], 4) == 47\n    \"\"\"\n    # Initialize the sum\n    total = 0\n    \n    # Loop through all possible pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR the pair and add to total\n            total += numbers[i] ^ numbers[j]\n    \n    # Return twice the sum since each pair is calculated twice\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs of numbers in the list.\n\n    :param numbers: List of integers\n    :param n: The length of the list, assumed to be equal to len(numbers)\n    :return: Sum of XOR of all possible pairs\n\n    Example:\n    >>> pair_xor_Sum([5,9,7,6], 4)\n    47\n    \"\"\"\n    total = 0\n    # Generate all pairs and compute their XOR\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_value = numbers[i] ^ numbers[j]\n            total += xor_value\n    \n    return total", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 65.79787234042553, "dps_norm": 72.33333333333333, "pass@1": 93.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n    \n    This function takes an array and reverses the elements from the beginning\n    up to (but not including) the index k. If k is greater than or equal to \n    the length of the array, it will reverse the entire array.\n\n    Parameters:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: A new list with elements reversed up to index k-1.\n\n    Raises:\n    ValueError: If k is negative or greater than the length of the array.\n\n    Example:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    # Check if k is within the bounds of the array\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array inclusive.\")\n\n    # Create a new list to avoid modifying the original\n    result = arr.copy()\n    \n    # Swap elements from 0 to k-1\n    i, j = 0, k - 1\n    while i < j:\n        result[i], result[j] = result[j], result[i]\n        i += 1\n        j -= 1\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n    \n    This function takes an array and a position k, and reverses\n    the portion of the array from the start up to (but not including) k.\n\n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: A new list with the first k elements in reverse order,\n          followed by the rest of the array unchanged.\n\n    Raises:\n    ValueError: If k is out of the array bounds or if the array is empty.\n\n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    >>> reverse_Array_Upto_K([1], 1)\n    [1]\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array is empty.\")\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k is out of bounds of the array.\")\n    \n    # Reverse the part of the array up to k\n    return arr[k-1::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the elements of the array up to the k-th position (inclusive).\n    \n    Parameters:\n    - arr (list): The input array to be partially reversed.\n    - k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    - list: A new list where elements up to k are reversed.\n    \n    Raises:\n    - ValueError: If k is greater than the length of the array or less than 1.\n    \n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    >>> reverse_Array_Upto_K([1, 2, 3], 3)\n    [3, 2, 1]\n    >>> reverse_Array_Upto_K([1, 2, 3, 4], 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: k should be between 1 and the length of the array\n    \"\"\"\n    # Check if k is valid\n    if k > len(arr) or k < 1:\n        raise ValueError(\"k should be between 1 and the length of the array\")\n    \n    # Slice the list into two parts, reverse the first part and concatenate\n    return arr[k-1::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n    \n    :param arr: List of integers to be partially reversed\n    :param k: Position up to which the array should be reversed\n    :return: New list with elements up to k reversed\n    \n    :raises ValueError: If k is out of bounds or not an integer\n\n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    # Check if k is valid\n    if not isinstance(k, int) or k < 1 or k > len(arr):\n        raise ValueError(\"k must be a positive integer and within the bounds of the array length\")\n\n    # Slice the list up to k, reverse it, and then concatenate with the rest of the list\n    return arr[k-1::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n    \n    :param arr: List of integers to be partially reversed\n    :param k: Integer indicating how many elements from the start should be reversed\n    :return: New list with the first k elements reversed\n    \n    :example:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    # Check if k is within bounds\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array\")\n    \n    # Slice the first k elements, reverse them, then concatenate with the rest\n    return arr[k-1::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of an array up to a specified position.\n    \n    Args:\n    arr (list): The input array to be reversed.\n    k (int): The position up to which the array should be reversed (1-indexed).\n    \n    Returns:\n    list: A new list with elements reversed up to index k-1.\n    \n    Raises:\n    ValueError: If k is out of range of the array length or if k is less than or equal to 0.\n    \"\"\"\n    # Check if k is valid\n    if k <= 0 or k > len(arr):\n        raise ValueError(\"k must be greater than 0 and less than or equal to the array length\")\n    \n    # Slice the array up to k, reverse this part, then concatenate with the rest\n    return arr[k-1::-1] + arr[k:]  # Here k-1 because array indexing is 0-based but k is 1-based", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n\n    Parameters:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array will be reversed.\n\n    Returns:\n    list: A new array with the elements up to index k-1 reversed.\n\n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n\n    >>> reverse_Array_Upto_K([9, 8, 7, 6, 5, 4, 3, 2, 1], 7)\n    [3, 4, 5, 6, 7, 8, 9, 2, 1]\n    \"\"\"\n    # Check if k is valid\n    if k > len(arr) or k <= 0:\n        raise ValueError(\"k must be between 1 and the length of the array inclusive\")\n\n    # Create a new array where the first k elements are reversed\n    reversed_part = arr[k-1::-1]  # Reverse from k-1 to 0\n    # Combine the reversed part with the unchanged part\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses elements in the array 'arr' up to the position 'k'.\n    \n    Args:\n    arr (list): The input list to be partially reversed.\n    k (int): The position up to which the list should be reversed (1-indexed).\n    \n    Returns:\n    list: A new list with elements reversed up to the k-th position.\n    \n    Example:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        raise ValueError(\"K must be within the bounds of the array length.\")\n\n    # Convert k to 0-indexed position\n    k -= 1\n    # Slice and reverse the portion of the list up to k\n    reversed_portion = arr[:k+1][::-1]\n    # Combine the reversed portion with the rest of the list\n    return reversed_portion + arr[k+1:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to the k-th position.\n\n    Args:\n    arr (list): The input array to be reversed partially.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: A new list with elements reversed from index 0 to k-1.\n\n    Raises:\n    ValueError: If k is out of the range of the array index.\n\n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    # Check if k is within the array bounds\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k should be between 0 and the length of the array\")\n\n    # Reverse the slice up to k\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of an array up to a given position k.\n\n    Args:\n    arr (list): The input list to be partially reversed.\n    k (int): The position up to which the array needs to be reversed.\n\n    Returns:\n    list: A new list where elements up to index k-1 are reversed.\n\n    Raises:\n    ValueError: If k is out of the list bounds.\n\n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    >>> reverse_Array_Upto_K([10, 20, 30], 2)\n    [20, 10, 30]\n    \"\"\"\n    # Check if k is within bounds\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k must be between 1 and the length of the array inclusive.\")\n\n    # Create a slice of the array up to k, reverse it, and concatenate with the rest of the array\n    return arr[k-1::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the elements of an array up to a specified position.\n\n    This function modifies the input array by reversing its elements\n    from index 0 to k-1, while keeping the rest of the array unchanged.\n\n    Parameters:\n    arr (list): The array to be modified.\n    k (int): The position up to which the array should be reversed. \n             Note: k is 1-indexed here, where the full length of the \n             array would be reversed if k > len(arr).\n\n    Returns:\n    list: A new list with elements reversed up to position k.\n\n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    >>> reverse_Array_Upto_K([1, 2, 3], 1)\n    [1, 2, 3]\n    \"\"\"\n    # Adjust k for 0-indexing\n    k = min(k, len(arr))  # Prevent index out of range if k > len(arr)\n    \n    # Slice the array up to k-1, reverse it, then combine with the rest\n    return list(reversed(arr[:k])) + arr[k:]", "matching_cluster_idx": 9}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses a portion of the array up to the given position k.\n    \n    Args:\n    arr (list): The input list to be partially reversed.\n    k (int): The position up to which the list should be reversed.\n    \n    Returns:\n    list: A new list where elements from 0 to k-1 are reversed,\n          and elements from k onwards remain unchanged.\n    \n    Raises:\n    ValueError: If k is out of bounds of the array length.\n\n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    >>> reverse_Array_Upto_K([9, 8, 7, 6, 5], 2)\n    [8, 9, 7, 6, 5]\n    \"\"\"\n    # Check if k is within the array bounds\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k is out of bounds\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to the k-th element.\n\n    Parameters:\n    - arr: List of integers to be partially reversed.\n    - k: Integer, the position up to which the array should be reversed.\n\n    Returns:\n    - List with elements up to k-th position reversed.\n\n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n\n    Raises:\n    - ValueError if k is greater than the length of the array or less than 1.\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k must be between 1 and the length of the array inclusive.\")\n    \n    # Reverse the first k elements\n    reversed_part = arr[:k][::-1]\n    \n    # Combine the reversed part with the rest of the array\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the elements of an array up to a specified position k.\n    \n    Parameters:\n    - arr (list): The input array to be partially reversed.\n    - k (int): The position up to which the array should be reversed (inclusive).\n    \n    Returns:\n    - list: A new list with elements up to index k reversed.\n    \n    Raises:\n    - ValueError: If k is greater than the length of the array or less than 0.\n    \"\"\"\n    # Check if k is within bounds\n    if k > len(arr) or k < 0:\n        raise ValueError(\"k must be between 0 and the length of the array inclusive.\")\n    \n    # If k equals the length of the array or 0, return the array as is or reversed entirely\n    if k == len(arr):\n        return list(reversed(arr))\n    elif k == 0:\n        return arr\n    \n    # Slice the array up to k, reverse it, and then concatenate with the remainder\n    return list(reversed(arr[:k])) + arr[k:]", "matching_cluster_idx": 9}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of an array up to a given position k.\n    \n    Parameters:\n    arr (list): The input array to be reversed partially.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: A new array with elements reversed up to index k-1.\n    \n    Example:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    # Check if k is within the bounds of the array\n    if k > len(arr):\n        raise ValueError(\"k is larger than the array size\")\n    \n    # Slice the array up to k, reverse it, then concatenate with the rest\n    reversed_part = arr[:k][::-1]\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n\n    Args:\n    arr (list): The input list to be partially reversed.\n    k (int): The index up to which the array should be reversed (0-indexed).\n\n    Returns:\n    list: A new list with elements reversed up to the k-th position.\n\n    Raises:\n    ValueError: If k is out of the range of the array length or negative.\n\n    Example:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    # Check if k is valid\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n\n    # If k is at or beyond the end of the list, return a simple reverse of the whole list\n    if k >= len(arr):\n        return arr[::-1]\n\n    # Reverse the first k elements and concatenate with the rest\n    return arr[k-1::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n    \n    Parameters:\n    arr (list): The input array to be reversed partially.\n    k (int): The position up to which the array should be reversed (1-indexed).\n    \n    Returns:\n    list: A new array where elements up to k are reversed, and the rest remain in order.\n    \n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    # Adjust k to be 0-indexed for slicing\n    k = k - 1\n    \n    # If k is less than 0 or greater than or equal to the array length, return the original array\n    if k < 0 or k >= len(arr):\n        return arr[:]\n    \n    # Slice the array up to k, reverse it, and concatenate with the rest\n    return arr[:k+1][::-1] + arr[k+1:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to the given position k.\n    \n    Args:\n    arr (list): The input array to be reversed partially.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: A new list with elements reversed from index 0 to k-1.\n\n    Raises:\n    ValueError: If k is out of range of the array indices.\n\n    Example:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    if k > len(arr) or k < 0:\n        raise ValueError(\"k is out of range for the given array.\")\n    \n    # Slice the array to reverse up to k, reverse it, and concatenate with the rest\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the given array up to the k-th position.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: A new array with elements reversed up to index k-1, or the original array if k is out of bounds.\n    \n    Example:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    # If k is 0 or less, or greater than the array length, return the array as is\n    if k <= 0 or k > len(arr):\n        return arr.copy()  # Return a copy to ensure immutability of original\n    \n    # Use slicing to reverse the part of the array up to k\n    return arr[k-1::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the portion of the array up to index k-1, keeping the rest unchanged.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: A new array with the first k elements in reverse order, followed by the remaining elements.\n    \n    Raises:\n    ValueError: If k is greater than the length of the array or less than or equal to 0.\n    \n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    >>> reverse_Array_Upto_K(['a', 'b', 'c'], 2)\n    ['b', 'a', 'c']\n    \"\"\"\n    if k > len(arr) or k <= 0:\n        raise ValueError(\"k must be between 1 and the length of the array.\")\n    \n    # Slice the array into two parts: up to k and after k\n    first_part = arr[:k]\n    second_part = arr[k:]\n    \n    # Reverse the first part\n    first_part.reverse()\n    \n    # Combine the reversed first part with the unchanged second part\n    return first_part + second_part", "matching_cluster_idx": 10}]}, "Mbpp/720": {"dps": 85.57692307692308, "dps_norm": 94.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(existing_tuple, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of an existing tuple.\n\n    Args:\n    existing_tuple (tuple): A tuple to which the dictionary will be appended.\n    dictionary (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple with the original items plus the dictionary.\n\n    Example:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    # Create a new tuple by combining the existing tuple with the dictionary\n    return existing_tuple + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, dictionary):\n    \"\"\"\n    Add a dictionary to the end of a given tuple.\n\n    Args:\n    input_tuple (tuple): The initial tuple to which the dictionary will be added.\n    dictionary (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended to the end of the original tuple.\n\n    Example:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    return input_tuple + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(base_tuple, dict_to_add):\n    \"\"\"\n    Adds a dictionary to the end of a given tuple.\n\n    Args:\n    base_tuple (tuple): The original tuple to which the dictionary will be added.\n    dict_to_add (dict): The dictionary to be appended to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary added to the end of the base tuple.\n\n    Example:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    # Convert the tuple to a list, add the dictionary, and then convert back to tuple\n    return tuple(list(base_tuple) + [dict_to_add])", "matching_cluster_idx": 2}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to append to the tuple.\n\n    Returns:\n    tuple: A new tuple with the original tuple contents followed by the dictionary.\n\n    Examples:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    # Combine the tuple with a single-element tuple containing the dictionary\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"\n    Adds a dictionary to a given tuple, returning a new tuple with the dictionary as the last element.\n\n    Args:\n    tup (tuple): The original tuple to which the dictionary will be appended.\n    dic (dict): The dictionary to append to the tuple.\n\n    Returns:\n    tuple: A new tuple with all elements from the original tuple followed by the dictionary.\n\n    Example:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    # Convert tuple to list for modification, append dictionary, then convert back to tuple\n    return tuple(list(tup) + [dic])", "matching_cluster_idx": 2}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Args:\n    tup (tuple): The original tuple to which the dictionary will be added.\n    dictionary (dict): The dictionary to append to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended to the end of the original tuple.\n\n    Examples:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    # Create a new tuple by combining the original tuple with the dictionary\n    new_tuple = tup + (dictionary,)\n    return new_tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(initial_tuple, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a given tuple.\n\n    This function takes a tuple and a dictionary, and returns a new tuple\n    with the original tuple's elements followed by the dictionary.\n\n    Args:\n    initial_tuple (tuple): The initial tuple to which the dictionary will be added.\n    dictionary (dict): The dictionary to be appended to the tuple.\n\n    Returns:\n    tuple: A new tuple containing all elements of `initial_tuple` followed by `dictionary`.\n\n    Examples:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    # Convert tuple to list, append dictionary, and then convert back to tuple\n    return tuple(list(initial_tuple) + [dictionary])", "matching_cluster_idx": 2}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a given tuple and returns the new tuple.\n\n    Args:\n    tup (tuple): The original tuple to which the dictionary will be added.\n    dictionary (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n\n    Example:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict_to_add):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple to which the dictionary will be added.\n    dict_to_add (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n\n    Examples:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    # Create a new tuple with the original elements plus the dictionary\n    return tup + (dict_to_add,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(base_tuple, dictionary):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the result as a tuple.\n\n    Args:\n    base_tuple (tuple): The base tuple to which the dictionary will be appended.\n    dictionary (dict): The dictionary to append to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended to the end of the original tuple.\n\n    Example:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    # Create a new tuple by appending the dictionary to the base tuple\n    return base_tuple + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Args:\n    input_tuple (tuple): The initial tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple with the original elements followed by the dictionary.\n\n    Example:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple to which the dictionary will be appended.\n    dictionary (dict): The dictionary to be appended to the tuple.\n\n    Returns:\n    tuple: A new tuple with the original elements followed by the dictionary.\n\n    Examples:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    # Concatenate the tuple with a tuple containing the dictionary\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(initial_tuple, dict_to_add):\n    \"\"\"\n    Adds a dictionary to the end of a given tuple and returns the new tuple.\n\n    Args:\n    initial_tuple (tuple): The starting tuple to which we will add the dictionary.\n    dict_to_add (dict): The dictionary to be appended to the tuple.\n\n    Returns:\n    tuple: A new tuple with the original elements of `initial_tuple` followed by `dict_to_add`.\n\n    Examples:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n\n    \"\"\"\n    # Create a new tuple by concatenating the original tuple with the dictionary\n    return initial_tuple + (dict_to_add,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"\n    Add a dictionary to a tuple and return the resulting tuple.\n    \n    Parameters:\n    tup (tuple): The original tuple to which the dictionary will be added.\n    dic (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: A new tuple with the original tuple elements followed by the dictionary.\n    \n    Examples:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a given tuple.\n\n    Parameters:\n    input_tuple (tuple): The input tuple to which the dictionary will be appended.\n    dictionary (dict): The dictionary to append to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended to the end.\n\n    Examples:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    return input_tuple + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"\n    Adds a dictionary to a given tuple and returns a new tuple with the dictionary as the last element.\n\n    Parameters:\n    - tup (tuple): The input tuple to which the dictionary will be appended.\n    - dic (dict): The dictionary to be appended to the tuple.\n\n    Returns:\n    - tuple: A new tuple where the dictionary is the final element.\n\n    Example:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(base_tuple, new_dict):\n    \"\"\"\n    Add a dictionary to the end of a tuple.\n\n    This function takes a tuple and a dictionary as arguments and returns\n    a new tuple with the original tuple elements followed by the dictionary.\n\n    Args:\n    base_tuple (tuple): The initial tuple to which the dictionary will be appended.\n    new_dict (dict): The dictionary to append to the tuple.\n\n    Returns:\n    tuple: A new tuple with elements from base_tuple followed by new_dict.\n\n    Example:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    # Combine the base tuple with a tuple containing the dictionary\n    return base_tuple + (new_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Add a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The initial tuple to which we'll append the dictionary.\n    dictionary (dict): The dictionary to be added at the end of the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended to the original tuple.\n\n    Example:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"\n    Adds a dictionary to the end of a given tuple.\n\n    Parameters:\n    tup (tuple): The original tuple to which the dictionary will be added.\n    dic (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended to the end.\n\n    Example:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Add a dictionary to a tuple, returning a new tuple with the dictionary as its last element.\n\n    Args:\n    tup (tuple): The initial tuple to which we will add the dictionary.\n    dictionary (dict): The dictionary to be appended to the tuple.\n\n    Returns:\n    tuple: A new tuple containing all elements of the original tuple plus the dictionary.\n\n    Examples:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3})\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    # Create a new tuple by concatenating the existing tuple with the dictionary\n    return tup + (dictionary,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 77.8415300546448, "dps_norm": 76.25, "pass@1": 85.0, "profiled": [{"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extract values between quotation marks in the given string.\n\n    Args:\n    text (str): A string containing quoted text.\n\n    Returns:\n    list: A list of strings that were within quotation marks.\n\n    Examples:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Regular expression to find all quoted strings\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts strings enclosed in double quotes from the given string.\n\n    This function uses a regular expression to find all substrings\n    that are enclosed within double quotes in the input string.\n\n    Parameters:\n    s (str): The input string containing quoted values.\n\n    Returns:\n    list: A list of strings that were between double quotes.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Use regex to find all text within double quotes\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts all substrings that are enclosed in double quotes from the given text.\n\n    Args:\n    text (str): The string from which to extract quoted substrings.\n\n    Returns:\n    list: A list of strings that were found between quotation marks.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Use regex to find all text between quotes\n    # The pattern '\"([^\"]*)\"' looks for anything between quotes, excluding the quotes themselves\n    matches = re.findall(r'\"([^\"]*)\"', text)\n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extract values between quotation marks from the given string.\n\n    This function uses a regular expression to find all substrings \n    enclosed by double quotes.\n\n    Args:\n    input_string (str): The string to search for quoted values.\n\n    Returns:\n    list: A list of strings found within quotes.\n\n    Examples:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # The regex pattern looks for anything between double quotes\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts strings enclosed in quotation marks from the given text.\n\n    Args:\n    text (str): The string from which to extract quoted text.\n\n    Returns:\n    list: A list of strings that were enclosed in quotes within the text.\n\n    Examples:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # The regular expression looks for content inside double quotes, \n    # capturing everything between \" and \"\n    pattern = r'\"(.*?)\"'\n    # Find all matches in the text, 're.DOTALL' allows . to match newline characters\n    matches = re.findall(pattern, text, re.DOTALL)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the given string.\n\n    Args:\n    text (str): The string to extract quoted substrings from.\n\n    Returns:\n    list: A list of strings found between quotation marks.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # This pattern matches everything between double quotes\n    pattern = r'\"([^\"]*)\"'\n    # Using findall to return all non-overlapping matches of the pattern in the string\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s: str) -> list:\n    \"\"\"\n    Extracts values enclosed in quotation marks from a string.\n\n    This function uses a regular expression to find all occurrences of text \n    between double quotes in the provided string, stripping away the quotes.\n\n    Args:\n        s (str): The input string containing text within quotation marks.\n\n    Returns:\n        list: A list of strings, where each string was between quotes in the input.\n\n    Examples:\n        >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n        ['A53', 'multi', 'Processor']\n\n    Raises:\n        None: This function assumes well-formed input and does not raise exceptions.\n    \"\"\"\n    # Regular expression to find all quoted substrings\n    pattern = r'\"([^\"]*)\"'\n    # Find all matches and return them in a list\n    return re.findall(pattern, s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the given string.\n    \n    Args:\n    input_string (str): The string to search for quoted text.\n\n    Returns:\n    list: A list of strings where each string was between double quotes in the input.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Use regex to find all quoted strings, removing the quotes from the match\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the given string.\n\n    Args:\n    s (str): The input string containing quoted text.\n\n    Returns:\n    list: A list of strings where each string was within double quotes in the original text.\n\n    Examples:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Use regex to find all occurrences of quoted text\n    # The pattern looks for anything enclosed in double quotes but not containing quotes itself\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from the given string.\n    \n    Args:\n    s (str): The input string containing quoted phrases.\n    \n    Returns:\n    list: A list of strings where each string was enclosed in quotes in the original input.\n    \n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Use regex to find all sequences enclosed in quotation marks\n    # The pattern r'\"([^\"]*)\"' means:\n    # - \\\" matches a quotation mark\n    # - (...) captures anything within parentheses\n    # - [^\"]* matches zero or more characters that are not a quotation mark\n    match_list = re.findall(r'\"([^\"]*)\"', s)\n    return match_list", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regex to find all substrings enclosed in quotation marks\n    matches = re.findall(r'\"([^\"]*)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the provided string.\n\n    Args:\n    text (str): The string to search for quoted substrings.\n\n    Returns:\n    list: A list of strings found within double quotes.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Use regex to find all strings inside quotation marks\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts all substrings that are enclosed by quotation marks in the given string.\n\n    Args:\n    text (str): The string from which to extract quoted substrings.\n\n    Returns:\n    list: A list of strings that were between quotation marks.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Use regex to find all text enclosed in quotation marks\n    # The pattern looks for any character except a quote, zero or more times, \n    # that is enclosed by quotes\n    pattern = r'\"([^\"]*)\"'\n    # re.findall will return a list of all non-overlapping matches in the string\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts strings enclosed in double quotation marks from the given text.\n\n    This function uses a regular expression to find all substrings that are \n    enclosed within double quotes, excluding the quotes themselves.\n\n    Args:\n    text (str): The string from which to extract quoted values.\n\n    Returns:\n    list: A list of strings that were between quotation marks.\n\n    Examples:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Regular expression pattern to match quoted strings\n    pattern = r'\"([^\"]*)\"'\n    # Find all matches and return them in a list\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts all substrings from the given text that are enclosed in double quotes.\n\n    Args:\n    text (str): The string from which to extract quoted substrings.\n\n    Returns:\n    list: A list of strings that were between double quotes.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # This regex pattern looks for any characters enclosed by double quotes\n    # (?:\\\\.|[^\"\\\\]) means either an escaped character or any character except \"\n    # The non-greedy quantifier *? ensures that it stops at the first closing quote\n    matches = re.findall(r'\"(?:\\\\.|[^\"\\\\])*\"', text)\n    # Strip out the quotation marks from each match\n    return [match[1:-1] for match in matches]", "matching_cluster_idx": 2}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts all text enclosed in double quotes from the given string.\n\n    Args:\n    text (str): A string containing quoted text.\n\n    Returns:\n    list: A list of strings, each being a word or phrase found within quotes.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Use regex to find all quoted strings\n    # The pattern '\".*?\"' finds any sequence enclosed by double quotes\n    matches = re.findall(r'\"([^\"]*)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts all substrings enclosed in quotation marks from the given string.\n\n    Args:\n    text (str): The string to search for quoted text.\n\n    Returns:\n    list: A list of strings that were enclosed in quotation marks.\n\n    Example:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Use regex to find all strings between double quotes\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all text within quotation marks\n    # This pattern looks for anything between \" and \" excluding the quotes themselves\n    matches = re.findall(r'\"([^\"]*)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the given string.\n\n    Args:\n    text (str): The input string containing quoted phrases.\n\n    Returns:\n    list: A list of strings found within quotation marks.\n\n    Examples:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    # Use regex to find all occurrences of strings within quotes\n    matches = re.findall(r'\"([^\"]*)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regex to find all content within double quotes\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 5}]}, "Mbpp/732": {"dps": 68.56589147286822, "dps_norm": 92.0, "pass@1": 93.0, "profiled": [{"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n    text (str): The string to modify.\n\n    Returns:\n    str: A new string where all spaces, commas, and dots are replaced with a colon.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Create a translation table. \n    # The characters in the first string are mapped to the characters at the same position in the second string.\n    trans_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    \n    # Use translate to apply our translation table\n    return text.translate(trans_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon in the given string.\n\n    Args:\n    input_string (str): The input string to be modified.\n\n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n\n    Examples:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    >>> replace_specialchar('No,spaces.or.commas')\n    'No::spaces:or:commas'\n    \"\"\"\n    # Create a translation table that maps each character to be replaced with a colon\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    \n    # Use the translation table to replace characters in the string\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \n    Args:\n    text (str): The input string to process.\n\n    Returns:\n    str: A string with spaces, commas, and dots replaced by colons.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Characters to be replaced\n    replace_chars = [' ', ',', '.']\n    # Replace each specified character with a colon\n    for char in replace_chars:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n    text (str): The string to process.\n\n    Returns:\n    str: A string where all spaces, commas, or dots are replaced with a colon.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Use regex to find spaces, commas, or dots and replace them with a colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n    text (str): The string in which characters are to be replaced.\n\n    Returns:\n    str: The string with special characters replaced by a colon.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Replace spaces, commas, and dots with a colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon in the given string.\n\n    Args:\n    input_string (str): The string to process.\n\n    Returns:\n    str: A new string where spaces, commas, and dots are replaced with colons.\n\n    Examples:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Create a translation table to map spaces, commas, and dots to colons\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    \n    # Use the translation table to replace the characters\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in the given text with a colon.\n\n    Args:\n    text (str): The input string to process.\n\n    Returns:\n    str: A string where all spaces, commas, and dots are replaced by colons.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Use a translation table to replace characters efficiently\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    return text.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n    text (str): The input string which might contain spaces, commas, and dots.\n\n    Returns:\n    str: The modified string where all spaces, commas, and dots are replaced with colons.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Define characters to be replaced\n    chars_to_replace = {' ', ',', '.'}\n    \n    # Use string translation for an efficient replacement\n    translation_table = str.maketrans({char: ':' for char in chars_to_replace})\n    \n    # Translate the string\n    return text.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n    text (str): The input string containing characters to be replaced.\n\n    Returns:\n    str: The string after replacing spaces, commas, and dots with colons.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Create a translation table where space, comma, and dot are replaced by colon\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    \n    # Apply the translation to the text\n    return text.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots in the given text with colons.\n\n    Args:\n    text (str): The string to process.\n\n    Returns:\n    str: A new string where spaces, commas, and dots are replaced with colons.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Define characters to be replaced\n    chars_to_replace = [' ', ',', '.']\n    \n    # Replace each character with a colon\n    for char in chars_to_replace:\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots in the given text with a colon.\n\n    Args:\n    text (str): The input string where special characters need to be replaced.\n\n    Returns:\n    str: A string with all spaces, commas, and dots replaced by colons.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = [' ', ',', '.']\n    \n    # Iterate over each character to be replaced\n    for char in chars_to_replace:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n    input_string (str): The input string to process.\n\n    Returns:\n    str: A string where spaces, commas, and dots are replaced by colons.\n\n    Examples:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Replace spaces, commas, and dots with a colon\n    replacements = {' ', ',', '.'}\n    for char in replacements:\n        input_string = input_string.replace(char, ':')\n    \n    return input_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots in the given text with a colon.\n\n    Args:\n    text (str): The input string where special characters will be replaced.\n\n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n\n    Examples:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Define the characters to be replaced\n    replacements = [' ', ',', '.']\n    \n    # Replace each character in replacements with ':'\n    for char in replacements:\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots in the given string with a colon.\n\n    Args:\n    text (str): The input string where special characters need to be replaced.\n\n    Returns:\n    str: A new string with spaces, commas, and dots replaced by colons.\n\n    Examples:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Characters to be replaced\n    chars_to_replace = [' ', ',', '.']\n    # Replace each character with a colon\n    for char in chars_to_replace:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Define the characters to be replaced\n    special_chars = ' .,'\n    # Replace each special character with a colon\n    return ''.join(':' if char in special_chars else char for char in input_string)", "matching_cluster_idx": 5}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n    text (str): The string to process.\n\n    Returns:\n    str: A new string where all spaces, commas, and dots are replaced by colons.\n\n    Examples:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Define the characters to replace\n    chars_to_replace = (' ', ',', '.')\n    \n    # Replace each character with a colon\n    for char in chars_to_replace:\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in the given text with a colon.\n\n    Args:\n    text (str): The input string containing special characters to be replaced.\n\n    Returns:\n    str: A new string where spaces, commas, and dots are replaced with colons.\n\n    Examples:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = [' ', ',', '.']\n    \n    # For each character in chars_to_replace, replace it with a colon\n    for char in chars_to_replace:\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in the input string with a colon.\n\n    Args:\n    input_string (str): The string where characters will be replaced.\n\n    Returns:\n    str: A string where all spaces, commas, and dots are replaced with a colon.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Create a translation table where space, comma, and dot map to colon\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    \n    # Use the translation table to replace characters in the input string\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n    text (str): The input string to modify.\n\n    Returns:\n    str: A new string with special characters replaced by colons.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Replace spaces, commas, and dots with colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(sentence):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in the given sentence with a colon.\n    \n    Args:\n    sentence (str): The string to process.\n\n    Returns:\n    str: A new string where all spaces, commas, and dots are replaced by colons.\n\n    Example:\n    >>> replace_specialchar('Python language, Programming language.')\n    'Python:language::Programming:language:'\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = ' ,.'\n    \n    # Replace each of these characters with a colon\n    for char in chars_to_replace:\n        sentence = sentence.replace(char, ':')\n    \n    return sentence", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 85.23636363636363, "dps_norm": 76.11111111111111, "pass@1": 88.0, "profiled": [{"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple with elements (key1, value1, key2, value2, ...) to a dictionary {key1: value1, key2: value2, ...}.\n    \n    Args:\n    tup (tuple): A tuple where keys and values are alternating.\n    \n    Returns:\n    dict: A dictionary constructed from the tuple.\n\n    Raises:\n    ValueError: If the length of the tuple is not even.\n\n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Check if the tuple has an even length\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements\")\n\n    # Use dict comprehension with zip to create the dictionary\n    # Here, we assume the first n/2 elements are keys and the second n/2 are values\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple of alternating keys and values into a dictionary.\n    \n    Args:\n    tup (tuple): A tuple where each element at an even index is a key and \n                 the next element is its value.\n    \n    Returns:\n    dict: A dictionary where each pair from the tuple is turned into a key-value pair.\n    \n    Examples:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \n    Raises:\n    ValueError: If the tuple length is not even.\n    \"\"\"\n    # Check if the tuple has an even length\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements\")\n    \n    # Convert tuple to dictionary using dictionary comprehension\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple of alternating keys and values into a dictionary.\n    \n    Args:\n    input_tuple (tuple): A tuple containing alternating keys and values.\n    \n    Returns:\n    dict: A dictionary where each odd-indexed element in the tuple is a key, \n          and each even-indexed element following it is the value.\n    \n    Raises:\n    ValueError: If the input tuple has an odd length, which would leave the last element without a pair.\n\n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Check if tuple length is even to ensure every key has a value\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n\n    # Use list comprehension to pair every two elements from the tuple\n    # Here, we're taking advantage of Python's unpacking in tuple/list operations\n    return dict((input_tuple[i], input_tuple[i+1]) for i in range(0, len(input_tuple), 2))", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple of elements into a dictionary where each key is followed by its value in the tuple.\n\n    Args:\n    tup (tuple): A tuple with an even number of elements where keys and values are alternating.\n\n    Returns:\n    dict: A dictionary where each element at an even index in the tuple becomes a key, \n          and the element at the next index becomes its value.\n\n    Raises:\n    ValueError: If the tuple length is not even or if there are duplicate keys before values.\n\n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Check if the length of the tuple is even\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements.\")\n    \n    # Create the dictionary by using slice notation with a step of 2 for keys and 1 for values\n    try:\n        return dict(zip(tup[::2], tup[1::2]))\n    except ValueError:  # This can happen if the tuple has duplicate keys before values are defined\n        raise ValueError(\"Duplicate keys found before all values could be assigned.\")", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple with adjacent elements into a dictionary where every odd-indexed element \n    becomes a key and the following even-indexed element becomes the value.\n\n    :param tup: Tuple where adjacent elements form key-value pairs\n    :return: Dictionary formed from tuple elements\n    :raises ValueError: If the tuple has an odd number of elements, as the last element would have no pair\n    \"\"\"\n    # Check if the length of the tuple is even, which is necessary for key-value pair creation\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must contain an even number of elements for key-value pairing.\")\n    \n    # Use dictionary comprehension to create the dictionary from adjacent elements\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple with an even number of elements into a dictionary where each pair of elements forms a key-value pair.\n    \n    :param t: Tuple with even number of elements\n    :return: Dictionary where keys and values are alternate elements from the tuple\n    \n    :raises ValueError: If the tuple does not have an even number of elements\n    \n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Check if tuple length is even\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must contain an even number of elements for key-value pairing.\")\n    \n    # Use dictionary comprehension to create the dictionary\n    # t[0::2] gets all even-indexed elements (keys)\n    # t[1::2] gets all odd-indexed elements (values)\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a dictionary where each even index is a key and the next element is its value.\n\n    Args:\n    tup (tuple): A tuple containing pairs of elements where the first of each pair is intended to be a dictionary key,\n                 and the second its value.\n\n    Returns:\n    dict: A dictionary constructed from the tuple.\n\n    Raises:\n    ValueError: If the tuple has an odd number of elements, as the last element would have no pair.\n\n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Check if the tuple length is even, otherwise the last element would have no corresponding value\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements to form key-value pairs.\")\n    \n    # Use dictionary comprehension to build the dictionary\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple into a dictionary where each odd-indexed element becomes a key\n    and the following even-indexed element becomes its value.\n\n    Args:\n    tup (tuple): A tuple where elements at odd indices are keys and even indices are values.\n\n    Returns:\n    dict: A dictionary created from the tuple.\n\n    Raises:\n    ValueError: If the tuple has an odd number of elements, making the last key unmatched.\n\n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Check if the length of the tuple is even\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements to pair keys with values.\")\n    \n    # Use dictionary comprehension to create the dict, slicing with step 2 for keys and values\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple of alternating keys and values to a dictionary.\n\n    This function assumes the input tuple has an even number of elements\n    where each pair of elements is considered as key-value pairs.\n\n    Args:\n    tup (tuple): A tuple containing pairs of items to be converted into dictionary.\n\n    Returns:\n    dict: A dictionary where each key from the tuple maps to its following value.\n\n    Raises:\n    ValueError: If the tuple length is odd, making it impossible to pair elements.\n\n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements.\")\n    \n    # Use dict with zip to pair adjacent elements as key-value pairs\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple of alternating keys and values into a dictionary.\n    \n    This function assumes that the input tuple has an even number of elements,\n    where each even index is a key and each odd index is the corresponding value.\n    \n    Args:\n    t (tuple): A tuple with even length where elements at even indices are keys and elements at odd indices are values.\n    \n    Returns:\n    dict: A dictionary where keys and values are extracted from the tuple in pairs.\n    \n    Raises:\n    ValueError: If the tuple has an odd length.\n    \n    Examples:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Check if tuple has even length\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements to pair up as key-value pairs.\")\n    \n    # Use dictionary comprehension to create dictionary from tuple\n    # The slice step [::2] takes every other element starting from 0 (keys)\n    # The slice step [1::2] takes every other element starting from 1 (values)\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple into a dictionary where each pair of elements \n    from the tuple becomes a key-value pair in the dictionary.\n\n    :param tup: A tuple with an even number of elements where \n                each even index is a key and each odd index is a value.\n    :return: Dictionary where keys are even-indexed elements from the tuple \n             and values are the following elements.\n\n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # If the tuple length is odd, raise an error\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements\")\n    \n    # Use dictionary comprehension to pair elements from the tuple\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple of adjacent elements into a dictionary where each pair of elements \n    represents a key-value pair.\n\n    Args:\n    tup (tuple): A tuple where elements at even indices are keys and \n                 those at odd indices are values.\n\n    Returns:\n    dict: A dictionary created from the tuple.\n\n    Raises:\n    ValueError: If the tuple has an odd number of elements, making it impossible to \n                pair all items.\n\n    Examples:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    >>> tuple_to_dict(('a', 'apple', 'b', 'banana', 'c', 'cat'))\n    {'a': 'apple', 'b': 'banana', 'c': 'cat'}\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must contain an even number of elements.\")\n    \n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple with adjacent elements into a dictionary where the first element of each pair\n    becomes the key and the second becomes the value.\n\n    Args:\n    tup (tuple): A tuple where elements are assumed to be in pairs.\n\n    Returns:\n    dict: A dictionary constructed from the tuple.\n\n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n\n    Raises:\n    ValueError: If the tuple does not have an even number of elements.\n    \"\"\"\n    # Check if the tuple length is even\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The provided tuple must have an even number of elements for pairing.\")\n    \n    # Use dictionary comprehension to create the dictionary from adjacent elements\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple of elements into a dictionary where each odd-indexed element\n    becomes a key and each even-indexed element becomes the corresponding value.\n\n    Args:\n    tup (tuple): A tuple with an even number of elements.\n\n    Returns:\n    dict: A dictionary with key-value pairs formed from the tuple elements.\n\n    Raises:\n    ValueError: If the tuple does not have an even number of elements.\n\n    Examples:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements\")\n    \n    # Use dictionary comprehension to create the dictionary\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a dictionary where each key is followed by its value.\n\n    This function assumes the tuple has an even number of elements where each pair\n    of elements is taken as key-value pairs.\n\n    Parameters:\n    tup (tuple): A tuple containing an even number of elements.\n\n    Returns:\n    dict: A dictionary where the key is the odd-indexed elements and the value \n          are the even-indexed elements of the input tuple.\n\n    Raises:\n    ValueError: If the tuple length is not even.\n\n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Check if the length of the tuple is even\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements.\")\n    \n    # Create dictionary using dictionary comprehension\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple into a dictionary where each pair of elements \n    becomes a key-value pair.\n\n    Args:\n    tup (tuple): A tuple containing an even number of elements \n                 where each pair represents a key-value.\n\n    Returns:\n    dict: A dictionary created from the tuple.\n\n    Raises:\n    ValueError: If the tuple has an odd number of elements.\n\n    Examples:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements to form key-value pairs.\")\n    \n    # Use dictionary comprehension to create the dictionary\n    # Here, we step by 2 to match key with its corresponding value\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple into a dictionary where each pair of elements becomes a key-value pair.\n    \n    :param tup: A tuple with an even number of elements where adjacent elements are paired as key and value.\n    :return: Dictionary where keys and values are derived from adjacent tuple elements.\n    :raises ValueError: If the tuple has an odd number of elements, making pairing impossible.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements to form key-value pairs.\")\n    \n    # Initialize an empty dictionary\n    result = {}\n    \n    # Iterate over the tuple in steps of 2, using slicing to create key-value pairs\n    for i in range(0, len(tup), 2):\n        key = tup[i]\n        value = tup[i + 1]\n        result[key] = value\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple of alternating keys and values into a dictionary.\n\n    Args:\n    tup (tuple): A tuple where every odd index is a key and every even index is a value.\n\n    Returns:\n    dict: A dictionary with keys from odd indices of the tuple and values from even indices.\n\n    Raises:\n    ValueError: If the tuple has an odd number of elements, making it impossible to pair them as key-value pairs.\n\n    Examples:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple should have an even number of elements for proper key-value pairing.\")\n    \n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple of alternating keys and values to a dictionary.\n\n    This function takes a tuple where elements are expected to be in key-value pairs.\n    If the tuple has an odd number of elements, the last element will be ignored.\n\n    Args:\n    tup (tuple): A tuple containing alternating keys and values.\n\n    Returns:\n    dict: A dictionary constructed from the tuple where each even-indexed element \n          (starting from 0) is a key, and the next element is its corresponding value.\n\n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Check if the length of the tuple is even\n    if len(tup) % 2 != 0:\n        print(\"Warning: The last element will be ignored as it has no pair.\")\n    \n    # Use dict comprehension for creating the dictionary from the tuple\n    return {tup[i]: tup[i+1] for i in range(0, len(tup) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple of alternating keys and values into a dictionary.\n    \n    This function assumes that the input tuple has an even number of elements,\n    where each key is followed by its value.\n    \n    Args:\n    tup (tuple): A tuple of elements where keys are at even indices and values at odd indices.\n\n    Returns:\n    dict: A dictionary where the first element of each pair in the tuple is the key,\n          and the second element is the value.\n\n    Raises:\n    ValueError: If the tuple length is not even.\n\n    Examples:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements\")\n    \n    # Use dict comprehension for efficient key-value pairing\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 76.02739726027397, "dps_norm": 82.5, "pass@1": 100.0, "profiled": [{"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None values.\n\n    Args:\n    tup (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if the tuple contains at least one None, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    # Use the 'in' operator to check if None is in the tuple\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    This function iterates through each element of the given tuple\n    and returns True if any element is None, otherwise False.\n\n    Args:\n    tup (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if 'None' is found in the tuple, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    # Use the `in` operator to check if None is in the tuple\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None values.\n\n    Args:\n    tup (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if None is in the tuple, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3, 4, 5))\n    False\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    input_tuple (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if the tuple contains None, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    tup (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if tup contains at least one None, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    This function iterates through each element of the tuple\n    to determine if there is at least one None value.\n\n    Args:\n    tup (tuple): The input tuple to check for None.\n\n    Returns:\n    bool: True if the tuple contains None, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(values):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    values (tuple): A tuple to check for None values.\n\n    Returns:\n    bool: True if the tuple contains at least one None, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    return any(val is None for val in values)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n    \n    Args:\n    tup (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if the tuple contains None, False otherwise.\n    \n    Examples:\n    >>> assert check_none((10, 4, 5, 6, None)) == True\n    >>> assert check_none((1, 2, 3)) == False\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    tup (tuple): A tuple to check for None values.\n\n    Returns:\n    bool: True if None is found in the tuple, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    # Use the any() function with a generator to check for None in the tuple\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    input_tuple (tuple): A tuple to check for None values.\n\n    Returns:\n    bool: True if the tuple contains at least one None, False otherwise.\n\n    Example:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    # Use any() function with a generator expression to find if None exists in the tuple\n    return any(item is None for item in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(data):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    data (tuple): The tuple to be checked for None values.\n\n    Returns:\n    bool: True if the tuple contains at least one None, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    return None in data", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    tup (tuple): The tuple to be checked for None values.\n\n    Returns:\n    bool: True if the tuple contains at least one None, False otherwise.\n\n    Example:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    input_tuple (tuple): The tuple to be checked for None values.\n\n    Returns:\n    bool: True if the tuple contains None, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    # Use 'in' operator to check for presence of None in the tuple\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    tup (tuple): The tuple to check for None.\n\n    Returns:\n    bool: True if the tuple contains None, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3, 4))\n    False\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tpl):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    This function iterates through each element of the tuple\n    and checks for the presence of None.\n\n    Args:\n    tpl (tuple): A tuple to check for None values.\n\n    Returns:\n    bool: True if the tuple contains at least one None, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    # Using 'in' operator for simplicity, which works for any iterable\n    return None in tpl", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    tup (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if tup contains None, False otherwise.\n\n    Example:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple 't' contains any None value.\n\n    Parameters:\n    t (tuple): The input tuple to check for None values.\n\n    Returns:\n    bool: True if t contains None, otherwise False.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    return any(item is None for item in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if the tuple contains None, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    # Use 'in' operator for simplicity and efficiency\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    t (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if the tuple contains at least one None, False otherwise.\n\n    Example:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    return any(element is None for element in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    input_tuple (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if there is at least one None in the tuple, False otherwise.\n\n    Examples:\n    >>> check_none((10, 4, 5, 6, None))\n    True\n    >>> check_none((1, 2, 3))\n    False\n    \"\"\"\n    # Use the `any` function with a generator expression to check for None\n    # This is more memory efficient for large tuples as it stops at the first None it encounters\n    return any(item is None for item in input_tuple)", "matching_cluster_idx": 2}]}, "Mbpp/750": {"dps": 55.98639455782313, "dps_norm": 57.5, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Adds the elements of a given tuple to the end of a given list.\n    \n    Args:\n    input_list (list): The list to which elements will be added.\n    input_tuple (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: A new list containing all elements from the original list followed by elements from the tuple.\n    \n    Examples:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Create a new list by extending the input list with tuple elements\n    return input_list + list(input_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds elements of a tuple to the end of a list.\n\n    Args:\n    lst (list): The original list to which elements will be added.\n    tpl (tuple): The tuple containing elements to be added to the list.\n\n    Returns:\n    list: A new list with the elements of the tuple added to the original list.\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Convert tuple to list and concatenate with the existing list\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n    \n    Args:\n    input_list (list): The original list to which elements will be added.\n    input_tuple (tuple): The tuple containing elements to add to the list.\n    \n    Returns:\n    list: A new list that includes all original elements followed by all elements from the tuple.\n    \n    Examples:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Use list concatenation to add all elements of the tuple to the list\n    return input_list + list(input_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Add elements of a tuple to the end of a list.\n\n    Args:\n    input_list (list): The list to which elements will be added.\n    input_tuple (tuple): The tuple whose elements are to be added to the list.\n\n    Returns:\n    list: A new list with elements of the tuple appended to the original list.\n\n    Examples:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Convert tuple to list to make use of list extension or directly use +=\n    return input_list + list(input_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Add elements from a tuple to the end of a list.\n\n    Args:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple containing elements to be added.\n\n    Returns:\n    list: A new list with elements from the tuple appended.\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Create a new list to avoid modifying the original list\n    result = lst.copy()\n    # Extend the list with the tuple elements\n    result.extend(tpl)\n    return result", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The initial list to which items will be added.\n    tpl (tuple): The tuple containing items to be added to the list.\n    \n    Returns:\n    list: A new list with the elements of 'tpl' appended to 'lst'.\n    \n    Examples:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Create a copy of the original list to avoid modifying it directly\n    result = lst.copy()\n    # Extend the list with the elements from the tuple\n    result.extend(tpl)\n    return result", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    - lst (list): The list to which elements are to be added.\n    - tup (tuple): The tuple whose elements are to be added to the list.\n\n    Returns:\n    - list: A new list with the elements of the tuple appended to the original list.\n\n    Example:\n    >>> assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    \"\"\"\n    # Create a new list by concatenating the original list with the tuple elements\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    This function takes a list and a tuple as input and appends all elements\n    from the tuple to the list.\n\n    Parameters:\n    input_list (list): The list to which elements will be added.\n    input_tuple (tuple): The tuple containing elements to be added to the list.\n\n    Returns:\n    list: A new list with elements from both the original list and tuple.\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Create a new list to avoid modifying the original input_list\n    result = input_list.copy()\n    \n    # Extend the result list with elements from the tuple\n    result.extend(input_tuple)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Adds elements of a tuple to the end of a list.\n\n    Parameters:\n    input_list (list): The initial list to which elements will be added.\n    input_tuple (tuple): The tuple whose elements are to be appended to the list.\n\n    Returns:\n    list: A new list with elements of the tuple added.\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Create a new list by extending the original list with tuple elements\n    # This avoids modifying the original list in case it's needed elsewhere\n    new_list = input_list + list(input_tuple)\n    return new_list", "matching_cluster_idx": 2}, {"solution": "def add_tuple(original_list, tuple_to_add):\n    \"\"\"\n    Add elements of a tuple to the end of a list.\n\n    This function takes a list and a tuple, and appends all elements from the tuple\n    to the list. \n\n    Args:\n    original_list (list): The original list to which items will be added.\n    tuple_to_add (tuple): The tuple containing elements to be added to the list.\n\n    Returns:\n    list: A new list with elements from both the original list and the tuple.\n\n    Example:\n    >>> assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    \"\"\"\n    # Create a new list to avoid modifying the input list in-place\n    new_list = original_list.copy()\n    \n    # Extend the new list with all elements from the tuple\n    new_list.extend(tuple_to_add)\n    \n    return new_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The list to which elements will be added.\n    tup (tuple): The tuple containing elements to add to the list.\n    \n    Returns:\n    list: A new list with elements from both the original list and the tuple.\n    \n    Examples:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Extend the list with the tuple's elements\n    lst = lst[:]  # Create a copy to avoid modifying the original list\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Add the elements of a tuple to the end of a list.\n\n    This function takes a list and a tuple, then appends all elements of the tuple\n    to the list.\n\n    Args:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple whose elements are to be added to the list.\n\n    Returns:\n    list: A new list with elements from both the original list and the tuple.\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Create a new list that includes all items from lst followed by items from tpl\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n    list: A new list with elements from both the original list and tuple.\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Convert the tuple to a list and concatenate it with the original list\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Add elements of a tuple to the end of a list.\n\n    Args:\n    input_list (list): The list to which elements will be added.\n    input_tuple (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n    list: A new list with elements of the tuple appended to the original list.\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Convert the tuple to a list to allow concatenation\n    return input_list + list(input_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Adds elements of a tuple to the end of a list.\n\n    Args:\n    input_list (list): The list to which elements will be added.\n    input_tuple (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n    list: A new list with the elements of the tuple appended to the end.\n\n    Examples:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Create a new list to avoid modifying the original list\n    result = input_list.copy()\n    \n    # Extend the list with all elements from the tuple\n    result.extend(input_tuple)\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the elements of a tuple to the end of a list.\n\n    This function takes a list and appends all elements from the given tuple\n    to this list, modifying the original list in place.\n\n    Parameters:\n    lst (list): The list to which elements will be added.\n    tup (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n    list: The modified list with elements from the tuple added.\n\n    Examples:\n    >>> add_tuple([1, 2, 3], (4, 5))\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds all elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which elements are to be added.\n    tup (tuple): The tuple whose elements are to be added to the list.\n    \n    Returns:\n    list: A new list containing all elements from lst followed by all elements from tup.\n    \"\"\"\n    # Create a new list by concatenating lst with the elements of tup\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n    \n    This function takes a list and a tuple as inputs and appends all the elements\n    from the tuple to the list in the order they appear in the tuple.\n\n    Parameters:\n    input_list (list): The list to which elements will be added.\n    input_tuple (tuple): The tuple whose elements are to be added to the list.\n\n    Returns:\n    list: A new list with elements from the original list followed by elements from the tuple.\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Create a copy of the list to avoid modifying the original\n    result = input_list.copy()\n    # Extend the list with elements from the tuple\n    result.extend(input_tuple)\n    return result", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the given tuple to the end of the given list.\n\n    Args:\n    lst (list): The list to which elements will be appended.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: A new list with elements from both the original list and tuple.\n\n    Examples:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Create a new list by extending the original list with tuple elements\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Adds elements of a tuple to the end of a list.\n    \n    This function takes a list and a tuple, then appends each element\n    of the tuple to the list in order.\n\n    Parameters:\n    - input_list (list): The initial list to which elements will be added.\n    - input_tuple (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    - list: A new list with elements from the tuple appended.\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # Create a new list to avoid modifying the original list\n    result_list = input_list.copy()\n    # Extend the list with elements from the tuple\n    result_list.extend(input_tuple)\n    return result_list", "matching_cluster_idx": 3}]}, "Mbpp/753": {"dps": 87.71812080536913, "dps_norm": 72.5, "pass@1": 46.0, "profiled": [{"solution": "def min_k(records, k):\n    \"\"\"\n    Find the k records with the lowest scores from a list of name-score tuples.\n\n    :param records: List of tuples where each tuple contains a name and a score.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the lowest scores.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list based on the score (second element of each tuple)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k records or all records if k is greater than list length\n    return sorted_records[:min(k, len(sorted_records))]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the k records with the minimum second element from a list of tuples.\n\n    Args:\n    records (list): A list of tuples where each tuple has a string followed by an integer.\n    k (int): The number of records to return.\n\n    Returns:\n    list: A list containing k tuples with the smallest second element, sorted by this element.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list by the second item in each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k items from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the k tuples with the smallest second element from the list of records.\n\n    :param records: List of tuples where each tuple contains a name and a score.\n    :param k: The number of minimum records to return.\n    :return: List of k tuples sorted by their scores in ascending order.\n\n    Example:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    if k > len(records):\n        return records  # If k is greater than the list length, return all records\n\n    # Sort the records by the second item (score) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return only the first k elements\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element.\n\n    :param records: List of tuples, where each tuple contains (name, score)\n    :param k: Number of minimum records to return\n    :return: List of k tuples with the lowest scores\n    \"\"\"\n    # Sort the list of records based on the second item (score) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Args:\n    records (list of tuple): A list of (name, value) tuples.\n    k (int): The number of records to return.\n\n    Returns:\n    list of tuple: The k smallest records, sorted by value.\n\n    Example:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list based on the value (second element of each tuple)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements or all elements if k is larger than the list\n    return sorted_records[:min(k, len(sorted_records))]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Parameters:\n    - records: List[Tuple[str, int]] where each tuple contains a name and a score.\n    - k: int, number of minimum records to return.\n\n    Returns:\n    - List[Tuple[str, int]] with k tuples having the lowest scores.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list by the score in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records based on the second item (value) in each tuple.\n\n    Args:\n    records (list of tuples): A list where each tuple contains a name and a numeric value.\n    k (int): The number of records to return.\n\n    Returns:\n    list: Sorted list of tuples with the k smallest values.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the records by the second element in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples.\n\n    Args:\n    records (list of tuple): A list where each tuple contains a name and a number.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuple: A list containing the k smallest tuples based on the second element (number).\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list by the second element in the tuple (the number)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements after sorting\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the k smallest records from a list of tuples based on the second element of each tuple.\n\n    Args:\n    records (list of tuple): A list where each tuple contains a name (str) and a score (int).\n    k (int): The number of smallest records to return.\n\n    Returns:\n    list of tuple: A list of the k tuples with the smallest scores, sorted by score.\n\n    Raises:\n    ValueError: If k is larger than the length of records.\n\n    Example:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    if k > len(records):\n        raise ValueError(\"k must not be greater than the number of records\")\n\n    # Sort the list based on the score (second item of each tuple)\n    sorted_records = sorted(records, key=lambda x: x[1])\n\n    # Return the first k items from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list based on the second element of each tuple in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k items after sorting\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param records: List of tuples where each tuple contains a name and an associated number.\n    :param k: The number of minimum records to return.\n    :return: List of k tuples with the smallest values in descending order.\n    \"\"\"\n    # Sort the list of tuples based on the second item (integer)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements of the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the k records with the minimum second element from a list of tuples.\n    \n    Args:\n    records (list of tuple): A list where each tuple contains a name and a number.\n    k (int): Number of minimum records to return.\n    \n    Returns:\n    list of tuple: A list of k tuples with the smallest numbers, in ascending order.\n\n    Example:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list based on the second item in each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (score)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element in each tuple.\n\n    Args:\n    records (list of tuples): A list of tuples where each tuple contains a name and a score.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: A list containing the k tuples with the smallest scores.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list based on the score (second item of each tuple)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the k tuples with the smallest second element from the list of tuples.\n\n    Args:\n    records (List[Tuple[str, int]]): List of tuples where each tuple contains a name (str) and a number (int).\n    k (int): Number of minimum records to return.\n\n    Returns:\n    List[Tuple[str, int]]: The k tuples with the smallest second elements.\n\n    Raises:\n    ValueError: If k is greater than the length of records.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    if k > len(records):\n        raise ValueError(\"k should not be greater than the number of records\")\n    \n    # Sort the list based on the second item of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records based on the second element of each tuple.\n\n    Args:\n    records (list of tuple): A list of tuples where each tuple contains a name and a score.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuple: k tuples sorted in ascending order by their score.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the records by the second item (the score) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k items from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the k smallest records based on the integer value in each tuple.\n\n    Args:\n    records (list of tuple): List where each tuple contains a name and a score.\n    k (int): The number of top records to return.\n\n    Returns:\n    list of tuple: k smallest records sorted in ascending order by the score.\n\n    Example:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the list of tuples by the second element (score)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return only the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples where each tuple contains a name and a numeric value.\n    \n    :param tuple_list: List of tuples (name, numeric_value)\n    :param k: Number of minimum records to return\n    :return: List of k tuples with the smallest values\n    \"\"\"\n    # Sort the list by the second item in each tuple (the numeric value)\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements of the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the k records with the minimum second element from a list of tuples.\n\n    :param records: A list of tuples where each tuple contains a name and a number.\n    :param k: Number of records to retrieve.\n    :return: List of tuples with the k smallest numbers.\n    \"\"\"\n    # Sort the list by the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return only the first k elements or all if k > length of list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "from typing import List, Tuple\ndef min_k(records: List[Tuple[str, int]], k: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Find the minimum k records from a list of tuples where each tuple contains a name and a value.\n\n    Args:\n    records (List[Tuple[str, int]]): A list of tuples where each tuple is (name, value).\n    k (int): The number of minimum records to return.\n\n    Returns:\n    List[Tuple[str, int]]: A list containing the k tuples with the smallest values.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the records by the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n\n    # Return only the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 68.70689655172414, "dps_norm": 79.375, "pass@1": 57.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists where the elements match at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare.\n\n    Returns:\n    list: A list containing elements that are common in l1, l2, and l3 at the same index.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Use zip to pair up elements from all three lists by index\n    # Then use a list comprehension to filter only those where all elements are the same\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists at the same indices.\n\n    Args:\n    l1 (list): The first list of elements.\n    l2 (list): The second list of elements.\n    l3 (list): The third list of elements.\n\n    Returns:\n    list: A list containing elements that are common in all three lists at the same index.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to find common elements at the same index\n    return [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find elements common to three lists at the same index.\n\n    Args:\n    l1, l2, l3 (list): Three lists of comparable items.\n\n    Returns:\n    list: A list containing elements common to all three lists at corresponding indices.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Initialize the result list\n    common_elements = []\n    \n    # Check the minimum length of the lists to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate over the lists simultaneously\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find elements that appear at the same index in three lists.\n\n    Args:\n    l1, l2, l3 (list): The lists to compare.\n\n    Returns:\n    list: A list containing elements common to l1, l2, and l3 at the same indices.\n\n    Examples:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Use list comprehension to find common elements at the same index\n    return [x for i, x in enumerate(l1) if i < len(l2) and i < len(l3) and x == l2[i] == l3[i]]", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in lists l1, l2, and l3 where the elements share the same index.\n    \n    Args:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n    \n    Returns:\n    list: A list containing elements that appear at the same index in all three input lists.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4], [0, 1, 2, 3], [0, 1, 2, 7])\n    [1]\n    \"\"\"\n    # Ensure all lists are of the same length by taking the minimum length\n    min_length = min(len(l1), len(l2), len(l3))\n    l1, l2, l3 = l1[:min_length], l2[:min_length], l3[:min_length]\n    \n    # Use a list comprehension to find elements where all lists match at the same index\n    return [x for i, x in enumerate(l1) if x == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common at the same index across three lists.\n\n    Args:\n    l1, l2, l3 (list): Three lists to compare for common elements at identical indices.\n\n    Returns:\n    list: A list containing elements that are common at the same index in all three lists.\n\n    Examples:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Determine the shortest list length to avoid index out of range errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to collect elements where all indices match\n    common = [x for i, x in enumerate(l1[:min_len]) if l1[i] == l2[i] == l3[i]]\n    \n    return common", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that are at the same index in all lists.\n\n    Args:\n    l1, l2, l3 (list): The lists to compare.\n\n    Returns:\n    list: A list containing elements that appear at the same index in all three lists.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Ensure lists are of the same length by truncating to the length of the shortest list\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension with zip to iterate through lists in parallel\n    # Include an element if it's the same in all lists at the same index\n    common_elements = [elem for elem in zip(l1[:min_length], l2[:min_length], l3[:min_length]) if len(set(elem)) == 1]\n    \n    # Since we know all elements in each tuple are the same, we take the first one\n    return [element[0] for element in common_elements]", "matching_cluster_idx": 3}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements at the same index from three lists.\n    \n    Args:\n    l1, l2, l3 (list): Three lists to compare.\n\n    Returns:\n    list: A list containing elements that are common across all three lists at the same index.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Ensure all lists are of the same length\n    min_length = min(len(l1), len(l2), len(l3))\n    l1, l2, l3 = l1[:min_length], l2[:min_length], l3[:min_length]\n    \n    # Use list comprehension to find elements where all three lists have the same element at the same index\n    common_elements = [elem for elem in zip(l1, l2, l3) if len(set(elem)) == 1]\n    \n    # Since the elements are the same, we can just take the first from each tuple\n    return [elem[0] for elem in common_elements]", "matching_cluster_idx": 3}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Extract elements that are common in three lists at the same index position.\n\n    Args:\n    l1 (list): First list of integers.\n    l2 (list): Second list of integers.\n    l3 (list): Third list of integers.\n\n    Returns:\n    list: A list containing elements that are the same at each index across all three input lists.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # The length of the list to be returned is the minimum length of the input lists\n    result = []\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_len):\n        # Check if the elements at index i are the same across all three lists\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists at the same index.\n\n    Args:\n    l1, l2, l3 (list): Three lists to compare.\n\n    Returns:\n    list: A list of elements that are at the same index in all three lists.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Ensure all lists are of the same length by trimming to the shortest list length\n    min_length = min(len(l1), len(l2), len(l3))\n    l1, l2, l3 = l1[:min_length], l2[:min_length], l3[:min_length]\n    \n    # Find common elements using zip for simultaneous iteration\n    common_elements = [e for e, f, g in zip(l1, l2, l3) if e == f == g]\n    \n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements at the same index from three lists.\n\n    This function checks each index across three lists to see if the elements at that index\n    are identical. It collects and returns these common elements in a new list.\n\n    Args:\n    l1 (list): The first list of elements.\n    l2 (list): The second list of elements.\n    l3 (list): The third list of elements.\n\n    Returns:\n    list: A list containing elements that appear at the same index in all three input lists.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7],[0, 1, 2, 3, 4, 5, 7],[0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Determine the minimum length to avoid index out of range\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to find common elements at the same index\n    common_elements = [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Extract elements that are common at the same index across three lists.\n\n    Args:\n    l1, l2, l3 (list): The three lists to compare.\n\n    Returns:\n    list: A list of elements common to l1, l2, and l3 at the same index.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Initialize an empty list to hold common elements\n    common_elements = []\n    \n    # Get the length of the shortest list to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # If the elements at this index are the same in all three lists, add to common_elements\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements common to all three lists at the same index.\n\n    Args:\n    l1 (list): The first list\n    l2 (list): The second list\n    l3 (list): The third list\n\n    Returns:\n    list: A list containing elements that are present at the same index in all three input lists.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Determine the shortest length among the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to find common elements by index\n    result = [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements in three lists where the element's index must match across all lists.\n\n    Args:\n    l1, l2, l3 (list): The three lists to compare.\n\n    Returns:\n    list: A list of common elements by index.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Use list comprehension to check elements at each index in all three lists\n    common_elements = [elem for idx, elem in enumerate(l1) if idx < len(l2) and idx < len(l3) and elem == l2[idx] == l3[idx]]\n    \n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements common to all three lists at the same index.\n\n    Args:\n    l1 (list): First list to compare.\n    l2 (list): Second list to compare.\n    l3 (list): Third list to compare.\n\n    Returns:\n    list: A list containing elements that appear at the same index in all three input lists.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Use zip to pair up elements by index from all lists\n    zipped_lists = zip(l1, l2, l3)\n    # Filter for tuples where all elements are identical\n    common_elements = [element[0] for element in zipped_lists if len(set(element)) == 1]\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Ensure all lists are of the same length by using the minimum length among them\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to find common elements at the same index\n    common_elements = [val for i, val in enumerate(l1[:min_length]) \n                       if val == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements common to three lists at the same index.\n\n    This function compares elements of three lists at each index to find\n    elements that are the same in all three lists.\n\n    Args:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n    l3 (list): Third list of elements.\n\n    Returns:\n    list: A list containing elements that are identical in all three lists at the same index.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Use list comprehension to check for equality at each index\n    return [val for i, val in enumerate(l1) if i < len(l2) and i < len(l3) and l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find elements that appear at the same index in all three lists.\n    \n    :param l1, l2, l3: Lists to be compared\n    :return: A list of common elements at the same index\n    \n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Use list comprehension to filter elements at the same index in all lists\n    return [elem for idx, elem in enumerate(l1) if idx < len(l2) and idx < len(l3) and elem == l2[idx] == l3[idx]]", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists where the elements appear at the same index.\n\n    Args:\n    l1, l2, l3 (list): Lists to compare for common indexed elements.\n\n    Returns:\n    list: A list containing elements common to all three lists at the same index.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Ensure all lists have the same length by truncating to the shortest list\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Use zip to iterate over all three lists simultaneously\n    result = [x for x, y, z in zip(l1[:min_length], l2[:min_length], l3[:min_length]) if x == y == z]\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements at the same index in three lists.\n\n    Args:\n    l1 (list): The first list\n    l2 (list): The second list\n    l3 (list): The third list\n\n    Returns:\n    list: A list containing elements common to all three lists at the same index.\n\n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    # Determine the length of the shortest list\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to gather elements where all list values at the same index are equal\n    common = [item for i, item in enumerate(l1[:min_len]) if item == l2[i] == l3[i]]\n    \n    return common", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 78.14159292035399, "dps_norm": 89.16666666666667, "pass@1": 29.0, "profiled": [{"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a given list.\n    \n    Args:\n    numbers (list): A list of numbers where to find the second smallest number.\n    \n    Returns:\n    The second smallest number from the list. If there's no second smallest \n    (e.g., list with less than 2 distinct elements), returns None.\n    \n    Raises:\n    TypeError: If the list contains non-numeric types or if the argument isn't a list.\n    \n    Example:\n    >>> second_smallest([1, 2, -8, -2, 0, -2])\n    -2\n    \"\"\"\n    # Type checking\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Check if list has enough elements\n    if len(numbers) < 2:\n        return None\n\n    # Use a set to remove duplicates for efficiency, then convert back to list\n    unique_numbers = list(set(numbers))\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the list of unique numbers and return the second one\n    unique_numbers.sort()\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # If there aren't at least two numbers, there is no second smallest\n    \n    # Remove duplicates to ensure we're dealing with unique numbers\n    unique_numbers = list(set(numbers))\n    \n    # If all numbers are the same, return None as there is no second smallest\n    if len(unique_numbers) == 1:\n        return None\n    \n    # Sort the unique numbers in ascending order\n    sorted_numbers = sorted(unique_numbers)\n    \n    return sorted_numbers[1]  # Return the second smallest number", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # Not enough numbers to find second smallest\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(numbers))\n    \n    # Check if there are at least two different numbers\n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]  # Return the second element", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # Not enough numbers to find a second smallest\n    \n    # Find the smallest and second smallest using set to remove duplicates\n    distinct_numbers = set(numbers)\n    if len(distinct_numbers) < 2:\n        return None  # No second smallest if there aren't at least two distinct numbers\n    \n    smallest = float('inf')\n    second = float('inf')\n    \n    for num in distinct_numbers:\n        if num < smallest:\n            second = smallest\n            smallest = num\n        elif num < second and num != smallest:\n            second = num\n    \n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Check if the list has at least two elements\n    if len(numbers) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(numbers))\n    \n    # Return the second item if it exists\n    return unique_sorted[1] if len(unique_sorted) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in a list.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    The second smallest number in the list. If there are less than two unique numbers, \n    it returns None.\n\n    Example:\n    >>> assert second_smallest([1, 2, -8, -2, 0, -2]) == -2\n    \"\"\"\n    # Check if the list has less than 2 elements\n    if len(numbers) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(numbers))\n    \n    # Return the second item if it exists\n    return unique_sorted[1] if len(unique_sorted) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    This function first converts the list into a set to remove duplicates, \n    then sorts it and returns the second element or None if there are fewer than two unique numbers.\n\n    Args:\n    numbers (list): A list of numbers to search through.\n\n    Returns:\n    int or float or None: The second smallest number or None if there isn't a second smallest.\n\n    Examples:\n    >>> assert second_smallest([1, 2, -8, -2, 0, -2]) == -2\n    >>> second_smallest([1]) is None\n    True\n    \"\"\"\n    # Convert to set to remove duplicates, then sort\n    unique_numbers = sorted(set(numbers))\n    \n    # Check if there are at least 2 unique numbers\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Return the second element, which is the second smallest number\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in the list.\n    \n    Args:\n    numbers (list): A list of numbers to search through.\n    \n    Returns:\n    The second smallest number in the list or None if there's not at least two unique numbers.\n\n    Examples:\n    >>> second_smallest([1, 2, -8, -2, 0, -2])\n    -2\n    >>> second_smallest([5, 5, 5])\n    None\n    >>> second_smallest([])\n    None\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(numbers))\n    \n    # Check if we have at least two unique numbers\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element, which is the second smallest\n    return unique_sorted[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest unique number in a list.\n\n    This function first removes duplicates by converting the list to a set,\n    then finds the smallest and second smallest elements.\n\n    Args:\n    numbers (list): A list of numbers to search through.\n\n    Returns:\n    int or float: The second smallest unique number in the list.\n    If there is only one unique number or the list is empty, it returns None.\n\n    Raises:\n    TypeError: If the list contains non-comparable types or non-numeric data.\n\n    Example:\n    >>> second_smallest([1, 2, -8, -2, 0, -2])\n    -2\n    \"\"\"\n    # Convert to a set to remove duplicates\n    unique_numbers = list(set(numbers))\n    \n    # Check if we have at least two unique numbers\n    if len(unique_numbers) < 2:\n        return None\n    \n    try:\n        # Sort the unique numbers\n        unique_numbers.sort()\n        \n        # Return the second element in the sorted list\n        return unique_numbers[1]\n    except TypeError:\n        # If sorting raises a TypeError due to incomparable elements, raise a custom error message\n        raise TypeError(\"The list contains elements that cannot be compared for order.\")", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest unique number in a list.\n    \n    This function sorts the list and returns the second element if there's more than\n    one unique number. If there's less than two unique numbers, it returns None.\n    \n    Args:\n    numbers (list): A list of numbers\n    \n    Returns:\n    number or None: The second smallest number or None if there are not enough unique numbers.\n    \n    Example:\n    >>> second_smallest([1, 2, -8, -2, 0, -2])\n    -2\n    >>> second_smallest([1,1,1])\n    None\n    \"\"\"\n    # Create a sorted set of numbers to eliminate duplicates\n    unique_sorted = sorted(set(numbers))\n    \n    # Check if there are at least two unique numbers\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element, which is the second smallest\n    return unique_sorted[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Check if the list has at least two unique elements\n    if len(set(numbers)) < 2:\n        return None\n    \n    # Sort the unique numbers in ascending order\n    sorted_unique = sorted(set(numbers))\n    \n    # Return the second element if it exists\n    return sorted_unique[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in the given list.\n\n    Args:\n    numbers (list): A list of numbers where we need to find the second smallest.\n\n    Returns:\n    int or float or None: Returns the second smallest number or None if there\n    isn't a second smallest number (e.g., all numbers are the same or the list has fewer than 2 unique numbers).\n\n    Raises:\n    TypeError: If the list contains elements that are not numbers.\n\n    Examples:\n    >>> second_smallest([1, 2, -8, -2, 0, -2])\n    -2\n    >>> second_smallest([1])\n    None\n    >>> second_smallest([1, 1, 1])\n    None\n    \"\"\"\n    # Convert to set to remove duplicates and then back to list for sorting\n    unique_numbers = list(set(numbers))\n    \n    # Check if we have at least two unique numbers\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers\n    unique_numbers.sort()\n    \n    # Return the second element or None if there's no second smallest\n    return unique_numbers[1] if len(unique_numbers) >= 2 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest unique number in the given list.\n    \n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    The second smallest number in the list. If there is no second smallest number \n    (like in case of fewer than 2 unique numbers), returns None.\n\n    Example:\n    >>> second_smallest([1, 2, -8, -2, 0, -2])\n    -2\n    \"\"\"\n    # Check if the list has less than 2 unique numbers\n    if len(set(numbers)) < 2:\n        return None\n\n    # Sorting the list of unique numbers will automatically place \n    # the smallest and second smallest numbers in the first two positions\n    unique_sorted = sorted(set(numbers))\n    return unique_sorted[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(arr):\n    if len(arr) < 2:\n        return None  # Not enough elements to find second smallest\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(arr))\n    \n    # Return the second element or None if there isn't one\n    return None if len(unique_sorted) < 2 else unique_sorted[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in the given list.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    Any: The second smallest number in the list, or None if there's less than two unique numbers.\n\n    Raises:\n    ValueError: If the list contains non-numeric data.\n\n    Examples:\n    >>> second_smallest([1, 2, -8, -2, 0, -2])\n    -2\n    >>> second_smallest([5])\n    None\n    \"\"\"\n    # Check if list has at least two numbers\n    if len(numbers) < 2:\n        return None\n\n    # Convert all to numbers to avoid issues with strings or other types\n    try:\n        numbers = [float(num) for num in set(numbers)]  # Using set to remove duplicates\n    except ValueError:\n        raise ValueError(\"The list should contain only numeric values.\")\n\n    if len(numbers) < 2:\n        return None\n\n    # Sort the unique numbers\n    sorted_nums = sorted(numbers)\n    \n    # Return the second smallest number\n    return sorted_nums[1]", "matching_cluster_idx": 2}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None  # Not enough elements to find a second smallest\n    \n    # Remove duplicates to ensure we find the second unique smallest number\n    unique_numbers = sorted(set(numbers))\n    \n    # If there are less than 2 unique numbers after removing duplicates, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in the given list.\n\n    Args:\n    numbers (list of int): A list of integers.\n\n    Returns:\n    int: The second smallest number in the list, or None if there are less than 2 unique numbers.\n\n    Example:\n    >>> second_smallest([1, 2, -8, -2, 0, -2])\n    -2\n    \"\"\"\n    # Check if the list has less than 2 elements\n    if len(numbers) < 2:\n        return None\n    \n    # Remove duplicates while preserving order\n    unique_numbers = list(dict.fromkeys(sorted(numbers)))\n    \n    # If there are less than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    return unique_numbers[1]", "matching_cluster_idx": 1}, {"solution": "def second_smallest(arr):\n    if len(arr) < 2:\n        return None  # Not enough elements to find second smallest\n    # Find the two smallest numbers using Python's built-in functions\n    smallest, second = float('inf'), float('inf')\n    for num in arr:\n        if num < smallest:\n            second = smallest\n            smallest = num\n        elif num < second and num != smallest:\n            second = num\n    return second if second != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in a given list.\n\n    This function first removes duplicates to ensure we count distinct numbers,\n    then sorts the list to find the second element. If there's not enough \n    distinct numbers, it will return None.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int or float or None: The second smallest number in the list or None if not possible.\n\n    Examples:\n    >>> second_smallest([1, 2, -8, -2, 0, -2])\n    -2\n    >>> second_smallest([1])\n    None\n    >>> second_smallest([1, 1, 2, 2, 3])\n    2\n    \"\"\"\n    # Convert to a set to remove duplicates, then back to list and sort\n    unique_sorted = sorted(set(numbers))\n    \n    # Check if there are at least 2 unique numbers\n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Check if there are at least two unique numbers in the list\n    if len(set(numbers)) < 2:\n        return None\n    \n    # Use a set to get unique numbers, sort them and get the second smallest\n    sorted_numbers = sorted(set(numbers))\n    return sorted_numbers[1]", "matching_cluster_idx": 4}]}, "Mbpp/757": {"dps": 80.48166786484543, "dps_norm": 33.72781065088758, "pass@1": 13.0, "profiled": [{"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Count the pairs of strings that are reverses of each other from the given list.\n\n    This function checks each string against every other string in the list\n    to see if they are reverse pairs. \n\n    Args:\n    strings (list of str): A list of strings to check for reverse pairs.\n\n    Returns:\n    int: The number of reverse string pairs found.\n\n    Example:\n    >>> count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])\n    2\n    \"\"\"\n    count = 0\n    # Use enumerate to keep track of the index as we'll need it for comparison\n    for i, string1 in enumerate(strings):\n        for string2 in strings[i+1:]:  # Only check forward to avoid counting pairs twice\n            if string1 == string2[::-1] or string2 == string1[::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the number of pairs of reverse strings in the given list.\n    \n    This function checks each pair of strings in the list to see if one is the\n    reverse of the other, excluding comparisons of a string with itself.\n    \n    Args:\n    strings (list): A list of strings where pairs of reverse strings are to be counted.\n    \n    Returns:\n    int: The number of pairs where one string is the reverse of another.\n    \n    Examples:\n    >>> count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])\n    2\n    \"\"\"\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            # Check if string at j is the reverse of string at i\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(words):\n    \"\"\"\n    Count the number of pairs of strings in the list where one string is the reverse of the other.\n\n    :param words: List of strings to check for reverse pairs.\n    :return: Number of reverse pairs found.\n    \n    Example:\n    >>> count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])\n    2\n    \"\"\"\n    def is_reverse(s1, s2):\n        \"\"\"Helper function to check if one string is the reverse of another.\"\"\"\n        return s1 == s2[::-1]\n    \n    count = 0\n    n = len(words)\n    \n    # We don't need to check pairs twice or with themselves\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(words[i], words[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the number of pairs of reverse strings in the given list.\n    \n    Args:\n    strings (list): A list of strings to check for reverse pairs.\n    \n    Returns:\n    int: The number of pairs of reverse strings found.\n\n    Example:\n    >>> count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])\n    2\n    \"\"\"\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n    \n    # Initialize counter for reverse pairs\n    count = 0\n    \n    # Iterate through all possible pairs\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if is_reverse(strings[i], strings[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(strings[i], strings[j]):\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Count the number of pairs where one string is the reverse of another.\n\n    Args:\n    strings (list): A list of strings to analyze for reverse pairs.\n\n    Returns:\n    int: The number of reverse string pairs found.\n\n    Example:\n    >>> count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])\n    2\n    \"\"\"\n    # Initialize a dictionary to keep track of strings we've seen\n    seen = {}\n    count = 0\n    \n    for s in strings:\n        # Check if the reverse of the current string exists in our seen dict\n        reverse_s = s[::-1]\n        if reverse_s in seen:\n            count += seen[reverse_s]\n        # Update the dictionary with the current string and its count\n        # This helps handle cases where there are multiple occurrences of the same string\n        seen[s] = seen.get(s, 0) + 1\n    \n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the number of pairs of strings that are reverse of each other in the list.\n\n    Args:\n    strings (list of str): A list of strings to analyze.\n\n    Returns:\n    int: The count of reverse string pairs found in the list.\n\n    Example:\n    >>> count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])\n    2\n    \"\"\"\n    count = 0\n    n = len(strings)\n    \n    # Iterate over all possible pairs with i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if string at i is reverse of string at j\n            if strings[i] == strings[j][::-1]:\n                count += 1\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    Counts the number of pairs of reverse strings in the given list.\n    \n    Args:\n    string_list (list): A list of strings where pairs of reverse strings are to be counted.\n    \n    Returns:\n    int: The count of pairs where one string is the reverse of another in the list.\n    \n    Example:\n    >>> count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])\n    2\n    \"\"\"\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            # If one string is the reverse of the other, increment the counter\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n                # Optionally, you might want to break here to not count the same pair twice, \n                # but for the given assertion, this isn't necessary as we only need to count pairs.\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(words):\n    \"\"\"\n    Count the number of string pairs where one string is the reverse of the other in the list.\n\n    Args:\n    words (list): A list of strings to check for reverse pairs.\n\n    Returns:\n    int: The number of reverse pairs found.\n\n    Example:\n    >>> count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])\n    2\n    \"\"\"\n    reverse_count = 0\n    n = len(words)\n    \n    # Since order does not matter for reverse, we compare each word with every other\n    for i in range(n):\n        for j in range(i+1, n):\n            # Check if the strings are reverse of each other\n            if words[i][::-1] == words[j]:\n                reverse_count += 1\n\n    return reverse_count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    Counts the number of pairs of reverse strings in the given list.\n    \n    :param string_list: List of strings to check for reverse pairs\n    :return: Integer count of reverse string pairs\n\n    Example:\n    >>> count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])\n    2\n    \"\"\"\n    # Dictionary to keep track of seen strings\n    string_count = {}\n    \n    # Counter for reverse pairs\n    pairs = 0\n    \n    for s in string_list:\n        # Reverse the string\n        reversed_s = s[::-1]\n        if reversed_s in string_count:\n            # If the reversed string has been seen before, it's a pair\n            pairs += string_count[reversed_s]\n            # Increment the count of the current string, as this could match with future strings\n            string_count[s] = string_count.get(s, 0) + 1\n        else:\n            # String hasn't been seen, just add it to the dictionary\n            string_count[s] = string_count.get(s, 0) + 1\n    \n    return pairs", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Count the pairs of reverse strings in the given string list.\n    \n    This function checks each string in the list with every other string \n    to see if one is the reverse of another, then counts these pairs.\n    \n    Args:\n    strings (list of str): List of strings to check for reverse pairs.\n\n    Returns:\n    int: The count of pairs where one string is the reverse of another.\n\n    Example:\n    >>> count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])\n    2\n    \"\"\"\n    count = 0\n    # Iterate over each string in the list\n    for i, str1 in enumerate(strings):\n        for str2 in strings[i+1:]:  # Compare with subsequent strings to avoid counting pairs twice\n            # Check if str1 is the reverse of str2 or vice versa\n            if str1 == str2[::-1]:\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Count the pairs of reverse strings in the given list.\n\n    This function checks each string against all others to determine\n    if any two strings are reverse of each other.\n\n    Args:\n    strings (list of str): A list of strings to check for reverse pairs.\n\n    Returns:\n    int: The number of reverse string pairs found in the list.\n\n    Example:\n    >>> count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])\n    2\n    \"\"\"\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # If string at index i is the reverse of string at index j\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 82.06563706563706, "dps_norm": 80.625, "pass@1": 100.0, "profiled": [{"solution": "def unique_sublists(lists):\n    \"\"\"\n    Convert lists within a list to tuples and count their occurrences.\n    \n    Args:\n    lists (list of list): A list containing lists which might be duplicate.\n    \n    Returns:\n    dict: A dictionary with tuples as keys (converted from inner lists) and their count as values.\n    \n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate through each list in the input\n    for sublist in lists:\n        # Convert the sublist to a tuple to make it hashable\n        tuple_key = tuple(sublist)\n        # Update the count for this tuple, defaulting to 0 if not seen before\n        count_dict[tuple_key] = count_dict.get(tuple_key, 0) + 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Convert lists within a list to tuples and count their occurrences.\n    \n    This function takes a list of lists, converts each sublist to a tuple,\n    and then counts how many times each unique tuple appears.\n\n    Args:\n    lists (list): A list containing lists to be counted.\n\n    Returns:\n    dict: A dictionary where keys are tuples of sublists, and values are their count.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Create a dictionary to store the counts\n    count_dict = {}\n    \n    for sublist in lists:\n        # Convert each sublist to a tuple to make it hashable\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count, otherwise set it to 1\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict, Tuple\ndef unique_sublists(lists: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    # Convert each list to a tuple for hashability, then count occurrences\n    tuple_counts = Counter(tuple(sublist) for sublist in lists)\n    # Return the dictionary comprehension of tuples and their counts\n    return {k: v for k, v in tuple_counts.items()}", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Count the occurrences of sublists within a list of lists.\n    \n    This function takes a list of lists, converts each inner list to a tuple\n    (to make them hashable), and counts how many times each unique sublist\n    appears in the original list. The result is returned as a dictionary where\n    keys are tuples (converted from lists) and values are the count of occurrences.\n\n    Args:\n    lists (list of list): A list containing sublists to be counted.\n\n    Returns:\n    dict: A dictionary where keys are unique sublists (as tuples) and values are their occurrence counts.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Convert lists to tuples for hashability\n    tuples = [tuple(sublist) for sublist in lists]\n    \n    # Use a dictionary to count occurrences of each tuple\n    count_dict = {}\n    for t in tuples:\n        if t in count_dict:\n            count_dict[t] += 1\n        else:\n            count_dict[t] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize a dictionary to count occurrences\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to make it hashable\n        key = tuple(sublist)\n        # If the tuple is already a key in the dictionary, increment its count, otherwise add it with a count of 1\n        if key in count_dict:\n            count_dict[key] += 1\n        else:\n            count_dict[key] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Count the occurrences of lists within a list.\n    \n    This function converts each inner list to a tuple (since lists are not hashable) \n    and counts how many times each unique list appears in the provided list of lists.\n    \n    Args:\n    lists (list): A list of lists to be counted.\n    \n    Returns:\n    dict: A dictionary where keys are tuples representing lists, and values are their occurrence count.\n    \n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Convert all inner lists to tuples for hashability\n    tuple_lists = [tuple(sublist) for sublist in lists]\n    \n    # Use dict comprehension to count occurrences\n    return {tuple_key: tuple_lists.count(tuple_key) for tuple_key in set(tuple_lists)}", "matching_cluster_idx": 2}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list, converting each sublist to a tuple.\n\n    Args:\n    lists (List[List[int]]): A list containing sublists to be counted.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where keys are tuples representing the sublists,\n                                and values are the count of occurrences of those sublists.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    from collections import Counter\n    \n    # Convert all sublists to tuples to make them hashable for counting\n    tuple_lists = [tuple(sublist) for sublist in lists]\n    \n    # Use Counter to count occurrences of each tuple\n    count_dict = Counter(tuple_lists)\n    \n    return dict(count_dict)  # Convert Counter object to regular dictionary", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(nested_list):\n    # Initialize an empty dictionary to store the count of each unique sublist\n    count_dict = {}\n    \n    # Iterate through each sublist in the nested list\n    for sublist in nested_list:\n        # Convert the list to a tuple for hashability\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple exists in the dictionary, increment its count, else set to 1\n        count_dict[tuple_sublist] = count_dict.get(tuple_sublist, 0) + 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(nested_list):\n    # Initialize an empty dictionary to hold our counts\n    count_dict = {}\n    \n    for sublist in nested_list:\n        # Convert the sublist to a tuple as lists are not hashable\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple exists in the dictionary, increment its count, otherwise initialize it to 1\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Dictionary to store tuples of sublists as keys and their counts as values\n    sublist_count = {}\n\n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to make it hashable\n        tuple_sublist = tuple(sublist)\n        # If tuple_sublist is already a key in sublist_count, increment its value, otherwise set it to 1\n        sublist_count[tuple_sublist] = sublist_count.get(tuple_sublist, 0) + 1\n    \n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "from typing import List, Dict, Tuple\ndef unique_sublists(lists: List[List]) -> Dict[Tuple, int]:\n    \"\"\"\n    Count occurrences of unique sublists within a list and convert each sublist to a tuple.\n\n    Args:\n    - lists (List[List]): A list containing sublists.\n\n    Returns:\n    - Dict[Tuple, int]: A dictionary with sublists converted to tuples as keys, \n                        and the count of their occurrences as values.\n\n    Examples:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Dictionary to keep track of tuples and their counts\n    count_dict = {}\n    \n    for sublist in lists:\n        # Convert each sublist to an immutable tuple\n        key = tuple(sublist)\n        if key in count_dict:\n            count_dict[key] += 1\n        else:\n            count_dict[key] = 1\n            \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(nested_list):\n    # Initialize an empty dictionary to store the results\n    result = {}\n    \n    # Iterate over each list in the nested_list\n    for sublist in nested_list:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_key = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_key in result:\n            result[tuple_key] += 1\n        else:\n            # Otherwise, add it to the dictionary with a count of 1\n            result[tuple_key] = 1\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Count occurrences of each unique sublist within a given list.\n    \n    This function converts each sublist into a tuple (since lists are not hashable and \n    cannot be used as dictionary keys) and then counts how many times each unique \n    sublist occurs in the provided list.\n\n    Args:\n    lists (list of list): The main list containing sublists.\n\n    Returns:\n    dict: A dictionary where keys are tuples of sublists and values are the count of occurrences.\n\n    Examples:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Convert all sublists to tuples because lists are not hashable\n    tuple_lists = [tuple(sublist) for sublist in lists]\n    \n    # Use collections.Counter to count occurrences\n    from collections import Counter\n    count_dict = Counter(tuple_lists)\n    \n    return dict(count_dict)", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list by converting each sublist to a tuple and then counting them.\n\n    Args:\n    lists (List[list]): A list containing sublists.\n\n    Returns:\n    dict: A dictionary where keys are tuples representing unique sublists, and values are their occurrence counts.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Initialize an empty dictionary to store counts of tuples\n    count_dict = {}\n    \n    for sublist in lists:\n        # Convert each sublist to a tuple since lists are mutable and can't be dict keys\n        sublist_tuple = tuple(sublist)\n        \n        # Count occurrences\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Count occurrences of lists within a list and return them as a dictionary.\n\n    Args:\n    lists (List[List[int]]): A list of lists where each inner list represents \n                             a sublist to count.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where keys are tuples representing \n                                the unique sublists, and values are their counts.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Convert each sublist to a tuple for hashability and use Counter for counting\n    from collections import Counter\n    count_dict = Counter(tuple(sublist) for sublist in lists)\n    \n    # Convert Counter object to a regular dictionary\n    return dict(count_dict)", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Counts the occurrences of each unique sublist within a given list of lists.\n\n    This function converts each sublist to a tuple to make it hashable, then counts\n    the occurrences of each tuple, returning a dictionary where keys are tuples\n    (representing unique sublists) and values are the count of each tuple's occurrence.\n\n    Args:\n    lists (List[List]): A list containing sublists.\n\n    Returns:\n    Dict[Tuple, int]: A dictionary where the keys are tuples (representing sublists)\n    and the values are the count of each sublist's occurrence.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Convert each sublist to a tuple since lists are not hashable\n    tuple_lists = [tuple(sublist) for sublist in lists]\n    \n    # Count occurrences using a dictionary comprehension\n    return {item: tuple_lists.count(item) for item in set(tuple_lists)}", "matching_cluster_idx": 2}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Counts the occurrences of sublists within a list and returns a dictionary where\n    each sublist is represented as a tuple with its count.\n\n    Args:\n    lists (List[List[Any]]): A list of lists where each inner list can contain any hashable items.\n\n    Returns:\n    dict: A dictionary where keys are tuples representing the lists, and values are their occurrence counts.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Convert each list to a tuple for hashability\n    tuple_lists = [tuple(sublist) for sublist in lists]\n    \n    # Use a defaultdict to count occurrences, which handles missing keys effortlessly\n    from collections import defaultdict\n    count = defaultdict(int)\n    \n    # Count each tuple\n    for t in tuple_lists:\n        count[t] += 1\n    \n    # Convert defaultdict to regular dict for the assert to work as expected\n    return dict(count)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Count occurrences of sublists within a list and return a dictionary where keys are tuples of the sublists\n    and values are their counts.\n\n    Args:\n    lists (List[List]): A list of lists whose sublists are to be counted.\n\n    Returns:\n    Dict[Tuple, int]: A dictionary with tuples as keys representing each sublist, \n                      and the value being the count of occurrences of that sublist.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Convert lists to tuples so they can be hashed (dictionaries require hashable keys)\n    tuple_lists = [tuple(sublist) for sublist in lists]\n    # Use a dictionary comprehension to count occurrences\n    count_dict = {t: tuple_lists.count(t) for t in set(tuple_lists)}\n    return count_dict", "matching_cluster_idx": 2}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Count the occurrences of unique sublists within a list.\n\n    This function takes a list of lists, converts each sublist to a tuple,\n    and returns a dictionary where the keys are these tuples and the values\n    are the counts of their occurrences in the original list.\n\n    Args:\n    lists (List[List]): A list containing sublists to be counted.\n\n    Returns:\n    dict: A dictionary with tuples as keys (converted from sublists) \n          and their occurrence counts as values.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Initialize an empty dictionary to store counts\n    result = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to an immutable tuple for dictionary keying\n        sub_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sub_tuple in result:\n            result[sub_tuple] += 1\n        else:\n            # Otherwise, add it to the dictionary with a count of 1\n            result[sub_tuple] = 1\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    # Convert each list to a tuple and use it as a key in a dictionary\n    # Count occurrences using dict.get() method which initializes to 0 if the key doesn't exist yet\n    count_dict = {}\n    for lst in lists:\n        tuple_key = tuple(lst)\n        count_dict[tuple_key] = count_dict.get(tuple_key, 0) + 1\n    \n    return count_dict", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 53.978102189781026, "dps_norm": 70.0, "pass@1": 73.0, "profiled": [{"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if a list contains only one distinct element.\n\n    Args:\n    numbers (list): A list of numbers to be checked.\n\n    Returns:\n    bool: True if the list has only one unique element, False otherwise.\n\n    Examples:\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1,2,3])\n    False\n    \"\"\"\n    # If the list is empty, we'll consider it as having no unique elements\n    if not numbers:\n        return False\n    \n    # Compare each number to the first element\n    return all(num == numbers[0] for num in numbers)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the given list contains only one distinct element.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n\n    Examples:\n    >>> assert unique_Element([1,1,1]) == True\n    >>> assert unique_Element([1,2,1]) == False\n    \"\"\"\n    # If the list has less than 2 elements, by definition it has at most one distinct element\n    if len(lst) < 2:\n        return True\n    \n    # Check if all elements are the same by comparing each to the first element\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n    lst (list): A list of numbers to check.\n\n    Returns:\n    bool: True if the list contains only one unique element, False otherwise.\n\n    Examples:\n    >>> unique_Element([1, 1, 1])\n    True\n    >>> unique_Element([1, 2, 1])\n    False\n    \"\"\"\n    # If the list is empty, it technically has one distinct element (none)\n    if not lst:\n        return True\n    \n    # Use set to remove duplicates, then check if there's only one element\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if the given list contains only one distinct element.\n\n    Args:\n    numbers (list): A list of numbers to check for uniqueness.\n\n    Returns:\n    bool: True if the list contains only one unique element, False otherwise.\n\n    Examples:\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1,2,1])\n    False\n    \"\"\"\n    # If the list is empty, we consider it as having only one 'distinct' element (vacuously true)\n    if not numbers:\n        return True\n    \n    # Check if all elements are equal to the first element\n    return all(num == numbers[0] for num in numbers)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the given list contains only one distinct element.\n\n    Args:\n    lst (list): A list of numbers to check for uniqueness.\n\n    Returns:\n    bool: True if the list has only one distinct element, False otherwise.\n\n    Examples:\n    >>> assert unique_Element([1,1,1]) == True\n    >>> assert unique_Element([1,2,1,2]) == False\n    \"\"\"\n    # If the list is empty or has only one element, it's trivially unique\n    if len(lst) <= 1:\n        return True\n    \n    # Compare all elements to the first one\n    first_element = lst[0]\n    return all(x == first_element for x in lst[1:])", "matching_cluster_idx": 3}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if the given list contains only one distinct element.\n\n    Args:\n    numbers (list): A list of numbers to check.\n\n    Returns:\n    bool: True if the list has only one unique element, False otherwise.\n\n    Examples:\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1,2,1])\n    False\n    \"\"\"\n    # If the list is empty, we consider it to have no unique elements by default\n    if not numbers:\n        return False\n    \n    # Check if all elements in the list are the same as the first element\n    first_element = numbers[0]\n    return all(num == first_element for num in numbers)", "matching_cluster_idx": 4}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if a list contains only one distinct element.\n\n    Args:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if the list contains only one unique element, False otherwise.\n\n    Examples:\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1,2,1])\n    False\n    \"\"\"\n    if not lst:\n        return True  # An empty list technically has only one distinct element, none\n    # Convert list to set to get unique elements, and compare its length to 1\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Parameters:\n    numbers (list): A list of numbers to check.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n\n    Example:\n    >>> unique_Element([1, 1, 1])\n    True\n    >>> unique_Element([1, 2, 1])\n    False\n    \"\"\"\n    # If the list has 0 or 1 elements, by definition, there's only one distinct element or none at all\n    if len(numbers) <= 1:\n        return True\n    \n    # Check if all elements are equal to the first one\n    return all(num == numbers[0] for num in numbers[1:])", "matching_cluster_idx": 3}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the given list contains only one distinct element.\n\n    This function determines whether every element in the list is the same.\n\n    Parameters:\n    lst (list): A list of numbers to check for uniqueness.\n\n    Returns:\n    bool: True if the list has only one distinct element, False otherwise.\n\n    Examples:\n    >>> unique_Element([1, 1, 1])\n    True\n    >>> unique_Element([1, 1, 2])\n    False\n    \"\"\"\n    # If the list is empty or has only one element, it trivially has only one distinct element\n    if len(lst) <= 1:\n        return True\n    \n    # Use set to find unique elements. If there's only one, len(set(lst)) will be 1\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n    lst (list): A list of numbers to check.\n\n    Returns:\n    bool: True if the list contains only one unique element, False otherwise.\n\n    Examples:\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1,2,1])\n    False\n    \"\"\"\n    # If the list is empty or has only one element, it's trivially unique\n    if len(lst) <= 1:\n        return True\n    \n    # Convert the list to a set; sets in Python only keep unique elements\n    # If the set has only one element, then the original list had only one distinct element\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the given list contains only one distinct element.\n    \n    Args:\n    lst (list): A list of numbers to check for uniqueness.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \n    Examples:\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1,2,1,1])\n    False\n    \"\"\"\n    # If the list is empty, consider it as having one element (by convention or interpretation)\n    if not lst:\n        return True\n    \n    # Use set for efficient uniqueness check\n    # If the set of the list has only one element, then the original list contains only one distinct value\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n    numbers (list): A list of numbers to check.\n\n    Returns:\n    bool: True if all elements in the list are the same, False otherwise.\n\n    Examples:\n    >>> assert unique_Element([1,1,1]) == True\n    >>> assert unique_Element([1,1,2]) == False\n    \"\"\"\n    # If the list is empty or has only one element, it inherently has only one distinct element\n    if len(numbers) <= 1:\n        return True\n    \n    # Convert the list to a set to remove duplicates and check if it contains only one element\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n    lst (list): A list of numbers to check.\n\n    Returns:\n    bool: True if the list has only one distinct element, False otherwise.\n\n    Examples:\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1,2,1])\n    False\n    \"\"\"\n    # If the set of the list has only one item, then all elements are the same\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n    lst (list): A list of numbers to check for uniqueness.\n\n    Returns:\n    bool: True if the list has only one distinct element, False otherwise.\n\n    Examples:\n    >>> unique_Element([1, 1, 1])\n    True\n    >>> unique_Element([1, 1, 2])\n    False\n    >>> unique_Element([])\n    True\n    \"\"\"\n    # If the list is empty, it trivially has only one distinct element (none)\n    if not lst:\n        return True\n    \n    # Compare the first element with every other element in the list\n    first = lst[0]\n    for item in lst[1:]:\n        if item != first:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements in the list are the same, False otherwise.\n\n    Examples:\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1,2,1])\n    False\n    \"\"\"\n    if not lst:  # Handle the case of an empty list\n        return True\n    \n    # Compare all items to the first item in the list\n    return all(x == lst[0] for x in lst)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the given list contains only one distinct element.\n    \n    Args:\n    lst (list): The list of numbers to check.\n    \n    Returns:\n    bool: True if the list has only one distinct element, False otherwise.\n    \n    Examples:\n    >>> assert unique_Element([1, 1, 1]) == True\n    >>> assert unique_Element([1, 2, 1]) == False\n    \"\"\"\n    # If the list is empty or has less than 2 elements, \n    # it technically has only one (or zero) distinct element\n    if len(lst) <= 1:\n        return True\n    \n    # Check if all elements are equal to the first element\n    return all(x == lst[0] for x in lst[1:])", "matching_cluster_idx": 3}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n    lst (list): A list of numbers to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n\n    Examples:\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1,2,1,1])\n    False\n    \"\"\"\n    # If the list is empty, it technically contains one distinct element (none)\n    if not lst:\n        return True\n    \n    # Use a set to check uniqueness. A set will only keep unique elements.\n    # If the set has only one element, all elements in the original list were the same.\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the given list contains only one distinct element.\n\n    This function determines whether all elements in the given list are identical.\n\n    Parameters:\n    lst (list): The list to be checked for uniqueness.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n\n    Examples:\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1, 2, 3])\n    False\n    >>> unique_Element([])\n    True\n    \"\"\"\n    # If the list is empty or has only one element, it trivially satisfies the condition\n    if len(lst) < 2:\n        return True\n    \n    # Use set to find unique elements; if the length of set is 1, all elements are the same\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n    \n    Args:\n    lst (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one unique element, False otherwise.\n    \n    Examples:\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1,2,1])\n    False\n    \"\"\"\n    # If the list is empty, it technically contains only one \"element\" (None), so return True\n    if not lst:\n        return True\n    \n    # Compare the first element with the rest. If all are equal, the list has one unique element\n    return all(element == lst[0] for element in lst)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if the list contains only one distinct element.\n    \n    Args:\n    numbers (list): A list of numbers to check for uniqueness.\n    \n    Returns:\n    bool: True if the list has only one distinct element, False otherwise.\n    \n    Examples:\n    >>> unique_Element([1,1,1])\n    True\n    >>> unique_Element([1,2,1])\n    False\n    \"\"\"\n    # If the list has one or zero elements, it automatically has one or zero distinct elements\n    if len(numbers) <= 1:\n        return True\n    \n    # Get the first element\n    first_element = numbers[0]\n    \n    # Use the all() function with a generator expression to check if all elements are the same\n    return all(x == first_element for x in numbers[1:])", "matching_cluster_idx": 3}]}, "Mbpp/764": {"dps": 90.37037037037037, "dps_norm": 52.5, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Args:\n    s (str): The string to analyze for digits.\n\n    Returns:\n    int: The count of digits found in the string.\n\n    Examples:\n    >>> number_ctr('program2bedone')\n    1\n    >>> number_ctr('a1b2c3d4e5')\n    5\n    \"\"\"\n    # Use a list comprehension with isdigit() to count only digits\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    s (str): The string in which to count the digits.\n\n    Returns:\n    int: The number of digits found in the string.\n    \"\"\"\n    # Use a list comprehension to filter out digits and count them\n    return len([char for char in s if char.isdigit()])", "matching_cluster_idx": 3}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count the number of digits in a given string.\n\n    This function iterates through each character in the input string,\n    checking if it's a digit using Python's built-in str.isdigit() method.\n\n    Args:\n        s (str): The string to analyze.\n\n    Returns:\n        int: The count of digits found in the string.\n\n    Examples:\n        >>> number_ctr('program2bedone')\n        1\n        >>> number_ctr('no digits here')\n        0\n        >>> number_ctr('123abc45')\n        5\n    \"\"\"\n    # Use list comprehension to get all digit characters and count them\n    return len([char for char in s if char.isdigit()])", "matching_cluster_idx": 3}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    This function iterates through each character in the string and checks if it is a digit.\n    It uses the isdigit() method, which returns True for Unicode characters that are classified\n    as digits.\n    \n    Args:\n    s (str): The input string to check for digits.\n    \n    Returns:\n    int: The count of digits found in the string.\n    \n    Examples:\n    >>> number_ctr('program2bedone')\n    1\n    >>> number_ctr('123abc456')\n    6\n    \"\"\"\n    # Use sum to count True values from a generator expression where each character is checked if it's a digit\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Args:\n    s (str): The input string to analyze.\n\n    Returns:\n    int: The count of digit characters in the string.\n\n    Examples:\n    >>> number_ctr('program2bedone')\n    1\n    \"\"\"\n    # Use sum to count True values, where isdigit() returns True for each digit\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Args:\n    s (str): The string to check for digits.\n\n    Returns:\n    int: The count of digits found in the string.\n\n    Example:\n    >>> number_ctr('program2bedone')\n    1\n    \"\"\"\n    # Use a list comprehension to filter out digits and then count them\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    This function iterates through each character in the string and\n    counts those that are digits.\n\n    Parameters:\n    s (str): The input string to check for digits.\n\n    Returns:\n    int: The count of digit characters found in the string.\n\n    Examples:\n    >>> number_ctr('program2bedone')\n    1\n    >>> number_ctr('123program')\n    3\n    \"\"\"\n    # Use a list comprehension to count digits\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count the number of digits in the given string.\n\n    This function iterates through each character in the string and checks if it's a digit.\n    \n    Args:\n    s (str): The input string to check for digits.\n\n    Returns:\n    int: The count of digits found in the string.\n\n    Examples:\n    >>> number_ctr('program2bedone')\n    1\n    >>> number_ctr('1234')\n    4\n    \"\"\"\n    # Use a generator expression with sum to count digits\n    # The isdigit() method returns True if all characters in the string are digits\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    s (str): The string to check for digits.\n\n    Returns:\n    int: The count of digits found in the string.\n\n    Example:\n    >>> number_ctr('program2bedone')\n    1\n    \"\"\"\n    # Use sum to count how many characters are digits\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Args:\n    s (str): The string to search for digits.\n\n    Returns:\n    int: The count of digits found in the string.\n\n    Example:\n    >>> number_ctr('program2bedone')\n    1\n    \"\"\"\n    # Use a generator expression with sum to count digits\n    # 'd.isdigit()' checks if 'd' is a digit character\n    return sum(d.isdigit() for d in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    s (str): The input string to search for digits.\n\n    Returns:\n    int: The count of digits found in the string.\n\n    Example:\n    >>> number_ctr('program2bedone')\n    1\n    \"\"\"\n    # Use a generator expression with sum to count characters that are digits\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Args:\n    s (str): The input string to check for digits.\n\n    Returns:\n    int: The count of digits found in the string.\n\n    Examples:\n    >>> number_ctr('program2bedone')\n    1\n    >>> number_ctr('test123test')\n    3\n    \"\"\"\n    # Use sum with a generator expression to count digits\n    # isdigit() checks if each character is a digit\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count the number of digits in the given string.\n\n    This function iterates over each character in the string,\n    checks if it is a digit, and counts it if so.\n\n    Args:\n    s (str): The input string to check for digits.\n\n    Returns:\n    int: The count of digits found in the string.\n\n    Raises:\n    TypeError: If the input is not a string.\n\n    Example:\n    >>> number_ctr('program2bedone')\n    1\n    \"\"\"\n    # Check if input is string\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Use a list comprehension to create a list of digits then count them\n    # Alternatively, for Python 2 or to avoid comprehension, you could:\n    # count = sum(1 for char in s if char.isdigit())\n    count = len([char for char in s if char.isdigit()])\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Args:\n    s (str): The input string to analyze for digits.\n\n    Returns:\n    int: The count of digits found in the string.\n\n    Examples:\n    >>> number_ctr('program2bedone')\n    1\n    >>> number_ctr('python3.0')\n    2\n    >>> number_ctr('no_digits_here')\n    0\n    \"\"\"\n    # Use a list comprehension to filter out non-digit characters\n    # and then count the remaining characters which are digits\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Counts the number of digits in the given string.\n\n    This function iterates through each character in the string\n    and checks if it is a digit. It returns the count of digits found.\n\n    Args:\n    s (str): The input string to check for digits.\n\n    Returns:\n    int: The number of digits in the string.\n\n    Examples:\n    >>> number_ctr('program2bedone')\n    1\n    >>> number_ctr('123test456')\n    6\n    \"\"\"\n    # Use a list comprehension with sum to count digits. \n    # 'c.isdigit()' will be True for each digit, summing to total count\n    return sum(1 for c in s if c.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    This function iterates through each character in the string and checks\n    if it is a digit. If so, it increments a counter.\n\n    Args:\n    string (str): The string to check for digits.\n\n    Returns:\n    int: The count of digits found in the string.\n\n    Example:\n    >>> number_ctr('program2bedone')\n    1\n    \"\"\"\n    # Initialize the count of digits\n    digit_count = 0\n    \n    # Iterate over each character in the string\n    for char in string:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    s (str): The input string to be analyzed for digits.\n\n    Returns:\n    int: The count of digit characters found in the string.\n\n    Example:\n    >>> number_ctr('program2bedone')\n    1\n    \"\"\"\n    # Use a list comprehension to filter digits and then count them\n    return len([char for char in s if char.isdigit()])", "matching_cluster_idx": 3}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count the number of digits in the given string.\n\n    This function iterates through each character in the string and checks\n    if it's a digit. It returns the count of such characters.\n\n    Args:\n    s (str): The input string to check for digits.\n\n    Returns:\n    int: The number of digits found in the string.\n\n    Examples:\n    >>> number_ctr('program2bedone')\n    1\n    >>> number_ctr('123abc')\n    3\n    \"\"\"\n    # Use a list comprehension with sum to count digits\n    # 'isdigit()' returns True if a character is a digit, False otherwise\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    s (str): The input string to check for digits.\n\n    Returns:\n    int: The count of digits found in the string.\n\n    Examples:\n    >>> number_ctr('program2bedone')\n    1\n    >>> number_ctr('123python456')\n    6\n    >>> number_ctr('no_digits_here')\n    0\n    \"\"\"\n    # Use a list comprehension with string.digits to check for digits\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Args:\n    s (str): The input string to search for digits.\n\n    Returns:\n    int: The count of digits found in the string.\n\n    Examples:\n    >>> number_ctr('program2bedone')\n    1\n    >>> number_ctr('python3.9')\n    2\n    \"\"\"\n    # Use sum with a generator expression to count digits\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 79.48598130841121, "dps_norm": 75.0, "pass@1": 96.0, "profiled": [{"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    This function takes a list and generates a new list where each element \n    is a tuple containing two consecutive elements from the original list.\n    \n    Args:\n    lst (list): The input list containing elements to pair.\n\n    Returns:\n    list of tuples: A list where each tuple contains consecutive pairs from lst.\n\n    Examples:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Use list comprehension with zip to pair up consecutive elements\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(arr):\n    \"\"\"\n    Returns a list of tuples where each tuple contains consecutive pairs from the input list.\n\n    :param arr: List of items where pairs are to be formed\n    :return: List of tuples, each containing a pair of consecutive elements\n\n    Example:\n    >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    if len(arr) < 2:\n        return []  # Return an empty list if there aren't enough elements to form pairs\n    # Use zip to pair each element with the next one\n    return list(zip(arr, arr[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of pairs of consecutive items from the input list.\n\n    Args:\n    lst (list): The list from which to form pairs.\n\n    Returns:\n    list of tuple: A list containing tuples of consecutive elements.\n\n    Example:\n    >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Check if the list has less than 2 items, then no pairs can be formed\n    if len(lst) < 2:\n        return []\n\n    # Use list comprehension with zip to pair consecutive elements\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items from the given list.\n    \n    Args:\n    lst (list): The input list from which to form pairs.\n    \n    Returns:\n    list: A list of tuples where each tuple is a pair of consecutive elements from lst.\n    \n    Examples:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Use list comprehension with zip to create pairs of consecutive items\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(arr):\n    # Ensure we have a list to work with\n    if not isinstance(arr, list) or len(arr) < 2:\n        return []\n    \n    # Use list comprehension with zip to pair each element with the next one\n    return [(arr[i], arr[i+1]) for i in range(len(arr)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of tuples where each tuple contains pairs of consecutive items from the input list.\n\n    Args:\n    lst (list): A list of items.\n\n    Returns:\n    list of tuples: Each tuple is a pair of consecutive elements from the input list.\n\n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # If the list has fewer than 2 items, return an empty list\n    if len(lst) < 2:\n        return []\n    \n    # Use zip to create pairs from the list and the list offset by one\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(items):\n    \"\"\"\n    Returns a list of tuples where each tuple contains pairs of consecutive items from the input list.\n\n    Args:\n    items (list): A list of items to pair.\n\n    Returns:\n    list of tuple: Each tuple contains consecutive pairs from the original list.\n\n    Examples:\n    >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Use list comprehension to create pairs of consecutive items\n    return [(items[i], items[i+1]) for i in range(len(items) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(items):\n    \"\"\"\n    Generate pairs of consecutive items from the given list.\n\n    Args:\n    items (list): A list of items to generate pairs from.\n\n    Returns:\n    list of tuple: A list containing tuples of consecutive pairs from the input list.\n\n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Use zip to pair each item with the next one\n    # zip_longest with fillvalue=None handles the case when list has odd length\n    return list(zip(items, items[1:] + [None]))[:-1]", "matching_cluster_idx": 5}, {"solution": "def pair_wise(items):\n    \"\"\"\n    Generate pairs of consecutive items from the given list.\n\n    Args:\n    items (list): The input list from which to generate pairs.\n\n    Returns:\n    list of tuple: A list where each element is a pair (tuple) of consecutive items from the input list.\n\n    Example:\n    >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Check if the list has at least two elements\n    if len(items) < 2:\n        return []\n\n    # Use list comprehension with zip to pair each element with its successor\n    return [(items[i], items[i + 1]) for i in range(len(items) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(sequence):\n    \"\"\"\n    Returns a list of tuples where each tuple contains consecutive items from the given sequence.\n\n    Args:\n    sequence (list): A list of elements to process.\n\n    Returns:\n    list of tuples: Each tuple represents a pair of consecutive items from the sequence.\n\n    Example:\n    >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Check if the sequence is empty or has only one item, return an empty list in such cases\n    if len(sequence) < 2:\n        return []\n    \n    # Using list comprehension to create pairs\n    return [(sequence[i], sequence[i+1]) for i in range(len(sequence) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(items):\n    \"\"\"\n    Returns a list of tuples where each tuple contains two consecutive items from the input list.\n    \n    Args:\n    items (list): A list of items to process.\n\n    Returns:\n    list: A list of tuples of consecutive pairs.\n\n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Check if the list has less than two elements, return an empty list in this case\n    if len(items) < 2:\n        return []\n\n    # Use list comprehension with zip to create pairs\n    return [(items[i], items[i+1]) for i in range(len(items)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(items):\n    \"\"\"\n    Return a list of tuples where each tuple contains pairs of consecutive items from the input list.\n    \n    Args:\n    items (list): The list of items to process.\n    \n    Returns:\n    list of tuples: A list where each tuple is a pair of consecutive items from 'items'.\n    \n    Examples:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Use zip to pair each item with the next one, but stop at the second last element\n    # since we can't pair the last item with anything\n    return list(zip(items, items[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(items):\n    \"\"\"\n    Generate a list of all pairs of consecutive items in the given list.\n\n    Args:\n    items (list): A list of elements to form pairs from.\n\n    Returns:\n    list of tuple: A list where each element is a tuple of two consecutive items from the input list.\n\n    Examples:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Use list comprehension to create pairs. zip(items, items[1:]) \n    # creates pairs from current item and next item.\n    return [(items[i], items[i+1]) for i in range(len(items)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of tuples, where each tuple is a pair of consecutive items from the input list.\n\n    :param lst: List of items from which to create pairs\n    :type lst: list\n    :return: List of tuples containing consecutive pairs\n    :rtype: list of tuple\n\n    Example:\n    >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # If the list has fewer than two elements, return an empty list\n    if len(lst) < 2:\n        return []\n    \n    # Use zip to pair each item with the next one\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of tuples where each tuple contains consecutive pairs from the input list.\n    \n    Args:\n    lst (list): The input list of items.\n    \n    Returns:\n    list of tuples: Each tuple contains consecutive elements from the input list.\n    \n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Use list comprehension to create pairs from lst and lst with offset of 1\n    # zip() pairs elements from two iterables together\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Generate a list of all pairs of consecutive items from the given list.\n\n    Args:\n    lst (list): The input list from which to generate pairs.\n\n    Returns:\n    list of tuples: A list where each element is a tuple of two consecutive items from the input list.\n\n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Using list comprehension to create pairs of consecutive items\n    # We pair each element with the next one using zip; if lst is empty, zip will return an empty iterator\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(items):\n    \"\"\"\n    Returns a list of tuples where each tuple contains two consecutive items from the input list.\n\n    Args:\n    items (list): The list from which to extract consecutive pairs.\n\n    Returns:\n    list of tuples: A list where each element is a tuple of two consecutive items.\n\n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Use zip to pair each item with the next one in the list, \n    # stopping one short to ensure there's a pair for each item except the last\n    return list(zip(items, items[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(items):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n\n    Args:\n    items (list): The input list from which to generate consecutive pairs.\n\n    Returns:\n    list of tuple: A list containing pairs of consecutive elements from 'items'.\n\n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Use list comprehension to generate pairs from the list\n    # zip the list with itself offset by one position to create pairs\n    return [(items[i], items[i+1]) for i in range(len(items)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of tuples, each containing pairs of consecutive items from the input list.\n    \n    Args:\n    lst (list): A list of items to process.\n\n    Returns:\n    list: A list where each element is a tuple of consecutive pairs from the input list.\n\n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Use list comprehension with zip to pair up each element with its next one\n    # zip(lst[:-1], lst[1:]) pairs each element with the next, excluding the last element for the first argument\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 4}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Generate all pairs of consecutive items from the given list.\n\n    Args:\n    lst (list): A list of items to pair up consecutively.\n\n    Returns:\n    list of tuples: Pairs of consecutive items.\n\n    Example:\n    >>> pair_wise([1,1,2,3,3,4,4,5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Use list comprehension with zip to pair each item with the next one\n    return [(current, next_item) for current, next_item in zip(lst, lst[1:])]", "matching_cluster_idx": 3}]}, "Mbpp/775": {"dps": 90.35999999999999, "dps_norm": 67.85714285714286, "pass@1": 95.0, "profiled": [{"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index in the list is an odd number.\n\n    Args:\n    lst (list): A list of integers to be checked.\n\n    Returns:\n    bool: True if all odd indices contain odd numbers, False otherwise.\n\n    Examples:\n    >>> odd_position([2,1,4,3,6,7,6,3])\n    True\n    >>> odd_position([2,2,4,8,6,9])\n    False\n    \"\"\"\n    # We start from index 1 because 0 is considered even\n    for i in range(1, len(lst), 2):  \n        # If the number at an odd index is not odd, return False\n        if lst[i] % 2 == 0:\n            return False\n    \n    # If we've gone through all odd indices without returning False, then all are odd\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index in the list is an odd number.\n\n    Args:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if all numbers at odd indices are odd, False otherwise.\n\n    Example:\n    >>> odd_position([2, 1, 4, 3, 6, 7, 6, 3])\n    True\n    \"\"\"\n    # Check if list has at least one element for the test to make sense\n    if len(lst) < 2:\n        return True  # As a convention for this function, empty lists or lists with one element are always true\n    \n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:  # If the number at odd index is even\n            return False\n    \n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if all numbers at odd indices (1-based) in the list are odd.\n\n    Parameters:\n    lst (list of int): The list to check.\n\n    Returns:\n    bool: True if all numbers at odd positions are odd, False otherwise.\n\n    Examples:\n    >>> odd_position([2, 1, 4, 3, 6, 7, 6, 3])\n    True\n    >>> odd_position([1, 2, 3, 4, 5])\n    False\n    \"\"\"\n    # Iterate over the list using enumerate to get both index and value\n    # The list indices in Python are 0-based, so we start from index 1\n    for index, num in enumerate(lst):\n        if index % 2 == 1:  # Check for odd index\n            if num % 2 != 1:  # If the number at odd index is not odd\n                return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index in the list is an odd number.\n    \n    :param lst: List of integers to check\n    :return: Boolean indicating whether the condition is met\n    \"\"\"\n    # Check if the list has at least one element at an odd index\n    if len(lst) < 2:\n        return True  # By default, an empty list or a list with one element satisfies the condition\n    \n    # Iterate through odd indexes (remember, list index in Python starts at 0)\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:  # Check if the number at odd index is even\n            return False\n    \n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index in the list is an odd number.\n\n    Args:\n    lst (list): The list to check for odd-position rule.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n\n    Example:\n    >>> odd_position([2,1,4,3,6,7,6,3])\n    True\n    \"\"\"\n    # Check odd indices (1, 3, 5, ...) \n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:  # If the number at an odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index (1, 3, 5, etc.) in the list is an odd number.\n    \n    Args:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if all odd-indexed elements are odd numbers, False otherwise.\n\n    Examples:\n    >>> odd_position([2,1,4,3,6,7,6,3])\n    True\n    >>> odd_position([2,1,4,2])\n    False\n    \"\"\"\n    # Check if every element at an odd index is odd\n    for i in range(1, len(lst), 2):  # Start at index 1, step by 2\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every odd index in the list contains an odd number.\n    \n    Args:\n    lst (list): A list of integers to check.\n    \n    Returns:\n    bool: True if all numbers at odd indices are odd, False otherwise.\n    \n    Examples:\n    >>> odd_position([2,1,4,3,6,7,6,3])\n    True\n    >>> odd_position([2,1,4,2,6,7,6,3])\n    False\n    \"\"\"\n    # Check if list length is sufficient for the condition to even be applicable\n    if len(lst) < 2:\n        return True  # By default, an empty list or a single element list would pass this condition\n    \n    for i in range(1, len(lst), 2):  # Start from index 1, step by 2\n        if lst[i] % 2 == 0:  # If number at an odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n\n    This function iterates through the list checking only the elements \n    at odd indices (1, 3, 5, ...) to see if they are odd.\n\n    Args:\n    lst (list): A list of integers to check.\n\n    Returns:\n    bool: True if all odd-indexed elements are odd, False otherwise.\n\n    Examples:\n    >>> odd_position([2,1,4,3,6,7,6,3])\n    True\n    >>> odd_position([2,1,4,2])\n    False\n    \"\"\"\n    # Check if list is empty or if length is 1 (no odd indices to check)\n    if len(lst) <= 1:\n        return True\n\n    # Check every odd index\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Check if every odd index in the list contains an odd number.\n\n    Args:\n    numbers (list): A list of integers to check.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n\n    Examples:\n    >>> odd_position([2,1,4,3,6,7,6,3])\n    True\n    >>> odd_position([1,3,5,7,9,11])\n    True\n    >>> odd_position([2,2,2,2])\n    False\n    >>> odd_position([2,1,4])\n    False\n    \"\"\"\n    # Iterate over the list, checking odd indices (which are 1, 3, 5 etc. in Python's zero-based indexing)\n    for i in range(1, len(numbers), 2):\n        # If any number at an odd index is not odd, return False\n        if not numbers[i] % 2:\n            return False\n    # If we've made it through the loop, all odd indices have odd numbers\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index in the list is an odd number.\n    \n    :param lst: List of integers to check\n    :return: Boolean indicating if the condition is met\n    \n    Example:\n    >>> odd_position([2, 1, 4, 3, 6, 7, 6, 3])\n    True\n    \"\"\"\n    # Check each element at odd indices (1, 3, 5, etc.)\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:  # If the number at odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Check if every element at an odd index in the list is an odd number.\n\n    Args:\n    numbers (list): A list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n\n    Examples:\n    >>> odd_position([2, 1, 4, 3, 6, 7, 6, 3])\n    True\n    >>> odd_position([1, 2, 1, 2])\n    False\n    \"\"\"\n    # Check if list has at least one odd index (which means at least 2 elements)\n    if len(numbers) < 2:\n        return True  # By definition, an empty list or a single-element list satisfies this condition\n\n    for i in range(1, len(numbers), 2):  # Start from index 1 and step by 2 for odd indices\n        if numbers[i] % 2 == 0:  # If the number at an odd index is even\n            return False\n    \n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index (1, 3, 5, etc.) in the list is an odd number.\n\n    Parameters:\n    lst (list of int): The input list to check.\n\n    Returns:\n    bool: True if all odd-indexed elements are odd numbers, False otherwise.\n\n    Examples:\n    >>> odd_position([2,1,4,3,6,7,6,3])\n    True\n    >>> odd_position([2,1,2,3])\n    False\n    \"\"\"\n    # Check if the list length is at least 2 since we're talking about odd positions\n    if len(lst) < 2:\n        return True  # By default, return True for lists with no odd index\n    \n    # Iterate over the list by index, checking odd positions\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:  # If the number at an odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every odd-indexed element (1-indexed) in the list contains an odd number.\n    \n    Args:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if all odd-indexed positions hold odd numbers, False otherwise.\n    \n    Examples:\n    >>> odd_position([2,1,4,3,6,7,6,3])\n    True\n    >>> odd_position([1,2,3,5])\n    False\n    \"\"\"\n    # Check if all elements at odd indices are odd\n    # Remember Python uses 0-based indexing, so we check 1, 3, 5, ... indices\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index in the list is an odd number.\n    \n    Args:\n    lst (list): The list to check.\n    \n    Returns:\n    bool: True if all numbers at odd indices are odd, False otherwise.\n    \n    Examples:\n    >>> odd_position([2,1,4,3,6,7,6,3])\n    True\n    >>> odd_position([2,1,4,3,6,7,6,2])\n    False\n    \"\"\"\n    # Check if every odd-indexed element is odd\n    # We use 1-based indexing for clarity in odd index positions\n    return all(num % 2 != 0 for index, num in enumerate(lst, start=1) if index % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index in the list is an odd number.\n\n    This function iterates through the list checking only the elements \n    at indices 1, 3, 5, etc., to see if they are odd numbers.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n\n    Example:\n    >>> odd_position([2,1,4,3,6,7,6,3])\n    True\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index in the list is an odd number.\n\n    Args:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n\n    Examples:\n    >>> odd_position([2,1,4,3,6,7,6,3])\n    True\n    >>> odd_position([2,1,4,3,6,8,6,3])\n    False\n    \"\"\"\n    # Use list comprehension to check if numbers at odd indices are odd\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index in the list is an odd number.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if all elements at odd indices are odd numbers, False otherwise.\n    \n    Examples:\n    >>> odd_position([2, 1, 4, 3, 6, 7, 6, 3])\n    True\n    >>> odd_position([2,1,4,1])\n    False\n    >>> odd_position([2,1,4,3])\n    True\n    \"\"\"\n    # We start from index 1 (which is the second element), and step by 2 to get to odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the number at the odd index is even (not odd)\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index in the list is an odd number.\n    \n    Args:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if all numbers at odd indices are odd, False otherwise.\n    \n    Examples:\n    >>> assert odd_position([2,1,4,3,6,7,6,3]) == True\n    >>> assert odd_position([2,1,4,3,6,7,6,2]) == False\n    \"\"\"\n    # Iterate over the list with a step of 2 to get to odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the number at an odd index is odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every odd-indexed position (1-based index) contains an odd number.\n\n    This function iterates through the list, checking each element at an odd index\n    (indices 1, 3, 5, etc. in a 0-based list) to ensure they are odd numbers.\n\n    Args:\n    lst (list): A list of integers to check.\n\n    Returns:\n    bool: True if all numbers at odd indices are odd, False otherwise.\n\n    Examples:\n    >>> odd_position([2,1,4,3,6,7,6,3])\n    True\n    >>> odd_position([2,1,4,5])\n    True\n    >>> odd_position([4,1,2])\n    False\n    \"\"\"\n    # Check odd-indexed positions, but we adjust for 0-based indexing in Python\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index (1, 3, 5, etc.) in the list is an odd number.\n\n    Args:\n    lst (list): A list of integers to check.\n\n    Returns:\n    bool: True if all numbers at odd indexes are odd, False otherwise.\n\n    Example:\n    >>> odd_position([2,1,4,3,6,7,6,3])\n    True\n    \"\"\"\n    # Use list slicing to get elements at odd indices starting from 1\n    # Check if all these elements are odd\n    return all(num % 2 != 0 for num in lst[1::2])", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/781": {"dps": 94.68503937007874, "dps_norm": 95.0, "pass@1": 66.0, "profiled": [{"solution": "def count_divisors(n):\n    \"\"\"\n    Check if the number of divisors of n is even.\n    \n    :param n: Integer to check for divisors\n    :return: Boolean indicating if the divisor count is even\n    \"\"\"\n    # Start with 1 and n as divisors, we don't need to count them twice\n    divisors = 1 if n == 1 else 2\n    \n    # We only need to check up to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i divides n, we add 2 because both i and (n/i) are divisors\n            if i * i != n:  # Avoid counting the square root twice\n                divisors += 2\n            else:\n                divisors += 1  # For perfect squares, count the square root once\n    \n    # If divisors count is even, return True\n    return divisors % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check if the count of divisors of n is even.\n    \n    This function counts how many numbers divide n without remainder.\n    If the count is even, it returns True; otherwise, False.\n    \n    Parameters:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \n    Example:\n    >>> count_divisors(10)\n    True\n    \"\"\"\n    # Start with 1 and n as the only divisors, if n isn't 1 itself\n    divisor_count = 2 if n != 1 else 1\n    \n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i divides n, both i and n/i are divisors\n            if i * i == n:  # This check prevents counting the square root twice\n                divisor_count += 1\n            else:\n                divisor_count += 2\n    \n    return divisor_count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(num):\n    \"\"\"\n    Check if the count of divisors of a given number is even.\n    \n    Args:\n    num (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # 1 is always a divisor, and the number itself if it's not 1\n    count = 2 if num != 1 else 1\n    \n    # Check for other divisors up to the square root of num\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            # If i divides num, then both i and (num/i) are divisors\n            # However, if i == num/i, then we've counted i once instead of twice\n            count += 2 if i * i != num else 1\n            \n    # If count is even, return True, otherwise return False\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check if the count of divisors for a number is even.\n\n    This function counts how many numbers from 1 to n (inclusive) divide n evenly.\n    It then checks if this count is even.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n\n    Example:\n    >>> count_divisors(10)\n    True\n    \"\"\"\n    # Initialize divisor count\n    divisor_count = 0\n    \n    # Check divisibility from 1 to n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisor_count += 1\n    \n    # Check if the count of divisors is even\n    return divisor_count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check if the number of divisors for the given number 'n' is even.\n    \n    A divisor is a number that divides 'n' without leaving a remainder.\n    This function counts the divisors and checks if the count is even.\n    \n    :param n: Integer to check for divisors\n    :return: True if the number of divisors is even, False otherwise\n    \n    :example:\n    >>> count_divisors(10)\n    True\n    >>> count_divisors(7)  # 7 has only one divisor, itself\n    False\n    \"\"\"\n    # If n is 0, it technically has infinite divisors, but we'll handle this case:\n    if n == 0:\n        return False\n    \n    # Count of divisors\n    divisor_count = 0\n    \n    # For loop from 1 to the square root of n, which is efficient for finding divisors\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If 'i' is not equal to its counterpart divisor (n // i), we have two divisors\n            if i * i != n:\n                divisor_count += 2\n            else:\n                # If 'i' is the square root of n, we count it only once\n                divisor_count += 1\n    \n    # Check if the count is even\n    return divisor_count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of divisors for a given number n is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \n    Examples:\n    >>> count_divisors(10)\n    True\n    >>> count_divisors(15)\n    False\n    \"\"\"\n    # Initialize count with 1 as every number is divisible by 1\n    count = 1\n    \n    # Check divisors up to the square root of n for efficiency\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If 'i' is a divisor, count both i and n/i as divisors\n            if i * i != n:  # This condition ensures we don't count the same divisor twice for perfect squares\n                count += 2\n            else:\n                count += 1  # For perfect squares like 4, 9, 16 where both divisors are the same\n    \n    # Count n itself if n != 1 since 1 has already been counted\n    if n != 1:\n        count += 1\n    \n    # If the count of divisors is even, return True, otherwise False\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check if the count of divisors for the given number is even.\n    \n    :param n: Integer to check\n    :return: Boolean indicating if the divisor count is even\n    \"\"\"\n    # Start from 1 and count up to the square root of n for efficiency\n    divisor_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is not the square root of n, then count both i and n/i\n            if i * i != n:\n                divisor_count += 2\n            else:\n                divisor_count += 1  # In case n is a perfect square, count i only once\n    \n    return divisor_count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check if the number of divisors of 'n' is even.\n    \n    A number has an even count of divisors if it can be expressed as a product \n    of an odd number of prime factors each to an odd power. For simplicity, \n    this function directly counts divisors:\n    - Every number > 1 is divisible by 1 and itself.\n    - If count > 2 and the number is not a perfect square, it's even.\n    - A perfect square has at least one factor repeated, which makes the count odd.\n\n    :param n: An integer to check for the evenness of its divisor count.\n    :return: Boolean indicating if the count of divisors is even.\n    \"\"\"\n    # Numbers less than or equal to 1 have an odd number of divisors (only 1)\n    if n <= 1:\n        return False\n    \n    # Count divisors\n    divisor_count = 2  # Divisible by 1 and itself\n    for i in range(2, int(n**0.5) + 1):  # Loop up to the square root\n        if n % i == 0:\n            # If 'i' is a divisor, so is 'n/i'\n            divisor_count += 2 if i != n // i else 1\n    \n    # If the count is more than 2, it's even unless n is a perfect square\n    return divisor_count % 2 == 0 and (divisor_count > 2 or n != int(n**0.5)**2)", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check if the count of divisors of the given number is even.\n    \n    This function finds all divisors of 'n' and then determines\n    if the count of those divisors is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \n    Examples:\n    >>> count_divisors(10)\n    True\n    >>> count_divisors(15)\n    False\n    \"\"\"\n    # We include 1 and n itself if n > 1\n    divisors = set()  # Using a set for efficient lookup\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            # If i is not the square root, then n/i is also a divisor\n            if i != n // i:\n                divisors.add(n // i)\n    \n    # Check if the count of divisors is even\n    return len(divisors) % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    # Start counting from 1 to include 1 as a divisor\n    count = 0\n    # Only go up to the square root of n for efficiency\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, n/i is also a divisor unless i == n/i\n            if i * i != n: \n                count += 2\n            else:\n                count += 1  # If i is the square root of n, count it only once\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check if the number of divisors for the given integer n is even.\n    \n    :param n: Integer to check for divisors\n    :return: True if the count of divisors is even, False otherwise\n    \"\"\"\n    # Ensure n is positive\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    # List to keep track of divisors\n    divisors = []\n    \n    # Check up to the square root of n for efficiency\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If 'i' is a divisor, add both i and n/i\n            if i != n // i:\n                divisors.append(i)\n                divisors.append(n // i)\n            else:\n                # In case of perfect squares, we don't double count\n                divisors.append(i)\n    \n    # If the count of divisors is even, return True\n    return len(divisors) % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check if the count of divisors of n is even.\n    \n    :param n: Integer whose divisors are to be counted\n    :return: Boolean, True if the number of divisors is even, False otherwise\n    \n    Examples:\n    >>> count_divisors(10)\n    True\n    >>> count_divisors(7)\n    False\n    \"\"\"\n    # We only need to check up to the square root of n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i divides n, then either i is sqrt(n) or n/i is another divisor\n            # We count i if and only if i * i != n (to avoid double counting the square root)\n            if i * i != n:\n                count += 2\n            else:\n                count += 1\n    \n    # The function should return whether this count is even\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check if the count of divisors of n is even.\n    \n    Args:\n    n (int): The number to check for divisor count.\n    \n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \n    Examples:\n    >>> count_divisors(10)\n    True\n    >>> count_divisors(8)\n    False\n    \"\"\"\n    # Initialize count of divisors to 0\n    divisor_count = 0\n    \n    # Loop up to the square root of n to optimize the divisor count\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, count it\n            divisor_count += 1\n            # If i != n/i, then count n/i as well to avoid overcounting for perfect squares\n            if i != n // i:\n                divisor_count += 1\n                \n    # Return True if the count of divisors is even\n    return divisor_count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Determine if the count of divisors for a given number is even.\n    \n    A divisor count is considered even if including the number itself, \n    which technically isn't correct by strict definition, but is often how \n    this problem is approached in interview scenarios. Here, 1 and the number \n    itself are always included, which inherently leads to an even count for \n    numbers greater than 1, except for primes.\n\n    Args:\n    n (int): The number to check for divisors.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        raise ValueError(\"Number must be greater than zero.\")\n    \n    if n == 1:\n        return False  # 1 has only 1 divisor, which is odd\n\n    # Count divisors, but note that for efficiency, we don't actually \n    # count all divisors since we already know that including 1 and n \n    # makes the count even for all non-prime numbers > 1\n    count = 2  # We start with 2 because n itself and 1 are divisors\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i != n:  # If n is not a perfect square, we count both divisors\n                count += 2\n            else:\n                count += 1\n    \n    # However, for the purpose of this problem, where we're just asserting:\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\" \n    This function checks if the number of divisors for a given integer n is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize the count of divisors\n    divisor_count = 0\n    \n    # Check for divisors from 1 to sqrt(n) since divisors come in pairs\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, n/i is also a divisor\n            if i * i != n:  # Avoid counting perfect squares twice\n                divisor_count += 2\n            else:\n                divisor_count += 1\n    \n    # Return whether the count of divisors is even\n    return divisor_count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    if n == 1:\n        return False  # 1 has exactly one divisor, which is an odd count\n    \n    divisor_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are not the same, count both\n            if i * i != n:  \n                divisor_count += 2\n            else:\n                # If divisors are the same, count only one\n                divisor_count += 1\n    # Return if count of divisors is even\n    return divisor_count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check if the number of divisors of n is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n\n    Examples:\n    >>> count_divisors(10)\n    True\n    >>> count_divisors(7)\n    False\n    \"\"\"\n    # Initialize count of divisors\n    divisor_count = 0\n    \n    # Check divisors up to the square root of n for efficiency\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, count it and its pair\n            # If i == n/i, we should only count once\n            if i * i == n:\n                divisor_count += 1\n            else:\n                divisor_count += 2\n    \n    # Return True if the number of divisors is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\" \n    Check if the count of divisors of n is even.\n\n    :param n: Integer to check\n    :return: True if the count of divisors is even, False otherwise\n    \"\"\"\n    # Edge case for n = 0 or n = 1, which both have exactly one divisor\n    if n in (0, 1):\n        return False\n    \n    count = 0\n    # Check up to the square root of n for divisors\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, both i and n//i are divisors unless i == n//i\n            if i * i != n:  # Avoid counting a perfect square divisor twice\n                count += 2\n            else:\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \n    Example:\n    >>> assert count_divisors(10) == True\n    \"\"\"\n    # Edge case: 1 has only one divisor, which makes the count odd\n    if n == 1:\n        return False\n    \n    # Count of divisors, starts with 2 for 1 and n itself\n    divisor_count = 2 if n != 1 else 1\n    \n    # Check divisors from 2 to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If 'i' is a divisor, count it, and its pair if they're different\n            if i * i != n:  # When i is not the square root of n\n                divisor_count += 2\n            else:  # When i is the square root of n\n                divisor_count += 1\n\n    # The count of divisors is even if it's divisible by 2\n    return divisor_count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors for a number is even.\n\n    Parameters:\n    n (int): The number to check for divisors.\n\n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n\n    Examples:\n    >>> count_divisors(10)\n    True\n    >>> count_divisors(7)\n    False\n    \"\"\"\n    # Handle 1 as a special case since its only divisor is itself\n    if n == 1:\n        return False\n    \n    # Count of divisors\n    divisor_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are different, increment by 2\n            if i != n // i:\n                divisor_count += 2\n            # If the divisor is the same (i.e., perfect square), increment by 1\n            else:\n                divisor_count += 1\n    \n    # Check if the divisor count is even\n    return divisor_count % 2 == 0", "matching_cluster_idx": 4}]}, "Mbpp/800": {"dps": null, "dps_norm": null, "pass@1": 7.0, "profiled": []}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 87.0, "profiled": [{"solution": "def max_sum_list(lists):\n    # Use a list comprehension with max to find the list with the largest sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list from a list of lists whose sum of elements is the highest.\n    \n    Args:\n    lists (list): A list of lists containing numbers.\n    \n    Returns:\n    list: The list with the highest sum of elements.\n    \n    Examples:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    # If the input list is empty, return an empty list\n    if not lists:\n        return []\n    \n    # Use max with a key function that calculates the sum of each inner list\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Use max with a key function that calculates the sum of each sublist\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list from a list of lists whose sum of elements is the highest.\n\n    Args:\n    lists (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n    List[int]: The list with the maximum sum.\n\n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    # Check if the input is empty or not a list of lists\n    if not lists or not all(isinstance(item, list) for item in lists):\n        raise ValueError(\"Input must be a non-empty list of lists\")\n\n    # Use max with a key function that calculates the sum of each list\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # If the list is empty, return an empty list\n    if not lists:\n        return []\n    \n    # Use max with a key function that computes the sum of each sublist\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list from a list of lists whose sum of elements is the highest.\n    \n    Args:\n    list_of_lists (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n    List[int]: The list with the highest sum of elements. If multiple lists \n    have the same sum, returns the first encountered.\n\n    Examples:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    >>> max_sum_list([[0,0,0], [-1, -2]])\n    [0, 0, 0]\n    \"\"\"\n    if not list_of_lists:\n        return []  # Handle the case of an empty list\n\n    # Use max with a key function to find the list with the maximum sum\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize variables\n    max_sum = float('-inf')  # Start with negative infinity for comparison\n    max_list = None\n\n    # Iterate over each sublist\n    for sublist in lists:\n        # Calculate the sum of the current sublist\n        current_sum = sum(sublist)\n        # Update max_sum and max_list if current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # If the list of lists is empty, return an empty list\n    if not lists:\n        return []\n    \n    # Use max with a key function to find the list with the highest sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list with the highest sum of elements from a list of lists.\n\n    Args:\n    lists (list of lists): A collection of lists containing numeric elements.\n\n    Returns:\n    list: The list from the input with the highest sum of its elements.\n\n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    # Check if the input list is empty\n    if not lists:\n        return None\n    \n    # Use max with a key function that computes the sum of each list\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Find and return the list with the highest sum of elements from a list of lists.\n\n    Args:\n    lists (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n    List[int]: The list with the maximum sum of its elements.\n\n    Examples:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    # Use max with a key function to find the list with the highest sum\n    # The key function here calculates the sum of each sublist\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list from a list of lists whose elements sum to the highest value.\n\n    Parameters:\n    lists (list of lists): A collection of integer lists.\n\n    Returns:\n    list: The list with the highest sum.\n\n    Examples:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    if not lists:\n        return []\n    \n    # Use max with a key function to find the list with the maximum sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Find the sublist from a list of lists with the highest sum of its elements.\n\n    Args:\n    lists (list of lists): A collection of lists where each internal list contains numbers.\n\n    Returns:\n    list: The list whose sum of elements is the highest.\n\n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    # Use max with a key function that sums each list to find the list with the maximum sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Find the sublist with the highest sum from a list of lists.\n    \n    This function iterates through each sublist, computes its sum, and \n    returns the sublist with the maximum sum.\n    \n    Parameters:\n    lists (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    List[int]: The list with the largest sum of elements.\n    \n    Examples:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    # If the list is empty, return an empty list\n    if not lists:\n        return []\n\n    # Find the list with max sum using max() with a key function\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # If the list of lists is empty, return None\n    if not lists:\n        return None\n    \n    # Find the list with the maximum sum using max with a key function\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list from a list of lists whose sum of elements is the highest.\n    \n    :param lists: List of lists containing integers\n    :return: List with the highest sum of elements\n    \"\"\"\n    # Use max with a key function that computes the sum of each sublist\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list from a list of lists with the highest sum of its elements.\n\n    :param lists: List of lists containing numbers\n    :return: The list with the maximum sum or None if the input is empty\n\n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    if not lists:  # If the input list is empty\n        return None\n    \n    # Use max with a key function that computes the sum of each sublist\n    # Here lambda is used to create an anonymous function that calculates the sum of each list\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    This function returns the list from a list of lists which has the highest sum of elements.\n\n    Args:\n    lists (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n\n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    # Check if the list of lists is empty\n    if not lists:\n        return []\n    \n    # Find the list with the maximum sum\n    max_sum = float('-inf')\n    max_list = []\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Check if the input list is empty\n    if not lists:\n        return None\n    \n    # Find the list with the maximum sum using a list comprehension\n    # max() takes the list with the maximum sum using sum() as key function\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Find and return the list with the highest sum of elements from a list of lists.\n    \n    Args:\n    lists (List[List[int]]): A list containing sublists of integers.\n    \n    Returns:\n    List[int]: The sublist whose sum is the highest.\n    \n    Examples:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    # Check if the list is empty to avoid errors\n    if not lists:\n        return None\n    \n    # Use the max function with a key that calculates the sum of each sublist\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list from a list of lists that has the highest sum of its elements.\n    \n    Args:\n    list_of_lists (list of list of int): A list containing sublists of integers.\n\n    Returns:\n    list of int: The sublist with the maximum sum of elements.\n\n    Examples:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    # If the list is empty, return an empty list\n    if not list_of_lists:\n        return []\n    \n    # Find the list with the max sum using a key function with built-in sum\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 93.0, "profiled": [{"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple 'tup' contains the value 'k'.\n\n    Args:\n    tup (tuple): The tuple to search through.\n    k (Any): The value to look for in the tuple.\n\n    Returns:\n    bool: True if 'k' is found in the tuple, False otherwise.\n\n    Examples:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((1, 2, 3), 4)\n    False\n    \"\"\"\n    # Directly use the 'in' operator for simplicity and efficiency\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tup (tuple): The tuple to check within.\n    k (any): The value to look for in the tuple.\n\n    Returns:\n    bool: True if k is found in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Args:\n    tup (tuple): The tuple to check.\n    k: The value to look for in the tuple.\n    \n    Returns:\n    bool: True if k is found in tup, False otherwise.\n    \n    Examples:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((1, 2, 3, 4), 5)\n    False\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    - tup: A tuple to search in.\n    - k: The value to look for.\n\n    Returns:\n    - bool: True if k is in tup, False otherwise.\n\n    Examples:\n    >>> assert check_K((10, 4, 5, 6, 8), 6) == True\n    >>> assert check_K((1, 2, 3), 4) == False\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    k (Any): The value to search for.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n\n    Examples:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((10, 4, 5, 7, 8), 3)\n    False\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tup (tuple): A tuple of integers to search through.\n    k (int): The value to find in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n\n    Examples:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((1, 2, 3), 5)\n    False\n    \"\"\"\n    # Using 'in' operator for simplicity and efficiency\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to search through.\n    k (any): The value to look for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n\n    Example:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((1, 2, 3), 4)\n    False\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple 'tup' contains the element 'k'.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    k (any): The element to look for in the tuple.\n\n    Returns:\n    bool: True if 'k' is found in 'tup', False otherwise.\n\n    Examples:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((1, 2, 3), 4)\n    False\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    k (int): The value to look for in the tuple.\n\n    Returns:\n    bool: True if k is found in tup, False otherwise.\n\n    Examples:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((1, 2, 3), 5)\n    False\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple 'tup' contains the value 'k'.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    k (Any): The value to search for.\n\n    Returns:\n    bool: True if 'k' is found in 'tup', False otherwise.\n\n    Example:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((1, 2, 3), 4)\n    False\n    \"\"\"\n    # Use Python's 'in' operator for membership test which is optimized for sequences\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple 'tup' contains the value 'k'.\n\n    Args:\n    tup (tuple): A tuple of elements to search through.\n    k: The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n\n    Examples:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((1, 2, 3), 4)\n    False\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple contains the value k.\n\n    Args:\n    tup (tuple): The tuple to search through.\n    k: The value to find.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n\n    Examples:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((1, 2, 3, 4), 5)\n    False\n    \"\"\"\n    # Directly use the 'in' operator to check for the presence of k in tup\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the specified element k.\n\n    Args:\n    tup (tuple): The tuple to search in.\n    k: The element to look for.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n\n    Examples:\n    >>> assert check_K((10, 4, 5, 6, 8), 6) == True\n    >>> assert check_K((1, 2, 3, 4, 5), 6) == False\n    \"\"\"\n    # Directly use the 'in' operator to check if k is in the tuple\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple 'tup' contains the element 'k'.\n\n    Args:\n    tup (tuple): The tuple to check for the presence of k.\n    k (Any): The value to look for in the tuple.\n\n    Returns:\n    bool: True if 'k' is in 'tup', False otherwise.\n\n    Examples:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((10, 4, 5, 16, 8), 6)\n    False\n    \"\"\"\n    # Using Python's 'in' operator to check for membership\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_to_check, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Parameters:\n    tuple_to_check (tuple): The tuple to search through.\n    k (int): The value to find in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_to_check", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple contains the given element k.\n\n    Args:\n    tup (tuple): A tuple to be searched.\n    k (any): The element to search for within the tuple.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n\n    Examples:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((1, 2, 3, 4, 5), 7)\n    False\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple 'tup' contains the value 'k'.\n\n    Parameters:\n    tup (tuple): The tuple to search through.\n    k: The value to search for.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n\n    Examples:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((1, 2, 3), 4)\n    False\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple 'tup' contains the element 'k'.\n\n    Parameters:\n    - tup (tuple): The input tuple to check.\n    - k (int): The number to look for in the tuple.\n\n    Returns:\n    - bool: True if 'k' is found in 'tup', False otherwise.\n\n    Examples:\n    >>> assert check_K((10, 4, 5, 6, 8), 6) == True\n    >>> assert check_K((1, 2, 3, 4, 5), 7) == False\n    \"\"\"\n    # Use the 'in' operator for efficiency and simplicity\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the specified value k.\n\n    Args:\n    tup (tuple): The tuple to search within.\n    k: The value to look for in the tuple.\n\n    Returns:\n    bool: True if k is found in tup, False otherwise.\n\n    Examples:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((1, 2, 3), 4)\n    False\n    \"\"\"\n    # Use the 'in' operator to check for the presence of k in the tuple\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    - tup: A tuple of integers to check.\n    - k: The value to look for in the tuple.\n\n    Returns:\n    - bool: True if k is found in tup, False otherwise.\n\n    Example:\n    >>> check_K((10, 4, 5, 6, 8), 6)\n    True\n    >>> check_K((1, 2, 3), 4)\n    False\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}]}}}
