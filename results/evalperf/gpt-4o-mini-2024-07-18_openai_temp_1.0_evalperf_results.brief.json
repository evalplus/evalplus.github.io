{"date": "2024-10-19 16:30", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 84.19186096830988, "dps_norm": 79.21827803090933, "pass@1": 85.51694915254237}, "eval": {"HumanEval/9": {"dps": 76.15141955835962, "dps_norm": 73.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_list = []\n    current_max = numbers[0]\n    \n    for number in numbers:\n        current_max = max(current_max, number)\n        max_list.append(current_max)\n        \n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n\n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    current_max = numbers[0]\n    \n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = []\n    current_max = numbers[0]\n    \n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    current_max = numbers[0]\n    \n    for number in numbers:\n        current_max = max(current_max, number)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = []\n    current_max = numbers[0]\n    \n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        rolling_max_list.append(current_max)\n    \n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = []\n    current_max = numbers[0]\n    \n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n        \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for number in numbers[1:]:\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum elements found until a given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_list = []\n    current_max = numbers[0]\n\n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n\n    return max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = []\n    current_max = numbers[0]\n    \n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    current_max = numbers[0]\n    \n    for number in numbers:\n        current_max = max(current_max, number)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}]}, "HumanEval/0": {"dps": 54.70930232558139, "dps_norm": 59.28571428571429, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    numbers.sort()\n    \n    # Compare each pair of adjacent numbers\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to make comparison easier\n    for i in range(len(numbers) - 1):\n        # Check if the difference between consecutive numbers is less than the threshold\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the numbers to allow for efficient checking of proximity\n    numbers.sort()\n    # Iterate through the sorted list and check adjacent elements\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the numbers to make the distance checking more efficient\n    numbers.sort()\n    \n    # Check adjacent numbers in the sorted list\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n            \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list of numbers\n    sorted_numbers = sorted(numbers)\n    \n    # Check pairs of adjacent numbers\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n            \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the numbers to make it easier to find close elements\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:  # Compare adjacent elements\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Args:\n    numbers: A list of floating point numbers.\n    threshold: A floating point number representing the threshold distance.\n    \n    Returns:\n    A boolean indicating if any two numbers are closer than the threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the numbers to check only adjacent pairs\n    sorted_numbers = sorted(numbers)\n    # Iterate through sorted numbers and check the difference between adjacent numbers\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the numbers to make comparison easier\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to find close pairs\n    numbers.sort()\n    \n    # Compare each number with the next one\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n            \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the numbers to make it easier to check for close elements\n    numbers.sort()\n    \n    # Compare each number to the next one in the sorted list\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n            \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Args:\n        numbers (List[float]): A list of float numbers.\n        threshold (float): The threshold distance to check against.\n\n    Returns:\n        bool: True if there are any two numbers that are closer than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the numbers to make it easier to check adjacent pairs\n    sorted_numbers = sorted(numbers)\n\n    # Check the distance between each pair of adjacent numbers\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    numbers.sort()\n\n    # Check consecutive elements for closeness\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n            \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to check adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    # Check the difference between adjacent numbers\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the numbers first\n    numbers.sort()\n    \n    # Check pairs of adjacent numbers in the sorted list\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n            \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list of numbers\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n            \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    >>> has_close_elements([1.0, 1.3, 1.6], 0.4)\n    True\n    >>> has_close_elements([], 1.0)\n    False\n    >>> has_close_elements([1.0], 0.5)\n    False\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    numbers.sort()\n    \n    # Compare each number to the next number in the sorted list\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list of numbers first\n    numbers.sort()\n    # Iterate through the sorted numbers and check differences\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0 for empty list to avoid division by zero\n\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0 for an empty list to avoid division by zero\n    \n    mean_value = sum(numbers) / len(numbers)  # Calculate the mean\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)  # Calculate Mean Absolute Deviation\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation of the input numbers.\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of float numbers.\n\n    Returns:\n        float: The mean absolute deviation of the input numbers.\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Handle empty list case\n    \n    mean_value = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of numerical values.\n    \n    Returns:\n        float: The Mean Absolute Deviation of the input numbers.\n    \n    Examples:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n        >>> mean_absolute_deviation([1.0, 1.0, 1.0])\n        0.0\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0])\n        1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean_value = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Handle the case of an empty list\n\n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of numerical values.\n        \n    Returns:\n        float: The Mean Absolute Deviation of the numbers.\n        \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0 for empty list to avoid division by zero\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0.0 for an empty list to avoid division by zero\n    \n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the Mean Absolute Deviation\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n    numbers (List[float]): A list of numbers to calculate the MAD for.\n\n    Returns:\n    float: The Mean Absolute Deviation of the input numbers.\n\n    Examples:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Handle the case of an empty list\n    \n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Handle empty list case\n    \n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute deviations\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0 for empty list to avoid division by zero\n    \n    mean_value = sum(numbers) / len(numbers)  # Calculate the mean\n    absolute_deviations = [abs(x - mean_value) for x in numbers]  # Calculate absolute deviations\n    mad = sum(absolute_deviations) / len(numbers)  # Calculate the mean of absolute deviations\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # If the list is empty, return 0 as MAD is not defined\n\n    mean_value = sum(numbers) / len(numbers)  # Calculate the mean\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)  # Calculate MAD\n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0 for an empty list to avoid division by zero\n\n    # Calculate the mean\n    mean_value = sum(numbers) / len(numbers)\n\n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n\n    # Calculate the Mean Absolute Deviation\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Handle the case of an empty list\n    \n    mean = sum(numbers) / len(numbers)  # Calculate the mean\n    deviations = [abs(x - mean) for x in numbers]  # Calculate absolute deviations\n    mad = sum(deviations) / len(numbers)  # Calculate the mean of absolute deviations\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Handle the case of an empty list\n\n    # Calculate the mean of the numbers\n    x_mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - x_mean) for x in numbers]\n    \n    # Calculate the mean of the absolute deviations\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0 for empty list\n\n    mean_value = sum(numbers) / len(numbers)  # Calculate the mean\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)  # Calculate the MAD\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0 for empty list to avoid division by zero\n    \n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}]}, "HumanEval/16": {"dps": 44.263565891472865, "dps_norm": 86.11111111111111, "pass@1": 87.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to handle case insensitivity\n    lowercased_string = string.lower()\n    # Use a set to find distinct characters\n    distinct_characters = set(lowercased_string)\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to handle case insensitivity\n    string_lower = string.lower()\n    # Use a set to find distinct characters\n    distinct_characters = set(string_lower)\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase and create a set of characters to find distinct ones\n    distinct_characters = set(string.lower())\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase and use a set to find distinct characters\n    distinct_characters = set(string.lower())\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase and use a set to find distinct characters\n    distinct_characters = set(string.lower())\n    \n    # Remove non-alphabetic characters if needed (optional, based on the problem definition)\n    # distinct_characters = {char for char in distinct_characters if char.isalpha()}\n\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case and create a set of characters to count distinct ones\n    distinct_characters = set(string.lower())\n    # Return the count of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to ensure case insensitivity\n    lower_case_string = string.lower()\n    \n    # Use a set to get distinct characters\n    distinct_characters = set(lower_case_string)\n    \n    # Return the count of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase and create a set of characters to find distinct ones\n    distinct_characters = set(string.lower())\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_case_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_case_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to handle case insensitivity\n    lowercased_string = string.lower()\n    # Create a set of characters to find distinct characters\n    distinct_characters = set(lowercased_string)\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Args:\n        string (str): The input string.\n        \n    Returns:\n        int: The count of distinct characters in the string, ignoring case.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase and create a set of characters to get distinct values\n    distinct_characters = set(string.lower())\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to ensure case insensitivity\n    string_lower = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(string_lower)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Use a set to store distinct characters, converting to lower case\n    distinct_characters = set(char.lower() for char in string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase and create a set of characters to remove duplicates\n    distinct_characters = set(string.lower())\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    # Use a set to find distinct characters\n    distinct_characters = set(lower_string)\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to count characters regardless of case\n    lowercase_string = string.lower()\n    # Use a set to find distinct characters\n    distinct_characters = set(lowercase_string)\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to find distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to ignore case sensitivity\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_characters = set(string)\n    # Return the count of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase and create a set of characters\n    distinct_characters = set(string.lower())\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    string_lower = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(string_lower)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}]}, "HumanEval/20": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list of numbers\n    sorted_numbers = sorted(numbers)\n\n    # Initialize the closest pair and the smallest distance found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_distance = abs(sorted_numbers[1] - sorted_numbers[0])\n\n    # Iterate through the sorted list to find the closest elements\n    for i in range(1, len(sorted_numbers)):\n        current_distance = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if current_distance < smallest_distance:\n            smallest_distance = current_distance\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    \n    # Sort the numbers first\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (0, 0)\n    \n    # Iterate through the sorted list and find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the numbers\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum distance and the closest pair\n    min_distance = float('inf')\n    closest_pair = (0.0, 0.0)\n\n    # Iterate through sorted numbers to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        first = sorted_numbers[i]\n        second = sorted_numbers[i + 1]\n        distance = second - first\n        if distance < min_distance:\n            min_distance = distance\n            closest_pair = (first, second)\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two numbers.\")\n    \n    # Sort the numbers first\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers to facilitate finding the closest pair\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the smallest distance and the closest pair\n    min_distance = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        # Calculate the distance between consecutive elements\n        distance = sorted_numbers[i + 1] - sorted_numbers[i]\n        \n        # If this distance is smaller than the minimum found so far, update\n        if distance < min_distance:\n            min_distance = distance\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n    \n    # Sort the list first\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the smallest difference and closest pair\n    min_diff = float('inf')\n    closest_pair = (0, 0)\n    \n    # Iterate through sorted numbers to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list of numbers\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum distance and the closest pair\n    min_distance = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted numbers to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        # Calculate the distance between the current and next number\n        distance = sorted_numbers[i + 1] - sorted_numbers[i]\n        \n        # Update the closest pair if a smaller distance is found\n        if distance < min_distance:\n            min_distance = distance\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([10.5, 2.3, 4.8, 2.1, 2.2])\n    (2.1, 2.2)\n    >>> find_closest_elements([5.0, 3.0, 1.0, 4.0, 2.0])\n    (1.0, 2.0)\n    \"\"\"\n    \n    # Sort the numbers\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and closest pair\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n\n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        num1 = sorted_numbers[i]\n        num2 = sorted_numbers[i + 1]\n        diff = num2 - num1\n        \n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (num1, num2)\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([3.5, 2.1, 6.7, 2.0, 2.2, 5.1])\n    (2.1, 2.2)\n    >>> find_closest_elements([0.1, 0.2, 0.3, 0.4])\n    (0.1, 0.2)\n    >>> find_closest_elements([5.0, 5.0, 5.0])\n    (5.0, 5.0)\n    \"\"\"\n    \n    # Sort the numbers first\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the closest pair with a large difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_difference = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate over the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if diff < smallest_difference:\n            smallest_difference = diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([5.0, 4.0, 3.0, 2.0, 1.0])\n    (1.0, 2.0)\n    >>> find_closest_elements([-1.0, 2.5, 3.6, 0.0])\n    (0.0, 2.5)\n    \"\"\"\n    # Sort the numbers first\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n\n    # Loop through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers to make it easier to find the closest pairs\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference as infinity and the closest pair as None\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through sorted numbers to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        # Calculate the difference between consecutive numbers\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        # If this difference is smaller than the minimum difference found so far\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list of numbers\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the smallest difference and corresponding closest elements\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the closest pair and the smallest difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_difference = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest elements\n    for i in range(1, len(sorted_numbers)):\n        # Calculate the difference between consecutive elements\n        difference = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        \n        # Check if this is the smallest difference found so far\n        if difference < smallest_difference:\n            smallest_difference = difference\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers first\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and result tuple\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Compare adjacent pairs in the sorted list\n    for i in range(len(sorted_numbers) - 1):\n        # Calculate the difference between adjacent numbers\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        \n        # If this difference is smaller than the minimum found so far, update\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers to easily find the closest pairs\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the closest pair\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through sorted numbers to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        current_diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Sort the list first\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate over the sorted list to find the closest elements\n    for i in range(len(sorted_numbers) - 1):\n        num1 = sorted_numbers[i]\n        num2 = sorted_numbers[i + 1]\n        diff = num2 - num1\n        \n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (num1, num2)\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers to make it easier to find the closest pairs\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n\n    # Loop through the sorted numbers to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    # Sort the numbers\n    sorted_numbers = sorted(numbers)\n\n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (0, 0)\n\n    # Iterate through sorted numbers to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        num1 = sorted_numbers[i]\n        num2 = sorted_numbers[i + 1]\n        diff = num2 - num1\n        \n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (num1, num2)\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([0.5, 0.6, 0.2, 0.1])\n    (0.1, 0.2)\n    >>> find_closest_elements([10.0, 10.1, 10.2])\n    (10.0, 10.1)\n    \"\"\"\n    # Sort the list of numbers to make it easier to find the closest pair\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the smallest difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list and find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        num1 = sorted_numbers[i]\n        num2 = sorted_numbers[i + 1]\n        diff = num2 - num1\n        \n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (num1, num2)\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    \n    # Sort the numbers to bring closer elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum distance with a large value\n    min_distance = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        current_distance = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if current_distance < min_distance:\n            min_distance = current_distance\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 74.421768707483, "dps_norm": 47.5, "pass@1": 100.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(10)\n    5\n    >>> largest_divisor(1)\n    0  # There is no divisor smaller than 1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <= 1:\n        return 0  # Handle the case where n is 1 or less\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(10)\n    5\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # Return 0 for 1 or negative numbers since they have no divisors < n\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # This line handles cases when n is prime, returning 1 as the largest divisor.", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(100)\n    50\n    >>> largest_divisor(21)\n    7\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(1)\n    0  # Edge case, since there are no positive divisors of 1\n    \"\"\"\n    if n <= 1:\n        return 0  # Return 0 for n = 1 or less, as there are no positive divisors\n    \n    for i in range(n // 2, 0, -1):  # Start from n//2 down to 1\n        if n % i == 0:  # Check if i is a divisor of n\n            return i  # Return the largest divisor found", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(17)\n    1\n    \"\"\"\n    # Check for numbers less than or equal to 1\n    if n <= 1:\n        return 0  # There is no divisor for 1 or numbers less than it\n    \n    # Start from n//2 and go down to find the largest divisor\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # The largest divisor for any number greater than 1 is at least 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(12)\n    6\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    # Start checking from n-1 down to 1\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 0  # Return 0 if there are no divisors", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # If n is 1 or less, there are no divisors smaller than n.\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(10)\n    5\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(28)\n    14\n    \"\"\"\n    if n <= 1:\n        return 0  # No divisors for 1 or less\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(10)\n    5\n    >>> largest_divisor(17)\n    1\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(28)\n    14\n    \"\"\"\n    if n <= 1:\n        return 0  # If n is 1 or less, return 0 as there are no divisors smaller than n\n\n    for i in range(n // 2, 0, -1):  # Start checking from n // 2 down to 1\n        if n % i == 0:  # Check if i is a divisor of n\n            return i  # Return the largest divisor found", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(18)\n    9\n    >>> largest_divisor(10)\n    5\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 0  # If there is no divisor smaller than n, return 0.", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(12)\n    6\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # There is no positive divisor smaller than 1\n    \n    for i in range(n // 2, 0, -1):  # Check from n//2 down to 1\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(17)\n    1\n    \"\"\"\n    if n <= 1:\n        return 0  # No divisors less than 1\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(12)\n    6\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # No divisors for 1 or less\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0  # since there is no number smaller than 1 that can divide it evenly\n    \"\"\"\n    if n <= 1:\n        return 0  # There is no positive divisor of numbers less than or equal to 1\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(20)\n    10\n    >>> largest_divisor(17)\n    1\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # For n = 1 or less, there is no divisor smaller than n\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(10)\n    5\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # There are no divisors less than 1\n    \n    for i in range(n // 2, 0, -1):  # Check from n//2 down to 1\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(10)\n    5\n    \"\"\"\n    if n <= 1:\n        return 0  # No positive divisors less than n for n <= 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(10)\n    5\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(28)\n    14\n    \"\"\"\n    # Start checking from n-1 down to 1\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 0  # Return 0 if there is no divisor other than n itself", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # no positive divisor less than 1\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(100)\n    50\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0  # There is no positive divisor of 1\n    \"\"\"\n    if n <= 1:\n        return 0  # There is no positive divisor of 1 or numbers less than 1\n\n    for i in range(n // 2, 0, -1):  # Check from n//2 down to 1\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(10)\n    5\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(28)\n    14\n    \"\"\"\n    if n <= 1:\n        return 0  # Return 0 for n <= 1 as there are no divisors smaller than n\n    \n    for i in range(n // 2, 0, -1):  # Check divisors from n//2 down to 1\n        if n % i == 0:  # If i is a divisor\n            return i  # Return the largest divisor found", "matching_cluster_idx": 3}]}, "HumanEval/26": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number in the list\n    count = {}\n    for number in numbers:\n        count[number] = count.get(number, 0) + 1\n\n    # Collect numbers that occur only once, maintaining their order\n    result = [number for number in numbers if count[number] == 1]\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 2, 2, 3])\n    [3]\n    >>> remove_duplicates([4, 5, 6, 4, 5, 6])\n    []\n    >>> remove_duplicates([7, 8, 9])\n    [7, 8, 9]\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    from collections import Counter\n    \n    # Count the occurrences of each number in the list\n    counts = Counter(numbers)\n    \n    # Return a new list with only the numbers that occur once\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count = {}\n    for number in numbers:\n        count[number] = count.get(number, 0) + 1\n        \n    # Collect elements that occur exactly once\n    result = [number for number in numbers if count[number] == 1]\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count = {}\n    for number in numbers:\n        count[number] = count.get(number, 0) + 1\n\n    # Keep elements that occur only once\n    result = [number for number in numbers if count[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count = {}\n    for number in numbers:\n        count[number] = count.get(number, 0) + 1\n\n    # Filter the numbers based on their count\n    result = [number for number in numbers if count[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count = {}\n    for num in numbers:\n        count[num] = count.get(num, 0) + 1\n    \n    # Filter out elements that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    counts = {}\n    for number in numbers:\n        counts[number] = counts.get(number, 0) + 1\n\n    # Create a result list including only those numbers that occur once\n    result = [number for number in numbers if counts[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = {}\n    \n    # Count occurrences of each number\n    for number in numbers:\n        if number in count:\n            count[number] += 1\n        else:\n            count[number] = 1\n    \n    # Return elements that occur only once, maintaining order\n    return [number for number in numbers if count[number] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = {}\n    \n    # Count occurrences of each number\n    for number in numbers:\n        if number in count:\n            count[number] += 1\n        else:\n            count[number] = 1\n            \n    # Build the result list with numbers that occur only once\n    result = [number for number in numbers if count[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([1, 2, 3, 4])\n    [1, 2, 3, 4]\n    >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5])\n    [1, 3, 5]\n    \"\"\"\n    # Count occurrences of each number\n    count = {}\n    for number in numbers:\n        count[number] = count.get(number, 0) + 1\n    \n    # Filter out numbers that occur more than once\n    return [number for number in numbers if count[number] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count = {}\n    for number in numbers:\n        if number in count:\n            count[number] += 1\n        else:\n            count[number] = 1\n\n    # Create a new list with only the numbers that occur once\n    result = [number for number in numbers if count[number] == 1]\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = {}\n    for number in numbers:\n        count[number] = count.get(number, 0) + 1\n\n    return [number for number in numbers if count[number] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 2, 2, 3, 3])\n    []\n    >>> remove_duplicates([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> remove_duplicates([1, 2, 3, 1, 2, 3])\n    []\n    >>> remove_duplicates([1])\n    [1]\n    \"\"\"\n    counts = {}\n    \n    # Count occurrences of each number\n    for number in numbers:\n        counts[number] = counts.get(number, 0) + 1\n    \n    # Collect numbers that occur only once in the order they appeared\n    result = [number for number in numbers if counts[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    counts = {}\n    for number in numbers:\n        counts[number] = counts.get(number, 0) + 1\n\n    # Create a list of numbers that occur only once\n    result = [number for number in numbers if counts[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 2, 2, 3, 3])\n    []\n    >>> remove_duplicates([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> remove_duplicates([5, 4, 3, 2, 1, 2, 3, 4, 5])\n    [1]\n    \"\"\"\n    count = {}\n    for number in numbers:\n        count[number] = count.get(number, 0) + 1\n    \n    return [number for number in numbers if count[number] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count = {}\n    for number in numbers:\n        count[number] = count.get(number, 0) + 1\n    \n    # Return list of numbers that occur exactly once, maintaining order\n    return [number for number in numbers if count[number] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> remove_duplicates([1, 2, 3, 1, 2, 3])\n    []\n    >>> remove_duplicates([1, 2, 3, 4, 5, 1, 2])\n    [3, 4, 5]\n    \"\"\"\n    from collections import Counter\n    \n    # Count occurrences of each number\n    counts = Counter(numbers)\n    \n    # Create a new list with elements that occur exactly once\n    result = [num for num in numbers if counts[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to count the occurrences of each number\n    count = {}\n    \n    # Count occurrences of each number\n    for number in numbers:\n        if number in count:\n            count[number] += 1\n        else:\n            count[number] = 1\n\n    # Create a list of numbers that occur only once\n    result = [number for number in numbers if count[number] == 1]\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([1, 2, 3, 4])\n    [1, 2, 3, 4]\n    >>> remove_duplicates([1, 2, 3, 2, 1, 4, 5, 5, 6])\n    [3, 4, 6]\n    \"\"\"\n    count = {}\n    \n    # Count the occurrences of each number\n    for number in numbers:\n        count[number] = count.get(number, 0) + 1\n    \n    # Filter out the numbers that occur more than once\n    result = [number for number in numbers if count[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    counts = {}\n    for number in numbers:\n        counts[number] = counts.get(number, 0) + 1\n    \n    # Filter out numbers that occur more than once\n    result = [number for number in numbers if counts[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 50.63291139240506, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    A prime number is a number greater than 1 that has no positive divisors other than 1 and itself.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    A prime number is a natural number greater than 1 that cannot be formed\n    by multiplying two smaller natural numbers. The only even prime number is 2.\n\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(0)\n    False\n    >>> is_prime(-5)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    A prime number is a natural number greater than 1 that cannot be formed\n    by multiplying two smaller natural numbers. The only even prime number \n    is 2. All other even numbers are not prime.\n\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    A prime number is greater than 1 and has no divisors other than 1 and itself.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}]}, "HumanEval/33": {"dps": 97.22222222222223, "dps_norm": 81.81818181818181, "pass@1": 94.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the values at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort those values\n    sorted_values = sorted(divisible_by_three)\n    \n    # Create a new list to hold the result\n    result = l[:]  # Make a copy of the original list\n    \n    # Replace the values at indices divisible by 3 with sorted values\n    for i, value in enumerate(sorted_values):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted values\n    divisible_by_three.sort()\n    \n    # Create a new list to hold the result\n    result = l[:]\n    \n    # Place the sorted values back into the appropriate indices\n    for i, val in zip([i for i in range(len(l)) if i % 3 == 0], divisible_by_three):\n        result[i] = val\n        \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by three\n    third_indices_values = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted values\n    third_indices_values.sort()\n    \n    # Create a new list to fill with sorted values at third indices\n    sorted_list = l[:]\n    \n    # Replace values at indices divisible by three with sorted values\n    for idx, value in zip((i for i in range(len(l)) if i % 3 == 0), third_indices_values):\n        sorted_list[idx] = value\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted values\n    sorted_values = sorted(divisible_by_three)\n    \n    # Create the new list with sorted values at indices divisible by 3\n    result = []\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(sorted_values[sorted_index])\n            sorted_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort those elements\n    divisible_by_three.sort()\n    \n    # Create a new list to hold the result\n    result = l.copy()\n    \n    # Place sorted elements back in their original positions\n    for index, value in zip((i for i in range(len(l)) if i % 3 == 0), divisible_by_three):\n        result[index] = value\n        \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices that are divisible by 3\n    third_indices = [i for i in range(len(l)) if i % 3 == 0]\n    third_values = [l[i] for i in third_indices]\n\n    # Sort the values that were extracted\n    sorted_third_values = sorted(third_values)\n\n    # Create a new list that will hold the result\n    result = l[:]\n\n    # Replace the values at the indices that are divisible by 3 with the sorted values\n    for idx, sorted_value in zip(third_indices, sorted_third_values):\n        result[idx] = sorted_value\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values from indices that are divisible by 3\n    sortable_values = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these values\n    sorted_values = sorted(sortable_values)\n    \n    # Create a new list to hold the result\n    result = l[:]  # Start with a copy of the original list\n    \n    # Replace the values at the indices that are divisible by 3 with the sorted values\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_values[sorted_index]\n            sorted_index += 1\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    \n    # Extract values at indices that are divisible by 3\n    sorted_values = sorted(l[i] for i in range(len(l)) if i % 3 == 0)\n    \n    # Create a new list with the same values as l\n    result = l.copy()\n    \n    # Replace the values at indices divisible by 3 with the sorted values\n    for idx, value in zip((i for i in range(len(l)) if i % 3 == 0), sorted_values):\n        result[idx] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by three\n    third_indices = [i for i in range(len(l)) if i % 3 == 0]\n    third_values = [l[i] for i in third_indices]\n\n    # Sort those values\n    sorted_third_values = sorted(third_values)\n\n    # Create a new list to hold the results\n    result = l[:]\n    \n    # Place the sorted values back in their original indices\n    for index, sorted_value in zip(third_indices, sorted_third_values):\n        result[index] = sorted_value\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible = sorted(divisible_by_three)\n    \n    # Create a new list to hold the result\n    result = l.copy()\n    \n    # Replace the elements at indices divisible by three with the sorted ones\n    for idx, sorted_value in zip([i for i in range(len(l)) if i % 3 == 0], sorted_divisible):\n        result[idx] = sorted_value\n        \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted values\n    sorted_values = sorted(divisible_by_three)\n    \n    # Create a new list to hold the result\n    result = l[:]  # Copy the original list\n    \n    # Place sorted values back in their respective positions\n    for index, value in zip([i for i in range(len(l)) if i % 3 == 0], sorted_values):\n        result[index] = value\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by 3\n    third_indices_values = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted values\n    sorted_values = sorted(third_indices_values)\n    \n    # Create a new list to hold the result\n    result = l.copy()\n    \n    # Place the sorted values back into their respective positions\n    for idx, value in zip((i for i in range(len(l)) if i % 3 == 0), sorted_values):\n        result[idx] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted values\n    sorted_values = sorted(divisible_by_three)\n    \n    # Create a new list to hold the result\n    result = l[:]  # Start with a copy of the original list\n    \n    # Replace the values at indices divisible by 3 with sorted values\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_values[sorted_index]\n            sorted_index += 1\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices that are divisible by 3\n    values_to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort those values\n    values_to_sort.sort()\n    \n    # Create a new list to hold the result\n    result = l.copy()\n    \n    # Replace values at indices divisible by 3 with the sorted values\n    sort_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = values_to_sort[sort_index]\n            sort_index += 1\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort those elements\n    sorted_divisible = sorted(divisible_by_three)\n    \n    # Create a new list to hold the result\n    result = l[:]  # Start with a copy of the original list\n    \n    # Replace elements at indices divisible by three with sorted elements\n    j = 0  # Index for the sorted elements\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible[j]\n            j += 1\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values from indices that are divisible by three\n    third_indices = [i for i in range(len(l)) if i % 3 == 0]\n    third_values = [l[i] for i in third_indices]\n    \n    # Sort the values from the third indices\n    third_values.sort()\n    \n    # Create a new list to store the result\n    result = l[:]\n    \n    # Place sorted values back into the result list at the appropriate indices\n    for idx, sorted_value in zip(third_indices, third_values):\n        result[idx] = sorted_value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by 3\n    third_indices_values = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort those values\n    sorted_third_values = sorted(third_indices_values)\n    \n    # Create a new list with the same values as l\n    result = l[:]\n    \n    # Replace the values at indices divisible by 3 with the sorted values\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_third_values[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    values_to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort those values\n    values_to_sort.sort()\n    \n    # Create a new list for the result\n    result = l[:]  # Make a copy of l to preserve non-modifiable indices\n    \n    # Replace the values at indices divisible by 3 with sorted values\n    for idx, sorted_value in zip((i for i in range(len(l)) if i % 3 == 0), values_to_sort):\n        result[idx] = sorted_value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    sorted_values = sorted(divisible_by_three)\n\n    # Create a new list where we will place sorted values in the correct indices\n    result = l[:]\n    sort_index = 0\n    \n    for i in range(len(l)):\n        if i % 3 == 0:  # if index is divisible by 3\n            result[i] = sorted_values[sort_index]\n            sort_index += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by 3\n    sorted_values = sorted(l[i] for i in range(len(l)) if i % 3 == 0)\n    \n    # Create a new list to hold the result\n    result = []\n    sorted_index = 0\n\n    # Populate the result list according to the specified rules\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(sorted_values[sorted_index])\n            sorted_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n    \n    Args:\n        l (list): A list of elements.\n    \n    Returns:\n        list: A sorted list of unique elements.\n    \n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n\n    Args:\n        l (list): A list of elements.\n\n    Returns:\n        list: A sorted list of unique elements.\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Use set to get unique elements and then sort them\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_of_7 = 0\n    \n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_of_7 += str(i).count('7')\n    \n    return count_of_7", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_of_sevens = 0\n\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_of_sevens += str(i).count('7')\n\n    return count_of_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_of_sevens = 0\n    \n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_of_sevens += str(i).count('7')\n    \n    return count_of_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_7s = 0\n    \n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_7s += str(i).count('7')\n    \n    return count_7s", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    \n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_sevens = 0\n    \n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_sevens += str(i).count('7')\n    \n    return count_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_of_sevens = 0\n    \n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_of_sevens += str(i).count('7')\n    \n    return count_of_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_sevens = 0\n    \n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_sevens += str(i).count('7')\n    \n    return count_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_of_sevens = 0\n    \n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_of_sevens += str(i).count('7')\n    \n    return count_of_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    \n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_of_sevens = 0\n    \n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_of_sevens += str(i).count('7')\n    \n    return count_of_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_of_sevens = 0\n    \n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_of_sevens += str(i).count('7')\n    \n    return count_of_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_of_sevens = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_of_sevens += str(i).count('7')\n    return count_of_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_of_sevens = 0\n    \n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_of_sevens += str(i).count('7')\n    \n    return count_of_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n\n    which are divisible by 11 or 13.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_sevens = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_sevens += str(i).count('7')\n    return count_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_of_sevens = 0\n\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count_of_sevens += str(i).count('7')\n\n    return count_of_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 94.92635024549918, "dps_norm": 90.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices \n    are equal to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements and sort them\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    sorted_even_indices = sorted(even_indices)\n    \n    # Create a new list to hold the result\n    result = []\n    \n    # Fill the result list\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:  # Even index\n            result.append(sorted_even_indices[even_index])\n            even_index += 1\n        else:  # Odd index\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract values at even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the extracted values\n    even_indices_values.sort()\n    \n    # Create a new list with sorted even indices and original odd indices\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:  # Even index\n            result.append(even_indices_values[even_index])\n            even_index += 1\n        else:  # Odd index\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 9, 2, 8, 3])\n    [8, 1, 10, 2, 9, 3]\n    >>> sort_even([7, 5, 6, 1, 4, 9])\n    [4, 5, 6, 1, 7, 9]\n    \"\"\"\n    # Extract even indexed values and sort them\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    even_indices_values.sort()\n\n    # Create a new list to hold the sorted values at even indices and the original at odd indices\n    result = []\n    even_index = 0  # Index for sorted even values\n\n    for i in range(len(l)):\n        if i % 2 == 0:  # Even index\n            result.append(even_indices_values[even_index])\n            even_index += 1\n        else:  # Odd index\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices and sort them\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    even_indices_values.sort()\n    \n    # Create a new list for the result\n    result = l[:]\n    \n    # Place sorted values back into the even indices of the result list\n    for i, val in enumerate(even_indices_values):\n        result[i * 2] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    \n    # Extract the values from even indices\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the values of the even indices\n    even_sorted = sorted(even_indices)\n    \n    # Create a new list to hold the result\n    result = l.copy()\n    \n    # Replace the values at the even indices with the sorted values\n    for i, val in enumerate(even_sorted):\n        result[i * 2] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices elements\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the even elements\n    even_elements.sort()\n    \n    # Create a new list to hold the result\n    result = []\n    \n    # Fill the result list with sorted even elements and original odd elements\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:  # Even index\n            result.append(even_elements[even_index])\n            even_index += 1\n        else:  # Odd index\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Create a new list to build the result\n    result = l[:]  # Start with a copy of the original list\n    \n    # Replace even indexed positions in the result with sorted elements\n    for i, value in enumerate(even_elements):\n        result[2 * i] = value  # Place the sorted element in the even index\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements and sort them\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    sorted_even_values = sorted(even_indices_values)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Place the sorted even indexed values back in their original positions\n    for i, value in zip(range(0, len(result), 2), sorted_even_values):\n        result[i] = value\n        \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements\n    even_indexed_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even indexed elements\n    sorted_even_indexed_elements = sorted(even_indexed_elements)\n    \n    # Create the result list\n    result = l[:]  # Copy the original list\n    \n    # Place the sorted elements back into the even indices\n    for i, sorted_value in enumerate(sorted_even_indexed_elements):\n        result[2 * i] = sorted_value\n        \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    \n    # Extract the values at even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the extracted values\n    even_indices_values.sort()\n    \n    # Create a new list to hold the result\n    result = []\n    \n    # Fill the result list with sorted even indices values and original odd indices values\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices_values[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices \n    are equal to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even indexed elements\n    sorted_evens = sorted(even_indices)\n    \n    # Create a new list to hold the result\n    result = l.copy()\n    \n    # Place the sorted even indexed elements back in the result list\n    for index, sorted_value in zip(range(0, len(l), 2), sorted_evens):\n        result[index] = sorted_value\n        \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 20, 30, 40, 50])\n    [10, 20, 30, 40, 50]\n    >>> sort_even([7, 8, 5, 6, 3, 4])\n    [5, 8, 7, 6, 3, 4]\n    >>> sort_even([])\n    []\n    \"\"\"\n    # Extract even indexed elements\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort even indexed elements\n    even_indices_values.sort()\n    \n    # Create a new list to hold the result\n    result = []\n    \n    # Fill the result list\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:  # Even index\n            result.append(even_indices_values[even_index])\n            even_index += 1\n        else:  # Odd index\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    # Sort the even indexed elements\n    even_indices_sorted = sorted(even_indices)\n    \n    # Create a new list to hold the result\n    result = []\n    even_index = 0  # Index for sorted even elements\n    \n    # Reconstruct the result list\n    for i in range(len(l)):\n        if i % 2 == 0:  # Even index\n            result.append(even_indices_sorted[even_index])\n            even_index += 1\n        else:  # Odd index\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extracting even indexed elements\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sorting the extracted even indexed elements\n    even_indices_values.sort()\n    \n    # Creating the new list with sorted even indices and original odd indices\n    result = []\n    even_index = 0\n    \n    for i in range(len(l)):\n        if i % 2 == 0:  # Even index\n            result.append(even_indices_values[even_index])\n            even_index += 1\n        else:  # Odd index\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extracting even indexed elements\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    # Sorting the extracted even indexed values\n    even_indices_values.sort()\n    \n    # Creating a new list for the result\n    result = l[:]  # Copy original list to result\n    # Inserting the sorted even indexed values back to their positions\n    for i, value in enumerate(even_indices_values):\n        result[i * 2] = value  # Even indices are 0, 2, 4, ...\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements\n    even_indexed_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the even indexed elements\n    even_indexed_elements.sort()\n    \n    # Create the new list\n    result = []\n    even_index = 0\n    \n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indexed_elements[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements and sort them\n    even_indexed_elements = [l[i] for i in range(0, len(l), 2)]\n    even_indexed_elements.sort()\n\n    # Create a new list to hold the result\n    result = l[:]  # start with a copy of the original list\n    \n    # Replace the even indexed positions with the sorted values\n    for index, value in zip(range(0, len(result), 2), even_indexed_elements):\n        result[index] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements and sort them\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    even_indices_values.sort()\n\n    # Create a new list to hold the result\n    result = l.copy()\n\n    # Place the sorted values back into the even indices of the result\n    for i, value in enumerate(even_indices_values):\n        result[i * 2] = value\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Create a new list to hold the result\n    result = []\n    \n    # Populate the result list\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:  # even index\n            result.append(even_elements[even_index])\n            even_index += 1\n        else:           # odd index\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even-indexed elements\n    even_indexed_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even-indexed elements\n    even_indexed_elements.sort()\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    sorted_list = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:  # Even index\n            sorted_list.append(even_indexed_elements[even_index])\n            even_index += 1\n        else:  # Odd index\n            sorted_list.append(l[i])\n    \n    return sorted_list", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 82.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent to which 2 is raised.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of 2^n modulo p.\n\n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p <= 0:\n        raise ValueError(\"Modulus p must be greater than 0.\")\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    This implementation uses modular exponentiation to efficiently calculate\n    the result without overflowing large integers.\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n    n (int): The exponent to raise 2 to.\n    p (int): The modulus.\n    \n    Returns:\n    int: The result of (2^n) % p.\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    Vowels are defined as 'a', 'e', 'i', 'o', 'u' (case insensitive).\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"  # Define the vowels to remove (both lowercase and uppercase)\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    Vowels are defined as 'a', 'e', 'i', 'o', 'u' (case insensitive).\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'  # Define vowels, including uppercase\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    Vowels are defined as 'a', 'e', 'i', 'o', 'u' (case-insensitive).\n\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    Vowels are defined as 'a', 'e', 'i', 'o', 'u' (case insensitive).\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"  # Define vowels\n    return ''.join(char for char in text if char not in vowels)  # Use a generator expression to filter out vowels", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 94.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function verifies that both input strings contain the same unique characters,\n    regardless of the frequency of each character in the strings.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Create a set of characters for each string\n    chars_s0 = set(s0)\n    chars_s1 = set(s1)\n    \n    # Check if both sets are equal\n    return chars_s0 == chars_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Two words have the same characters if they consist of the same unique characters\n    irrespective of their counts or order.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    This function checks if two input strings have the same set of unique characters, \n    ignoring the frequency of those characters.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function checks if two strings contain the exact same set of characters,\n    regardless of their frequency in the strings.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function compares the unique characters of the two input strings.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets to find unique characters\n    unique_chars_s0 = set(s0)\n    unique_chars_s1 = set(s1)\n    \n    # Check if the sets of unique characters are the same\n    return unique_chars_s0 == unique_chars_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    This function returns True if both strings contain the same unique characters,\n    regardless of the frequency of those characters. It is case-sensitive.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Use set to find unique characters in both strings\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    Args:\n        s0 (str): First string.\n        s1 (str): Second string.\n\n    Returns:\n        bool: True if both strings have the same unique characters, False otherwise.\n\n    Examples:\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n        True\n        >>> same_chars('abcd', 'dddddddabc')\n        True\n        >>> same_chars('dddddddabc', 'abcd')\n        True\n        >>> same_chars('eabcd', 'dddddddabc')\n        False\n        >>> same_chars('abcd', 'dddddddabce')\n        False\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n        False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function returns True if the two input strings contain the same \n    unique characters, regardless of their frequency in the strings.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    The function checks if both strings contain the same unique characters,\n    irrespective of the number of times each character appears.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    Two words have the same characters if they contain the same set of unique characters\n    regardless of the count of each character.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Two words are considered to have the same characters if they can be formed \n    with the same set of unique characters, regardless of their frequency.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function checks if the two input strings `s0` and `s1` contain exactly the same characters,\n    regardless of the number of times each character appears.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function ignores the frequency of characters and only checks for the presence\n    of the same unique characters in both strings.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    Two words have the same characters if they contain exactly the same characters,\n    regardless of their frequencies or order.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Create sets of characters from both strings\n    chars_s0 = set(s0)\n    chars_s1 = set(s1)\n\n    # Compare the sets to determine if they are the same\n    return chars_s0 == chars_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    Two strings have the same characters if they contain the same unique\n    characters regardless of frequency.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Two strings are considered to have the same characters if they contain\n    the same unique characters, regardless of the number of times they appear.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Create a set of characters for both strings\n    chars_s0 = set(s0)\n    chars_s1 = set(s1)\n    \n    # Compare the sets of characters\n    return chars_s0 == chars_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function checks whether two input strings have exactly the same\n    characters, regardless of their order or frequency. It returns True\n    if they contain the same unique characters; otherwise, it returns False.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Two words have the same characters if they contain exactly the same unique characters,\n    irrespective of their counts.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Use sets to compare unique characters in both strings\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1.intersection(set2)\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert lists to sets to find unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection and convert it to a sorted list\n    common_elements = sorted(set1.intersection(set2))\n    \n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert both lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find the intersection of both sets\n    common_elements = set1.intersection(set2)\n\n    # Return the sorted list of unique common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Convert lists to sets to get unique elements and perform intersection\n    common_elements = set(l1) & set(l2)\n    \n    # Return a sorted list of the unique common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Use set to find unique elements, then find the intersection\n    common_elements = set(l1) & set(l2)\n    # Sort the results and return as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Convert both lists to sets to get unique elements and find intersection\n    unique_l1 = set(l1)\n    unique_l2 = set(l2)\n    common_elements = unique_l1.intersection(unique_l2)\n    \n    # Sort the common elements and return as a list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    \n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Convert both lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find the intersection of both sets\n    common_elements = set1.intersection(set2)\n\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Convert both lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1.intersection(set2)\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Convert both lists to sets to find unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1.intersection(set2)\n    \n    # Return a sorted list of the common unique elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Convert both lists to sets to get unique elements, then find the intersection\n    common_elements = set(l1).intersection(set(l2))\n    # Return the sorted list of common unique elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Convert both lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1.intersection(set2)\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Convert lists to sets to find common elements and remove duplicates\n    common_elements = set(l1) & set(l2)\n    # Return a sorted list of the common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Convert lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find common elements and convert back to a sorted list\n    common_elements = sorted(set1.intersection(set2))\n    \n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Convert both lists to sets to find unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find common elements\n    common_elements = set1.intersection(set2)\n\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Convert both lists to sets to find unique elements and then find the intersection\n    common_elements = set(l1) & set(l2)\n    \n    # Return a sorted list of the common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Return sorted list of unique common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    # Convert lists to sets to find unique elements, then find the intersection\n    common_elements = set(l1) & set(l2)\n    \n    # Return a sorted list of the common unique elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find common elements and return them sorted\n    common_elements = sorted(set1.intersection(set2))\n    \n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find unique elements and their intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    \n    # Return the sorted list of common unique elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 92.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    factor = 2\n    \n    # Continue dividing n by factor while it is divisible\n    while n > 1:\n        if n % factor == 0:\n            n //= factor  # Divide n by the factor\n        else:\n            factor += 1  # Move to the next potential factor\n            \n    return factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    factor = 2\n    \n    # Continue dividing n by factor until n becomes 1\n    while n > 1:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    factor = 2\n    # Divide n by the factor until it is no longer divisible\n    while n > 1:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    prime_factor = 2\n    # Keep dividing n by the current prime factor until it's no longer divisible\n    while n > 1:\n        if n % prime_factor == 0:\n            n //= prime_factor  # Divide n by the prime factor\n        else:\n            prime_factor += 1  # Move to the next potential prime factor\n    return prime_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start by finding the smallest prime factor\n    largest_factor = None\n    # Check for the number of 2s that divide n\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # n must be odd at this point, check for odd factors from 3 to sqrt(n)\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    factor = 2\n    \n    # Divide n by factor until it can no longer be divided\n    while n > 1:\n        if n % factor == 0:  # Check if factor is a divisor of n\n            n //= factor  # Divide n by factor\n        else:\n            factor += 1  # Move to the next potential factor\n    \n    return factor  # The last factor is the largest prime factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_factor = None\n\n    # Check for the number of 2s that divide n\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # n must be odd at this point, so we can skip even numbers\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n\n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_factor = None\n    \n    # Check for the number of 2s that divide n\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # n must be odd at this point, thus a skip of 2 (i.e., check only odd factors) can be used\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n            \n    # This condition checks if n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    factor = 2\n    largest_factor = 1\n    \n    # Divide n by factor until it is no longer divisible\n    while n > 1:\n        if n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        else:\n            factor += 1\n            \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    factor = 2\n    while factor * factor <= n:  # Only need to check up to the square root of n\n        if n % factor == 0:  # If factor divides n, it's a prime factor\n            n //= factor  # Divide out all instances of this prime factor\n        else:\n            factor += 1  # Move to the next potential factor\n    return n  # If n is greater than 1, it is prime and is the largest prime factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    factor = 2\n    \n    # Keep dividing n by factor until it is no longer divisible\n    while n > 1:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n            \n    return factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    factor = 2\n    # Divide n by factor until n is no longer divisible by factor\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor  # Divide out the factor\n        else:\n            factor += 1  # Move to the next factor\n    return n  # The remaining n is the largest prime factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    largest_factor = None\n    \n    # Check for number of 2s that divide n\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Now n must be odd at this point so we can skip one element (i.e., we can check only odd numbers)\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, add i and divide n\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    prime_factor = 2\n    \n    # Divide n by the smallest prime factor until it is no longer divisible\n    while n > 1:\n        if n % prime_factor == 0:\n            n //= prime_factor\n        else:\n            prime_factor += 1\n\n    return prime_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    largest_factor = 1\n\n    # Check for the number of 2s that divide n\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Now n must be odd at this point, so we can skip even numbers\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n\n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_factor = None\n    \n    # Check for the number of 2s that divide n\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # n must be odd at this point, check for odd factors from 3 to sqrt(n)\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    factor = 2\n    \n    # Divide n by factor until it's no longer divisible\n    while n > 1:\n        if n % factor == 0:\n            n //= factor  # Keep dividing n by factor\n        else:\n            factor += 1   # Move to the next possible factor\n            \n    return factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    largest_factor = 1\n    \n    # Check for number of 2s that divide n\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # n must be odd at this point, so we can skip even numbers\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    largest_factor = None\n\n    # Check for number of 2s that divide n\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Now n must be odd at this point, so we can skip even numbers\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n\n    # This condition checks if n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start by dividing n by 2 until n is odd\n    while n % 2 == 0:\n        largest = 2\n        n //= 2\n\n    # At this point, n is odd, we can check for odd factors\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest = factor\n            n //= factor\n        factor += 2  # Increment to the next odd number\n\n    # If n becomes a prime number greater than 2\n    if n > 2:\n        largest = n\n\n    return largest", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 45.51948051948052, "dps_norm": 48.75, "pass@1": 95.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define vowels and initialize count\n    vowels = 'aeiouAEIOU'\n    count = 0\n    \n    # Loop through each character in the string\n    for i in range(len(s)):\n        char = s[i]\n        # Check if character is a vowel\n        if char in vowels:\n            count += 1\n        # Check if 'y' is at the end of the word\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n            \n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' or s[i] == 'Y':\n            if i == len(s) - 1:  # 'y' is a vowel only if it's at the end\n                count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the set of vowels\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    \n    # Count vowels in the string\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        # Check if 'y' is at the end of the word\n        elif s[i].lower() == 'y' and i == len(s) - 1:\n            count += 1\n            \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n\n    # Check each character in the string\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i].lower() == 'y' and i == len(s) - 1:\n            count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()  # Convert to lowercase to handle case insensitivity\n    vowels = 'aeiou'\n    count = 0\n\n    for i in range(len(s)):\n        if s[i] in vowels:  # Count standard vowels\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:  # Count 'y' if it's at the end\n            count += 1\n            \n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"queue\")\n    4\n    >>> vowels_count(\"harmony\")\n    3\n    >>> vowels_count(\"Y\")\n    0\n    >>> vowels_count(\"play\")\n    1\n    >>> vowels_count(\"happy\")\n    2\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    \n    # Normalize the input to lower case for consistent counting\n    s = s.lower()\n    \n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"hello\")\n    2\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"aeiouy\")\n    6\n    >>> vowels_count(\"PYTHON\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"y\")\n    0\n    >>> vowels_count(\"yummy\")\n    2\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = 0\n\n    # Count standard vowels\n    for char in s:\n        if char in vowels:\n            count += 1\n\n    # Check if the last character is 'y'\n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n\n    # Count lowercase vowels\n    for char in s.lower():\n        if char in vowels:\n            count += 1\n    \n    # Check for 'y' at the end of the word\n    if s.lower().endswith('y'):\n        count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    \n    # Count vowels in the string\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        # Check if the character is 'y' and it's the last character of the string\n        elif s[i] == 'y' or s[i] == 'Y':\n            if i == len(s) - 1:\n                count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    \n    # Convert the string to lower case for uniformity\n    s = s.lower()\n\n    # Count the vowels in the string\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        # Check if 'y' is at the end of the string\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' or s[i] == 'Y':\n            if i == len(s) - 1:  # Check if 'y' is at the end of the word\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = 0\n    \n    # Count vowels in the string\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char in 'yY' and i == len(s) - 1:  # Check if 'y' is the last character\n            count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the set of vowels\n    vowels = 'aeiouAEIOU'\n    count = 0\n    \n    # Iterate through the string to count vowels\n    for i in range(len(s)):\n        # Check if the character is a vowel\n        if s[i] in vowels:\n            count += 1\n        # Check if 'y' is at the end of the word\n        elif s[i] == 'y' or s[i] == 'Y':\n            if i == len(s) - 1:\n                count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n\n    # Count vowels in the string\n    for char in s:\n        if char in vowels:\n            count += 1\n\n    # Check if 'y' is at the end of the string\n    if s and s[-1].lower() == 'y':\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()  # Convert string to lowercase to count vowels case-insensitively\n    \n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:  # Check if 'y' is at the end of the word\n            count += 1\n            \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"y\")\n    1\n    >>> vowels_count(\"horizon\")\n    4\n    >>> vowels_count(\"AEIOUY\")\n    6\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"xyz\")\n    0\n    \"\"\"\n    # Normalize the string to lowercase for case-insensitive counting\n    s = s.lower()\n    vowels = \"aeiou\"\n    count = 0\n\n    # Count vowels in the string\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"hello\")\n    2\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"symphony\")\n    2\n    >>> vowels_count(\"queue\")\n    3\n    >>> vowels_count(\"Y\")\n    0\n    >>> vowels_count(\"AY\")\n    1\n    >>> vowels_count(\"\")\n    0\n    \"\"\"\n    # Define vowels\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    \n    # Count vowels in the string\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i].lower() == 'y' and i == len(s) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the set of vowels\n    vowels = set('aeiouAEIOU')\n    count = 0\n\n    # Check each character in the string\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        # Check if 'y' is at the end of the word\n        elif s[i].lower() == 'y' and i == len(s) - 1:\n            count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the set of vowels\n    vowels = set(\"aeiouAEIOU\")\n    count = 0\n\n    # Count standard vowels\n    for char in s:\n        if char in vowels:\n            count += 1\n\n    # Check if 'y' is the last character\n    if s and s[-1].lower() == 'y':\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()  # Convert the string to lowercase for uniformity\n    vowels = 'aeiou'\n    count = 0\n    \n    for i, char in enumerate(s):\n        if char in vowels:  # Count regular vowels\n            count += 1\n        elif char == 'y' and i == len(s) - 1:  # Count 'y' only at the end\n            count += 1\n            \n    return count", "matching_cluster_idx": 2}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 13.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the total characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1  # If they are equal, return the first list", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare total characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1  # If equal, return the first list", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total character counts for both lists\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the total character counts and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1  # Return lst1 in case of a tie", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the total characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the totals and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in both lists\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare total characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1  # If they are equal, return the first list", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n\n    # Calculate the total number of characters in lst1\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    \n    # Calculate the total number of characters in lst2\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1  # If equal, return the first list", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1  # If equal, return the first list", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n\n    # Calculate total number of characters in lst1 and lst2\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare total characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 91.68316831683168, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([1, 2, 3, 4, 5, 6]) ==> 8  # 2 (index 1) + 6 (index 5)\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements found at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 4, 2, 5, 6]) ==> 4 \n        add([10, 2, 3, 8, 4]) ==> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Parameters:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements located at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 2, 3, 4, 5, 6])\n        6\n        >>> add([10, 5, 2, 9, 8, 1])\n        8\n        >>> add([1, 3, 5, 7])\n        0\n    \"\"\"\n    return sum(num for index, num in enumerate(lst) if index % 2 == 1 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list of int): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate through the list, starting from index 1 to get odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the element at the odd index is even\n        if lst[i] % 2 == 0:\n            total += lst[i]  # Add to total if even\n    \n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, adds the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Iterate over odd indices (1, 3, 5, ...)\n        if lst[i] % 2 == 0:  # Check if the element at this index is even\n            total += lst[i]  # Add it to the total if it's even\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, adds the even elements that are at odd indices.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of even integers located at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start at index 1 and step by 2 (odd indices)\n        if lst[i] % 2 == 0:  # Check if the element is even\n            total += lst[i]  # Add to total if it's even\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of the even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements located at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list of int): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 4, 3, 8, 10]) ==> 4 + 10 = 14\n        add([2, 3, 4, 5]) ==> 0  # No even elements at odd indices\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # start from index 1 and step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # check if the element is even\n            total += lst[i]  # add to total if it is even\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements that are at odd indices.\n        \n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements that are at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 2, 3, 4, 5])\n        0\n        >>> add([0, 1, 2, 3, 4, 5])\n        6\n        >>> add([10, 11, 12, 13, 14, 15])\n        12\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even integers at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 2, 3, 4, 5, 6])\n        8\n        >>> add([0, 1, 2, 3, 4, 5])\n        6\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for index in range(1, len(lst), 2):  # Start from index 1 and step by 2 to get odd indices\n        if lst[index] % 2 == 0:  # Check if the element is even\n            total += lst[index]  # Add to total if it's even\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list of int): A list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4, 5]) ==> 0\n        add([0, 1, 2, 3, 4]) ==> 4\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    # Iterate through the list using enumerate to get both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 == 1 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n    \n    Returns:\n        int: The sum of the even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 4, 3, 6, 8]) ==> 4\n        add([10, 1, 20, 3, 30]) ==> 0\n    \"\"\"\n    total = 0\n    for index in range(1, len(lst), 2):  # Start from index 1 and step by 2 (odd indices)\n        if lst[index] % 2 == 0:  # Check if the element at the odd index is even\n            total += lst[index]  # Add to the total if it is even\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, adds the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for index in range(1, len(lst), 2):  # Start from index 1 and step by 2 (odd indices)\n        if lst[index] % 2 == 0:  # Check if the element at the odd index is even\n            total += lst[index]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}]}, "HumanEval/86": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    The ordered version of string is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort the characters in each word\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words preserving spaces\n    words = s.split(' ')\n    \n    # Sort the characters of each word while keeping the spaces\n    ordered_words = [''.join(sorted(word)) for word in words]\n    \n    # Reconstruct the sentence with sorted words\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        # Sort the characters of the word based on ASCII value\n        return ''.join(sorted(word))\n    \n    # Split the input string by spaces to preserve order\n    words = s.split(' ')\n    # Process each word to sort its characters\n    sorted_words = [sort_word(word) for word in words]\n    # Join the sorted words back with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    # Create a list to hold the processed words\n    ordered_words = []\n\n    for word in words:\n        # Sort the characters of each word and join them back into a string\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n\n    # Join the processed words back together with spaces\n    result = ' '.join(ordered_words)\n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def order_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    ordered_words = [order_word(word) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    # Split the input string by spaces to preserve spaces in the final result\n    words = s.split(' ')\n    # Sort each word in the list\n    sorted_words = [sort_word(word) for word in words]\n    \n    # Join the sorted words back with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while keeping spaces intact\n    words = s.split(' ')\n    \n    # Sort characters in each word\n    sorted_words = [''.join(sorted(word)) for word in words]\n\n    # Join the sorted words back with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces while keeping track of spaces\n    words = s.split(' ')\n    \n    # Process each word\n    sorted_words = []\n    for word in words:\n        # Sort the characters in the word and join back into a string\n        sorted_word = ''.join(sorted(word))\n        sorted_words.append(sorted_word)\n    \n    # Join the processed words back into a single string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    The ordered version of the string is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ASCII value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string by spaces to handle words individually\n    words = s.split(' ')\n    \n    # Sort characters in each word and maintain spaces\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back with a single space\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    The ordered version of the string is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in\n    ascending order based on ASCII value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    \n    def sort_word(word):\n        \"\"\"Return the characters of the word sorted in ascending ASCII order.\"\"\"\n        return ''.join(sorted(word))\n    \n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    \n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    The ordered version of the string is created by sorting the characters of \n    each word (separated by spaces) in ascending order based on ASCII value, \n    while keeping the order of words and blank spaces in the sentence.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The transformed string with characters in each word sorted.\n    \"\"\"\n    def sort_word(word):\n        # Sort the characters of the word and return as a new string\n        return ''.join(sorted(word))\n\n    # Split the input string by spaces to handle words separately\n    words = s.split(' ')\n    # Sort each word and keep the spaces as they are\n    sorted_words = [sort_word(word) for word in words]\n    # Join the sorted words with spaces to reconstruct the sentence\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    The ordered version of the string is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in\n    ascending order based on ASCII value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words, keeping spaces intact\n    words = s.split(' ')\n    # Sort characters in each word and reconstruct the string\n    ordered_words = [''.join(sorted(word)) for word in words]\n    # Join the words back into a single string with spaces\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words based on spaces\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    sorted_words = []\n    for word in words:\n        # Sort the characters of the word and join them back\n        sorted_word = ''.join(sorted(word))\n        sorted_words.append(sorted_word)\n    \n    # Join the sorted words back into a string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string by spaces to preserve the words\n    words = s.split(' ')\n    # Create an empty list to store processed words\n    ordered_words = []\n    \n    # Process each word\n    for word in words:\n        # Sort the characters in the word and join them back into a string\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    \n    # Join the ordered words with a space to form the final string\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Process each word to sort characters\n    sorted_words = []\n    for word in words:\n        # Sort the characters in the word and join them back\n        sorted_word = ''.join(sorted(word))\n        sorted_words.append(sorted_word)\n    \n    # Join the processed words back with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words\n    words = s.split(' ')\n    # Create a list to hold the sorted words\n    sorted_words = []\n\n    # Process each word\n    for word in words:\n        # Sort the characters in the word and join them back into a string\n        sorted_word = ''.join(sorted(word))\n        # Append the sorted word to the list\n        sorted_words.append(sorted_word)\n\n    # Join the sorted words back into a single string with spaces\n    result = ' '.join(sorted_words)\n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    The ordered version of the string is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ASCII value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        # Sort the characters in the word and join them back to a string\n        return ''.join(sorted(word))\n\n    # Split the string into words while keeping track of spaces\n    words = s.split(' ')\n    \n    # Apply sorting to each word\n    sorted_words = [sort_word(word) for word in words]\n    \n    # Join the sorted words back into a single string with spaces\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        # Sort the characters of the word and return as a new string\n        return ''.join(sorted(word))\n    \n    # Split the input string by spaces to handle words and preserve spaces\n    words = s.split(' ')\n    # Sort each word and preserve the spaces by joining back\n    ordered_words = [sort_word(word) for word in words]\n    \n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words by spaces\n    words = s.split(' ')\n    \n    # Sort characters in each word while maintaining spaces in the result\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back with a space\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 93.94812680115274, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1, 2, 3, 4, 5, 6],\n      [1, 2, 3, 4, 1, 6],\n      [1, 2, 3, 4, 5, 1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    \n    coordinates = []\n    \n    # Iterate through each row in the list\n    for row_index, row in enumerate(lst):\n        # Iterate through each column in the row\n        for col_index, value in enumerate(row):\n            # If we find the target value x, store its coordinates\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort by row (ascending) and then by column (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort primarily by row index, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    \n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort primarily by row index (ascending) and then by column index (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    \n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort by row index ascending and then by column index descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n\n    # Iterate over each row and its index\n    for row_idx, row in enumerate(lst):\n        # Iterate over each element in the row and its index\n        for col_idx, value in enumerate(row):\n            # If the value matches x, add the coordinates to the result\n            if value == x:\n                result.append((row_idx, col_idx))\n\n    # Sort the results: first by row (ascending), then by column (descending)\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n                \n    # Sort by row index (ascending) and then by column index (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    # Sort by row first (ascending), and then by column (descending)\n    result.sort(key=lambda coordinate: (coordinate[0], -coordinate[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2-dimensional data as nested lists,\n    which is similar to a matrix; however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1, 2, 3, 4, 5, 6],\n      [1, 2, 3, 4, 1, 6],\n      [1, 2, 3, 4, 5, 1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort by row index first (ascending), then by column index (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    # Iterate through each row in the list\n    for row_index, row in enumerate(lst):\n        # Find all occurrences of x in the row\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort first by row index (ascending) and then by column index (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort coordinates by row index (ascending) and then by column index (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    coordinates = []\n\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort by row index (ascending) and column index (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1, 2, 3, 4, 5, 6],\n      [1, 2, 3, 4, 1, 6],\n      [1, 2, 3, 4, 5, 1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    get_row([], 1) == []\n    \n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    coordinates = []\n    \n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort by row index (ascending) and then by column index (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort coordinates first by row (ascending) and then by column (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through each row and its index\n    for row_index, row in enumerate(lst):\n        # Iterate through each column and its index\n        for col_index, value in enumerate(row):\n            # If the value matches x, store the coordinate (row, col)\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort by row first (ascending), and then by column (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix; however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1, 2, 3, 4, 5, 6],\n      [1, 2, 3, 4, 1, 6],\n      [1, 2, 3, 4, 5, 1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    get_row([], 1) == []\n    \n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through each row in the list\n    for row_index, row in enumerate(lst):\n        # Find indices of x in the current row\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by row index (ascending) and by column index (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort first by row (ascending) and then by column (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2-dimensional data as nested lists,\n    which is similar to a matrix; however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and an integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1, 2, 3, 4, 5, 6],\n      [1, 2, 3, 4, 1, 6],\n      [1, 2, 3, 4, 5, 1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    \n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    # Sort by row index and then by column index (descending)\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2-dimensional data, as a nested list,\n    which is similar to a matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort by row index, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    get_row([], 1) == []\n    \n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort by row index (ascending) and then by column index (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort coordinates by row (ascending), and by column (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.64948453608248, "dps_norm": 28.571428571428573, "pass@1": 86.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the rotation amount\n    rotation = 4  # 2 multiplied by 2\n    \n    # Create an empty result string\n    encrypted_string = \"\"\n    \n    for char in s:\n        # Check if the character is an alphabet letter\n        if char.isalpha():\n            # Determine if the letter is uppercase or lowercase\n            start = ord('a') if char.islower() else ord('A')\n            # Rotate the character by the defined rotation amount\n            rotated_char = chr(start + (ord(char) - start + rotation) % 26)\n            encrypted_string += rotated_char\n        else:\n            # Non-alphabet characters are left unchanged\n            encrypted_string += char\n            \n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Shift the letter by 4 positions (2 multiplied by 2)\n            # Use modulo to wrap around the alphabet\n            shifted = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            result.append(shifted)\n        else:\n            # If it's not a letter, keep it unchanged\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt the input string by rotating each letter down the alphabet by 4 positions.\"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Calculate the new character's ordinal value after rotation\n            new_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a')) if char.islower() else \\\n                           chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            result.append(new_char)\n        else:\n            result.append(char)  # Keep non-alphabet characters unchanged\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt a string by shifting each letter down the alphabet by 4 positions.\"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Shift character by 4 positions in the alphabet\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a')) if char.islower() else \\\n                               chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted_string += shifted_char\n        else:\n            # If the character is not a letter, we can choose to leave it unchanged\n            encrypted_string += char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if char.isalpha():  # Check if character is a letter\n            # Shift character down the alphabet by 4 places\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(new_char)\n        else:\n            encrypted.append(char)  # Non-alphabet characters are unchanged\n\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Rotate the character by 4 positions (2 * 2)\n            shifted = ord(char) + 4\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26  # Wrap around for lowercase letters\n            elif char.isupper():\n                if shifted > ord('Z'):\n                    shifted -= 26  # Wrap around for uppercase letters\n            result.append(chr(shifted))\n        else:\n            result.append(char)  # Non-alphabetic characters are unchanged\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    # Create a mapping for each letter\n    encrypted = ''\n    for char in s:\n        if char in alphabet:\n            # Find the current index and shift it by 4 positions (2 * 2)\n            new_index = (alphabet.index(char) + 4) % 26\n            encrypted += alphabet[new_index]\n        else:\n            # If character is not in the alphabet, we can just keep it as is\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    \n    for char in s:\n        if char.isalpha():  # Check if character is a letter\n            # Shift character by 4 positions\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a')) if char.islower() else \\\n                        chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            result.append(new_char)\n        else:\n            result.append(char)  # Keep non-alphabet characters unchanged\n\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt a string by rotating the letters down by four places in the alphabet.\"\"\"\n    result = []\n    \n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Get the ASCII value of the character\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            # Shift the character down by 4, wrapping around the alphabet\n            new_char = chr(ascii_offset + (ord(char) - ascii_offset + 4) % 26)\n            result.append(new_char)\n        else:\n            # If not a letter, we can just append it as is (or handle as needed)\n            result.append(char)\n    \n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt the input string by rotating each letter down by four places in the alphabet.\"\"\"\n    encrypted_string = \"\"\n    \n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Calculate the new position with rotation\n            shift = 4  # Two multiplied by two\n            new_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a')) if char.islower() else \\\n                           chr(((ord(char) - ord('A') + shift) % 26) + ord('A'))\n            encrypted_string += new_char\n        else:\n            encrypted_string += char  # Keep non-alphabet characters unchanged\n    \n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the input string by rotating its letters down the alphabet\n    by two multiplied by two places (i.e., four places).\n    \n    Args:\n        s (str): The input string to encrypt.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    \n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Calculate the rotated character\n            # Shift by 4 positions within the bounds of 'a' to 'z'\n            new_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(new_char)\n        else:\n            encrypted.append(char)  # Append non-alphabetic characters unchanged\n    \n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():  # Check if the character is an alphabet\n            # Shift the character by 2 * 2 = 4 places\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char)  # Non-alphabet characters remain unchanged\n\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the input string by rotating each letter down the alphabet\n    by two multiplied to two places (i.e., shifting each letter by 4 places).\n    \n    Args:\n    s (str): The string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    encrypted_string = []\n    \n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Calculate the new character's ASCII value\n            shift = (ord(char) - ord('a') + 4) % 26 + ord('a') if char.islower() else (ord(char) - ord('A') + 4) % 26 + ord('A')\n            encrypted_string.append(chr(shift))\n        else:\n            # If it's not a letter, we just add it to the result unchanged\n            encrypted_string.append(char)\n    \n    return ''.join(encrypted_string)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet is rotated in a manner such that the letters \n    shift down by 4 places.\n    \n    Args:\n    s (str): The string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Calculate the new character\n            offset = ord('a') if char.islower() else ord('A')\n            new_char = chr((ord(char) - offset + 4) % 26 + offset)\n            result.append(new_char)\n        else:\n            # If it's not a letter, append it unchanged\n            result.append(char)\n\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating its letters down the alphabet\n    by two multiplied by two places (i.e., a shift of 4).\n\n    Args:\n        s (str): The string to encrypt.\n\n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            shift = 4  # Define the shift amount\n            if char.islower():\n                # Shift the character and wrap around using modulo\n                new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                # Shift the character for uppercase letters\n                new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            encrypted.append(new_char)\n        else:\n            # Non-alphabetic characters remain unchanged\n            encrypted.append(char)\n\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Calculate the new character position\n            new_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted += new_char\n        else:\n            encrypted += char  # If it's not a letter, keep it unchanged\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Create a list to hold the encrypted characters\n    encrypted_chars = []\n    \n    # Iterate over each character in the input string\n    for char in s:\n        if char.isalpha():  # Check if the character is an alphabet letter\n            # Determine the base (ASCII code) for lowercase or uppercase letters\n            base = ord('a') if char.islower() else ord('A')\n            # Calculate the new character's position, rotating 4 positions\n            new_char = chr((ord(char) - base + 4) % 26 + base)\n            encrypted_chars.append(new_char)\n        else:\n            # If not an alphabet letter, append it unchanged\n            encrypted_chars.append(char)\n    \n    # Join the list into a string and return\n    return ''.join(encrypted_chars)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():  # Check if character is a letter\n            # Find the starting point of the letter's ASCII value\n            start = ord('a') if char.islower() else ord('A')\n            # Rotate the character by 4 positions (2 multiplied by 2)\n            new_char = chr(start + (ord(char) - start + 4) % 26)\n            result.append(new_char)\n        else:\n            result.append(char)  # Non-alphabetical characters remain unchanged\n    \n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Calculate the new character's ASCII value\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(new_char)\n        else:\n            encrypted.append(char)  # Non-alphabet characters remain unchanged\n\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    \n    for char in s:\n        # Check if character is a lowercase letter\n        if 'a' <= char <= 'z':\n            # Shift the character by 4 positions in the alphabet\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        # Check if character is an uppercase letter (optional, you can include or exclude)\n        elif 'A' <= char <= 'Z':\n            new_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            result.append(new_char)\n        else:\n            # If the character is not a letter, you can choose to leave it unchanged\n            result.append(char)\n    \n    return ''.join(result)", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 87.54863813229572, "dps_norm": 58.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting to a set, then back to a sorted list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting the list to a set, then back to a list\n    unique_lst = list(set(lst))\n    \n    # Sort the list to find the 2nd smallest element\n    unique_lst.sort()\n    \n    # Check if there are at least two unique elements\n    if len(unique_lst) < 2:\n        return None\n    \n    # Return the 2nd smallest element\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = list(set(lst))  # Remove duplicates\n    unique_elements.sort()  # Sort the list\n    \n    if len(unique_elements) < 2:\n        return None  # If there are less than 2 unique elements, return None\n    \n    return unique_elements[1]  # Return the second smallest element", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting the list to a set, then back to a sorted list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Create a set to remove duplicates\n    unique_elements = set(lst)\n\n    # If there are less than 2 unique elements, return None\n    if len(unique_elements) < 2:\n        return None\n\n    # Convert the set back to a sorted list\n    sorted_unique_elements = sorted(unique_elements)\n\n    # Return the second smallest element\n    return sorted_unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = set(lst)  # Get unique elements to handle duplicates\n    if len(unique_elements) < 2:  # Check if there are at least 2 unique elements\n        return None\n    unique_sorted = sorted(unique_elements)  # Sort the unique elements\n    return unique_sorted[1]  # Return the second smallest element", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Use a set to eliminate duplicates and then convert it back to a sorted list\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    # Return the second smallest element\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then back to a sorted list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting to a set and then back to a list\n    unique_lst = list(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_lst) < 2:\n        return None\n    \n    # Sort the list to find the second smallest element\n    unique_lst.sort()\n    \n    # Return the second smallest element\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_numbers = set(lst)\n    \n    # If there are fewer than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the second smallest element\n    return sorted_numbers[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Use a set to eliminate duplicates and sort the unique elements\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    This function returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Parameters:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest integer or None if it does not exist.\n    \"\"\"\n    # Remove duplicates by converting to a set\n    unique_numbers = set(lst)\n    \n    # If there are fewer than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the second smallest\n    return sorted_numbers[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Use a set to eliminate duplicates and then sort the unique elements\n    unique_sorted = sorted(set(lst))\n\n    # Return the second smallest element if it exists\n    if len(unique_sorted) < 2:\n        return None\n    else:\n        return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Create a set from the list to remove duplicates and then convert it back to a list\n    unique_numbers = list(set(lst))\n    \n    # Sort the unique numbers\n    unique_numbers.sort()\n    \n    # Check if there is at least a second smallest element\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Return the second smallest element\n    return unique_numbers[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_numbers = set(lst)  # Remove duplicates\n    if len(unique_numbers) < 2:\n        return None  # Less than 2 unique elements, no 2nd smallest\n    sorted_numbers = sorted(unique_numbers)  # Sort the unique elements\n    return sorted_numbers[1]  # Return the 2nd smallest element", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Convert the list to a set to remove duplicates and sort it\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second smallest element\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting the list to a set, then back to a list\n    unique_lst = list(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_lst) < 2:\n        return None\n    \n    # Sort the unique list and return the second smallest element\n    unique_lst.sort()\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting to a set, then convert back to a sorted list\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    # Return the second smallest element\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Use a set to find unique elements and then sort them\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_sorted) < 2:\n        return None\n    else:\n        return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    This function returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_elements = list(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_elements) < 2:\n        return None\n    \n    # Sort the unique elements\n    unique_elements.sort()\n    \n    # Return the second smallest element\n    return unique_elements[1]", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 99.43204868154159, "dps_norm": 75.83333333333333, "pass@1": 100.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for char in s if char in '13579')\n        # Create the output string using the counted odd digits\n        output_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    \n    result = []\n    for string in lst:\n        # Count the odd digits in the current string\n        odd_count = sum(1 for char in string if char in '13579')\n        # Create the output string with the count inserted\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    \n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits,\n    return a list. Each element i of the output should be \"the number of odd \n    elements in the string i of the input.\" where all the i's should be \n    replaced by the number of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    \n    for s in lst:\n        # Count the odd digits in the string\n        odd_count = sum(1 for char in s if char in '13579')\n        \n        # Construct the output string with the count\n        output_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output_string)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    results = []\n    \n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 == 1)  # Count odd digits\n        result = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        results.append(result)\n    \n    return results", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    \n    for s in lst:\n        odd_count = sum(1 for char in s if char in '13579')  # Count odd digits\n        # Format the output string with the count of odd digits\n        output_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output_str)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_count = sum(1 for char in s if char in '13579')\n        result_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        output.append(result_string)\n    return output", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if char in '13579')  # Count odd digits\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 == 1)  # Count odd digits\n        output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    \n    for s in lst:\n        # Count odd digits in the current string\n        odd_count = sum(1 for char in s if char in '13579')\n        \n        # Construct the output string\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count odd digits\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        # Formulate the output string\n        output_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for char in s if char in '13579')\n        # Construct the output string with the counted odd digits\n        output_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        odd_count = sum(1 for char in string if char in '13579')  # Count odd digits\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for string in lst:\n        odd_count = sum(1 for char in string if char in '13579')\n        result_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        output.append(result_string)\n    return output", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits,\n    return a list. Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count odd digits in the string\n        odd_count = sum(1 for char in s if char in '13579')\n        # Create the result string with the counted odd digits\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 6.686046511627907, "dps_norm": 77.0, "pass@1": 85.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n            # If balance goes negative, there are unmatched ')'\n            if balance < 0:\n                return False\n        # For the string to be good, balance must be zero at the end\n        return balance == 0\n\n    # Check both concatenations\n    s1, s2 = lst\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    # Helper function to check if a string has balanced parentheses\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Get the two strings\n    str1, str2 = lst\n    \n    # Check both possible concatenations\n    return 'Yes' if is_balanced(str1 + str2) or is_balanced(str2 + str1) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Check both concatenations: s1 + s2 and s2 + s1\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def count_parentheses(s):\n        open_count = s.count('(')\n        close_count = s.count(')')\n        return open_count, close_count\n\n    # Count parentheses in both strings\n    open_a, close_a = count_parentheses(lst[0])\n    open_b, close_b = count_parentheses(lst[1])\n\n    # Check both concatenation orders: lst[0] + lst[1] and lst[1] + lst[0]\n    # For a good string, the number of closing brackets should not exceed \n    # the number of opening brackets at any point.\n\n    # Check if lst[0] + lst[1] is good\n    if open_a + open_b >= close_a + close_b:\n        # Check if we can balance while concatenating\n        balance = 0\n        for char in lst[0] + lst[1]:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n            if balance < 0:\n                break\n        else:\n            if balance == 0:\n                return 'Yes'\n    \n    # Check if lst[1] + lst[0] is good\n    if open_b + open_a >= close_b + close_a:\n        # Check if we can balance while concatenating\n        balance = 0\n        for char in lst[1] + lst[0]:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n            if balance < 0:\n                break\n        else:\n            if balance == 0:\n                return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Check both concatenation orders\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    a, b = lst\n    # Check both concatenation orders\n    if is_good(a + b) or is_good(b + a):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n\n    # Check both concatenation orders: s1 + s2 and s2 + s1\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:  # At any point, we shouldn't have more ')' than '('\n                return False\n        return balance == 0  # Should be balanced at the end\n\n    first, second = lst\n\n    # Check both concatenation orders\n    if is_good(first + second) or is_good(second + first):\n        return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:  # More closing than opening\n                return False\n        return balance == 0  # Should be balanced at the end\n\n    a, b = lst\n\n    # Check both concatenation orders\n    if is_good(a + b) or is_good(b + a):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    # Function to check if a string is balanced\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n            # If balance goes negative, we have more ')' than '('\n            if balance < 0:\n                return False\n        # The string is balanced if we end up with 0 balance\n        return balance == 0\n\n    # Check both concatenation orders\n    return 'Yes' if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n            if balance < 0:  # More closing than opening\n                return False\n        return balance == 0  # Must end with a balance of zero\n\n    s1, s2 = lst\n    \n    # Check both concatenation orders\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    a, b = lst[0], lst[1]\n    \n    # Check both possible concatenations\n    return 'Yes' if is_good(a + b) or is_good(b + a) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    str1, str2 = lst\n\n    # Check both concatenation orders\n    if is_good(str1 + str2) or is_good(str2 + str1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both concatenations: lst[0] + lst[1] and lst[1] + lst[0]\n    return 'Yes' if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good(concat_str):\n        balance = 0\n        for char in concat_str:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n            if balance < 0:  # More closing than opening\n                return False\n        return balance == 0  # Must end with a balance of zero\n\n    # Check both concatenation orders\n    return 'Yes' if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_good_string(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    str1, str2 = lst\n\n    # Check both concatenation orders\n    return 'Yes' if is_good_string(str1 + str2) or is_good_string(str2 + str1) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    first, second = lst\n    \n    # Check both concatenations: first + second and second + first\n    return 'Yes' if is_balanced(first + second) or is_balanced(second + first) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good(s1, s2):\n        combined = s1 + s2\n        balance = 0\n        for char in combined:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n            if balance < 0:  # more closing than opening parentheses\n                return False\n        return balance == 0  # must end with no open parentheses\n\n    s1, s2 = lst\n    # Check both orders of concatenation\n    if is_good(s1, s2) or is_good(s2, s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    return 'Yes' if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Check both possible concatenations\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 3}]}, "HumanEval/120": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Get the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Return the top k elements sorted in ascending order\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Take the first k elements\n    max_k_elements = sorted_arr[:k]\n    # Return the result sorted in ascending order\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order and take the first k elements\n    max_k_elements = sorted(arr, reverse=True)[:k]\n    # Sort the resulting k elements in ascending order before returning\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Handle case where k is 0\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    max_k_elements = sorted_arr[:k]\n    \n    # Return the sorted result in ascending order\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Use sorted to get the k largest elements\n    largest_k_elements = sorted(arr, reverse=True)[:k]\n    \n    # Return the sorted list of the largest k elements\n    return sorted(largest_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order and get the first k elements\n    max_k_elements = sorted(arr, reverse=True)[:k]\n    # Sort the result in ascending order before returning\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Handle edge case where k is 0\n    if k == 0:\n        return []\n\n    # Sort the array in descending order and pick the top k elements\n    max_elements = sorted(arr, reverse=True)[:k]\n    \n    # Sort the result to return in ascending order\n    return sorted(max_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Get the first k elements\n    max_k_elements = sorted_arr[:k]\n    \n    # Return the list sorted in ascending order\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n\n    # Sort the array in descending order and take the first k elements\n    max_elements = sorted(arr, reverse=True)[:k]\n    \n    # Return the sorted list of those k elements in ascending order\n    return sorted(max_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Step 1: Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Step 2: Get the first k elements (the maximum k numbers)\n    max_k_numbers = sorted_arr[:k]\n    \n    # Step 3: Sort the result in ascending order to meet the output requirement\n    return sorted(max_k_numbers)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Step 1: Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Step 2: Select the top k elements\n    top_k_elements = sorted_arr[:k]\n    \n    # Step 3: Sort the result in ascending order for the final output\n    return sorted(top_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Get the top k elements\n    top_k = sorted_arr[:k]\n    # Sort the top k elements in ascending order for the final output\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    \n    # Step 1: Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Step 2: Select the top k elements\n    top_k_elements = sorted_arr[:k]\n    \n    # Step 3: Sort the selected top k elements in ascending order\n    return sorted(top_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order to get the maximum elements\n    sorted_arr = sorted(arr, reverse=True)\n    # Select the first k elements from the sorted array\n    max_elements = sorted_arr[:k]\n    # Return the selected elements sorted in ascending order\n    return sorted(max_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Get the top k elements\n    top_k_elements = sorted_arr[:k]\n    # Sort the result in ascending order\n    return sorted(top_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order to get the largest elements first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Slice the first k elements (the largest k elements)\n    max_k_elements = sorted_arr[:k]\n    \n    # Return the sorted list of those k elements in ascending order\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order and get the first k elements\n    max_k_elements = sorted(arr, reverse=True)[:k]\n    # Return the sorted list of k maximum elements\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order to get the largest elements first\n    sorted_arr = sorted(arr, reverse=True)\n    # Take the first k elements and sort them in ascending order\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order to get the largest numbers\n    sorted_arr = sorted(arr, reverse=True)\n    # Get the top k elements and sort them in ascending order\n    max_k_elements = sorted(sorted_arr[:k])\n    return max_k_elements", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order and take the first k elements\n    max_elements = sorted(arr, reverse=True)[:k]\n    \n    # Sort the selected elements in ascending order before returning\n    return sorted(max_elements)", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 91.74887892376681, "dps_norm": 70.0, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize sum\n    total_sum = 0\n    \n    # Iterate over the list and check even index positions\n    for index in range(0, len(lst), 2):  # Step by 2 to get even indices\n        if lst[index] % 2 != 0:  # Check if the number is odd\n            total_sum += lst[index]  # Add to total_sum\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Even positions in a zero-indexed list are positions 0, 2, 4, etc.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of odd elements in even positions.\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Sum the odd elements at even indices\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Args:\n    lst (list of int): A non-empty list of integers.\n\n    Returns:\n    int: The sum of odd elements at even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    An even position is defined as indices 0, 2, 4, etc.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of odd elements at even positions in the list.\n\n    Examples:\n        solution([5, 8, 7, 1]) => 12\n        solution([3, 3, 3, 3, 3]) => 9\n        solution([30, 13, 24, 321]) => 0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even indices\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum variable\n    total_sum = 0\n    \n    # Iterate through the list with index\n    for index in range(len(lst)):\n        # Check if the index is even and the element at that index is odd\n        if index % 2 == 0 and lst[index] % 2 != 0:\n            total_sum += lst[index]\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Sum of odd elements at even indices\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Arguments:\n    lst -- list of integers\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    An element's position is considered even if its index is even (0-based indexing).\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Args:\n        lst (list): A list of integers.\n        \n    Returns:\n        int: The sum of odd elements in even positions.\n    \n    Examples:\n        solution([5, 8, 7, 1]) ==> 12\n        solution([3, 3, 3, 3, 3]) ==> 9\n        solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Args:\n        lst (list): A list of integers.\n    \n    Returns:\n        int: The sum of odd elements at even indices.\n    \n    Examples:\n        solution([5, 8, 7, 1]) ==> 12\n        solution([3, 3, 3, 3, 3]) ==> 9\n        solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Args:\n    lst: A list of integers.\n    \n    Returns:\n    An integer representing the sum of odd elements at even indices.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"Deletes strings with odd lengths from the list and returns a sorted list.\n    \n    Args:\n    lst: A list of strings.\n    \n    Returns:\n    A list of strings that have even lengths, sorted first by length and then alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Removes strings with odd lengths from the list and returns\n    a sorted list of the remaining strings based on length and then alphabetically.\n    \n    Args:\n        lst (list): A list of strings.\n    \n    Returns:\n        list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Remove strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Deletes strings with odd lengths and returns a sorted list of remaining strings.\n    \n    Args:\n        lst (list of str): A list of strings.\n    \n    Returns:\n        list of str: A sorted list of strings with even lengths, sorted by length and then alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings first by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted first by length\n    and then alphabetically.\n    \"\"\"\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length and then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Function that accepts a list of strings, removes those with odd lengths,\n    and returns a sorted list based on length and alphabetically.\n    \n    Args:\n    lst (list of str): List of strings to process.\n\n    Returns:\n    list of str: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Deletes strings with odd lengths from a list, \n    then returns the remaining strings sorted by length \n    and alphabetically if lengths are the same.\n    \n    Args:\n        lst (list of str): The input list of strings.\n        \n    Returns:\n        list of str: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Accepts a list of strings, deletes the strings with odd lengths,\n    and returns the resulting list sorted by length and alphabetically.\n    \"\"\"\n    # Remove strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort by length first, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Removes strings of odd lengths from the list and returns the remaining strings sorted \n    first by length and then alphabetically if lengths are the same.\n    \n    Args:\n        lst (list): A list of strings.\n        \n    Returns:\n        list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filters out strings with odd lengths from the list, sorts the remaining strings first by length\n    and then alphabetically, and returns the sorted list.\n    \n    Args:\n        lst (list of str): A list of strings.\n        \n    Returns:\n        list of str: A sorted list of strings with even lengths.\n    \"\"\"\n    # Remove strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Deletes strings with odd lengths and returns the remaining strings sorted\n    by length (ascending) and alphabetically.\n\n    Args:\n        lst (list of str): A list of strings.\n\n    Returns:\n        list of str: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort by length first, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda s: (len(s), s))\n\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filter out strings with odd lengths and return a sorted list\n    of the remaining strings by length and alphabetically.\n    \n    Parameters:\n    lst (list): A list of strings.\n    \n    Returns:\n    list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Accepts a list of strings, deletes strings with odd lengths,\n    and returns the list sorted by length and then alphabetically.\n    \n    Args:\n        lst (list): A list of strings.\n\n    Returns:\n        list: A sorted list of strings with even lengths.\n    \"\"\"\n    \n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort by length first, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Remove strings with odd lengths from the list, \n    and return the resulting list sorted by length and then alphabetically.\n    \n    Args:\n        lst (list): A list of strings.\n        \n    Returns:\n        list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Remove strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Remove strings with odd lengths from the list and return a sorted list.\n    \n    Args:\n        lst (list of str): A list of strings.\n\n    Returns:\n        list of str: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort first by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Accepts a list of strings, removes strings with odd lengths, \n    and returns the remaining strings sorted first by length and then alphabetically.\n    \n    Args:\n        lst (list): A list of strings.\n        \n    Returns:\n        list: A list of strings sorted by length and alphabetically.\n    \"\"\"\n    # Remove strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Deletes strings with odd lengths from the list and returns a sorted list.\n    \n    Args:\n        lst (list of str): A list of strings.\n        \n    Returns:\n        list of str: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda s: (len(s), s))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Removes strings with odd lengths from the list and returns the remaining\n    strings sorted first by length and then alphabetically.\n\n    Args:\n        lst (list of str): A list of strings.\n\n    Returns:\n        list of str: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the filtered list by length and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Filter out strings with odd lengths and return a sorted list.\n    \n    Args:\n    lst (list): A list of strings.\n    \n    Returns:\n    list: A list of strings filtered and sorted by length and alphabetically.\n    \"\"\"\n    # Step 1: Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Step 2: Sort the filtered list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Accepts a list of strings, removes those with odd lengths, \n    and returns the remaining strings sorted by length and alphabetically.\"\"\"\n    \n    # Remove strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Accepts a list of strings, deletes strings with odd lengths,\n    and returns the remaining strings sorted by length and then alphabetically.\n    \n    Args:\n        lst (list of str): A list of strings.\n        \n    Returns:\n        list of str: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 58.13559322033898, "dps_norm": 76.25, "pass@1": 100.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is non-prime.\n    \n    A number is considered non-prime if it is less than 2, or if it is \n    divisible by any number other than 1 and itself.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is non-prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"Returns True if n is not a prime number, otherwise False.\"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # n is divisible by some number other than 1 and itself\n    return False  # n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is non-prime.\n    \n    Parameters:\n    n (int): The number to check\n    \n    Returns:\n    bool: True if n is non-prime, False if n is prime\n    \"\"\"\n    if n < 2:\n        return True  # 0 and 1 are considered non-prime\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, so n is non-prime\n    return False  # No divisors found, so n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, so n is not prime\n    return False  # No divisors found, so n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Returns True if n is not a prime number, otherwise returns False.\n    \n    A prime number is defined as a number greater than 1 that has no positive \n    divisors other than 1 and itself. Therefore, any number less than 2 or any \n    even number greater than 2 is not prime.\n    \"\"\"\n    if n < 2:\n        return True  # 0 and 1 are not prime\n    if n == 2:\n        return False  # 2 is prime\n    if n % 2 == 0:\n        return True  # all even numbers greater than 2 are not prime\n    \n    # Check for factors from 3 to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True  # Found a factor, so not prime\n    return False  # No factors found, so it is prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"Return True if n is not a prime number, otherwise False.\"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, so n is not prime\n    return False  # No divisors found, so n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"Return True if n is not a prime number, False otherwise.\"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # n is divisible by some number other than 1 and itself, hence not prime\n    return False  # n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"Return True if n is not a prime number, otherwise False.\"\"\"\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n    \n    A prime number is a natural number greater than 1 \n    that cannot be formed by multiplying two smaller natural numbers.\n    Therefore, non-prime numbers are either less than 2 \n    or can be divided by some number other than 1 and itself.\n    \n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, so it's not prime\n    return False  # No divisors found, it's prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"Return True if n is not a prime number, False if it is prime.\"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # n is divisible by i, hence not prime\n    return False  # n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"Check if a number is non-prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is non-prime, False if it is prime.\n    \"\"\"\n    if n <= 1:\n        return True  # Numbers 0 and 1 are considered non-prime\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, so n is non-prime\n    return False  # No divisors found, so n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    Returns True if n is non-prime (including 0 and 1), False if it is prime.\n    \"\"\"\n    if n <= 1:  # 0 and 1 are not prime numbers\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # n is divisible by i, hence it's not prime\n    return False  # n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"Return True if n is not a prime number, otherwise False.\"\"\"\n    if n <= 1:  # 0 and 1 are not prime numbers\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, hence not prime\n    return False  # No divisors found, hence prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to determine if a number is not a prime number.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # n is divisible by some number other than 1 and itself\n    return False  # n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to determine if a number is non-prime.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is non-prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True  # 0 and 1 are not prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # n is divisible by i, hence not prime\n    return False  # n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, hence not prime\n    return False  # No divisors found, hence prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to determine if a number is non-prime.\n    \n    A number is considered non-prime if it is less than 2 or if it has \n    any divisors other than 1 and itself.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is non-prime, False if it is prime.\n    \"\"\"\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is not prime, False if n is prime.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # n is divisible by i, hence not prime\n    return False  # n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"Return True if n is a non-prime number, otherwise False.\"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # n is divisible by a number other than 1 and itself\n    return False  # n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Returns True if the number is non-prime, False otherwise.\n    \n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if non-prime, False if prime.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # n is divisible by i, thus it is non-prime\n    return False  # n is prime", "matching_cluster_idx": 5}]}, "Mbpp/4": {"dps": 91.51877133105802, "dps_norm": 82.91666666666666, "pass@1": 100.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    n (int): The number of largest integers to find.\n\n    Returns:\n    list: A list of the n largest integers in descending order.\n    \"\"\"\n    # Use heapq to find the n largest numbers\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to return\n    :return: List of n largest integers in descending order\n    \"\"\"\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of the n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers and return them in descending order.\n    \n    :param nums: List of integers\n    :param n: Number of largest integers to find\n    :return: List of the n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers.\n    n (int): The number of largest integers to return.\n    \n    Returns:\n    list: A list of the n largest integers in descending order.\n    \"\"\"\n    # Use heapq to find the n largest elements\n    largest_numbers = heapq.nlargest(n, numbers)\n    # Return them sorted in descending order\n    return sorted(largest_numbers, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from the given list of numbers,\n    returned in descending order.\n    \n    :param nums: List of numbers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    # Use heapq to find the n largest numbers\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: List of integers\n    :param n: Number of largest integers to return\n    :return: List of the n largest integers in descending order\n    \"\"\"\n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    # Return them in descending order\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers in descending order.\n\n    :param numbers: List of integers.\n    :param n: The number of largest integers to find.\n    :return: A list of the n largest integers in descending order.\n    \"\"\"\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers.\n    :param n: The number of largest integers to return.\n    :return: A list of the n largest integers in descending order.\n    \"\"\"\n    # Use heapq to get the n largest elements\n    largest_numbers = heapq.nlargest(n, numbers)\n    # Sort the result in descending order\n    return sorted(largest_numbers, reverse=True)", "matching_cluster_idx": 8}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"Return the n largest integers from a given list of numbers in descending order.\"\"\"\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers in descending order.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    n (int): The number of largest integers to find.\n    \n    Returns:\n    list: A list of the n largest integers in descending order.\n    \"\"\"\n    # Use heapq.nlargest to find the n largest elements\n    largest_numbers = heapq.nlargest(n, numbers)\n    # Sort the largest numbers in descending order\n    return sorted(largest_numbers, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"Find the n largest integers from a list of numbers, returned in descending order.\"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: List of integers\n    :param n: Number of largest integers to return\n    :return: List of n largest integers in descending order\n    \"\"\"\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Parameters:\n    numbers (list): A list of integers.\n    n (int): The number of largest integers to find.\n\n    Returns:\n    list: A list of the n largest integers in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    if n > len(numbers):\n        return sorted(numbers, reverse=True)  # if n is larger than the list, return the sorted list\n\n    # Use heapq to find the n largest elements\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    return sorted(largest_numbers, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from the given list of numbers in descending order.\n\n    Args:\n    nums (list): A list of integers.\n    n (int): The number of largest integers to find.\n\n    Returns:\n    list: A list of the n largest integers in descending order.\n    \"\"\"\n    # Use heapq to find the n largest elements, then sort them in descending order\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Parameters:\n    numbers (list): A list of integers.\n    n (int): The number of largest integers to find.\n\n    Returns:\n    list: A list containing the n largest integers in descending order.\n    \"\"\"\n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Sort the largest numbers in descending order\n    largest_numbers.sort(reverse=True)\n    \n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param nums: List of integers\n    :param n: The number of largest integers to find\n    :return: A list of the n largest integers in descending order\n    \"\"\"\n    # Use heapq to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, nums)\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from the given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to return\n    :return: List of n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    # Use heapq to find the n largest elements and then sort them in descending order\n    largest_numbers = heapq.nlargest(n, numbers)\n    return sorted(largest_numbers, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"Find the n largest integers from the list of numbers, returned in descending order.\"\"\"\n    if n <= 0:\n        return []\n    # Use heapq to find the n largest elements\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 59.795918367346935, "dps_norm": 53.0, "pass@1": 55.0, "profiled": [{"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    This function finds the minimum number of rotations (greater than 0) \n    required to get the same string.\n    \n    Args:\n    s (str): The input string to be rotated.\n    \n    Returns:\n    int: The minimum number of rotations greater than 0.\n    \"\"\"\n    length = len(s)\n    \n    # Create a doubled string to check for rotations\n    doubled_s = s + s\n    \n    # Check for the original string in the doubled string\n    for i in range(1, length):  # starting from 1 to ensure the rotation is greater than 0\n        if doubled_s[i:i + length] == s:\n            return i\n            \n    return length  # In case all rotations have been checked, return the length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    if not s:\n        return 0\n    \n    n = len(s)\n    # To find the minimum rotations, we can concatenate the string with itself\n    double_s = s + s\n    # We find the first occurrence of the original string in the doubled string\n    index = double_s.find(s, 1)  # Start looking after the first character\n    \n    if index == -1:\n        return n  # If not found, the only rotation is the string itself\n    else:\n        return index", "matching_cluster_idx": 7}, {"solution": "def find_Rotations(s: str) -> int:\n    # If the string is empty or has only one character, return 1\n    if len(s) <= 1:\n        return 1\n    \n    # Length of the string\n    n = len(s)\n    \n    # Check rotations\n    for i in range(1, n):\n        # Create the rotated version of the string\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i  # Return the number of rotations\n    \n    return n  # If no earlier match, it takes n rotations to return to original", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # Get the length of the string\n    n = len(s)\n    \n    # If the string is empty or has only one character, return 0\n    if n <= 1:\n        return 0\n    \n    # To find the minimum rotations, we'll check rotations\n    # We can find the rotations by concatenating the string to itself\n    # and checking for the original string in the doubled string\n    doubled_s = s + s\n    \n    # We check each possible rotation from 1 to n-1\n    for i in range(1, n):\n        if doubled_s[i:i+n] == s:\n            return i\n    \n    # If no valid rotation is found, return n (complete rotation)\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations required to get the same string.\n    \n    :param s: The input string\n    :return: The minimum number of rotations greater than 0\n    \"\"\"\n    n = len(s)\n    # Check for trivial case\n    if n == 0:\n        return 0\n    \n    # Create a double string\n    double_s = s + s\n    \n    # Loop through the possible rotations\n    for i in range(1, n):\n        if double_s[i:i+n] == s:\n            return i\n            \n    return n  # In case the string is unique (like \"abcd\")", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    n = len(s)\n    # Check if the string is empty or has a single character\n    if n <= 1:\n        return 0\n    \n    # Generate all rotations of the string\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n    return n  # If no rotation is found, the entire length is needed", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    This function finds the minimum number of rotations required to get the same string.\n    \n    :param s: A string for which we need to find the minimum number of rotations.\n    :return: Minimum number of rotations greater than 0 to obtain the same string.\n    \"\"\"\n    n = len(s)\n    \n    # Edge case: If the string is empty, we return 0\n    if n == 0:\n        return 0\n    \n    # Check for repeated characters\n    if s.count(s[0]) == n:\n        return 1\n    \n    # Find the minimum rotations needed\n    for i in range(1, n):\n        # Create rotated string\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n  # This should never be reached for a valid input.", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    This function returns the minimum number of rotations (greater than 0) required\n    to get the same string as input.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations needed to return to the original string.\n    \"\"\"\n    # Get the length of the string\n    n = len(s)\n    \n    # If the string is empty, there are no rotations needed\n    if n == 0:\n        return 0\n    \n    # A string can return to itself after a number of rotations equal to its length\n    # Check all possible rotation lengths\n    for i in range(1, n + 1):\n        if s[i:] + s[:i] == s:\n            return i\n\n    return n  # In the worst case, n rotations are needed, which won't happen for the test case \"aaaa\"", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    :param s: The input string\n    :return: The minimum number of rotations required\n    \"\"\"\n    length = len(s)\n    # Check for any rotations\n    for i in range(1, length + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return length  # This line should not be reached for non-empty strings", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    This function finds the minimum number of rotations required to\n    return to the original string.\n    \n    :param s: The input string.\n    :return: The minimum number of rotations (greater than 0).\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        # Create a rotated version of the string\n        rotated = s[i % n:] + s[:i % n]\n        if rotated == s:\n            return i\n    return n  # In case of all unique characters, would return n, which is not valid here.", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    This function finds the minimum number of rotations greater than 0 \n    required to get the same string.\n    \n    Args:\n    s (str): The input string to evaluate.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    \n    # Check if the string is empty or has only one unique character\n    if n == 0 or len(set(s)) == 1:\n        return 1\n    \n    # Check for the minimum rotations\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n    \n    return n  # If no rotation yields the original string, return n.", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    :param s: The input string\n    :return: The minimum number of rotations required\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0  # No rotation needed for an empty string\n    \n    for i in range(1, n):\n        # Generate the rotated version of the string\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i  # Return the rotation count\n\n    return n  # If not found, return n (the length of the string)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    This function finds the minimum number of rotations required to get the same string.\n    \n    Args:\n    s (str): The input string to check for rotations.\n    \n    Returns:\n    int: Minimum number of rotations required to get the same string.\n    \"\"\"\n    # A string can be rotated n times where n is the length of the string\n    n = len(s)\n    \n    # Check for rotations starting from 1 to n\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i  # Return the number of rotations\n\n    return n  # If no rotation matches, return the length of the string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0  # Return 0 for empty string\n\n    # Loop to check all rotations\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i  # Return the number of rotations\n\n    return n  # If no rotation found, return n (full rotation)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    # Check if the string is empty or has only one unique character\n    if len(s) == 0 or len(set(s)) == 1:\n        return 1\n    \n    # The length of the string\n    n = len(s)\n    \n    # Loop through each rotation\n    for i in range(1, n):\n        # Rotate the string\n        rotated = s[i:] + s[:i]\n        # Check if the rotated string is equal to the original\n        if rotated == s:\n            return i\n    \n    return n  # If no rotation matches, the number of rotations is equal to length of string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    :param s: The input string\n    :return: The minimum number of rotations needed\n    \"\"\"\n    n = len(s)\n    \n    if n == 0:\n        return 0\n    \n    # Check for all possible rotations\n    for i in range(1, n + 1):\n        if s[i:] + s[:i] == s:\n            return i\n    \n    return n  # In case of no rotations found (should not occur for non-empty strings)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    if not s:\n        return 0  # Early return for empty string\n    \n    n = len(s)\n    doubled_s = s + s  # Concatenate the string with itself\n\n    # Iterate through possible rotations\n    for i in range(1, n):  # We start from 1 to avoid the original string\n        if doubled_s[i:i+n] == s:\n            return i  # Return the number of rotations\n\n    return n  # In case the string is all the same characters, return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    This function finds the minimum number of rotations (greater than 0) required \n    to get the same string.\n    \n    :param s: Input string\n    :return: Minimum number of rotations required\n    \"\"\"\n    n = len(s)\n    \n    # A string can rotate at most n times, but we are looking for\n    # the smallest rotation that returns the string to its original form\n    for i in range(1, n + 1):  # Starting from 1 to n\n        if s[i % n:] + s[:i % n] == s:\n            return i\n            \n    return n  # In case no rotation matches, return n (this shouldn't happen)", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    This function calculates the minimum number of rotations\n    required to get the same string. The function assumes the input\n    string s consists of only lowercase letters.\n    \n    Parameters:\n    s (str): The input string to analyze.\n    \n    Returns:\n    int: The minimum number of rotations (greater than 0) to get\n         the same string.\n    \"\"\"\n    length = len(s)\n    \n    # Edge case: if the string is empty or has only one character\n    if length <= 1:\n        return 1\n    \n    # Concatenate the string with itself to check for rotations\n    double_s = s + s\n    \n    # Check each rotation\n    for i in range(1, length + 1):  # Start from 1 to length\n        if double_s[i:i + length] == s:\n            return i\n    \n    return length  # If no match found, return the length of the string", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    \n    # Check if the string is empty or has a single character\n    if n <= 1:\n        return 1\n    \n    # Check for all possible rotations\n    for i in range(1, n):\n        # Create the rotated string\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    # If no rotation yields the original string, return n (full rotation)\n    return n", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": 43.369175627240146, "dps_norm": 90.0, "pass@1": 43.0, "profiled": [{"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of a specified character from the string.\n    \n    Parameters:\n    s (str): The input string.\n    char (str): The character to remove.\n    \n    Returns:\n    str: The modified string with the first and last occurrences of char removed.\n    \"\"\"\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character does not exist in the string, return the string as is\n    if first_index == -1:\n        return s\n    \n    # If the first and last indices are the same, it means there's only one occurrence\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    # Adjust the last index since we modified the string\n    last_index -= 1\n    # Remove the last occurrence\n    return s[:last_index] + s[last_index + 1:]", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found or only one occurrence is found\n    if first_index == -1 or first_index == last_index:\n        return s.replace(char, \"\", 1)  # Remove just the first occurrence if there's only one\n\n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    # Adjust the last index since the string length has changed\n    last_index -= 1  # Adjust because we removed one character\n    \n    # Remove the last occurrence\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of the given character from the string.\n\n    :param s: The input string\n    :param char: The character to be removed\n    :return: The modified string with first and last occurrence of char removed\n    \"\"\"\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found or found at the same index\n    if first_index == -1 or first_index == last_index:\n        return s.replace(char, '', 1) if first_index != -1 else s\n\n    # Remove the character at the first index\n    s = s[:first_index] + s[first_index+1:]\n    # Adjust last index because of the previous removal\n    last_index -= 1  # Shift left due to the removal\n    \n    # Remove the character at the last index\n    s = s[:last_index] + s[last_index+1:]\n\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(string: str, char: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Parameters:\n    string (str): The input string from which to remove characters.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    # Find the first occurrence of the character\n    first_occurrence = string.find(char)\n    \n    # If character is not found, return the original string\n    if first_occurrence == -1:\n        return string\n    \n    # Find the last occurrence of the character\n    last_occurrence = string.rfind(char)\n    \n    # If first and last occurrence are the same, remove it once\n    if first_occurrence == last_occurrence:\n        return string[:first_occurrence] + string[first_occurrence + 1:]\n    \n    # Remove the first occurrence\n    string = string[:first_occurrence] + string[first_occurrence + 1:]\n    \n    # Remove the last occurrence (after removing the first occurrence)\n    last_occurrence -= 1  # Adjust the index because the string length has changed\n    string = string[:last_occurrence] + string[last_occurrence + 1:]\n    \n    return string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n\n    # If the character does not occur or occurs only once\n    if first_index == -1 or first_index == last_index:\n        return s.replace(char, \"\", 1)\n\n    # Remove first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n\n    # Adjust last_index because the string has changed\n    last_index -= 1  # since we have removed one character, last_index needs to be decremented\n    return s[:last_index] + s[last_index + 1:]", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"Remove the first and last occurrence of the specified character from the string.\"\"\"\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n\n    # If the character is not found or both occurrences are the same, return the string without that character\n    if first_index == -1 or first_index == last_index:\n        return s.replace(char, '', 1)  # Remove first occurrence only if it exists\n\n    # Remove first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n\n    # Adjust last_index since the string has changed\n    if last_index > first_index:  # Ensure we are not removing the same index\n        last_index -= 1  # Update the last_index because we've shortened the string\n\n    # Remove last occurrence\n    s = s[:last_index] + s[last_index + 1:]\n\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Parameters:\n    s (str): The input string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of char removed.\n    \"\"\"\n    # Check if the character is in the string\n    if char in s:\n        # Remove the first occurrence\n        s = s.replace(char, '', 1)\n        # Remove the last occurrence\n        s = s[::-1].replace(char, '', 1)[::-1]\n    return s", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    :param s: The original string\n    :param char: The character to remove\n    :return: The modified string with first and last occurrence of char removed\n    \"\"\"\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n\n    # If the character is not found or only one occurrence exists\n    if first_index == -1 or first_index == last_index:\n        return s.replace(char, '', 1)\n\n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n\n    # Adjust the last index because the string has been modified\n    last_index -= 1  # Account for the removal of the first occurrence\n\n    # Remove the last occurrence\n    s = s[:last_index] + s[last_index + 1:]\n\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found or if it's the same for first and last occurrence\n    if first_index == -1 or first_index == last_index:\n        return s.replace(char, '', 1)  # remove only the first occurrence\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    # Remove the last occurrence\n    s = s[:last_index - 1] + s[last_index:]  # Adjust last_index because of previous removal\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of the given character from the string.\n\n    Parameters:\n    s (str): The input string from which to remove characters.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of char removed.\n    \"\"\"\n    first_occurrence = s.find(char)\n    last_occurrence = s.rfind(char)\n\n    if first_occurrence == -1:  # Character not found\n        return s\n\n    if first_occurrence == last_occurrence:  # Character occurs only once\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n\n    # Remove the first and last occurrence\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of the specified character from the string.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n\n    # If the character occurs at least once, process the removal\n    if first_index != -1:\n        # Remove the first occurrence\n        s = s[:first_index] + s[first_index + 1:]\n\n    if last_index != -1 and last_index != first_index:\n        # Remove the last occurrence (adjusting for the removed first character)\n        s = s[:last_index - 1] + s[last_index:]\n\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    :param s: The input string.\n    :param char: The character to remove.\n    :return: A new string with the first and last occurrence of the character removed.\n    \"\"\"\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    \n    # If the character is not found, return the string as is\n    if first_index == -1:\n        return s\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the first and last index are the same, remove that one occurrence\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Create a new string by omitting the character at the first and last index\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of the specified character from the string.\n    \n    Parameters:\n    s (str): The input string.\n    char (str): The character to be removed.\n\n    Returns:\n    str: The modified string with the first and last occurrence of char removed.\n    \"\"\"\n    first_index = s.find(char)   # Find the first occurrence of the character\n    last_index = s.rfind(char)    # Find the last occurrence of the character\n\n    if first_index == -1:         # If the character is not found\n        return s\n    if first_index == last_index:  # If there is only one occurrence\n        return s[:first_index] + s[first_index + 1:]\n\n    # Construct the new string without the first and last occurrence\n    new_string = s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n    return new_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Parameters:\n    s (str): The input string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of char removed.\n    \"\"\"\n    # Find the first and last occurrence of the character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    # If the character is found at least twice, remove the occurrences\n    if first_index != -1 and first_index != last_index:\n        return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n    elif first_index != -1:  # If only one occurrence is found\n        return s[:first_index] + s[first_index + 1:]\n    else:  # If the character is not found\n        return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    s (str): The input string from which to remove the character.\n    char (str): The character to remove from the string.\n    \n    Returns:\n    str: The modified string with the first and last occurrences of the character removed.\n    \"\"\"\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the first and last index are the same, it means there's only one occurrence\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove the first and last occurrences\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    :param s: The input string\n    :param char: The character to remove from the string\n    :return: The modified string with the first and last occurrence of char removed\n    \"\"\"\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    # If the character is not found or if both occurrences are the same, remove only one\n    if first_index == -1:\n        return s  # Character not found, return original string\n    elif first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]  # Only one occurrence, remove it\n\n    # Remove first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    # Remove last occurrence (recalculate index since the string has changed)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index + 1:]\n\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    :param s: The input string\n    :param char: The character to be removed\n    :return: A new string with the first and last occurrences of char removed\n    \"\"\"\n    first_occurrence = s.find(char)\n    last_occurrence = s.rfind(char)\n    \n    # If the character does not occur in the string or occurs only once\n    if first_occurrence == -1 or first_occurrence == last_occurrence:\n        return s.replace(char, '', 1)  # Remove the only occurrence if exists\n    \n    # Remove first occurrence\n    s = s[:first_occurrence] + s[first_occurrence + 1:]\n    \n    # Remove last occurrence (after first is removed, adjust index)\n    last_occurrence -= 1  # Adjust index since we removed the first occurrence\n    s = s[:last_occurrence] + s[last_occurrence + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    if first_index == -1:  # Character not found\n        return s\n    \n    if first_index == last_index:  # Character occurs only once\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # Adjust last_index since we modified the string\n    last_index -= 1\n    \n    # Remove last occurrence\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n\n    # If the character is not found or both occurrences are the same, return the modified string\n    if first_index == -1 or first_index == last_index:\n        return s.replace(char, '', 1)\n\n    # Remove first occurrence by slicing\n    modified_string = s[:first_index] + s[first_index + 1:]\n\n    # Remove last occurrence by slicing\n    modified_string = modified_string[:last_index - 1] + modified_string[last_index:]\n\n    return modified_string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found or if the first and last indices are the same\n    if first_index == -1 or first_index == last_index:\n        return s.replace(char, '', 1)  # Remove only the first occurrence or return original string if not found\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    # Adjust the last index since the string length has changed\n    last_index -= 1  # Adjust for the removal of the first occurrence\n    \n    # Remove the last occurrence\n    return s[:last_index] + s[last_index + 1:]", "matching_cluster_idx": 7}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: List of lists (matrix) to be sorted\n    :return: Sorted matrix\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order according to the sum of its rows.\n\n    Args:\n    matrix (list of list of int): The matrix to be sorted.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of list of int): The matrix to be sorted.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of list of int): The matrix to sort.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists where each inner list represents a row in the matrix\n    :return: A new matrix sorted by the sum of its rows\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of list of int): The matrix to be sorted.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    :param matrix: List of lists (2D list) representing the matrix\n    :return: Sorted list of lists based on the sum of each row\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n        matrix (list of list of int): The matrix to be sorted.\n        \n    Returns:\n        list of list of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of lists of int): A 2D list representing the matrix to be sorted.\n\n    Returns:\n    list of lists of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of list of int): The matrix to be sorted.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort the given matrix in ascending order according to the sum of its rows.\n\n    Args:\n    matrix (list of list of int): The matrix to be sorted.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of list of int): The matrix to be sorted.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    Parameters:\n        matrix (list of list of int): A 2D list representing the matrix.\n        \n    Returns:\n        list of list of int: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: List of lists (2D list) where each inner list represents a row of the matrix.\n    :return: The sorted matrix (list of lists).\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n    matrix (list of list of int): A 2D list (matrix) to be sorted.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order according to the sum of its rows.\n\n    Args:\n    matrix (list of list of int): A 2D list representing the matrix.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of list of int): The input matrix to be sorted.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 65.03048780487805, "dps_norm": 76.25, "pass@1": 92.0, "profiled": [{"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    This function checks if the input string contains sequences of\n    lowercase letters joined with underscores.\n    \n    :param s: Input string to check\n    :return: True if the string consists of lowercase letter sequences \n             separated by underscores, False otherwise\n    \"\"\"\n    # Split the string by underscores and check if each part contains only lowercase letters\n    return all(part.islower() and part.isalpha() for part in s.split('_'))", "matching_cluster_idx": 4}, {"solution": "def text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n\n    Args:\n    s (str): The input string to check.\n\n    Returns:\n    bool: True if the string contains valid sequences, False otherwise.\n    \"\"\"\n    # Check if the string matches the pattern of lowercase letters with underscores\n    # The pattern allows one or more sequences of lowercase letters separated by underscores\n    if all(part.islower() for part in s.split('_')) and all(part for part in s.split('_')):\n        return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    This function returns True if the input string contains\n    sequences of lowercase letters joined with an underscore,\n    and False otherwise.\n    \"\"\"\n    # Split the string by underscores\n    segments = s.split('_')\n    \n    # Check if all segments are composed of lowercase letters\n    return all(segment.islower() and segment.isalpha() for segment in segments)", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters joined with underscores.\n    \n    :param s: Input string\n    :return: True if valid format, False otherwise\n    \"\"\"\n    # Split the string by underscores and check each part\n    parts = s.split('_')\n    return all(part.isalpha() and part.islower() for part in parts)", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters\n    joined with an underscore.\n    \n    Args:\n    s (str): The input string to check.\n    \n    Returns:\n    bool: True if the string meets the criteria, False otherwise.\n    \"\"\"\n    # Split the string by underscore and check each part\n    parts = s.split('_')\n    for part in parts:\n        if not part.islower() or not part.isalpha():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    # Check if the string matches the pattern: lowercase letters separated by underscores\n    import re\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 6}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    This function checks if the input string consists of sequences of \n    lowercase letters joined by an underscore.\n    \n    Args:\n    s (str): The input string to check.\n\n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Check if the string matches the pattern of lowercase letters joined by underscores\n    return all(part.isalpha() and part.islower() for part in s.split('_'))", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n    s (str): The input string to check.\n\n    Returns:\n    bool: True if the string contains only lowercase letters and underscores, False otherwise.\n    \"\"\"\n    # Split the string by underscores and check each part\n    parts = s.split('_')\n    return all(part.isalpha() and part.islower() for part in parts)", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    s (str): The input string to check.\n    \n    Returns:\n    bool: True if the string matches the criteria, False otherwise.\n    \"\"\"\n    # Split the string by underscores and check each segment\n    segments = s.split('_')\n    return all(segment.isalpha() and segment.islower() for segment in segments)", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    # Check if the string matches the pattern of lowercase letters separated by underscores\n    return all(part.isalpha() and part.islower() for part in s.split('_'))", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    s (str): The input string to check.\n    \n    Returns:\n    bool: True if the string matches the criteria, False otherwise.\n    \"\"\"\n    # Check if the string matches the pattern: lowercase letters separated by underscores\n    import re\n    pattern = r'^[a-z]+(_[a-z]+)*$'  # Pattern to match sequences of lowercase letters joined by underscores\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 6}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    s (str): The input string to check.\n    \n    Returns:\n    bool: True if the string follows the pattern, False otherwise.\n    \"\"\"\n    # Check if the string matches the pattern of lowercase letters joined by underscores\n    return all(part.islower() for part in s.split('_'))", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    This function checks if the input string contains sequences of lowercase letters\n    joined with an underscore.\n    \n    Args:\n    s (str): The input string to check.\n    \n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Split the string by underscore and check if all parts are lowercase letters\n    parts = s.split('_')\n    return all(part.islower() and part.isalpha() for part in parts)", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n    s (str): The input string to check.\n\n    Returns:\n    bool: True if the string follows the pattern, False otherwise.\n    \"\"\"\n    # Split the string by underscores\n    parts = s.split('_')\n    \n    # Check if all parts are lowercase letters\n    return all(part.isalpha() and part.islower() for part in parts)", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters\n    joined with an underscore.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    bool: True if the string contains valid sequences, False otherwise.\n    \"\"\"\n    # Split the string by underscores and check each segment\n    segments = s.split('_')\n    for segment in segments:\n        # Check if each segment is made up of lowercase letters\n        if not segment.isalpha() or not segment.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore and False otherwise.\n    \n    Args:\n    s (str): The input string to check.\n\n    Returns:\n    bool: True if the string meets the criteria, False otherwise.\n    \"\"\"\n    # Split the string by underscores\n    parts = s.split('_')\n    # Check if all parts are non-empty and consist of lowercase letters\n    return all(part.isalpha() and part.islower() for part in parts)", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters \n    joined with an underscore.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Use regular expression to match the pattern\n    import re\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 6}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with underscores, and False otherwise.\n    \"\"\"\n    # Split the string by underscores and check each segment\n    segments = s.split('_')\n    return all(segment.isalpha() and segment.islower() for segment in segments)", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters\n    joined with an underscore.\n\n    Args:\n    s (str): The input string to check.\n\n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Split the string by underscores\n    parts = s.split('_')\n    \n    # Check if all parts are composed of lowercase letters\n    return all(part.islower() and part.isalpha() for part in parts)", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    # Split the string by underscores\n    parts = s.split('_')\n    # Check if all parts are non-empty and contain only lowercase letters\n    return all(part.islower() and part.isalpha() for part in parts)", "matching_cluster_idx": 5}]}, "Mbpp/19": {"dps": 91.16161616161617, "dps_norm": 95.0, "pass@1": 100.0, "profiled": [{"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if there are any duplicate elements in the given array.\n    \n    :param arr: List of integers\n    :return: True if duplicates are found, False otherwise\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if the array contains any duplicate elements.\n\n    Parameters:\n    arr (list): List of integers to check for duplicates.\n\n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to determine if there are any duplicate elements in an array.\n    \n    Parameters:\n    arr (list): List of integers to check for duplicates.\n    \n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if there are any duplicate elements in the given array.\n    \n    :param arr: List of integers\n    :return: True if duplicates are found, otherwise False\n    \"\"\"\n    seen = set()\n    for number in arr:\n        if number in seen:\n            return True  # Duplicate found\n        seen.add(number)\n    return False  # No duplicates", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to determine if the array contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if there are any duplicate elements in the given array.\n    \n    :param arr: List of integers\n    :return: True if duplicates are found, False otherwise\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True  # Duplicate found\n        seen.add(num)\n    return False  # No duplicates found", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n\n    :param arr: List of integers\n    :return: True if duplicates exist, False otherwise\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True  # Duplicate found\n        seen.add(num)\n    return False  # No duplicates found", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"Check if the array contains any duplicate elements.\"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True  # Found a duplicate\n        seen.add(num)\n    return False  # No duplicates found", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to determine if there are any duplicate elements in the given array.\n    \n    Parameters:\n    arr (list): A list of integers to check for duplicates.\n    \n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if there are any duplicate elements in the given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates exist, False otherwise.\n    \"\"\"\n    # Use a set to track seen elements\n    seen = set()\n    \n    for number in arr:\n        if number in seen:\n            return True  # Duplicate found\n        seen.add(number)\n    \n    return False  # No duplicates found", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to determine if there are any duplicate elements in the given array.\n    \n    Args:\n    arr (list of int): The array to check for duplicates.\n    \n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for number in arr:\n        if number in seen:\n            return True\n        seen.add(number)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if there are any duplicate elements in the given array.\n    \n    :param arr: List of integers\n    :return: True if there are duplicates, False otherwise\n    \"\"\"\n    # Create a set to track seen elements\n    seen = set()\n    \n    # Iterate through each element in the array\n    for number in arr:\n        # If the number is already in the set, we found a duplicate\n        if number in seen:\n            return True\n        # Add the number to the set\n        seen.add(number)\n    \n    # No duplicates found\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to determine if there are any duplicate elements in the given array.\n    \n    Parameters:\n    arr (list): A list of integers to check for duplicates.\n\n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to determine if there are any duplicate elements in the array.\n    \n    :param arr: List of integers\n    :return: True if duplicates are found, otherwise False\n    \"\"\"\n    seen = set()  # Create a set to keep track of seen elements\n    for number in arr:\n        if number in seen:\n            return True  # Duplicate found\n        seen.add(number)  # Add number to the set if not seen\n    return False  # No duplicates found", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the array contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True  # Duplicate found\n        seen.add(num)\n    return False  # No duplicates found", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n\n    :param arr: List of integers\n    :return: True if there are duplicates, False otherwise\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if there are any duplicate elements in the given array.\n    \n    Args:\n    arr (list): List of integers.\n    \n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the input array contains any duplicate elements.\n\n    :param arr: List of integers\n    :return: True if duplicates are found, False otherwise\n    \"\"\"\n    # Use a set to track seen elements\n    seen = set()\n    \n    for num in arr:\n        if num in seen:\n            return True  # Duplicate found\n        seen.add(num)\n    \n    return False  # No duplicates", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if the array contains any duplicate elements.\n    \n    Parameters:\n    arr (list): List of integers to check for duplicates.\n    \n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Use a set to track seen elements\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True  # Duplicate found\n        seen.add(num)\n    return False  # No duplicates", "matching_cluster_idx": 14}]}, "Mbpp/62": {"dps": 70.0, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(numbers):\n    \"\"\"Return the smallest number in the given list.\"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    This function returns the smallest number in a list.\n    \n    :param numbers: List of numbers\n    :return: The smallest number in the list\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = numbers[0]\n    for number in numbers:\n        if number < smallest:\n            smallest = number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Return the smallest number in a list.\"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Return the smallest number in a list.\"\"\"\n    if not numbers:  # Check if the list is empty\n        raise ValueError(\"The list should not be empty\")\n    \n    smallest = numbers[0]  # Start with the first element as the smallest\n    for number in numbers:\n        if number < smallest:\n            smallest = number  # Update smallest if a smaller number is found\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    \"\"\"Returns the smallest number in a list.\"\"\"\n    if not nums:  # Check if the list is empty\n        raise ValueError(\"The list cannot be empty\")\n    smallest = nums[0]  # Start by assuming the first number is the smallest\n    for num in nums:\n        if num < smallest:\n            smallest = num  # Update smallest if a smaller number is found\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Function to find the smallest number in a list.\n    \n    Parameters:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list should not be empty.\")\n    \n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Function to find the smallest number in a list.\n    \n    Parameters:\n    lst (list): A list of numbers.\n    \n    Returns:\n    int/float: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list cannot be empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Returns the smallest number in a list.\"\"\"\n    if not numbers:  # Check if the list is empty\n        raise ValueError(\"The list cannot be empty.\")\n    smallest = numbers[0]  # Start with the first element\n    for number in numbers:\n        if number < smallest:\n            smallest = number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Return the smallest number in a list.\"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    smallest = numbers[0]  # Start by assuming the first number is the smallest\n    for num in numbers:\n        if num < smallest:\n            smallest = num  # Update smallest if a smaller number is found\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"Return the smallest number in a list.\"\"\"\n    if not lst:  # Check if the list is empty\n        raise ValueError(\"The list cannot be empty.\")\n    smallest = lst[0]  # Start with the first element as the smallest\n    for num in lst:\n        if num < smallest:  # If the current number is smaller, update smallest\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Return the smallest number in a list.\"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    smallest = numbers[0]\n    for number in numbers:\n        if number < smallest:\n            smallest = number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Function to find the smallest number in a list.\n\n    :param numbers: List of integers\n    :return: Smallest integer in the list\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty\")\n    \n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Return the smallest number from a list of numbers.\"\"\"\n    if not numbers:  # Check if the list is empty\n        raise ValueError(\"The list cannot be empty.\")\n    smallest = numbers[0]  # Assume the first number is the smallest\n    for num in numbers:  # Iterate through the list\n        if num < smallest:  # Compare each number with the current smallest\n            smallest = num  # Update smallest if a smaller number is found\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Return the smallest number in a list.\"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty.\")\n    min_num = numbers[0]\n    for num in numbers:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Return the smallest number in a list.\"\"\"\n    if not numbers:  # Check if the list is empty\n        raise ValueError(\"The list is empty\")\n    \n    smallest = numbers[0]  # Start by assuming the first number is the smallest\n    for num in numbers:  # Iterate through each number in the list\n        if num < smallest:  # If we find a smaller number\n            smallest = num  # Update the smallest number\n    return smallest  # Return the smallest number found", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Return the smallest number in a list.\"\"\"\n    if not numbers:  # Check if the list is empty\n        raise ValueError(\"The list is empty.\")\n    smallest = numbers[0]  # Start by assuming the first number is the smallest\n    for num in numbers:  # Iterate through the list\n        if num < smallest:  # If we find a smaller number, update smallest\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Return the smallest number in a given list of numbers.\"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty\")\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Returns the smallest number in a list.\"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Return the smallest number in a list.\"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Return the smallest number in a list.\"\"\"\n    if not numbers:  # Check if the list is empty\n        raise ValueError(\"The list cannot be empty.\")\n    smallest = numbers[0]  # Assume the first number is the smallest\n    for num in numbers:  # Iterate through the list\n        if num < smallest:  # If a smaller number is found\n            smallest = num  # Update the smallest number\n    return smallest", "matching_cluster_idx": 3}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function finds all tuples in the given list where all elements are divisible by k.\n    \n    :param tuples_list: List of tuples to check.\n    :param k: The divisor for checking divisibility.\n    :return: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    # Using list comprehension to filter tuples\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find all tuples in tuples_list where all elements are divisible by k.\n\n    Parameters:\n    tuples_list (list of tuples): A list of tuples to check.\n    k (int): The divisor to check against.\n\n    Returns:\n    list of tuples: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(el % k == 0 for el in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k,\n    and returns a list of tuples where all elements in the \n    tuple are divisible by k.\n    \n    :param tuples_list: List of tuples to be checked\n    :param k: Integer value to check divisibility against\n    :return: List of tuples with all elements divisible by k\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function finds all tuples from the given list that have all elements divisible by k.\n    \n    :param tuples_list: List of tuples to check.\n    :param k: The divisor.\n    :return: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k.\n    It returns a list of tuples where all elements in the tuple are divisible by k.\n    \n    :param tuples_list: List of tuples to check\n    :param k: Integer to check divisibility\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    tuples_list (list of tuples): A list of tuples to check.\n    k (int): The divisor to check for divisibility.\n\n    Returns:\n    list of tuples: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(x % k == 0 for x in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples in the given list where all elements are divisible by k.\n    \n    :param tuples_list: List of tuples to check\n    :param k: Integer to check divisibility\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function returns a list of tuples from tuples_list \n    where all elements in the tuple are divisible by k.\n    \n    :param tuples_list: List of tuples to check\n    :param k: Integer to check divisibility against\n    :return: List of tuples with all elements divisible by k\n    \"\"\"\n    return [tup for tup in tuples_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k.\n\n    Parameters:\n    tuples_list (list of tuples): The list of tuples to check.\n    k (int): The divisor to check against.\n\n    Returns:\n    list of tuples: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    tuples_list (list of tuples): List of tuples to check.\n    k (int): The divisor to check for.\n\n    Returns:\n    list: List of tuples where all elements are divisible by k.\n    \"\"\"\n    return [tup for tup in tuples_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function returns a list of tuples from the given list where all elements\n    in each tuple are divisible by k.\n    \n    Parameters:\n    tuples_list (list of tuples): The list of tuples to be checked.\n    k (int): The divisor to check divisibility against.\n    \n    Returns:\n    list of tuples: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples containing integers\n    :param k: An integer to check divisibility\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    :param tuples_list: List of tuples to check\n    :param k: The divisor\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuples_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"Return a list of tuples where all elements are divisible by k.\"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function finds all tuples in tuples_list where all elements are divisible by k.\n    \n    :param tuples_list: List of tuples to check\n    :param k: The divisor\n    :return: A list of tuples where all elements are divisible by k\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(x % k == 0 for x in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples in the given list where all elements are divisible by k.\n\n    :param tuples_list: List of tuples to check.\n    :param k: The divisor to check divisibility against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Function to find tuples which have all elements divisible by k.\n    \n    Parameters:\n    tuples_list (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n    \n    Returns:\n    list of tuples: A list containing tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k.\n    \n    Parameters:\n    tuples_list (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n    \n    Returns:\n    list of tuples: A list containing tuples with all elements divisible by k.\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples\n    :param k: Integer to check divisibility\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(x % k == 0 for x in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Parameters:\n    tuples_list (list of tuple): A list containing tuples of integers.\n    k (int): The divisor to check for divisibility.\n\n    Returns:\n    list of tuple: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.56862745098039, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    \"\"\"Returns a dictionary with the frequency of each element in the list.\"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Function to get the frequency of all elements in a list.\n    \n    Args:\n    lst (list): A list of elements to count frequencies.\n    \n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the provided list.\n\n    Args:\n    lst (list): A list of elements.\n\n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Calculate the frequency of all the elements in a list.\n\n    Args:\n    lst (list): A list of elements.\n\n    Returns:\n    dict: A dictionary where keys are elements and values are their respective frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the given list.\n    \n    Parameters:\n    lst (list): The list of elements for which to count the frequency.\n    \n    Returns:\n    dict: A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns the frequency of all elements in the provided list as a dictionary.\n\n    Args:\n    lst (list): A list of elements.\n\n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns the frequency of all elements in the list as a dictionary.\n    \n    Parameters:\n    lst (list): The list of elements to count frequencies.\n    \n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns the frequency of all the elements in the given list as a dictionary.\n    \n    Parameters:\n    lst (list): A list of elements.\n    \n    Returns:\n    dict: A dictionary with elements as keys and their counts as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Function to count the frequency of all elements in a list.\n\n    Args:\n    lst (list): The input list containing elements.\n\n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Count the frequency of each element in the given list.\n    \n    :param lst: List of elements to count\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Function to count the frequency of elements in a list and return as a dictionary.\n    \n    Parameters:\n    lst (list): A list of elements to count frequencies of.\n    \n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the given list.\n\n    Parameters:\n    lst (list): A list of elements.\n\n    Returns:\n    dict: A dictionary where keys are elements of the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Function to count the frequency of elements in a list.\n    \n    Parameters:\n    lst (list): A list of elements.\n    \n    Returns:\n    dict: A dictionary with elements as keys and their frequency as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"Return the frequency of all the elements in a list as a dictionary.\"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"Returns the frequency of elements in the list as a dictionary.\"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(elements):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n\n    Args:\n        elements (list): A list of elements.\n\n    Returns:\n        dict: A dictionary where keys are elements and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Parameters:\n    lst (list): A list of elements.\n    \n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Count the frequency of all elements in a list and return it as a dictionary.\n\n    Parameters:\n    lst (list): The list of elements to count.\n\n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns the frequency of all elements in a list as a dictionary.\n    \n    Parameters:\n    lst (list): The list of elements to count.\n    \n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 76.92682926829269, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list.\n\n    Args:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:  # Check for empty list\n        return 0\n\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"Returns the length of the longest word in the list.\"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    This function returns the length of the longest word in the provided list.\n\n    :param words: List of strings\n    :return: Length of the longest word\n    \"\"\"\n    if not words:  # Handle empty list case\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"Returns the length of the longest word in the given list of words.\"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    This function takes a list of words and returns the length of the longest word.\n    \n    :param words: List of strings\n    :return: Length of the longest word\n    \"\"\"\n    if not words:  # Check if the list is empty\n        return 0\n    \n    longest_length = max(len(word) for word in words)  # Find the maximum length\n    return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    This function takes a list of words and returns the length of the longest word.\n    \n    :param words: List of strings\n    :return: Integer length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Args:\n    words (list of str): A list of words to be evaluated.\n    \n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    # Use the max function to find the longest word and return its length\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"Return the length of the longest word in the list.\"\"\"\n    if not words:  # Check if the list is empty\n        return 0\n    return max(len(word) for word in words)  # Find the maximum length of the words", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Parameters:\n    words (list): A list of strings (words).\n    \n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    \n    longest_word_length = max(len(word) for word in words)\n    return longest_word_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list of words.\n\n    Args:\n    words (list): A list of strings.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:  # Handle empty list case\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list of words.\n    \n    Parameters:\n    words (list): A list of words (strings).\n    \n    Returns:\n    int: Length of the longest word.\n    \"\"\"\n    if not words:  # If the list is empty, return 0\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"Return the length of the longest word in the list.\"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"Returns the length of the longest word in the list.\"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list of words.\n    \n    Args:\n    words (list): A list of strings (words).\n    \n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0  # Return 0 if the list is empty\n    \n    longest_length = 0\n    for word in words:\n        longest_length = max(longest_length, len(word))\n    \n    return longest_length", "matching_cluster_idx": 3}, {"solution": "def len_log(words):\n    \"\"\"\n    This function takes a list of words and returns the length of the longest word.\n    \n    Parameters:\n    words (list of str): A list containing words as strings.\n\n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0  # Return 0 if the list is empty\n\n    longest_length = max(len(word) for word in words)\n    return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n\n    Args:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:  # handle empty list case\n        return 0\n    \n    # Find the longest word by applying the built-in max function with key set to len\n    longest_word = max(words, key=len)\n    return len(longest_word)", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the given list of words.\n    \n    :param words: List of strings\n    :return: Length of the longest word\n    \"\"\"\n    if not words:  # Check if the list is empty\n        return 0\n    return max(len(word) for word in words)  # Find the maximum length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Args:\n    words (list of str): A list containing words as strings.\n    \n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"Return the length of the longest word in the given list of words.\"\"\"\n    if not words:  # Check if the list is empty\n        return 0\n    return max(len(word) for word in words)  # Return the length of the longest word", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Parameters:\n    words (list): A list of words (strings).\n    \n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:  # Check if the list is empty\n        return 0\n    \n    longest_word_length = max(len(word) for word in words)\n    return longest_word_length", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 79.28353658536585, "dps_norm": 63.0, "pass@1": 72.0, "profiled": [{"solution": "def index_minimum(tuples_list):\n    # Check if the list is empty\n    if not tuples_list:\n        return None\n\n    # Initialize the first tuple as the minimum\n    min_tuple = tuples_list[0]\n\n    # Iterate over the list of tuples\n    for tup in tuples_list:\n        # Compare the second value of the current tuple with the minimum found so far\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples_list):\n    # If the list is empty, return None\n    if not tuples_list:\n        return None\n    # Find the tuple with the minimum second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the minimum second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    Args:\n    tuples_list (list of tuples): A list where each tuple contains two elements.\n\n    Returns:\n    The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples_list:\n        return None  # Return None if the list is empty\n\n    # Initialize the tuple with the smallest second value\n    min_tuple = tuples_list[0]\n\n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n\n    return min_tuple[0]  # Return the first value of the tuple with the smallest second value", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value in the list of tuples.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements.\n    :return: The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples is empty\")\n        \n    # Use the min function with a key to find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Args:\n    tuples_list (list of tuples): A list where each tuple contains two elements, \n                                   the first being a name (string) and the second an integer.\n\n    Returns:\n    string: The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples_list:\n        return None  # Handle the case of an empty list\n\n    # Find the tuple with the minimum second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]  # Return the first element of the tuple", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    tuples_list (list): A list of tuples where each tuple contains two elements.\n    \n    Returns:\n    str: The first element of the tuple with the smallest second element.\n    \"\"\"\n    # Check if the list is empty\n    if not tuples_list:\n        return None\n    \n    # Use the min function with a custom key to find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first value of the tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, this function returns the first value of the tuple\n    with the smallest second value.\n\n    :param tuples_list: List of tuples where each tuple contains two elements\n    :return: The first value of the tuple with the smallest second value\n    \"\"\"\n    # Using min with a custom key to find the tuple with the smallest second value\n    smallest_tuple = min(tuples_list, key=lambda x: x[1])\n    return smallest_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    tuples_list (list of tuple): A list of tuples where each tuple contains \n                                  two elements (a string and a number).\n    \n    Returns:\n    str: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:\n        return None  # Handle case with an empty list\n    \n    # Use the min function with a key that extracts the second element of each tuple\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second element\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    # Using min with a key to compare the second elements of the tuples\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Check if the list is empty\n    if not tuples_list:\n        return None  # or raise an exception depending on your needs\n\n    # Initialize the first tuple as the minimum\n    min_tuple = tuples_list[0]\n\n    # Iterate over the list of tuples\n    for current_tuple in tuples_list:\n        # Compare the second value\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains a name and a number.\n    :return: The first value (name) of the tuple with the smallest second value (number).\n    \"\"\"\n    # Using the min function with a custom key to find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Use the min function to find the tuple with the smallest second value\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Check if the list is empty\n    if not tuples_list:\n        return None\n    \n    # Use min() with a key to find the tuple with the smallest second value\n    smallest_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first value of the found tuple\n    return smallest_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Check if the list is empty\n    if not tuples_list:\n        return None\n    \n    # Use min with a custom key to find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples where each tuple contains two elements\n    :return: First element of the tuple with the minimum second element\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    # Use min function with a key to find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Return the first value of the tuple with the smallest second value\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Check if the list is empty\n    if not tuples_list:\n        return None\n    \n    # Use the min function with a custom key to find the tuple with the smallest second value\n    smallest_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first value of the found tuple\n    return smallest_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Use min to find the tuple with the smallest second value\n    # The key parameter is used to compare the second elements of the tuples\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"Returns the first value of the tuple with the smallest second value.\"\"\"\n    if not tuples_list:\n        return None  # Return None if the input list is empty\n    # Use the min function with a custom key to find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]  # Return the first value of the tuple", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Check if the input list is empty\n    if not tuples_list:\n        return None\n    \n    # Use min to find the tuple with the smallest second value\n    # min() will return the first tuple with the smallest second value in case of ties\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first value of the tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 68.19444444444443, "dps_norm": 70.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def divisor(n):\n    \"\"\"Return the number of divisors of the given integer n.\"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:  # Count the complementary divisor if it's different\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"Returns the number of divisors of the given integer n.\"\"\"\n    if n <= 0:\n        return 0  # Return 0 for non-positive integers\n    \n    count = 0\n    # Check for all numbers from 1 to sqrt(n)\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # If i is a divisor\n            count += 1  # Count i\n            if i != n // i:  # Count n // i if it's different\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"Returns the number of divisors of the given integer n.\"\"\"\n    if n <= 0:\n        return 0  # No divisors for non-positive integers\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"Return the number of divisors of the given integer n.\"\"\"\n    if n < 1:\n        return 0  # Return 0 for non-positive integers\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # i is a divisor\n            count += 1  # Count i\n            if i != n // i:  # Count the complementary divisor\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"Return the number of divisors of the integer n.\"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # i is a divisor\n            if i != n // i:\n                count += 1  # n // i is also a divisor if it's different from i\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"Return the number of divisors of the given integer n.\"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Args:\n    n (int): The integer to find the divisors of.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # i is a divisor\n            if i != n // i:\n                count += 1  # n // i is a divisor\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # Count the divisor\n            if i != n // i:  # Count the complementary divisor if it's different\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # If i is a divisor\n            count += 1  # Count i\n            if i != n // i:  # Count the complementary divisor\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"Returns the number of divisors of the given integer n.\"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # i is a divisor\n            count += 1\n            if i != n // i:  # Count the complementary divisor only if it's different\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \n    :param n: The integer to find divisors for.\n    :return: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        return 0  # No divisors for numbers less than 1\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # i is a divisor\n            if i != n // i:\n                count += 1  # n // i is also a divisor\n\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    This function returns the number of divisors of a given integer n.\n\n    Parameters:\n    n (int): The integer to find divisors for.\n\n    Returns:\n    int: The count of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    # Loop through numbers from 1 to n to find divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"Return the number of divisors of the given integer n.\"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # i is a divisor\n            if i != n // i:\n                count += 1  # n // i is also a divisor if it's not the same as i\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"Return the number of divisors of the given integer n.\"\"\"\n    if n < 1:\n        return 0  # No divisors for non-positive integers\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"Return the number of divisors of the given integer n.\"\"\"\n    if n <= 0:\n        return 0  # Return 0 for non-positive integers, as they don't have positive divisors\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # Count the divisor\n            if i != n // i:\n                count += 1  # Count the complementary divisor\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"Return the number of divisors of the given integer n.\"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"Return the number of divisors of the given integer n.\"\"\"\n    if n < 1:\n        return 0  # No divisors for non-positive integers\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # Count the divisor i\n            if i != n // i:\n                count += 1  # Count the complementary divisor n // i\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"Return the number of divisors of the given integer n.\"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    This function returns the number of divisors of the given integer n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # i is a divisor\n            if i != n // i:\n                count += 1  # n // i is also a divisor\n    return count", "matching_cluster_idx": 6}]}, "Mbpp/97": {"dps": 99.65811965811966, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    \n    # Flatten the list of lists and count frequencies\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n                \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Count the frequency of each element in a flattened list of lists.\n\n    Args:\n    lists (list of list): A list containing sublists of elements.\n\n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency_dict = {}\n    \n    for sublist in lists:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n                \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    frequency_dict = {}\n    \n    # Flatten the nested list and count frequencies\n    for sublist in nested_list:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    # Initialize an empty dictionary to hold the frequency of elements\n    frequency = {}\n    \n    # Iterate through each sublist in the nested list\n    for sublist in nested_list:\n        # Iterate through each element in the sublist\n        for item in sublist:\n            # Update the frequency count in the dictionary\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    \n    for inner_list in list_of_lists:\n        for item in inner_list:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n                \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    frequency_dict = {}\n    \n    # Flatten the nested list and count frequencies\n    for sublist in nested_list:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    frequency = {}\n    for sublist in nested_list:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    frequency = {}\n    for sublist in nested_list:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    frequency_dict = {}\n    for sublist in nested_list:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"Return a dictionary with the frequency of each element in a flattened list of lists.\"\"\"\n    frequency = {}\n    \n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n                \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst_of_lists):\n    frequency = {}\n    \n    for sublist in lst_of_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n                \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    # Create an empty dictionary to store frequencies\n    frequency_dict = {}\n    \n    # Flatten the list of lists\n    for sublist in nested_list:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n                \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_lists):\n    frequency = {}\n    for sublist in nested_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    frequency = {}\n    \n    for sublist in nested_list:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n                \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    \n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n                \n    return frequency", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Args:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing elements of the original tuple followed by elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the elements of the given list to the given tuple.\n\n    Parameters:\n    lst (list): A list of elements to append.\n    tup (tuple): A tuple to which the list elements will be appended.\n\n    Returns:\n    tuple: A new tuple with elements of the list added to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n    \n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple with elements of the list appended.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n    \n    Parameters:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the elements of the list appended to the tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list of elements to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple consisting of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the elements of the list appended to the tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n    \n    Args:\n    lst (list): The list of elements to append.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): A list of elements to be appended.\n    tup (tuple): A tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the elements of the list appended to the tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing elements of the original tuple followed by elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Parameters:\n    lst (list): A list of elements to append.\n    tup (tuple): A tuple to which the list elements will be appended.\n\n    Returns:\n    tuple: A new tuple containing the original tuple elements followed by the list elements.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list of elements to append.\n    tpl (tuple): The tuple to which the elements will be appended.\n\n    Returns:\n    tuple: A new tuple with the elements of the list appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n    \n    Args:\n    lst (list): The list of elements to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with elements of the list added to the tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with elements of the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to be appended.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the elements of the list appended to the original tuple.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple that contains all elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 97.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    combined_list.sort()\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    combined_list.sort()\n    \n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    combined_list.sort()\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    combined_list.sort()\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 91.53846153846155, "dps_norm": 86.25, "pass@1": 100.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Intersect with each subsequent list\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Start with the first list as the initial common set\n    common_elements = set(nested_lists[0])\n    \n    # Intersect with the rest of the lists\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use set intersection to find common elements\n    common_elements = set(nested_lists[0])  # Start with the first list as a set\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)  # Update the set with the intersection\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Use set intersection to find common elements\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use a set to find the common elements in all lists\n    if not nested_lists:\n        return []\n\n    # Start with the first list's elements as a set\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and update the common_elements set\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use set intersection to find common elements\n    if not nested_lists:\n        return []\n\n    # Start with the set of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Intersect with the sets of the remaining lists\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n\n    # Start with the set of the first list\n    common_elements = set(nested_lists[0])\n\n    # Intersect with the sets of the subsequent lists\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Check if the nested lists are not empty\n    if not nested_lists:\n        return []\n\n    # Initialize the common elements with the first list\n    common_elements = set(nested_lists[0])\n\n    # Iterate over the remaining lists and find common elements\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n\n    # Start with the first list's set\n    common_elements = set(nested_lists[0])\n\n    # Intersect with each subsequent list's set\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n\n    # Start with the set of the first list\n    common_elements = set(nested_lists[0])\n\n    # Intersect with sets of the remaining lists\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n    \n    Parameters:\n    nested_lists (list of list): A list containing multiple lists to search for common elements.\n    \n    Returns:\n    list: A list of common elements found in all provided nested lists.\n    \"\"\"\n    # Use set to find intersection among lists\n    common_elements = set(nested_lists[0])  # Start with the first list\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)  # Update the set with the intersection\n    return list(common_elements)  # Return as a list", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n    \n    Args:\n        nested_lists (list of lists): A list containing sublists of integers.\n    \n    Returns:\n        list: A list of common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Initialize the set with the elements of the first sublist\n    common_elements = set(nested_lists[0])\n\n    # Intersect with the sets of the remaining sublists\n    for sublist in nested_lists[1:]:\n        common_elements.intersection_update(set(sublist))\n\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Start with the first set of elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through each list and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use set intersection to find common elements\n    if not nested_lists:\n        return []\n    \n    # Initialize the common elements set with the first list\n    common_elements = set(nested_lists[0])\n    \n    # Intersect with the sets of each subsequent list\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Start with the first list's set\n    common_elements = set(nested_lists[0])\n    \n    # Intersect with the sets of the remaining lists\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Start with the set of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Intersect with the sets of the remaining lists\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(set(lst))\n    \n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Initialize a set with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Intersect with the sets of the remaining lists\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Initialize the common set with elements from the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n\n    # Start with the set of the first list\n    common_elements = set(nested_lists[0])\n\n    # Intersect with the sets of the remaining lists\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use the set intersection method to find common elements\n    if not nested_lists:\n        return []\n    \n    # Start with the set of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Intersect with the sets of the remaining lists\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 91.0, "profiled": [{"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors_sum = 1  # 1 is a proper divisor of any n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:  # Avoid adding the square root twice if n is a perfect square\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_numbers = set()\n\n    for num in range(1, limit + 1):\n        partner = sum_of_divisors(num)\n        \n        # Check if partner is different and if the sum of divisors of the partner leads back to the original number\n        if partner != num and sum_of_divisors(partner) == num:\n            amicable_numbers.add(num)\n            amicable_numbers.add(partner)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    if n < 1:\n        return 0\n    total = 1  # 1 is a proper divisor of any n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # Add the complementary divisor if it's not the same\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to a specified limit.\"\"\"\n    amicable_numbers = set()\n\n    for num in range(2, limit + 1):\n        if num not in amicable_numbers:\n            partner = sum_of_divisors(num)\n            if partner != num and partner <= limit:\n                if sum_of_divisors(partner) == num:\n                    amicable_numbers.add(num)\n                    amicable_numbers.add(partner)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n.\"\"\"\n    divisors_sum = 1  # Start with 1, as it's a proper divisor for all n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:  # Avoid adding the square root twice\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_numbers = set()\n    \n    for number in range(2, limit + 1):\n        if number not in amicable_numbers:\n            partner = sum_of_divisors(number)\n            if partner != number and sum_of_divisors(partner) == number:\n                amicable_numbers.add(number)\n                amicable_numbers.add(partner)\n    \n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n.\"\"\"\n    divisors_sum = 1  # start with 1 as it is a proper divisor for all n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_numbers = set()\n    \n    for num in range(2, limit + 1):\n        if num in amicable_numbers:\n            continue\n        \n        partner = sum_of_divisors(num)\n        \n        if partner != num and partner <= limit:\n            if sum_of_divisors(partner) == num:\n                amicable_numbers.add(num)\n                amicable_numbers.add(partner)\n    \n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Helper function to calculate the sum of proper divisors of n.\"\"\"\n    total = 1  # Start with 1, as it's a proper divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # Add the complement divisor if it's not the square root\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Function to calculate the sum of all amicable numbers up to a specified limit.\"\"\"\n    amicable_numbers = set()\n    \n    for i in range(2, limit):\n        # Find the sum of proper divisors of i\n        sum1 = sum_of_divisors(i)\n        if sum1 != i:  # To ensure it's not a perfect number\n            sum2 = sum_of_divisors(sum1)\n            if sum2 == i:  # Check if they are amicable\n                amicable_numbers.add(i)\n                amicable_numbers.add(sum1)\n                \n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    total = 1  # Start with 1 since it's a proper divisor of any n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # Add the complementary divisor\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_numbers = set()\n    \n    for num in range(2, limit + 1):\n        if num not in amicable_numbers:\n            sum1 = sum_of_divisors(num)\n            sum2 = sum_of_divisors(sum1)\n\n            # Check for amicable condition\n            if sum1 != num and sum2 == num:\n                amicable_numbers.add(num)\n                amicable_numbers.add(sum1)\n    \n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    total = 1  # start with 1 because it's a proper divisor of all n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # avoid adding the square root twice\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_numbers = set()\n    \n    for num in range(2, limit + 1):\n        if num not in amicable_numbers:\n            partner = sum_of_divisors(num)\n            if partner != num and partner <= limit:\n                if sum_of_divisors(partner) == num:\n                    amicable_numbers.add(num)\n                    amicable_numbers.add(partner)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    total = 1  # start with 1 as it is a proper divisor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_numbers = set()\n    \n    for number in range(2, limit + 1):\n        if number not in amicable_numbers:\n            partner = sum_of_divisors(number)\n            if partner != number and sum_of_divisors(partner) == number:\n                amicable_numbers.add(number)\n                amicable_numbers.add(partner)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def divisor_sum(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    total = 1  # start with 1, as it's a proper divisor of any n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # Add the complementary divisor\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_numbers = set()  # Use a set to avoid duplicates\n    \n    for num in range(2, limit + 1):\n        if num not in amicable_numbers:  # Check only if not already found\n            pair = divisor_sum(num)\n            if pair != num and divisor_sum(pair) == num:\n                amicable_numbers.add(num)\n                amicable_numbers.add(pair)\n    \n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    total = 1  # 1 is a proper divisor of any n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # Add the complement divisor if it's different\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_numbers = set()\n    for num in range(2, limit + 1):\n        if num not in amicable_numbers:\n            partner = sum_of_proper_divisors(num)\n            if partner != num and sum_of_proper_divisors(partner) == num:\n                amicable_numbers.add(num)\n                amicable_numbers.add(partner)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n.\"\"\"\n    divisors_sum = 1  # start with 1 since it is a proper divisor of all n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:  # add the complement divisor if it's different\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers up to the given limit.\"\"\"\n    amicable_numbers = set()\n    \n    for num in range(2, limit + 1):\n        if num not in amicable_numbers:\n            partner = sum_of_divisors(num)\n            if partner != num and partner <= limit:\n                if sum_of_divisors(partner) == num:\n                    amicable_numbers.add(num)\n                    amicable_numbers.add(partner)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    total = 1  # Start with 1 because it's a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # Add the complementary divisor if it's different\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to the specified limit.\"\"\"\n    amicable_numbers = set()\n    \n    for number in range(2, limit + 1):\n        if number not in amicable_numbers:\n            partner = sum_of_divisors(number)\n            if partner != number and sum_of_divisors(partner) == number:\n                amicable_numbers.add(number)\n                amicable_numbers.add(partner)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n.\"\"\"\n    divisors_sum = 1  # 1 is a proper divisor of any number > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_numbers = set()\n    \n    for num in range(2, limit + 1):\n        partner = sum_of_divisors(num)\n        if partner != num and partner <= limit:\n            if sum_of_divisors(partner) == num:\n                amicable_numbers.add(num)\n                amicable_numbers.add(partner)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n.\"\"\"\n    total = 1  # Start with 1, as it's a proper divisor for all n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # Include the complementary divisor\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_numbers = set()\n    \n    for number in range(2, limit + 1):\n        if number not in amicable_numbers:  # Only process if not already found\n            partner = sum_of_divisors(number)\n            if partner != number and sum_of_divisors(partner) == number:\n                amicable_numbers.add(number)\n                amicable_numbers.add(partner)\n    \n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    total = 1  # start with 1 since it's a proper divisor of any n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # avoid adding the square root twice\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_numbers = set()\n    \n    for num in range(2, limit + 1):\n        if num not in amicable_numbers:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_numbers.add(num)\n                amicable_numbers.add(partner)\n    \n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors_sum = 1  # 1 is always a proper divisor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:  # Add the complement divisor if it's not the same\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to the specified limit.\"\"\"\n    amicable_numbers = set()\n    for num in range(2, limit + 1):\n        partner = sum_of_divisors(num)\n        if partner != num and partner <= limit:\n            # Check if the partner's sum of divisors equals the original number\n            if sum_of_divisors(partner) == num:\n                amicable_numbers.add(num)\n                amicable_numbers.add(partner)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n.\"\"\"\n    total = 1  # 1 is a proper divisor for all n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_numbers = set()\n    \n    for num in range(2, limit + 1):\n        if num not in amicable_numbers:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_numbers.add(num)\n                amicable_numbers.add(partner)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n.\"\"\"\n    divisors_sum = 1  # start with 1 because it is a proper divisor of any n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:  # add the complementary divisor\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers up to a specified limit.\"\"\"\n    amicable_numbers = set()\n    \n    for number in range(2, limit + 1):\n        if number in amicable_numbers:\n            continue  # Skip if already found to be amicable\n        \n        partner = sum_of_divisors(number)\n        if partner != number and sum_of_divisors(partner) == number:\n            amicable_numbers.add(number)\n            amicable_numbers.add(partner)\n    \n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != 1 and i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_numbers = set()\n    \n    for number in range(2, limit + 1):\n        if number not in amicable_numbers:\n            partner = sum_of_divisors(number)\n            if partner != number and sum_of_divisors(partner) == number:\n                amicable_numbers.add(number)\n                amicable_numbers.add(partner)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def divisor_sum(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    total = 1  # 1 is a proper divisor of any number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # Avoid adding the square root twice\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers under the limit.\"\"\"\n    amicable_numbers = set()\n\n    for num in range(2, limit + 1):\n        if num not in amicable_numbers:\n            partner = divisor_sum(num)\n            if partner != num and divisor_sum(partner) == num:\n                amicable_numbers.add(num)\n                amicable_numbers.add(partner)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from the given sentence.\n    \n    Parameters:\n    n (int): The length threshold.\n    sentence (str): A string of words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter and return words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of words to find.\n    sentence (str): A sentence containing words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n    \n    Parameters:\n    n (int): The length to compare against.\n    sentence (str): The sentence from which to extract words.\n    \n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words longer than n characters\n    longer_words = [word for word in words if len(word) > n]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The length to compare against.\n    sentence (str): The input sentence from which to find long words.\n\n    Returns:\n    List[str]: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()  # Split the sentence into words\n    return [word for word in words if len(word) > n]  # Filter words longer than n", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    This function returns a list of words that are longer than n characters\n    from the given sentence.\n    \n    Parameters:\n    n (int): The minimum length of words to include in the result.\n    sentence (str): The input sentence from which to extract words.\n    \n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter and return the words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter and return words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    This function finds all words longer than n characters in the provided sentence.\n\n    Parameters:\n    n (int): The minimum length of words to be included in the result.\n    sentence (str): The input sentence from which to extract words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of words to consider.\n    sentence (str): The input sentence containing words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of words to find.\n    sentence (str): The input sentence containing words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter and return the words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the string into a list of words\n    word_list = words.split()\n    # Use a list comprehension to filter out words longer than n characters\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words longer than n characters from the given sentence.\n    \n    :param n: Integer representing the minimum length of words to include.\n    :param sentence: A string containing the words to evaluate.\n    :return: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words longer than n characters from the given sentence.\n    \n    :param n: The length threshold for the words.\n    :param sentence: A string containing words to evaluate.\n    :return: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter and return the words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the words string into a list of individual words\n    word_list = words.split()\n    # Use a list comprehension to filter words longer than n characters\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The length to compare against.\n    sentence (str): The sentence containing words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n    \n    Parameters:\n    n (int): The minimum length of the words to find.\n    sentence (str): The sentence containing the words.\n    \n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Return a list of words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    This function finds all the words in a given sentence that are longer than n characters.\n\n    :param n: An integer representing the minimum length of words to find.\n    :param sentence: A string containing the words to evaluate.\n    :return: A list of words that are longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter and return the words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words longer than n characters from the given sentence.\n\n    Parameters:\n    n (int): The minimum length of words to find.\n    sentence (str): The input sentence from which to find long words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from the given sentence.\n\n    Parameters:\n    n (int): The length threshold.\n    sentence (str): The input sentence containing words.\n\n    Returns:\n    List[str]: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Use list comprehension to filter out words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from the given sentence.\n\n    Parameters:\n    n (int): The length to compare the words against.\n    sentence (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Return words that are longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The length threshold.\n    sentence (str): The input sentence.\n\n    Returns:\n    List[str]: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter and return words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 87.30867346938776, "dps_norm": 98.33333333333333, "pass@1": 74.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n\n    # Calculate the sum of the first row as the magic constant\n    magic_constant = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n            \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n            \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is not empty\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        return False\n    \n    n = len(matrix)\n    magic_sum = sum(matrix[0])  # Calculate the magic sum from the first row\n\n    # Check sums of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check sums of the two diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the sum of the first row as the magic constant\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the anti-diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Get the size of the matrix\n    n = len(matrix)\n    \n    # Calculate the sum of the first row as the magic sum\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the two diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n\n    # Calculate the sum of the first row to set as the magic sum\n    magic_sum = sum(matrix[0])\n\n    # Check the sums of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sums of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if n == 0 or any(len(row) != n for row in matrix):\n        return False  # Not a square matrix\n\n    magic_sum = sum(matrix[0])  # Sum of the first row\n\n    # Check sums of rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check sum of diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)  # Size of the square matrix\n\n    # Calculate the sum of the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    if not matrix or len(matrix) != len(matrix[0]):\n        return False  # Not a square matrix\n\n    n = len(matrix)\n    magic_sum = sum(matrix[0])  # Sum of the first row\n\n    # Check sums of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check sums of the two diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the magic sum (sum of the first row)\n    magic_sum = sum(matrix[0])\n    \n    # Check sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    if not matrix or len(matrix) != len(matrix[0]):\n        return False\n    \n    n = len(matrix)\n    magic_sum = sum(matrix[0])  # The sum of the first row\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n            \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the anti diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n            \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n            \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row\n    n = len(matrix)\n    magic_sum = sum(matrix[0])\n\n    # Check each row sum\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check each column sum\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the main diagonal sum\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the secondary diagonal sum\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Check if the matrix is square\n    if any(len(row) != n for row in matrix):\n        return False\n    \n    # Calculate the magic sum (sum of the first row)\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n\n    # Calculate the sum of the first row\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the magic constant\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n            \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the anti-diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    if not matrix or len(matrix) != len(matrix[0]):\n        return False  # Not a square matrix\n\n    n = len(matrix)\n    magic_sum = sum(matrix[0])  # Sum of the first row\n\n    # Check the sums of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sums of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Get the size of the matrix\n    n = len(matrix)\n    \n    # Calculate the magic sum (the sum of the first row)\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to set as the magic constant\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        return False  # Not a square matrix\n\n    n = len(matrix)\n    magic_sum = sum(matrix[0])  # The magic constant sum\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}]}, "Mbpp/130": {"dps": 77.10762331838565, "dps_norm": 68.33333333333334, "pass@1": 97.0, "profiled": [{"solution": "def max_occurrences(lst):\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    frequency = {}\n    \n    # Count the frequency of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    \n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Find the item with maximum frequency in the given list.\n    \n    Parameters:\n    lst (list): A list of items.\n    \n    Returns:\n    item: The item with the maximum frequency. If there are ties,\n          the first one encountered in the list will be returned.\n    \"\"\"\n    frequency = {}\n    \n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    \n    max_freq = 0\n    max_item = None\n    \n    for item, count in frequency.items():\n        if count > max_freq:\n            max_freq = count\n            max_item = item\n            \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count the frequency of each item\n    frequency = {}\n    \n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n            \n    # Find the item with the maximum frequency\n    max_freq_item = None\n    max_freq_count = 0\n    \n    for item, count in frequency.items():\n        if count > max_freq_count:\n            max_freq_count = count\n            max_freq_item = item\n            \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count occurrences of each item\n    frequency = {}\n    \n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with maximum frequency\n    max_item = None\n    max_count = 0\n    \n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"Returns the item with the maximum frequency in the list.\"\"\"\n    frequency = {}\n    \n    # Count the frequency of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    \n    # Count the frequency of each element in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n            \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n            \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency_dict = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq_item = None\n    max_freq = 0\n    \n    for item, freq in frequency_dict.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_freq_item = item\n    \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count the occurrences of each item\n    frequency = {}\n    \n    # Count the frequency of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq_item = None\n    max_freq_count = 0\n    \n    for item, count in frequency.items():\n        if count > max_freq_count:\n            max_freq_count = count\n            max_freq_item = item\n            \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count occurrences of each item\n    frequency = {}\n    \n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    \n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    \n    # Count the frequency of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n            \n    # Find the item with the maximum frequency\n    max_freq_item = None\n    max_freq_count = 0\n    for item, count in frequency.items():\n        if count > max_freq_count:\n            max_freq_count = count\n            max_freq_item = item\n            \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    \n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n            \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    \n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n            \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Returns the item with maximum frequency in the given list.\n    If there are multiple items with the same maximum frequency,\n    it returns the first one encountered.\n\n    :param lst: List of elements (can be of any hashable type).\n    :return: The element with the maximum frequency.\n    \"\"\"\n    frequency = {}\n    \n    # Count the frequency of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n            \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n    \n    Parameters:\n        lst (list): A list of elements.\n        \n    Returns:\n        The element that occurs most frequently in the list.\n    \"\"\"\n    from collections import Counter\n\n    # Count the frequency of each element in the list\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency.items(), key=lambda item: item[1])[0]\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    This function returns the item with the maximum frequency in the given list.\n    \n    :param lst: List of elements\n    :return: Element with maximum frequency\n    \"\"\"\n    frequency = {}\n    \n    # Count the frequency of each element in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n            \n    # Find the item with the maximum frequency\n    max_freq_item = None\n    max_freq_count = 0\n    \n    for item, count in frequency.items():\n        if count > max_freq_count:\n            max_freq_count = count\n            max_freq_item = item\n            \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Function to find the item with maximum frequency in a given list.\n    \n    Parameters:\n    lst (list): The input list from which to find the maximum frequency item.\n    \n    Returns:\n    The item with the maximum frequency. If there are multiple items with the same frequency, \n    it returns the first one found.\n    \"\"\"\n    frequency = {}\n    \n    # Count the frequency of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with maximum frequency\n    max_freq_item = None\n    max_freq_count = 0\n    \n    for item, count in frequency.items():\n        if count > max_freq_count:\n            max_freq_count = count\n            max_freq_item = item\n            \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Count the frequency of each item in the list\n    frequency = Counter(lst)\n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"Return the item with the maximum frequency in the list.\"\"\"\n    frequency = {}\n    \n    # Count the frequency of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n            \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    \n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n            \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Returns the item with the maximum frequency in the given list.\n    If there are multiple items with the same maximum frequency, \n    it returns the first one that reaches that maximum.\n\n    Args:\n    lst (list): The list of items to check.\n\n    Returns:\n    item: The item with the maximum frequency.\n    \"\"\"\n    frequency = {}\n    \n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    max_freq = 0\n    max_item = None\n    \n    for item, count in frequency.items():\n        if count > max_freq:\n            max_freq = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"Find the item with maximum frequency in the given list.\"\"\"\n    frequency = {}\n    \n    # Count the frequency of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq_item = max(frequency, key=frequency.get)\n    \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    This function finds the item with maximum frequency in a given list.\n    \n    Parameters:\n    lst (list): A list of items (can be of any type).\n    \n    Returns:\n    The item with the maximum frequency.\n    \"\"\"\n    from collections import Counter\n\n    if not lst:\n        return None  # Return None if the list is empty\n\n    # Count occurrences of each item in the list\n    frequency = Counter(lst)\n\n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n\n    return max_item", "matching_cluster_idx": 4}]}, "Mbpp/137": {"dps": 9.354838709677418, "dps_norm": 24.375, "pass@1": 91.0, "profiled": [{"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    \n    if non_zeroes == 0:\n        return float('inf')  # Return infinity if there are no non-zero elements\n    \n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n    \"\"\"\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n\n    if non_zeroes == 0:\n        return float('inf')  # or raise an exception depending on desired behavior\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    \n    if non_zeroes == 0:  # To handle the case where there are no non-zeroes\n        return float('inf')  # Returning infinity if there are no non-zeroes\n    \n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n\n    if non_zeroes == 0:\n        return float('inf')  # Return infinity if there are no non-zeroes\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    \n    if non_zeroes == 0:\n        return float('inf')  # Handle the case when there are no non-zeroes\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n\n    if non_zeroes == 0:\n        return float('inf')  # Return infinity if there are no non-zeroes\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    \n    # Avoid division by zero\n    if non_zeroes == 0:\n        return float('inf') if zeroes > 0 else 0.0\n    \n    ratio = zeroes / non_zeroes\n    return ratio", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n\n    # Avoid division by zero\n    if non_zeroes == 0:\n        return float('inf')  # or you may return None or any other indication\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    \n    # Avoid division by zero\n    if non_zeroes == 0:\n        return float('inf')  # or return None, or handle as appropriate\n    \n    return zeroes / non_zeroes", "matching_cluster_idx": 0}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    \n    if non_zeroes == 0:\n        return float('inf')  # or some indication of no non-zero numbers, depends on use case\n    \n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    Parameters:\n    arr (list): List of integers\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes\n    \"\"\"\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    \n    if non_zeroes == 0:\n        return float('inf')  # or return None or a specific value if there are no non-zeroes\n    \n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeros to non-zeros in the given array of integers.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeros to non-zeros.\n    \"\"\"\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n\n    # Avoid division by zero\n    if non_zeroes == 0:\n        return float('inf')  # or handle as per requirements\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    \n    if non_zeroes == 0:\n        return float('inf')  # If there are no non-zeroes, return infinity\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. If there are no non-zeroes, returns float('inf').\n    \"\"\"\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n\n    if non_zeroes == 0:\n        return float('inf')  # Return infinity if there are no non-zeroes to avoid division by zero.\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Function to calculate the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Parameters:\n        arr (list of int): The input array of integers.\n        \n    Returns:\n        float: The ratio of zeroes to non-zeroes. If there are no non-zeroes, returns float('inf').\n    \"\"\"\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    \n    if non_zeroes == 0:\n        return float('inf')  # Return infinity if there are no non-zeroes.\n    \n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    \n    if non_zeroes == 0:\n        return float('inf')  # Handle the case where there are no non-zeroes\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    \n    if non_zeroes == 0:\n        return float('inf')  # Avoid division by zero; can also return None based on your requirement\n    else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n\n    # To avoid division by zero, we handle the case where non_zeroes is zero.\n    if non_zeroes == 0:\n        return float('inf')  # or return None, depending on the desired behavior\n    \n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n\n    # Avoid division by zero\n    if non_zeroes == 0:\n        return float('inf') if zeroes > 0 else 0.0\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    \n    if non_zeroes == 0:\n        return float('inf')  # Handle the case where there are no non-zeroes\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}]}, "Mbpp/140": {"dps": 89.06832298136646, "dps_norm": 84.375, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(lst):\n    # Flatten the list of tuples and convert to a set to remove duplicates\n    return {item for sublist in lst for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"Flatten the list of lists (or tuples) into a single set of numbers.\"\"\"\n    flat_set = set()\n    for sublist in nested_list:\n        flat_set.update(sublist)  # Add each number in the sublist to the set\n    return flat_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(nested_list):\n    \"\"\"Flatten a list of tuples into a single set of numbers.\"\"\"\n    return {num for tup in nested_list for num in tup}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"Flatten a list of tuples into a single set of numbers.\"\"\"\n    result_set = set()\n    for tpl in list_of_tuples:\n        result_set.update(tpl)  # Add elements of the tuple to the set\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n    nested_list (list): A list of lists or tuples containing numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the nested list.\n    \"\"\"\n    # Use a set comprehension to flatten the list and remove duplicates\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    # Flatten the list of tuples and create a set to ensure uniqueness\n    return set(num for tup in lst for num in tup)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_tuples):\n    # Use a set comprehension to flatten the list of tuples into a single set\n    return {num for tup in list_of_tuples for num in tup}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_lists):\n    # Flatten the list of tuples into a single set of numbers\n    return set(number for tup in nested_lists for number in tup)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Flattens a list of tuples into a single set of unique numbers.\n    \n    Parameters:\n    list_of_tuples (list of tuples): The input list containing tuples of numbers.\n\n    Returns:\n    set: A set containing unique numbers from the input tuples.\n    \"\"\"\n    # Use a set comprehension to extract unique numbers from the tuples\n    return {num for tup in list_of_tuples for num in tup}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Flattens a list of tuples into a single set of numbers.\n\n    Args:\n    list_of_tuples (list of tuples): A list containing tuples of integers.\n\n    Returns:\n    set: A set containing all unique integers from the tuples.\n    \"\"\"\n    flat_set = set()\n    for tup in list_of_tuples:\n        flat_set.update(tup)\n    return flat_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Flattens a list of tuples into a single set of numbers.\n    \n    Args:\n    list_of_tuples (list of tuple): A list where each element is a tuple of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the input tuples.\n    \"\"\"\n    flattened_set = set()\n    for tup in list_of_tuples:\n        flattened_set.update(tup)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"Flattens a list of tuples/lists into a single set of numbers.\"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    # Initialize an empty set to collect unique numbers\n    unique_numbers = set()\n    \n    # Iterate through each tuple in the list of lists\n    for sublist in list_of_lists:\n        # Add each number in the tuple to the set\n        unique_numbers.update(sublist)\n    \n    return unique_numbers", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Flatten the list of tuples into a single set of numbers.\n    \n    Args:\n    list_of_tuples (list of tuples): A list containing tuples of integers.\n    \n    Returns:\n    set: A set containing unique integers from all tuples.\n    \"\"\"\n    # Use a set comprehension to extract unique integers from each tuple\n    return {num for tup in list_of_tuples for num in tup}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested):\n    \"\"\"\n    Flatten a list of lists (or tuples) into a single set of numbers.\n\n    Parameters:\n    nested (list of lists or tuples): The input nested structure.\n\n    Returns:\n    set: A set containing the unique numbers from the input.\n    \"\"\"\n    # Use a set comprehension to flatten the input and ensure uniqueness\n    return {num for sublist in nested for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested):\n    \"\"\"\n    This function takes a list of lists or tuples and flattens it into a single set of numbers.\n    \n    :param nested: A list of lists or tuples containing numbers.\n    :return: A set of unique numbers extracted from the nested structure.\n    \"\"\"\n    result_set = set()\n    for sublist in nested:\n        result_set.update(sublist)\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    # Flatten the list of tuples and convert to set to extract unique numbers\n    return set(num for tup in list_of_tuples for num in tup)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    # Use a set to hold unique values\n    unique_numbers = set()\n    \n    # Iterate through each tuple in the nested list\n    for sublist in nested_list:\n        # Add each number to the set\n        unique_numbers.update(sublist)\n    \n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flattens a list of tuples/lists into a single set of unique numbers.\n\n    Parameters:\n    nested_list (list of tuples or lists): The input list containing tuples or lists of numbers.\n\n    Returns:\n    set: A set containing unique numbers from the input list.\n    \"\"\"\n    # Use a set comprehension to flatten the list and store unique numbers\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_tuples):\n    # Use a set comprehension to extract unique numbers from the list of tuples\n    return {num for tup in list_of_tuples for num in tup}", "matching_cluster_idx": 5}]}, "Mbpp/141": {"dps": 68.63945578231294, "dps_norm": 41.875, "pass@1": 95.0, "profiled": [{"solution": "def flip(arr, k):\n    \"\"\"Reverse the elements of arr from the start to the k-th index.\"\"\"\n    return arr[:k+1][::-1] + arr[k+1:]\ndef find_max_index(arr, n):\n    \"\"\"Find the index of the maximum element in arr[:n].\"\"\"\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\ndef pancake_sort(arr):\n    \"\"\"Sort the list arr using pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n, 1, -1):\n        # Find index of the maximum element in arr[0..i]\n        max_index = find_max_index(arr, i)\n\n        # If max is not already at the last position, we need to flip\n        if max_index != i - 1:\n            # First flip to bring max number to the front if it's not already there\n            if max_index != 0:\n                arr = flip(arr, max_index)\n            # Now flip it to put it at the end of the current unsorted array\n            arr = flip(arr, i - 1)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    \"\"\"Reverse the order of the first k elements in the array.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"Find the index of the maximum element in arr[0..n].\"\"\"\n    max_idx = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_idx]:\n            max_idx = i\n    return max_idx\ndef pancake_sort(arr):\n    \"\"\"Sorts the array using pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_idx = find_max_index(arr, curr_size)\n        \n        # Move the maximum element to the end of the current array\n        if max_idx != curr_size - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            # Flip it to its final position\n            arr = flip(arr, curr_size)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        \"\"\"Helper function to reverse the order of the first k elements in sub_arr.\"\"\"\n        return sub_arr[:k][::-1] + sub_arr[k:]\n\n    n = len(arr)\n    for i in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..i]\n        max_index = arr.index(max(arr[:i]))\n        \n        # Flip the maximum element to the front if it's not already at the front\n        if max_index != 0:\n            arr = flip(arr, max_index + 1)\n        \n        # Flip the maximum element to its final position\n        arr = flip(arr, i)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"Flip the first k elements of the array.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"Find the index of the maximum element in arr[0..n].\"\"\"\n    max_idx = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_idx]:\n            max_idx = i\n    return max_idx\ndef pancake_sort(arr):\n    \"\"\"Sort the array using the pancake sorting algorithm.\"\"\"\n    n = len(arr)\n    \n    for i in range(n, 1, -1):\n        # Find index of the maximum element in arr[0..i]\n        max_idx = find_max_index(arr, i)\n        \n        # Move the maximum element to the end of the current unsorted array\n        if max_idx != i - 1:\n            # Flip the maximum element to the front\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            # Flip it to its correct position\n            arr = flip(arr, i)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    \"\"\"Reverse the order of the first k elements in arr.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"Find the index of the maximum element in arr up to the first n elements.\"\"\"\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\ndef pancake_sort(arr):\n    \"\"\"Sort the input list using the pancake sort algorithm.\"\"\"\n    n = len(arr)\n    \n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..size]\n        max_index = find_max_index(arr, size)\n        \n        # Move the maximum number to the end of the current array size if it's not already at that position\n        if max_index != size - 1:\n            # Flip the maximum element to the front if it's not already at the front\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Flip it to its final position\n            arr = flip(arr, size)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    \"\"\"Helper function to flip the sub-array arr[0:k].\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"Find the index of the maximum element in arr[0:n].\"\"\"\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\ndef pancake_sort(arr):\n    \"\"\"Sort the list using pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:i]\n        max_index = find_max_index(arr, i)\n        \n        # If the maximum is not at the last position\n        if max_index != i - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Now flip it to its final position\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    \"\"\"Reverses the order of the first k elements in the array.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef pancake_sort(arr):\n    \"\"\"Sorts the array using pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..size-1]\n        max_index = arr.index(max(arr[:size]))\n\n        # Move the maximum element to the front if it's not already there\n        if max_index != size - 1:\n            # Flip the maximum element to the front\n            arr = flip(arr, max_index + 1)\n            # Now flip it to its correct position\n            arr = flip(arr, size)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"Flip the array from start to k (inclusive).\"\"\"\n    return arr[:k+1][::-1] + arr[k+1:]\ndef find_max_index(arr, n):\n    \"\"\"Find the index of the maximum element in arr[0..n].\"\"\"\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\ndef pancake_sort(arr):\n    \"\"\"Sort the array using pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in arr[0..curr_size-1]\n        max_index = find_max_index(arr, curr_size)\n\n        # Move the maximum element to the end of the current array if it's not already there\n        if max_index != curr_size - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                arr = flip(arr, max_index)\n            # Flip it to its correct position\n            arr = flip(arr, curr_size - 1)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    \"\"\"Reverse the order of the first k elements in the list.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"Find the index of the maximum element in arr[0:n].\"\"\"\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\ndef pancake_sort(arr):\n    \"\"\"Sorts a list using the pancake sort algorithm.\"\"\"\n    n = len(arr)\n    # Start from the complete array and one by one reduce the size\n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in arr[0..curr_size-1]\n        max_index = find_max_index(arr, curr_size)\n        \n        # Move the maximum element to the end of the current array\n        if max_index != curr_size - 1:\n            # Flip the maximum element to the front\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Flip it to its final position\n            arr = flip(arr, curr_size)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    \"\"\"Helper function to reverse the order of elements in arr up to index k.\"\"\"\n    return arr[:k + 1][::-1] + arr[k + 1:]\ndef find_max_index(arr, n):\n    \"\"\"Find the index of the maximum element in arr up to index n.\"\"\"\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\ndef pancake_sort(arr):\n    \"\"\"Sorts an array using the pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        max_index = find_max_index(arr, current_size)\n        \n        # Move the maximum number to the end of the current array\n        if max_index != current_size - 1:\n            # Flip the maximum number to the front\n            if max_index != 0:\n                arr = flip(arr, max_index)\n            # Flip it to the end\n            arr = flip(arr, current_size - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    \"\"\"Reverses the order of the first k elements in arr.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"Finds the index of the maximum element in arr up to the nth element.\"\"\"\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\ndef pancake_sort(arr):\n    \"\"\"Sorts the array using pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in arr[0..curr_size-1]\n        max_index = find_max_index(arr, curr_size)\n\n        # Move the maximum element to the end of the current subarray\n        if max_index != curr_size - 1:\n            # Flip the maximum number to the front if it's not already there\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Now flip it to the end of the current subarray\n            arr = flip(arr, curr_size)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    \"\"\"Helper function to reverse the order of the first k elements in arr.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef pancake_sort(arr):\n    \"\"\"Sorts the array using the pancake sort algorithm.\"\"\"\n    n = len(arr)\n    \n    # Traverse the array from end to start\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_index = arr.index(max(arr[:curr_size]))\n        \n        # Move the maximum element to the end of the current array\n        if max_index != curr_size - 1:\n            # First flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Now flip the maximum element to the current end\n            arr = flip(arr, curr_size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"Helper function to reverse the order of the first k elements of arr.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"Find the index of the maximum element in arr[0:n].\"\"\"\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\ndef pancake_sort(arr):\n    \"\"\"Sort the array using pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find index of the maximum element in arr[0:size]\n        max_index = find_max_index(arr, size)\n        \n        # Move the maximum element to the end of the current array\n        if max_index != size - 1:\n            # Flip to move max element to the front if it's not already at the front\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Flip the maximum element to its final position\n            arr = flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    \"\"\"Reverses the order of the first k elements in the array.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef pancake_sort(arr):\n    \"\"\"Sorts the input list using the pancake sorting algorithm.\"\"\"\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[:size]\n        max_index = arr.index(max(arr[:size]))\n        \n        # Move the maximum element to the front if it's not already there\n        if max_index != size - 1:\n            # Flip the maximum number to the front\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Now flip it to its correct position\n            arr = flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"Reverse the order of the first k elements in the list.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"Find the index of the maximum element in the first n elements.\"\"\"\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\ndef pancake_sort(arr):\n    \"\"\"Sort the array using pancake sorting algorithm.\"\"\"\n    n = len(arr)\n    \n    # One by one move the maximum element to the end of the array\n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in arr[0..curr_size-1]\n        max_index = find_max_index(arr, curr_size)\n\n        # Move the maximum element to the beginning of the array if it's not already there\n        if max_index != curr_size - 1:\n            # Flip the maximum element to the front\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Flip it to its final position\n            arr = flip(arr, curr_size)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    \"\"\"Helper function to reverse the first k elements of the list.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef pancake_sort(arr):\n    \"\"\"Sorts the array using the pancake sort algorithm.\"\"\"\n    n = len(arr)\n    # One by one move the maximum element to the end of the list\n    for i in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..i]\n        max_index = arr.index(max(arr[:i]))\n        # Move the maximum element to the front if it's not already there\n        if max_index != i - 1:\n            # Flip the maximum element to the front\n            arr = flip(arr, max_index + 1)\n            # Now flip it to its final position\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"Helper function to reverse the first k elements of arr.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"Function to find the index of the maximum element in arr.\"\"\"\n    max_idx = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_idx]:\n            max_idx = i\n    return max_idx\ndef pancake_sort(arr):\n    \"\"\"Function to sort an array using the pancake sorting algorithm.\"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in arr[0..curr_size-1]\n        max_idx = find_max_index(arr, curr_size)\n        \n        # Move the maximum element to the end of the current array size\n        if max_idx != curr_size - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            # Now flip the maximum element to its correct position\n            arr = flip(arr, curr_size)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    \"\"\"Helper function to reverse the order of the first k elements in the array.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef pancake_sort(arr):\n    \"\"\"Sorts the array using the pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part of the array\n        max_index = arr.index(max(arr[:i]))\n        \n        # If the maximum element is not already in place\n        if max_index != i - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Flip it to its correct position\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"Reverse the order of the first k elements in the array.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef pancake_sort(arr):\n    \"\"\"Sort the list using the pancake sorting algorithm.\"\"\"\n    n = len(arr)\n    \n    # Start from the complete array and reduce the size of the array\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_index = arr.index(max(arr[0:curr_size]))\n        \n        # Move the maximum number to the beginning if it's not already there\n        if max_index != curr_size - 1:\n            # Flip the maximum number to the front if it's not already there\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)  # Flip to bring max to the front\n            arr = flip(arr, curr_size)  # Flip to move max to its correct position\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"Reverse the order of the first k elements in the array.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"Find the index of the maximum element in arr[0..n].\"\"\"\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\ndef pancake_sort(arr):\n    \"\"\"Sort the given list using the pancake sort algorithm.\"\"\"\n    n = len(arr)\n    # Start from the complete array and reduce the size one by one\n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in arr[0..curr_size-1]\n        max_index = find_max_index(arr, curr_size)\n\n        # Move the maximum element to the end of the current array if it's not already there\n        if max_index != curr_size - 1:\n            # Flip the maximum number to the front if it's not already there\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Now flip it to the end of the current array\n            arr = flip(arr, curr_size)\n\n    return arr", "matching_cluster_idx": 2}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(nums):\n    count = 0\n    n = len(nums)\n    \n    # Check all pairs (i, j) with i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    n = len(numbers)\n    \n    # Iterate through each pair of numbers\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:  # Check if XOR is even\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    n = len(numbers)\n    \n    # Check all pairs of integers in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    n = len(nums)\n    \n    # Iterate through all possible pairs (i, j)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:  # Check if the XOR is even\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate through all possible pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the XOR of the pair is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    n = len(nums)\n    \n    # Loop through each pair of numbers\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    n = len(nums)\n    \n    # Iterate over all pairs of integers in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the XOR of the pair\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n\n    # Check each pair of integers\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    n = len(numbers)\n    \n    # Check all pairs (i, j) with i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    n = len(numbers)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    count = 0\n    n = len(arr)\n    \n    # Check all pairs of elements\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    count = 0\n    n = len(arr)\n    \n    # Iterate over all possible pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    n = len(numbers)\n    \n    # Check all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all unique pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:  # Check if XOR is even\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n\n    # Loop through each pair of integers in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n\n    Parameters:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The count of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    \n    # Check each pair (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:  # XOR is even if the last bit is 0\n                count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    n = len(numbers)\n\n    # Loop through each pair of numbers\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:  # Check if XOR is even\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    n = len(numbers)\n    \n    # Iterate through each pair of numbers\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 96.4573268921095, "dps_norm": 99.30555555555556, "pass@1": 18.0, "profiled": [{"solution": "def sum_range_list(nums, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list from index start to index end (inclusive).\n\n    Parameters:\n    nums (list): A list of numbers.\n    start (int): The starting index.\n    end (int): The ending index.\n\n    Returns:\n    int: The sum of the numbers in the specified range.\n    \"\"\"\n    return sum(nums[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list from start_index to end_index (inclusive).\n\n    :param numbers: List of numbers\n    :param start_index: Starting index for the range\n    :param end_index: Ending index for the range\n    :return: Sum of the numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0 or end_index >= len(numbers):\n        raise IndexError(\"Index out of range\")\n\n    # Calculate the sum in the specified range\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list from start_index to end_index (inclusive).\n\n    :param numbers: List of integers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of the specified range of numbers\n    \"\"\"\n    if start_index < 0 or end_index >= len(numbers):\n        raise IndexError(\"Index out of range.\")\n    \n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list from start_index to end_index (inclusive).\n\n    :param numbers: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of the numbers in the specified range\n    \"\"\"\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list from index start to index end (inclusive).\n\n    Parameters:\n    lst (list): The list of numbers.\n    start (int): The starting index (inclusive).\n    end (int): The ending index (inclusive).\n\n    Returns:\n    int: The sum of the numbers in the specified range.\n    \"\"\"\n    return sum(lst[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Returns the sum of the numbers in the list `nums` from index `start_index` to `end_index`, inclusive.\n    \n    Parameters:\n    nums (list): A list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n    \n    Returns:\n    int: The sum of the numbers in the specified range.\n    \"\"\"\n    return sum(nums[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Sums the numbers in the list from start_index to end_index (inclusive).\n    \n    :param numbers: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of the numbers in the specified range\n    \"\"\"\n    # Slice the list and calculate the sum\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list `numbers` from index `start_index` to `end_index` (inclusive).\n    \n    :param numbers: List of numbers\n    :param start_index: The starting index (inclusive)\n    :param end_index: The ending index (inclusive)\n    :return: Sum of the numbers from start_index to end_index\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0 or end_index >= len(numbers):\n        raise IndexError(\"Index out of range\")\n    \n    # Calculate the sum of the specified range\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculates the sum of elements in a list from start_index to end_index (inclusive).\n\n    Args:\n    numbers (list): A list of numbers.\n    start_index (int): The starting index of the range.\n    end_index (int): The ending index of the range.\n\n    Returns:\n    int: The sum of the numbers in the specified range.\n    \"\"\"\n    # Ensure the indices are within the range of the list\n    if start_index < 0 or end_index >= len(numbers):\n        raise IndexError(\"Index out of range.\")\n    \n    # Calculate the sum in the specified range\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list from start_index to end_index (inclusive).\n    \n    Parameters:\n    - numbers (list): A list of numbers.\n    - start_index (int): The starting index.\n    - end_index (int): The ending index.\n    \n    Returns:\n    - int: The sum of the numbers in the specified range.\n    \"\"\"\n    # Ensure indices are within the bounds of the list\n    if start_index < 0 or end_index >= len(numbers):\n        raise IndexError(\"Index out of range.\")\n    \n    # Calculate the sum of the specified range\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list from start_index to end_index (inclusive).\n    \n    Parameters:\n    numbers (list): A list of numbers.\n    start_index (int): The starting index of the range.\n    end_index (int): The ending index of the range.\n    \n    Returns:\n    int: The sum of the numbers in the specified range.\n    \"\"\"\n    # Check if indices are within bounds\n    if start_index < 0 or end_index >= len(numbers):\n        raise IndexError(\"Indices are out of bounds.\")\n    \n    # Calculate the sum of the specified range\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list from start_index to end_index (inclusive).\n    \n    Args:\n    numbers (list): A list of numbers.\n    start_index (int): The starting index.\n    end_index (int): The ending index.\n    \n    Returns:\n    int: The sum of numbers in the specified range.\n    \"\"\"\n    # Slice the list and calculate the sum\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list between the specified start and end indices (inclusive).\n    \n    :param lst: List of numbers\n    :param start_index: Starting index of the range\n    :param end_index: Ending index of the range\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    if start_index < 0 or end_index >= len(lst):\n        raise IndexError(\"Indices are out of range.\")\n    \n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list from start_index to end_index (inclusive).\n\n    :param numbers: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of the numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0 or end_index >= len(numbers):\n        raise IndexError(\"Index out of range\")\n    \n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list 'numbers' from 'start_index' to 'end_index' (inclusive).\n\n    Args:\n    numbers (list): A list of numbers.\n    start_index (int): The starting index.\n    end_index (int): The ending index.\n\n    Returns:\n    int: The sum of the numbers in the specified range.\n    \"\"\"\n    # Check if indices are within the bounds of the list\n    if start_index < 0 or end_index >= len(numbers):\n        raise IndexError(\"Index out of bounds\")\n    \n    # Calculate the sum in the specified range\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Calculates the sum of elements in the list 'lst' from index 'start_idx' to 'end_idx' (inclusive).\n\n    :param lst: List of numbers\n    :param start_idx: Starting index\n    :param end_idx: Ending index\n    :return: Sum of the elements from start_idx to end_idx\n    \"\"\"\n    # Ensure the indices are within the range of the list\n    if start_idx < 0 or end_idx >= len(lst):\n        raise IndexError(\"Indices are out of bounds.\")\n    \n    return sum(lst[start_idx:end_idx + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in the list from start_index to end_index inclusive.\n    \n    :param numbers: List of numbers to sum.\n    :param start_index: Starting index of the range.\n    :param end_index: Ending index of the range.\n    :return: Sum of the numbers in the specified range.\n    \"\"\"\n    # Ensure indices are within the bounds of the list\n    if start_index < 0 or end_index >= len(numbers):\n        raise IndexError(\"Index out of range.\")\n    \n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list from start_index to end_index (inclusive).\n    \n    Parameters:\n    lst (list): A list of numbers.\n    start_index (int): The starting index (inclusive).\n    end_index (int): The ending index (inclusive).\n    \n    Returns:\n    int: The sum of numbers in the specified range.\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0 or end_index >= len(lst):\n        raise IndexError(\"Index out of bounds.\")\n    \n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 74.57364341085271, "dps_norm": 31.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the string that are at odd index values.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters from even index values only.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s: str) -> str:\n    \"\"\"\n    Remove characters from the input string that have odd index values.\n\n    Parameters:\n    s (str): The input string from which to remove characters.\n\n    Returns:\n    str: A new string containing only characters with even index values.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n    \n    Parameters:\n    s (str): The input string from which characters at odd indices will be removed.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters from the input string that have odd index values.\n    \n    Args:\n    input_string (str): The string from which to remove characters.\n    \n    Returns:\n    str: A new string containing characters from even indices.\n    \"\"\"\n    # Using list comprehension to filter out characters at odd indices\n    return ''.join(input_string[i] for i in range(len(input_string)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: A new string with characters from even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n\n    :param s: Input string\n    :return: String with characters at odd indices removed\n    \"\"\"\n    # Using slicing to get characters at even indices\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n\n    Parameters:\n    s (str): The input string from which characters at odd indices will be removed.\n\n    Returns:\n    str: A new string consisting of characters from the input string at even indices.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the string 's' that have odd index values.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n    \n    Parameters:\n    s (str): The input string from which odd indexed characters will be removed.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return s[::2]  # Return characters at even indices", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the string that have odd index values.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"Remove characters with odd index values from a given string.\"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters with odd index values from the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the string that have odd index values.\n    \n    Parameters:\n    s (str): The input string from which to remove characters.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters from the even indices of the input string.\n    \"\"\"\n    # Using list comprehension to gather characters from even indices\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n    \n    :param s: Input string\n    :return: A new string with characters from even indices\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"Remove characters from the string that have odd index values.\"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the string at odd index values.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters with odd index values from the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A string with characters at odd indices removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from a string that have odd index values.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(input_string, character):\n    \"\"\"\n    Replaces blank spaces in the input string with the specified character.\n\n    Parameters:\n    input_string (str): The string in which to replace spaces.\n    character (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces blank spaces in the input_string with the specified replacement_char.\n    \n    Args:\n    input_string (str): The string in which to replace spaces.\n    replacement_char (str): The character to replace spaces with.\n    \n    Returns:\n    str: The modified string with spaces replaced.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces blank spaces in the input string with the specified character.\n\n    Parameters:\n    input_string (str): The string in which to replace blank spaces.\n    replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replace blank spaces in the input string with the specified character.\n\n    Parameters:\n    input_string (str): The string in which to replace spaces.\n    replacement_char (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by the replacement character.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces blank spaces in the input_string with the specified replacement_char.\n\n    Parameters:\n    input_string (str): The string in which to replace blank spaces.\n    replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by replacement_char.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces blank spaces in the string with the specified character.\n    \n    Args:\n    s (str): The input string.\n    char (str): The character to replace blank spaces with.\n    \n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces blank spaces in the input string with the specified character.\n    \n    Args:\n    input_string (str): The string in which to replace spaces.\n    char (str): The character to replace spaces with.\n    \n    Returns:\n    str: The modified string with spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replace blank spaces in the input string with the specified character.\n    \n    Parameters:\n    input_string (str): The string in which blank spaces will be replaced.\n    replacement_char (str): The character that will replace the blank spaces.\n    \n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces blank spaces in the input_string with the specified replacement_char.\n\n    Args:\n    input_string (str): The string to process.\n    replacement_char (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by the replacement_char.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string: str, char: str) -> str:\n    \"\"\"\n    Replace blank spaces in the input string with the specified character.\n    \n    Parameters:\n    input_string (str): The string to process.\n    char (str): The character to replace spaces with.\n    \n    Returns:\n    str: The modified string with spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replace blank spaces in the input string with the specified character.\n\n    Parameters:\n    input_string (str): The original string with blank spaces.\n    replacement_char (str): The character to replace the blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replace blank spaces in the input string with the specified character.\n\n    Parameters:\n    input_string (str): The string in which to replace spaces.\n    char (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces blank spaces in the input string with the specified character.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by the character.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replace blank spaces in the input string with the specified character.\n\n    Args:\n    input_string (str): The string in which to replace blank spaces.\n    replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replace blank spaces in the input string with the specified character.\n\n    Parameters:\n    input_string (str): The string in which to replace blank spaces.\n    replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the replacement character.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replace blank spaces in the input string with the specified character.\n\n    Parameters:\n    input_string (str): The string to process.\n    char (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, character):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    Args:\n    input_string (str): The string to process.\n    character (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return input_string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces blank spaces in the input string with the specified character.\n\n    Parameters:\n    input_string (str): The string in which to replace blank spaces.\n    replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces blank spaces in the input_string with the replacement_char.\n    \n    Parameters:\n    input_string (str): The string in which to replace blank spaces.\n    replacement_char (str): The character to replace the spaces with.\n    \n    Returns:\n    str: The modified string with spaces replaced by the replacement_char.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces blank spaces in the input string with the specified character.\n\n    Args:\n    input_string (str): The string to process.\n    replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 76.55172413793103, "dps_norm": 78.0, "pass@1": 64.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    # Memoization table\n    memo = {}\n\n    def count_sequences(prev, length):\n        # Base case: If the length of the sequence reaches n, we have found a valid sequence\n        if length == n:\n            return 1\n        # Use memoization to avoid recalculating\n        if (prev, length) in memo:\n            return memo[(prev, length)]\n        \n        total_count = 0\n        next_value = prev * 2\n        \n        # Count the valid next values in the range [next_value, m]\n        while next_value <= m:\n            total_count += count_sequences(next_value, length + 1)\n            next_value += 1\n        \n        # Store result in memoization table\n        memo[(prev, length)] = total_count\n        return total_count\n\n    total_sequences = 0\n    # Start with any number from 1 to m as the first element\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, 1)\n    \n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Define a helper function for recursive counting\n    def count_sequences(current_value, length):\n        if length == 0:\n            return 1\n        count = 0\n        next_value = current_value * 2\n        while next_value <= m:\n            count += count_sequences(next_value, length - 1)\n            next_value += 1\n        return count\n\n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += count_sequences(start, n - 1)\n\n    return total_count", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Dynamic programming table\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Base case: For length 1, any number from 1 to m is a valid sequence\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n\n    # Fill the DP table\n    for length in range(2, n + 1):  # For lengths from 2 to n\n        for last in range(1, m + 1):  # For each possible last element\n            # The next number must be between 2 * last and m\n            start = 2 * last\n            if start > m:\n                continue  # If starting point is beyond m, skip\n            for next_num in range(start, m + 1):  # Next number must be in valid range\n                dp[next_num][length] += dp[last][length - 1]\n\n    # Sum up all possible sequences of length n with any last element\n    total_sequences = sum(dp[i][n] for i in range(1, m + 1))\n    \n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Helper function to count sequences\n    def count_sequences(current, length):\n        if length == n:\n            return 1  # We found a valid sequence\n        total = 0\n        next_value = current * 2\n        while next_value <= m:\n            total += count_sequences(next_value, length + 1)\n            next_value += 1\n        return total\n\n    total_count = 0\n    # Start the sequence with each possible starting point from 1 to m\n    for start in range(1, m + 1):\n        total_count += count_sequences(start, 1)\n    \n    return total_count", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a memoization table\n    memo = {}\n\n    def count_sequences(current, length):\n        # Base case: when the desired length of the sequence is reached\n        if length == 0:\n            return 1\n        # If already computed, return the cached result\n        if (current, length) in memo:\n            return memo[(current, length)]\n        \n        total_count = 0\n        # Start from at least 2 * current (next element)\n        next_value = 2 * current\n        \n        # Continue while next_value is within bounds\n        while next_value <= m:\n            total_count += count_sequences(next_value, length - 1)\n            next_value += 1\n        \n        # Cache the result\n        memo[(current, length)] = total_count\n        return total_count\n    \n    total_sequences = 0\n    # Start the sequence with each possible first element from 1 to m\n    for starting_value in range(1, m + 1):\n        total_sequences += count_sequences(starting_value, n - 1)\n    \n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Create a memoization table to store counts of sequences\n    memo = {}\n\n    def count_sequences(previous, length):\n        # Base case: if the desired length is reached, return 1 (valid sequence)\n        if length == 0:\n            return 1\n        \n        # Use memoization to avoid recomputation\n        if (previous, length) in memo:\n            return memo[(previous, length)]\n\n        total_count = 0\n        # Start from 2 * previous and go up to m\n        start = 2 * previous\n        for next_element in range(start, m + 1):\n            total_count += count_sequences(next_element, length - 1)\n        \n        # Store result in memoization table\n        memo[(previous, length)] = total_count\n        return total_count\n\n    # Start the sequences from all positive integers from 1 to m\n    total_sequences = 0\n    for starting_element in range(1, m + 1):\n        total_sequences += count_sequences(starting_element, n - 1)\n    \n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Memoization table to store results\n    memo = {}\n\n    def count_sequences(last, length):\n        # If we have filled the sequence up to length n, return 1\n        if length == n:\n            return 1\n        \n        # If the result is already calculated, return it\n        if (last, length) in memo:\n            return memo[(last, length)]\n\n        total_sequences = 0\n        # Start the next number from at least twice the last number\n        next_num = 2 * last\n        \n        # Explore the possible next elements\n        while next_num <= m:\n            total_sequences += count_sequences(next_num, length + 1)\n            next_num += 1\n        \n        # Store the result in memoization table\n        memo[(last, length)] = total_sequences\n        return total_sequences\n\n    total = 0\n    # Start the sequence with any number from 1 to m\n    for start in range(1, m + 1):\n        total += count_sequences(start, 1)\n\n    return total", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Memoization table to store the results for dynamic programming\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Base case: for sequences of length 1, every number from 1 to m is valid\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    \n    # Fill the dp table\n    for length in range(2, n + 1):\n        for prev in range(1, m + 1):\n            # The next number must be between 2 * prev and m\n            start = 2 * prev\n            if start <= m:\n                for next_num in range(start, m + 1):\n                    dp[length][next_num] += dp[length - 1][prev]\n    \n    # Sum up all valid sequences of length n\n    total_sequences = sum(dp[n][i] for i in range(1, m + 1))\n    \n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    memo = {}\n\n    def count_sequences(last, length):\n        # Base case: If the sequence length reaches n, there's one valid sequence\n        if length == n:\n            return 1\n        # If we have computed this state before, return the cached result\n        if (last, length) in memo:\n            return memo[(last, length)]\n        \n        total_sequences = 0\n        # Start next_element from 2 * last and go up to m\n        next_element = 2 * last\n        while next_element <= m:\n            total_sequences += count_sequences(next_element, length + 1)\n            next_element += 1\n            \n        memo[(last, length)] = total_sequences\n        return total_sequences\n\n    total = 0\n    # Start the sequence with every possible first element from 1 to m\n    for first_element in range(1, m + 1):\n        total += count_sequences(first_element, 1)\n\n    return total", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Dynamic programming table to store results\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize for the first element\n    for i in range(1, m + 1):\n        dp[1][i] = 1  # There is one way to select each number for sequence of length 1\n\n    # Fill the DP table for lengths from 2 to n\n    for length in range(2, n + 1):\n        for prev in range(1, m + 1):\n            start = 2 * prev\n            # The sequence can start from 2 * prev and go to m\n            if start <= m:\n                # Calculate the sum for sequences starting from 2 * prev to m\n                for current in range(start, m + 1):\n                    dp[length][current] += dp[length - 1][prev]\n    \n    # Sum all sequences of length n\n    total_sequences = sum(dp[n][i] for i in range(1, m + 1))\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Create a memoization table to store results for subproblems\n    memo = {}\n\n    def count_sequences(current, length):\n        # If we have reached the desired length, return 1 sequence found\n        if length == 0:\n            return 1\n        # If the result is already computed, return it\n        if (current, length) in memo:\n            return memo[(current, length)]\n        \n        total_sequences = 0\n        # The next number must be between 2 * current and m (inclusive)\n        next_min = 2 * current\n        # Start from next_min and go up to m\n        for next_number in range(next_min, m + 1):\n            total_sequences += count_sequences(next_number, length - 1)\n\n        # Store the result in the memoization table\n        memo[(current, length)] = total_sequences\n        return total_sequences\n\n    total_count = 0\n    # Start the sequence with each possible starting number from 1 to m\n    for start in range(1, m + 1):\n        total_count += count_sequences(start, n - 1)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Memoization dictionary\n    memo = {}\n\n    def count_sequences(last_element, remaining_length):\n        # Base case: If no remaining length, there's one valid sequence (the empty sequence)\n        if remaining_length == 0:\n            return 1\n        # Check if we have already computed this state\n        if (last_element, remaining_length) in memo:\n            return memo[(last_element, remaining_length)]\n\n        total_sequences = 0\n        # Determine the minimum and maximum value for the next element\n        min_next = last_element * 2\n        max_next = m\n\n        # Iterate through all valid next elements\n        for next_element in range(min_next, max_next + 1):\n            total_sequences += count_sequences(next_element, remaining_length - 1)\n\n        # Store the result in memoization dictionary\n        memo[(last_element, remaining_length)] = total_sequences\n        return total_sequences\n\n    total = 0\n    # Start with each possible first element\n    for first_element in range(1, m + 1):\n        total += count_sequences(first_element, n - 1)\n\n    return total", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Memoization dictionary\n    memo = {}\n    \n    def count_sequences(current_length, last_value):\n        # If we've built a sequence of the desired length, return 1\n        if current_length == n:\n            return 1\n        # If the value has been memoized, return it\n        if (current_length, last_value) in memo:\n            return memo[(current_length, last_value)]\n        \n        total_sequences = 0\n        # Calculate the next valid values\n        next_value = last_value * 2\n        while next_value <= m:\n            total_sequences += count_sequences(current_length + 1, next_value)\n            next_value += 1\n        \n        # Memoize the result before returning\n        memo[(current_length, last_value)] = total_sequences\n        return total_sequences\n    \n    total_count = 0\n    # Start from each possible initial value from 1 to m\n    for starting_value in range(1, m + 1):\n        total_count += count_sequences(1, starting_value)\n    \n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    This function calculates the number of valid sequences of length n\n    where each element is a positive integer and is greater than or equal\n    to twice the previous element but less than or equal to m.\n    \n    :param m: Maximum allowed value for sequence elements.\n    :param n: Length of the sequence.\n    :return: Number of valid sequences.\n    \"\"\"\n    # Memoization table to store results for each (current length, previous value)\n    memo = {}\n\n    def count_sequences(length, prev_value):\n        # Base case: if the current length is n, we've formed a valid sequence\n        if length == n:\n            return 1\n        # Check if the result is already computed\n        if (length, prev_value) in memo:\n            return memo[(length, prev_value)]\n        \n        # Calculate the number of valid next values\n        next_min = max(prev_value * 2, 1)  # At least double the previous\n        next_max = m  # At most m\n\n        # Count valid sequences\n        total = 0\n        for next_value in range(next_min, next_max + 1):\n            total += count_sequences(length + 1, next_value)\n\n        # Memoize the result\n        memo[(length, prev_value)] = total\n        return total\n\n    # Start counting sequences from an initial value of 0 (no previous value)\n    return count_sequences(0, 0)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a memoization table\n    memo = {}\n\n    def count_sequences(last_value, remaining_length):\n        # If we've constructed a full sequence of length n, count it as 1\n        if remaining_length == 0:\n            return 1\n        # If this state has been computed before, return the stored result\n        if (last_value, remaining_length) in memo:\n            return memo[(last_value, remaining_length)]\n        \n        total_count = 0\n        # The next value must be between 2 * last_value and m\n        next_value = 2 * last_value\n        while next_value <= m:\n            total_count += count_sequences(next_value, remaining_length - 1)\n            next_value += 1  # Increment to consider the next possible value\n\n        # Store the computed result in the memoization table\n        memo[(last_value, remaining_length)] = total_count\n        return total_count\n\n    total_sequences = 0\n    # Start the sequence with any number from 1 to m\n    for starting_value in range(1, m + 1):\n        total_sequences += count_sequences(starting_value, n - 1)\n\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # A memoization table to store the number of sequences of length k starting from the value 'start'\n    memo = {}\n\n    def count_sequences(start, length):\n        # Base case: if the length is 0, there is one valid sequence (the empty sequence)\n        if length == 0:\n            return 1\n        \n        # Check if we already computed this state\n        if (start, length) in memo:\n            return memo[(start, length)]\n        \n        total_count = 0\n        next_start = 2 * start  # Next element must be at least twice the current element\n        \n        # Count valid sequences starting from the next_start and of length (length - 1)\n        while next_start <= m:\n            total_count += count_sequences(next_start, length - 1)\n            next_start += 1  # Increment to check the next possible starting point\n\n        # Memoize the computed result\n        memo[(start, length)] = total_count\n        return total_count\n\n    total_sequences = 0\n    # Start with each possible initial value from 1 to m\n    for initial in range(1, m + 1):\n        total_sequences += count_sequences(initial, n - 1)\n\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n, where each element\n    is a positive integer and is greater than or equal to twice the previous \n    element but less than or equal to m.\n\n    :param m: The upper limit for the elements in the sequence.\n    :param n: The length of the sequence.\n    :return: The count of valid sequences.\n    \"\"\"\n    # Create a memoization table\n    memo = {}\n\n    def count_sequences(previous, length):\n        # Base case: if we have formed a sequence of the required length\n        if length == n:\n            return 1\n        \n        # If the value is already computed\n        if (previous, length) in memo:\n            return memo[(previous, length)]\n        \n        total = 0\n        # Calculate the next element's lower bound\n        lower_bound = previous * 2\n        \n        # Iterate from the lower bound to m\n        for next_element in range(lower_bound, m + 1):\n            total += count_sequences(next_element, length + 1)\n        \n        memo[(previous, length)] = total\n        return total\n\n    total_sequences = 0\n    # Start the sequence with each possible first element from 1 to m\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(first_element, 1)\n\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Create a memoization table to store the results of subproblems\n    memo = {}\n\n    def count_sequences(last, length):\n        # If the length is 0, we've successfully formed a sequence\n        if length == 0:\n            return 1\n        # Check if this subproblem has already been solved\n        if (last, length) in memo:\n            return memo[(last, length)]\n\n        count = 0\n        # Find the next valid number\n        next_num = last * 2\n        while next_num <= m:\n            count += count_sequences(next_num, length - 1)\n            next_num += 1\n\n        # Store the result in the memo table\n        memo[(last, length)] = count\n        return count\n\n    total_sequences = 0\n    # Starting with an empty last number (0) and the full length n\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Base case: if n is 1, there are m valid sequences (1 to m)\n    if n == 1:\n        return m\n    \n    # Memoization table to store results for subproblems\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Initial condition: for length 1, there are m sequences\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n\n    # Fill the dp table\n    for length in range(2, n + 1):\n        for prev in range(1, m + 1):\n            # Calculate the range for the next number in the sequence\n            min_next = max(prev * 2, 1)\n            max_next = m\n            \n            if min_next <= max_next:\n                dp[prev][length] = sum(dp[i][length - 1] for i in range(min_next, max_next + 1))\n\n    # Sum all sequences of length n starting from 1 to m\n    total_sequences = sum(dp[i][n] for i in range(1, m + 1))\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # A memoization table to store results of subproblems\n    memo = {}\n\n    def count_sequences(last_element, remaining_length):\n        # Base case: if no more elements are left to place\n        if remaining_length == 0:\n            return 1\n        # If the result is already computed, return it\n        if (last_element, remaining_length) in memo:\n            return memo[(last_element, remaining_length)]\n\n        total_sequences = 0\n        # Calculate the range for the next element\n        next_min = 2 * last_element\n        next_max = m\n\n        # Ensure the next minimum is within bounds\n        for next_element in range(next_min, next_max + 1):\n            total_sequences += count_sequences(next_element, remaining_length - 1)\n\n        # Store the result in the memoization table\n        memo[(last_element, remaining_length)] = total_sequences\n        return total_sequences\n\n    total_count = 0\n    # Start by considering each positive integer from 1 to m as the first element\n    for first_element in range(1, m + 1):\n        total_count += count_sequences(first_element, n - 1)\n\n    return total_count", "matching_cluster_idx": 7}]}, "Mbpp/240": {"dps": 61.768292682926834, "dps_norm": 74.44444444444444, "pass@1": 100.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list to be appended.\n\n    Returns:\n    list: The modified list1 with the last element replaced by elements of list2.\n    \"\"\"\n    # Check if list1 is not empty\n    if list1:\n        # Remove the last element of list1\n        list1.pop()\n    # Extend list1 with elements from list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Parameters:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will be added to the first list.\n\n    Returns:\n    list: The modified first list with the last element replaced by the elements of the second list.\n    \"\"\"\n    # Check if list1 is not empty\n    if list1:\n        # Replace the last element of list1 with the elements of list2\n        list1 = list1[:-1] + list2\n    else:\n        # If list1 is empty, just return list2\n        list1 = list2\n\n    return list1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n    list1 (list): The first list to modify.\n    list2 (list): The second list whose elements will replace the last element of list1.\n\n    Returns:\n    list: The modified list1 with the last element replaced by the elements of list2.\n    \"\"\"\n    if not list1:  # Check if list1 is empty\n        return list2  # If list1 is empty, return list2\n\n    # Replace the last element of list1 with the elements of list2\n    list1 = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    \n    Args:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will replace the last element of list1.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Check if list1 is empty\n    if not list1:\n        return list2\n    # Create a new list with all elements from list1 except the last one\n    new_list = list1[:-1]\n    # Add all elements from list2 to the new list\n    new_list.extend(list2)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replace the last element of list1 with the elements of list2.\"\"\"\n    if not list1:  # If list1 is empty, return list2\n        return list2\n    return list1[:-1] + list2  # Replace last element of list1 with list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element from list1\n    list1 = list1[:-1]\n    # Concatenate list1 with list2\n    return list1 + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of list1 with the elements of list2.\n    \n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list whose elements will replace the last element of list1.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    if not list1:  # If list1 is empty, return list2\n        return list2\n    \n    # Create a new list containing all elements of list1 except the last one\n    new_list = list1[:-1]\n    # Append all elements of list2 to the new list\n    new_list.extend(list2)\n    \n    return new_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list.\n\n    Returns:\n    list: The modified first list with the last element replaced by elements of the second list.\n    \"\"\"\n    if not list1:  # Check if the first list is empty\n        return list2  # If empty, return the second list\n    \n    # Replace the last element of list1 with the elements of list2\n    list1 = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of list1 with the elements of list2\n    if list1:  # Check if list1 is not empty\n        list1.pop()  # Remove the last element of list1\n    return list1 + list2  # Concatenate the modified list1 with list2", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n    list1 (list): The first list from which the last element will be replaced.\n    list2 (list): The second list whose elements will be added.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by elements of list2.\n    \"\"\"\n    if not list1:\n        return list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n    \n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1\n    list1 = list1[:-1]\n    # Append elements of list2 to list1\n    return list1 + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list whose elements will replace the last element of the first list.\n\n    Returns:\n    list: The modified first list with elements of the second list appended.\n    \"\"\"\n    # Remove the last element of the first list\n    list1.pop()\n    # Extend the first list with the elements of the second list\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n    list1: A list of elements.\n    list2: A list of elements.\n\n    Returns:\n    A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Create a copy of list1 excluding the last element\n    new_list = list1[:-1]\n    # Append the elements of list2 to the new list\n    new_list.extend(list2)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of lst1 with the elements of lst2.\n\n    Args:\n    lst1 (list): The first list.\n    lst2 (list): The second list.\n\n    Returns:\n    list: The modified lst1 with the last element replaced by lst2 elements.\n    \"\"\"\n    # Replace the last element of lst1 with the elements from lst2\n    lst1 = lst1[:-1] + lst2\n    return lst1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Parameters:\n    list1 (list): The first list to modify.\n    list2 (list): The second list whose elements will replace the last element of the first list.\n\n    Returns:\n    list: The modified first list with the last element replaced by elements of the second list.\n    \"\"\"\n    # Remove the last element of list1\n    list1.pop()\n    # Extend list1 with the elements of list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    \n    Args:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will be added to list1.\n    \n    Returns:\n    list: The modified list1 with the last element replaced by elements from list2.\n    \"\"\"\n    if not list1:\n        return list2  # If list1 is empty, just return list2\n    \n    # Replace the last element of list1 with the elements of list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1\n    list1 = list1[:-1]\n    # Add all elements of list2 to the end of list1\n    return list1 + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    \n    Parameters:\n    list1 (list): The first list where the last element will be replaced.\n    list2 (list): The second list whose elements will replace the last element of list1.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    if not list1:  # Check if list1 is empty\n        return list2  # If list1 is empty, just return list2\n    \n    # Create a new list by combining the elements of list1 except the last one and all elements of list2\n    new_list = list1[:-1] + list2\n    return new_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    \n    Returns:\n    list: The modified first list with its last element replaced by the elements of the second list.\n    \"\"\"\n    # Remove the last element of list1\n    list1 = list1[:-1]\n    \n    # Append the elements of list2 to list1\n    list1.extend(list2)\n    \n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    if not list1:  # Check if list1 is empty\n        return list2\n    \n    # Replace the last element of list1 with the elements of list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}]}, "Mbpp/251": {"dps": 91.95402298850576, "dps_norm": 77.77777777777777, "pass@1": 85.0, "profiled": [{"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Insert an element before each element in the given list.\n\n    Args:\n        lst (list): The list to insert elements into.\n        element: The element to insert.\n\n    Returns:\n        list: A new list with the element inserted before each element of the original list.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)  # Insert the element\n        result.append(item)     # Insert the original item\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    # Create a new list to hold the result\n    result = []\n    # Iterate through each element in the input list\n    for item in lst:\n        # Append the element to the result list\n        result.append(elem)\n        # Append the current item to the result list\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the list.\n\n    Args:\n    lst (list): The list of elements.\n    elem (any): The element to insert.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)  # Insert the element\n        result.append(item)  # Insert the original item\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)  # Insert the element\n        result.append(item)     # Insert the current item\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts the specified element before each element in the given list.\"\"\"\n    result = []\n    for item in lst:\n        result.append(element)  # Append the element first\n        result.append(item)     # Then append the item from the original list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Create a new list to store the results\n    result = []\n    # Iterate through each item in the original list\n    for item in lst:\n        # Append the element and the current item to the result list\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts the specified element before each element in the given list.\"\"\"\n    result = []\n    for item in lst:\n        result.append(element)  # Insert the element\n        result.append(item)     # Insert the original item\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Create a new list to store the result\n    result = []\n    # Iterate through each item in the original list\n    for item in lst:\n        # Append the element and then the item to the result list\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)  # Insert the element before the current item\n        result.append(item)     # Append the current item\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts the given element before each element in the provided list.\n\n    Args:\n    lst (list): The list in which to insert the element.\n    element: The element to insert.\n\n    Returns:\n    list: A new list with the element inserted before each element of the original list.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)  # Insert the element before the current item\n        result.append(item)     # Append the current item\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Create a new list to hold the results\n    result = []\n    # Iterate over each item in the original list\n    for item in lst:\n        # Append the element and the current item to the result list\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)  # Insert the element before the current item\n        result.append(item)     # Append the current item\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the specified element before each element in the given list.\n\n    Args:\n    lst (list): The original list.\n    element (any): The element to insert.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)  # Insert the element\n        result.append(item)     # Insert the original item\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Insert the specified element before each element in the provided list.\n\n    Parameters:\n    lst (list): The list to insert elements into.\n    element: The element to be inserted.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)  # Insert the element before the current item\n        result.append(item)     # Add the current item\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)  # Insert the element before the current item\n        result.append(item)     # Insert the current item\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 60.730593607305934, "dps_norm": 56.470588235294116, "pass@1": 99.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to determine if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Returns the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for i in range(num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than n.\"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \"\"\"\n    if n < 2:\n        return 0  # There are no primes less than 2\n\n    primes_count = 0\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes_count += 1\n\n    return primes_count", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than n.\"\"\"\n    if n < 2:\n        return 0\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"Returns the number of prime numbers less than the given non-negative number n.\"\"\"\n    if n < 2:\n        return 0\n    \n    # Sieve of Eratosthenes to find all primes less than n\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"Returns the count of prime numbers less than n.\"\"\"\n    if n < 2:\n        return 0\n\n    def is_prime(num):\n        \"\"\"Returns True if num is a prime number, otherwise False.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            prime_count += 1\n\n    return prime_count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than n.\"\"\"\n    if n < 2:\n        return 0  # There are no prime numbers less than 2\n\n    primes = [True] * n  # Create a boolean array \"primes[0..n-1]\"\n    primes[0], primes[1] = False, False  # 0 and 1 are not prime numbers\n    \n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False  # Mark multiples of i as non-prime\n\n    return sum(primes)  # Count the number of True values in the array", "matching_cluster_idx": 14}, {"solution": "def is_prime(num):\n    \"\"\"Helper function to determine if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Returns the count of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the count of prime numbers less than n.\"\"\"\n    count = 0\n    for number in range(2, n):\n        if is_prime(number):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than n.\"\"\"\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the count of prime numbers less than n.\"\"\"\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for num in range(n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for num in range(n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than n.\"\"\"\n    count = 0\n    for num in range(n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than a given non-negative number n.\n    \n    Parameters:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The count of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    def is_prime(num):\n        \"\"\"Helper function to determine if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Function to count the number of prime numbers less than a non-negative number n.\"\"\"\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than the given non-negative number n.\"\"\"\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    \"\"\"Return True if num is a prime number, else False.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than the given non-negative number n.\"\"\"\n    count = 0\n    for number in range(n):\n        if is_prime(number):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The count of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n    \n    primes_count = 0\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes_count += 1\n            \n    return primes_count", "matching_cluster_idx": 8}]}, "Mbpp/265": {"dps": 58.02325581395349, "dps_norm": 76.66666666666666, "pass@1": 100.0, "profiled": [{"solution": "def list_split(input_list, n):\n    \"\"\"Splits the input list into sublists for every nth element.\"\"\"\n    # Create a list of empty lists for each split\n    result = [[] for _ in range(n)]\n    \n    # Iterate through the input list and append elements to the corresponding sublist\n    for index, element in enumerate(input_list):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists for every nth element.\n    \n    Parameters:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list containing sublists of every nth element.\n    \n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for index, item in enumerate(lst):\n        result[index % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists for every nth element.\n\n    :param input_list: List of elements to split\n    :param n: Integer specifying the interval for splitting\n    :return: A list of lists containing the split elements\n    \"\"\"\n    # Initialize a list to hold the resulting sublists\n    result = [[] for _ in range(n)]\n    \n    # Distribute elements into the sublists based on their index\n    for index, element in enumerate(input_list):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of resulting lists.\n    \n    Parameters:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, each containing elements spaced by n.\n    \"\"\"\n    # Initialize the result with empty lists for each of the n groups\n    result = [[] for _ in range(n)]\n    \n    # Iterate through the original list and distribute elements into result\n    for index, value in enumerate(lst):\n        result[index % n].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"Splits a list for every nth element.\n\n    Args:\n        input_list (list): The list to be split.\n        n (int): The interval at which to split the list.\n\n    Returns:\n        list: A list of lists containing the split elements.\n    \"\"\"\n    # Initialize a list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the result lists\n    for index, element in enumerate(input_list):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Parameters:\n    input_list (list): The list to be split.\n    n (int): The step size to split the list.\n    \n    Returns:\n    list: A list of lists containing every nth element.\n    \"\"\"\n    return [[input_list[i] for i in range(j, len(input_list), n)] for j in range(n)]", "matching_cluster_idx": 2}, {"solution": "def list_split(input_list, n):\n    # Create a list of empty lists for each group\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements to the correct sublist\n    for index, value in enumerate(input_list):\n        result[index % n].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits the input_list into sublists for every nth element.\n\n    Parameters:\n    input_list (list): The list to be split.\n    n (int): The number of elements after which to split.\n\n    Returns:\n    list: A list of sublists containing the elements from the input_list.\n    \"\"\"\n    result = []\n    for i in range(n):\n        sublist = []\n        for j in range(i, len(input_list), n):\n            sublist.append(input_list[j])\n        result.append(sublist)\n    return result", "matching_cluster_idx": 3}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits the input_list into sublists, each containing elements from \n    the input list taken every nth position.\n\n    Parameters:\n    input_list (list): The list to split.\n    n (int): The step used to group elements.\n\n    Returns:\n    list: A list of sublists containing every nth element from the original list.\n    \"\"\"\n    # Initialize a list of empty sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into sublists\n    for index, value in enumerate(input_list):\n        result[index % n].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element and returns a list of the resulting lists.\n    \n    :param input_list: List of elements to be split\n    :param n: Integer specifying the interval for splitting the list\n    :return: A list of lists containing elements split by every nth element\n    \"\"\"\n    # Create a list of lists for each index from 0 to n-1\n    result = [[] for _ in range(n)]\n    \n    # Iterate through the input list and assign elements to their corresponding sub-list\n    for index, value in enumerate(input_list):\n        result[index % n].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Create a list to hold the resulting sublists\n    result = []\n    # Use a range to iterate over the length of the list\n    for i in range(n):\n        # Use a list comprehension to get every nth element starting from index i\n        result.append([lst[j] for j in range(i, len(lst), n)])\n    return result", "matching_cluster_idx": 2}, {"solution": "def list_split(input_list, n):\n    \"\"\"Splits input_list into sublists, returning a list of the resulting lists,\n    where each sublist contains elements taken from input_list for every nth element.\"\"\"\n    \n    # Create a list of sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate through the input_list and distribute elements into the appropriate sublists\n    for index, element in enumerate(input_list):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into sublists, each containing every nth element.\n    \n    Args:\n    lst (list): The input list to be split.\n    n (int): The step size for splitting the list.\n    \n    Returns:\n    list: A list of sublists containing the split elements.\n    \"\"\"\n    # Create a list of empty lists for each sublist\n    result = [[] for _ in range(n)]\n    \n    # Fill the sublists with every nth element\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists, returning a list of the resulting lists,\n    each containing elements spaced n apart.\n\n    Parameters:\n    input_list (list): The list to be split.\n    n (int): The spacing between elements in the sublists.\n\n    Returns:\n    list: A list containing sublists with elements spaced n apart.\n    \"\"\"\n    # Initialize an empty list to hold the resulting sublists\n    result = []\n    \n    # Iterate over a range of n to create sublists\n    for i in range(n):\n        sublist = []\n        for j in range(i, len(input_list), n):\n            sublist.append(input_list[j])\n        result.append(sublist)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def list_split(input_list, n):\n    # Create a list of n empty lists\n    result = [[] for _ in range(n)]\n    \n    # Distribute elements into the resulting lists\n    for index, value in enumerate(input_list):\n        result[index % n].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    # Initialize the result as a list of empty lists for each \"bucket\"\n    result = [[] for _ in range(n)]\n    \n    # Iterate through the input list and distribute elements into the buckets\n    for index, element in enumerate(input_list):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits the input_list into sublists for every nth element.\n    \n    Parameters:\n    input_list (list): The list to split.\n    n (int): The step for splitting the list.\n    \n    Returns:\n    list: A list of lists containing the split elements.\n    \"\"\"\n    # Create a list to hold the result\n    result = [[] for _ in range(n)]\n    \n    # Populate the result lists\n    for index, item in enumerate(input_list):\n        result[index % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into sublists for every nth element.\n    \n    Parameters:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of sublists.\n    \"\"\"\n    # Initialize an empty list to hold the sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the sublists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits the input list for every nth element and returns a list of the resulting lists.\n\n    :param input_list: List of elements to split\n    :param n: Integer indicating the step size for splitting\n    :return: List of lists containing the split elements\n    \"\"\"\n    # Initialize the result with empty lists for each \"column\"\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the result lists\n    for index, element in enumerate(input_list):\n        result[index % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element and returns a list of the resulting lists.\n\n    Parameters:\n    input_list (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list: A list of lists containing the elements split every nth element.\n    \"\"\"\n    return [[input_list[j] for j in range(i, len(input_list), n)] for i in range(n)]", "matching_cluster_idx": 2}]}, "Mbpp/281": {"dps": 94.3, "dps_norm": 82.72727272727272, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): A list of elements to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Check if all elements in the list are unique.\"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n    \n    :param lst: List of elements to check\n    :return: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n    \n    Parameters:\n    lst (list): The list to check for unique elements.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Check if all elements in the input list are unique.\n\n    Parameters:\n    input_list (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n    \n    Args:\n    lst (list): The list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Use a set to track unique elements\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n    \n    Parameters:\n    lst (list): The list of elements to check.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Check if all elements in the input list are unique.\n\n    Parameters:\n    input_list (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Parameters:\n    lst (list): The list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(elements):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    elements (list): A list of elements to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(elements) == len(set(elements))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n  \n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n  \n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n          \n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0]*len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n  \n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all elements left to i\n            # in the left subarray are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n  \n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n  \n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n  \n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n        \n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n  \n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n  \n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n  \n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions because all remaining elements in the left subarray\n            # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0] * n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n  \n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n  \n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n  \n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n  \n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n          \n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in the left subarray (arr[i..mid]) \n            # are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)  # There are mid - i inversions\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)  # There are mid - i inversions\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in the left subarray (arr[i:mid]) \n            # are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0] * n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n  \n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1) # Count inversions\n            j += 1\n        k += 1\n  \n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n  \n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n  \n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n          \n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n  \n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n  \n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n  \n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)  # There are mid - i inversions, as all remaining elements in the left subarray (arr[i...mid]) are greater than arr[j]\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)  # Count inversions\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all elements left to i in the left subarray\n            # are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n  \n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in the left subarray\n            # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n  \n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n  \n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n  \n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n          \n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n  \n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n  \n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n  \n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0]*len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    \"\"\"Merge two halves and count inversions.\"\"\"\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all elements left to i in\n            # the left subarray are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    \"\"\"Sort the array and count inversions.\"\"\"\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    \"\"\"Count inversions in the array.\"\"\"\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in left subarray\n            # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in\n            # the left subarray (arr[i] ... arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0]*len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n  \n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)  # There are mid - i inversions\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n        \n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n  \n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0]*len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all elements left to i in the left subarray\n            # are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n        \n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all elements left to i in the left subarray\n            # are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions because all the remaining elements in the left subarray\n            # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0] * n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)", "matching_cluster_idx": 5}]}, "Mbpp/308": {"dps": 97.58620689655173, "dps_norm": 66.66666666666667, "pass@1": 99.0, "profiled": [{"solution": "def large_product(list1, list2, n):\n    # Generate all possible products\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order and select the top n\n    products.sort(reverse=True)\n    \n    # Return the top n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Create a list to hold the products of all combinations\n    products = []\n    \n    # Calculate the product of each combination of elements from both lists\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order and take the largest n products\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Create a list to hold all products\n    products = []\n    \n    # Calculate products of each combination of factors from both lists\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort products in descending order and get the top n products\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate the products of each combination of elements from the two lists\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order and get the top n products\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "from itertools import product\ndef large_product(list1, list2, n):\n    # Create all possible products from the two lists\n    products = [a * b for a, b in product(list1, list2)]\n    \n    # Sort the products in descending order and select the top n\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order and get the top n products\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from two lists, selecting one factor from each list.\n\n    :param list1: List of integers\n    :param list2: List of integers\n    :param n: Number of largest products to return\n    :return: List of the n largest products\n    \"\"\"\n    # Generate all possible products from both lists\n    products = [x * y for x in list1 for y in list2]\n\n    # Sort the products in descending order and get the n largest\n    largest_products = sorted(products, reverse=True)[:n]\n\n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products from the two lists\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n\n    # Sort the products in descending order and select the top n\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products from one element of list1 and one element of list2\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and select the top n products\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate the products of all pairs (a, b) where a is from list1 and b is from list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order and get the top 'n' products\n    top_products = sorted(products, reverse=True)[:n]\n    \n    return top_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n    \n    Args:\n    list1: List of integers.\n    list2: List of integers.\n    n: Number of largest products to return.\n    \n    Returns:\n    A list of the n largest products, sorted in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order and get the top n products\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Remove duplicates and sort in descending order\n    unique_products = list(set(products))\n    unique_products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return unique_products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products from the two lists\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n\n    # Sort the products in descending order and select the top 'n' products\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n\n    # Sort the products in descending order and get the top n products\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products between the two lists\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n\n    # Sort the products in descending order and get the top n products\n    top_n_products = sorted(products, reverse=True)[:n]\n    \n    return top_n_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products from one element in list1 and one in list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order and take the top n products\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order and take the top n products\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products from list1 and list2\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and get the top n products\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products from the two lists\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order and get the largest n products\n    largest_products = sorted(products, reverse=True)[:n]\n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n\n    # Sort the products in descending order and select the top n products\n    largest_products = sorted(products, reverse=True)[:n]\n    \n    return largest_products", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 96.0, "profiled": [{"solution": "def get_max_sum(n, memo={}):\n    # Check if the value is already computed\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is 0, the maximum sum is also 0\n    if n == 0:\n        return 0\n\n    # Calculate the maximum sum using the recursive formula\n    max_sum = max(get_max_sum(n // 2, memo) + \n                  get_max_sum(n // 3, memo) + \n                  get_max_sum(n // 4, memo) + \n                  get_max_sum(n // 5, memo), n)\n\n    # Store the computed value in memo\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0, the maximum sum is 0\n        if n == 0:\n            return 0\n        # If the value is already computed, return it from the memo dictionary\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the maximum sum using the recursive formula\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        \n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n < 1:\n        return 0\n    # Calculate the maximum sum using the provided equation\n    max_sum = max(get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) +\n                   get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo), n)\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n\n    if n in memo:\n        return memo[n]\n\n    if n <= 0:\n        return 0\n\n    # Recursive case: calculate the maximum sum using the given equation\n    max_sum = max(get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + \n                  get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo), n)\n\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a cache to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0, the maximum sum is 0\n        if n == 0:\n            return 0\n        # If the result is already computed, return it from the cache\n        if n in memo:\n            return memo[n]\n        # Calculate the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        # Store the result in the cache\n        memo[n] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a cache to store previously computed results\n    cache = {}\n\n    def f(n):\n        # If n is 0, the maximum sum is 0\n        if n == 0:\n            return 0\n        # If the result is already computed, return it from the cache\n        if n in cache:\n            return cache[n]\n        \n        # Recursively compute the sum for n/2, n/3, n/4, n/5\n        max_sum = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        # Take the maximum of the computed sum and n\n        cache[n] = max(max_sum, n)\n        return cache[n]\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store previously computed results\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0, the maximum sum is 0\n        if n == 0:\n            return 0\n        # Check if the result is already computed\n        if n in memo:\n            return memo[n]\n        \n        # Recursive case: calculate the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        \n        # Store the computed result in memoization dictionary\n        memo[n] = max_sum\n        return max_sum\n    \n    # Call the recursive function\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # A dictionary to store previously computed results\n    memo = {}\n\n    def helper(x):\n        # If the result is already computed, return it\n        if x in memo:\n            return memo[x]\n\n        # If x is 0, the maximum sum is also 0\n        if x == 0:\n            return 0\n\n        # Calculate the maximum sum using the given equation\n        max_sum = max(helper(x // 2) + helper(x // 3) + helper(x // 4) + helper(x // 5), x)\n\n        # Store the computed result in the memo dictionary\n        memo[x] = max_sum\n        return max_sum\n\n    # Start the recursion with the given n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store previously computed results\n    memo = {}\n\n    def f(n):\n        # If the result is already computed, return it\n        if n in memo:\n            return memo[n]\n        \n        # Base case for n = 0\n        if n == 0:\n            return 0\n        \n        # Calculate the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        \n        # Store the computed result in the memoization dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    # Compute the maximum sum for the given n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case for the recursion\n    if n <= 0:\n        return 0\n    # Check if the value is already computed\n    if n in memo:\n        return memo[n]\n    \n    # Recursive calculation\n    max_sum = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n    \n    # Store the computed value in memoization dictionary\n    memo[n] = max_sum\n    return max_sum\nmemo = {}", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store the results of already computed f(n)\n    memo = {}\n    \n    def f(n):\n        # If the result for f(n) is already computed, return it\n        if n in memo:\n            return memo[n]\n        \n        # Base case: if n is 0, the maximum sum is 0\n        if n == 0:\n            return 0\n        \n        # Calculate the maximum sum using the provided equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        \n        # Store the result in the memoization dictionary\n        memo[n] = max_sum\n        return max_sum\n    \n    # Call the helper function f(n)\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Use a dictionary to memoize the results\n    memo = {}\n\n    def f(n):\n        # Check if the value is already computed\n        if n in memo:\n            return memo[n]\n        \n        # Base case\n        if n == 0:\n            return 0\n        \n        # Recursively calculate the maximum sum\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        \n        # Store the result in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Base case: if n is 0, the maximum sum is 0\n    if n == 0:\n        return 0\n    # Check if the result is already computed and stored in memo\n    if n in memo:\n        return memo[n]\n    \n    # Calculate the maximum sum using the recursive formula\n    max_sum = max(get_max_sum(n // 2, memo) + \n                  get_max_sum(n // 3, memo) + \n                  get_max_sum(n // 4, memo) + \n                  get_max_sum(n // 5, memo), n)\n    \n    # Store the computed result in the memo dictionary\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Using a dictionary to store computed values for memoization\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0, the maximum sum is 0\n        if n == 0:\n            return 0\n        # Check if the value is already computed\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the maximum sum according to the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        \n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    # Call the helper function to compute the result for the given n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if we have already computed the result for this n\n    if n in memo:\n        return memo[n]\n    \n    # If n is 0, the maximum sum is 0\n    if n == 0:\n        return 0\n\n    # Calculate the maximum sum using the recursive formula\n    max_sum = max(get_max_sum(n // 2, memo) + \n                  get_max_sum(n // 3, memo) + \n                  get_max_sum(n // 4, memo) + \n                  get_max_sum(n // 5, memo), n)\n    \n    # Store the result in the memo dictionary for future reference\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store computed results for memoization\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0, the maximum sum is also 0\n        if n == 0:\n            return 0\n        # Return the result if it's already computed\n        if n in memo:\n            return memo[n]\n        # Calculate the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        # Store the result in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Use a dictionary to memoize the results of previous calculations\n    memo = {}\n\n    def f(n):\n        if n in memo:\n            return memo[n]\n        # Base case for n = 0\n        if n == 0:\n            return 0\n        # Calculate the maximum sum according to the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        memo[n] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Use a dictionary to store previously computed results\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0, return 0\n        if n == 0:\n            return 0\n        # Check if the result is already computed\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum according to the given equation\n        result = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        # Store the computed result in the memoization dictionary\n        memo[n] = result\n        return result\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Use memoization to store already computed results\n    memo = {}\n    \n    def f(n):\n        # Base case: if n is 0, the maximum sum is 0\n        if n == 0:\n            return 0\n        # Check if result is already computed\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        \n        # Store the computed result in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Use a dictionary to store previously computed results for optimization\n    memo = {}\n\n    def f(x):\n        if x in memo:\n            return memo[x]\n        if x == 0:\n            return 0\n        # Calculate the maximum sum using the given equation\n        max_sum = max(f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5), x)\n        memo[x] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n\n    :param s: The input string\n    :return: The first non-repeated character or None if all characters are repeated\n    \"\"\"\n    character_count = {}\n    \n    # Count occurrences of each character in the string\n    for char in s:\n        character_count[char] = character_count.get(char, 0) + 1\n    \n    # Find the first character that has a count of 1\n    for char in s:\n        if character_count[char] == 1:\n            return char\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"Return the first non-repeating character in the string s, or None if all characters are repeated.\"\"\"\n    char_count = {}\n\n    # Count the occurrences of each character in the string\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Find the first character in the string that has a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # Return None if no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Function to find the first non-repeated character in a string.\n    \n    Args:\n    s (str): Input string\n    \n    Returns:\n    str or None: First non-repeated character or None if no such character exists\n    \"\"\"\n    char_count = {}\n    \n    # Count occurrences of each character in the string\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Find the first character in the string that has a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n            \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count the occurrences of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character in the string that has a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If there are no non-repeating characters, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    :param s: Input string\n    :return: First non-repeated character or None if all characters are repeated\n    \"\"\"\n    # Dictionary to store character counts\n    char_count = {}\n\n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeated character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    :param s: Input string\n    :return: The first non-repeated character or None if all characters are repeated.\n    \"\"\"\n    char_count = {}\n\n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first character that occurs only once\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    \"\"\"\n    Function to find the first non-repeated character in a given string.\n    \n    Parameters:\n    s (str): The input string to check.\n    \n    Returns:\n    str: The first non-repeated character, or None if there are no non-repeated characters.\n    \"\"\"\n    character_count = {}\n\n    # Count occurrences of each character\n    for char in s:\n        if char in character_count:\n            character_count[char] += 1\n        else:\n            character_count[char] = 1\n\n    # Find the first non-repeated character\n    for char in s:\n        if character_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    \"\"\"Find the first non-repeated character in the string.\"\"\"\n    char_count = {}\n    \n    # Count occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    \"\"\"\n    Function to find the first non-repeated character in a given string.\n    \n    :param s: Input string\n    :return: First non-repeated character or None if all characters are repeated\n    \"\"\"\n    char_count = {}\n    \n    # Count occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count occurrences of each character in the string\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character in the string with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n        \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n            \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    This function finds the first non-repeated character in a given string.\n    \n    :param s: The input string to search for non-repeated characters.\n    :return: The first non-repeated character or None if all characters are repeated.\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character that has a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If all characters are repeated, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None  # Return None if there are no non-repeated characters", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n\n    # Count occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None  # All characters are repeated", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    \"\"\"\n    Find the first non-repeated character in a given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_count = {}\n\n    # Count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first character that occurs only once\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n\n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str or None: The first non-repeating character or None if all characters are repeated.\n    \"\"\"\n    char_count = {}\n\n    # Count occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    \"\"\"\n    Function to find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string to be processed.\n\n    Returns:\n    str: The first non-repeated character if found, otherwise None.\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count the occurrences of each character\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n            \n    # Find the first character that has a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n            \n    return None  # Return None if there is no non-repeating character", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element is found, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search in.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"Check if an element exists within a given tuple.\"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element (any): The element to find in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Args:\n    tup (tuple): The tuple to be checked.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"Check if an element exists within a tuple.\"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Checks whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search in.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"Check if an element exists in a tuple.\"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element is found, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tup (tuple): The tuple to check.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Args:\n    tup (tuple): The tuple to check.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"Check if an element exists within a tuple.\"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Parameters:\n    t (tuple): The tuple to search in.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Checks if the specified element exists in the given tuple.\n\n    Args:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"Check if the specified element exists in the given tuple.\"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to check.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    :param tup: Tuple in which to search for the element.\n    :param element: Element to search for in the tuple.\n    :return: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element is found, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search in.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 68.35403726708074, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n\n    Parameters:\n    seq1 (iterable): The first sequence.\n    seq2 (iterable): The second sequence.\n\n    Returns:\n    bool: True if there is an overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    :param seq1: First sequence (list, set, etc.)\n    :param seq2: Second sequence (list, set, etc.)\n    :return: True if there is at least one common element, False otherwise\n    \"\"\"\n    # Convert the sequences to sets for efficient lookup\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Check for intersection\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Parameters:\n    seq1 (iterable): First sequence to check.\n    seq2 (iterable): Second sequence to check against.\n    \n    Returns:\n    bool: True if there is an overlap, False otherwise.\n    \"\"\"\n    return not set(seq1).isdisjoint(set(seq2))", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (iterable): First sequence to check.\n    seq2 (iterable): Second sequence to check against.\n    \n    Returns:\n    bool: True if there is any overlapping value, False otherwise.\n    \"\"\"\n    # Use set intersection to find any common elements\n    return not set(seq1).isdisjoint(set(seq2))", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there are any common elements between two sequences.\n\n    Parameters:\n    seq1 (iterable): First sequence to check.\n    seq2 (iterable): Second sequence to check.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    # Convert the sequences to sets and check for intersection\n    return not set(seq1).isdisjoint(set(seq2))", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n    \n    Parameters:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check against.\n    \n    Returns:\n    bool: True if there is an overlap, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for O(1) average time complexity lookups\n    set_seq2 = set(seq2)\n    \n    # Check if any element in seq1 exists in set_seq2\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n    \n    Parameters:\n    seq1 (iterable): First sequence to check.\n    seq2 (iterable): Second sequence to check against.\n    \n    Returns:\n    bool: True if there is at least one common value, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for efficient look-up\n    set_seq2 = set(seq2)\n    \n    # Check for any overlap\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n\n    Parameters:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check against.\n\n    Returns:\n    bool: True if there is an overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n    \n    Parameters:\n    seq1 (iterable): The first sequence.\n    seq2 (iterable): The second sequence.\n    \n    Returns:\n    bool: True if there is at least one common value, otherwise False.\n    \"\"\"\n    # Convert both sequences to sets to find any intersection\n    return not set(seq1).isdisjoint(set(seq2))", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1: A sequence (list, tuple, etc.) of elements.\n    seq2: A sequence (list, tuple, etc.) of elements.\n\n    Returns:\n    bool: True if there is any overlap, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for O(1) average time complexity on membership tests\n    set_seq2 = set(seq2)\n    # Check for any overlapping values\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n    \n    :param seq1: First sequence (can be a list, set, or any iterable)\n    :param seq2: Second sequence (can be a list, set, or any iterable)\n    :return: True if there is any overlap, False otherwise\n    \"\"\"\n    # Convert sequences to sets for efficient lookup\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Check for intersection\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"Check if there are any overlapping values between two sequences.\"\"\"\n    return any(value in seq1 for value in seq2)", "matching_cluster_idx": 8}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n        seq1: A sequence (e.g., list or tuple).\n        seq2: A sequence (e.g., list or tuple).\n        \n    Returns:\n        True if there is any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any overlap between two sequences.\n    \n    Parameters:\n    seq1 (iterable): The first sequence.\n    seq2 (iterable): The second sequence.\n    \n    Returns:\n    bool: True if there is an overlap, False otherwise.\n    \"\"\"\n    # Convert both sequences to sets to take advantage of O(1) average time complexity for lookups\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Check if there is any intersection between the two sets\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there are any overlapping values between two sequences.\n\n    Parameters:\n    seq1 (iterable): First sequence.\n    seq2 (iterable): Second sequence.\n\n    Returns:\n    bool: True if there are overlapping values, False otherwise.\n    \"\"\"\n    return not set(seq1).isdisjoint(set(seq2))", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n\n    Parameters:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check against.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any overlap between two sequences.\n    \n    Args:\n    seq1: The first sequence (list, tuple, etc.)\n    seq2: The second sequence (list, tuple, etc.)\n    \n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    # Convert one of the sequences to a set for faster lookup\n    set_seq2 = set(seq2)\n    \n    # Check if any element in seq1 exists in set_seq2\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"Check whether any value in seq1 exists in seq2.\"\"\"\n    # Using set intersection to determine if there are common elements\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there are any overlapping values between two sequences.\n\n    Parameters:\n    seq1 (iterable): First sequence (list, set, etc.)\n    seq2 (iterable): Second sequence (list, set, etc.)\n\n    Returns:\n    bool: True if there is at least one overlapping value, False otherwise.\n    \"\"\"\n    # Convert sequences to sets for faster lookup\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Check for intersection\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (iterable): First sequence to check.\n    seq2 (iterable): Second sequence to check against.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    # Convert seq2 to a set for faster lookup\n    set_seq2 = set(seq2)\n    \n    # Check for any overlap\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 60.32921810699589, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"Concatenates each element of the tuple by the delimiter.\"\"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n    elements (tuple): The tuple containing elements to concatenate.\n    delimiter (str): The delimiter to use for concatenation (default is '-').\n\n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them using the delimiter\n    return delimiter.join(str(element) for element in elements)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    # Convert all elements in the tuple to string and join them with the delimiter\n    return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple by the specified delimiter.\n    \n    Parameters:\n    tup (tuple): The input tuple containing elements to concatenate.\n    delimiter (str): The delimiter used for concatenation (default is '-').\n\n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a string with a specified delimiter.\n    \n    Args:\n    input_tuple (tuple): The tuple containing elements to concatenate.\n    delimiter (str): The delimiter to use for concatenation. Default is '-'.\n    \n    Returns:\n    str: A string of concatenated elements.\n    \"\"\"\n    # Convert all elements to string and join them with the delimiter\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple by the delimiter.\n\n    Parameters:\n    elements (tuple): A tuple of elements to concatenate.\n    delimiter (str): The delimiter to use for concatenation (default is '-').\n\n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(str(element) for element in elements)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"Concatenate each element of the tuple by the specified delimiter.\"\"\"\n    # Convert all elements to string and join with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    Parameters:\n    tup (tuple): The tuple containing elements to concatenate.\n    delimiter (str): The delimiter to use for concatenation. Defaults to '-'.\n\n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the delimiter.\n    \n    Args:\n    elements (tuple): The tuple containing elements to be concatenated.\n    delimiter (str): The delimiter to use for concatenation. Default is '-'.\n    \n    Returns:\n    str: A string that concatenates the elements of the tuple.\n    \"\"\"\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple by the delimiter.\n\n    :param elements: A tuple of elements to concatenate.\n    :param delimiter: The delimiter to use for concatenation.\n    :return: A string representing the concatenated elements.\n    \"\"\"\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple by the specified delimiter.\n    \n    Parameters:\n    input_tuple (tuple): The tuple containing elements to concatenate.\n    delimiter (str): The delimiter used for concatenation. Default is '-'.\n    \n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    # Convert each element to string and join them with the delimiter\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"Concatenates each element of the tuple using the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use for concatenation.\n\n    Returns:\n        str: A string that is the concatenation of the tuple elements.\n    \"\"\"\n    # Convert all elements to string and join them with the delimiter\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple by the given delimiter.\n\n    Parameters:\n    tup (tuple): The input tuple containing elements to concatenate.\n    delimiter (str): The delimiter to use for concatenation.\n\n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    # Convert all elements to string and join them with the specified delimiter\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple by the specified delimiter.\n    \n    Args:\n    input_tuple (tuple): The tuple containing elements to be concatenated.\n    delimiter (str): The delimiter to use for concatenation.\n    \n    Returns:\n    str: A single string with the elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    # Convert all elements to string and join them with the delimiter\n    return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the delimiter.\n\n    Args:\n    elements (tuple): A tuple containing elements to concatenate.\n    delimiter (str): The delimiter to use for concatenation (default is '-').\n\n    Returns:\n    str: Concatenated string of elements.\n    \"\"\"\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple by the specified delimiter.\n\n    Args:\n    input_tuple (tuple): A tuple of elements to concatenate.\n    delimiter (str): The delimiter to use for concatenation.\n\n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    # Convert all elements to string and join them with the delimiter\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the input tuple using the specified delimiter.\n\n    :param input_tuple: Tuple containing the elements to concatenate\n    :param delimiter: String used to separate the elements\n    :return: A string that is the concatenation of the elements in the tuple\n    \"\"\"\n    # Convert all elements to string and join them with the delimiter\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(str(element) for element in elements)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    # Convert all elements to string and join them with the delimiter '-'\n    return '-'.join(str(element) for element in tup)", "matching_cluster_idx": 4}]}, "Mbpp/424": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n    \n    Args:\n    strings (tuple): A tuple containing strings.\n    \n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"Extract the last character of each string in the tuple.\"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the last character of each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the last characters of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the last character of each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list of last characters of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"Extract the last character of each string in the given tuple.\"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    Args:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    :param strings: A tuple of strings\n    :return: A list of the last characters of each string\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n    \n    Args:\n    input_tuple (tuple): A tuple containing strings.\n    \n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the last character of each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"Extract the last character of each string in the given tuple.\"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"Extract the last character from each string in the given tuple.\"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"Extracts the last character of each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the last character of each string in the given tuple.\n\n    :param strings: A tuple of strings\n    :return: A list of the last characters of each string\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"Extract the last character of each string in the given tuple.\"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n    \n    Args:\n    strings (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"Extract the last character from each string in the given tuple.\"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    Args:\n    strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"Extracts the last character of each string in the given tuple.\"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list of last characters from each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    sublists (list of list): A list of sublists.\n    element: The element to search for in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, target):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Parameters:\n    nested_list (list of list): The list containing sublists.\n    target: The element to count in the sublists.\n\n    Returns:\n    int: The count of sublists that contain the target element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if target in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    :param sublists: List of lists to search through\n    :param element: Element to search for in the sublists\n    :return: Number of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    sublists (list of list): A list containing sublists.\n    element (any): The element to search for in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Parameters:\n    sublists (list of list): The list of sublists to search through.\n    element: The element to count in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Parameters:\n    nested_list (list of list): A list containing sublists.\n    element: The element to count in the sublists.\n    \n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    sublists (list of lists): The list containing sublists to be checked.\n    element: The element to count within the sublists.\n\n    Returns:\n    int: The number of sublists that contain the specified element.\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst_of_lists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst_of_lists: List of lists to search through\n    :param element: Element to count in sublists\n    :return: Count of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    nested_list (list of list): A list of sublists to check.\n    element: The element to count occurrences of in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n    \n    Parameters:\n    nested_list (list of lists): The list of sublists to search.\n    element: The element to count in the sublists.\n    \n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Parameters:\n    nested_list (list of list): A list containing sublists.\n    element: The element to search for in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain a specified element.\n\n    Parameters:\n    sublists (list of lists): The list of sublists to be checked.\n    element: The element to count in the sublists.\n\n    Returns:\n    int: The number of sublists containing the specified element.\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Args:\n    nested_list (list of list): A list of sublists.\n    element: The element to search for in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    nested_list (list of list): The list of sublists to search through.\n    element (any): The element to count in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Count the number of sublists that contain a particular element.\n\n    Parameters:\n    sublists (list of list): A list containing sublists to be searched.\n    element: The element to search for within the sublists.\n\n    Returns:\n    int: The count of sublists that contain the specified element.\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists that contain the specified element.\n\n    Parameters:\n    lst (list of list): The list of sublists to check.\n    element (any): The element to look for in the sublists.\n\n    Returns:\n    int: The count of sublists containing the specified element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Parameters:\n    nested_list (list of list): The list containing sublists to be searched.\n    element (any): The element to be counted in the sublists.\n    \n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Parameters:\n    sublists (list of list): The list of sublists to search.\n    element (any): The element to count in the sublists.\n    \n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Args:\n    sublists (list of list): A list of sublists to search.\n    element (any): The element to search for in the sublists.\n\n    Returns:\n    int: The count of sublists containing the specified element.\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    sublists (list of lists): The list containing sublists.\n    element: The element to search for in the sublists.\n\n    Returns:\n    int: The count of sublists that contain the element.\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 75.49586776859503, "dps_norm": 53.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize gap size\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            # Add arr[i] to the elements that have been gap sorted\n            # Save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    \"\"\"Sorts an array using the shell sort algorithm.\"\"\"\n    n = len(array)\n    gap = n // 2  # Initialize the gap size\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            # Save array[i] in temp and make a hole at position i\n            temp = array[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for array[i] is found\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            \n            # Put temp (the original array[i]) in its correct location\n            array[j] = temp\n        \n        gap //= 2  # Reduce the gap size\n\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a gap equal to half of the array length\n\n    # Do a gapped insertion sort for this gap size.\n    while gap > 0:\n        for i in range(gap, n):\n            # save the current element to insert it in the correct position\n            temp = arr[i]\n            j = i\n            \n            # Shift elements of arr[0..i-gap] that are greater than temp\n            # to their new position\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp in its correct location\n            arr[j] = temp\n            \n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n\n    # Do a gapped insertion sort for this gap size\n    while gap > 0:\n        for i in range(gap, n):\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        gap //= 2  # Reduce the gap for the next element\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        gap //= 2  # Reduce the gap for the next stage\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n\n    # Do a gapped insertion sort for this gap size\n    while gap > 0:\n        for i in range(gap, n):\n            # Save the current element and find its correct position\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for temp is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    n = len(array)\n    gap = n // 2  # Start with a big gap\n\n    # Do a gapped insertion sort for this gap size.\n    while gap > 0:\n        for i in range(gap, n):\n            temp = array[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for array[i] is found\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap\n\n    # Do a gapped insertion sort for this gap size\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next stage\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n\n    # Do a gapped insertion sort for this gap size.\n    while gap > 0:\n        for i in range(gap, n):\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n\n    # Do a gapped insertion sort for this gap size.\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n    \n    # Start with the largest gap and work down to a gap of 1\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # Save the element at the current position\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for temp is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        gap //= 2  # Reduce the gap for the next element\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: List of elements to be sorted\n    :return: Sorted list of elements\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n\n    # Perform a gapped insertion sort for this gap size\n    while gap > 0:\n        for i in range(gap, n):\n            # Save the current element to be compared\n            temp = arr[i]\n            j = i\n\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Place temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the shell sort algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements until the correct location for temp is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n\n    # Perform a shell sort\n    while gap > 0:\n        for i in range(gap, n):\n            # Save the current element to be inserted\n            temp = arr[i]\n            j = i\n\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        gap //= 2  # Reduce the gap size\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n\n    # Do a gapped insertion sort for this gap size.\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n\n    # Do a gapped insertion sort for this gap size\n    while gap > 0:\n        for i in range(gap, n):\n            # Add arr[i] to the elements that have been gap sorted\n            # Save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n\n    # Start with the largest gap and reduce it\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # save the current value and its index\n            temp = arr[i]\n            j = i\n            \n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n    \n    # Start with the largest gap and reduce the gap until it becomes 0\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/433": {"dps": 81.96808510638297, "dps_norm": 81.0, "pass@1": 100.0, "profiled": [{"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all the elements of the given array.\n\n    Parameters:\n    arr (list of int): The array of integers.\n    num (int): The number to compare against the elements of the array.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): A list of integers.\n    num (int): The integer to compare against the elements of the array.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): A list of integers.\n    num (int): The number to compare against the elements of the array.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Args:\n    array (list): A list of numerical elements.\n    number (int or float): The number to be checked against the array elements.\n\n    Returns:\n    bool: True if number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in array:\n        if number <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements in the given array.\n\n    Parameters:\n    arr (list of int): The array of integers to compare against.\n    num (int): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, otherwise False.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"Check if the given number is greater than all elements in the array.\"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the entered number is greater than all the elements of the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the elements of the array.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all the elements of the given array.\n\n    Parameters:\n    arr (list of int): The list of integers to compare against.\n    num (int): The number to compare.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to check against the array elements.\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int): List of integers.\n    num (int): The number to compare against the array elements.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    array (list): A list of numbers.\n    number (int or float): The number to compare against the elements of the array.\n    \n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in array:\n        if number <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Check whether the given number is greater than all elements in the array.\n    \n    Parameters:\n    array (list): A list of numerical elements.\n    number (int or float): The number to compare against the array elements.\n    \n    Returns:\n    bool: True if number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in array:\n        if number <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the elements of the array.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    Args:\n    arr (list of int): The array of integers to compare against.\n    num (int): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, otherwise False.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int): The array of integers to compare against.\n    num (int): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, number):\n    \"\"\"\n    Check whether the entered number is greater than all the elements of the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    number (int or float): The number to compare against the elements of the array.\n\n    Returns:\n    bool: True if the number is greater than all elements, False otherwise.\n    \"\"\"\n    return all(number > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Check if the entered number is greater than all elements of the given array.\n\n    Parameters:\n    array (list of int): The array of integers to compare against.\n    number (int): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(number > element for element in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): A number to compare against the elements of the array.\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/437": {"dps": 76.98529411764706, "dps_norm": 37.0, "pass@1": 97.0, "profiled": [{"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at odd indices from the input string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 1)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"Remove characters at odd indices from the input string.\"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters from odd indices in a string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: A string with characters from odd indices removed.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"Removes characters at odd indices from the given string.\"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"Remove characters from odd indices in the given string.\"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"Remove characters at odd indices from the given string.\"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters from odd indices in a string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters from odd indices removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"Remove characters at odd indices from the string.\"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Remove characters from the string at odd indices.\n    \n    :param s: Input string\n    :return: A new string with characters at odd indices removed\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"Remove characters at odd indices from the string.\"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Removes characters from the string at odd indices.\n\n    Args:\n    s (str): The input string from which odd indexed characters will be removed.\n\n    Returns:\n    str: A new string with characters from odd indices removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters from the string at odd indices.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters from odd indices removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"Remove characters at odd indices from the given string.\"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at odd indices from the string.\n    \n    Args:\n    s (str): The input string from which to remove odd indexed characters.\n    \n    Returns:\n    str: A new string with characters from even indices.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at odd indices from the string s.\n    \n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    # Using list comprehension to filter out odd indexed characters\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"Remove characters at odd indices from the string s.\"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"Remove characters at odd indices from the input string.\"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"Remove characters at odd indices from the input string.\"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Removes odd indexed characters from the given string.\n    \n    :param s: The input string from which to remove odd indexed characters.\n    :return: A string containing only the characters at even indices.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at odd indices from the input string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list containing elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of the list elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrences of all elements of list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple containing elements to be counted.\n    lst (list): The list containing the elements to look for in the tuple.\n\n    Returns:\n    int: The total count of occurrences of elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count.\n\n    Returns:\n    int: The total count of occurrences of elements in lst found in tup.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of the list in the tuple.\n    \n    Parameters:\n    tup (tuple): A tuple containing elements to be counted.\n    lst (list): A list of elements to count in the tuple.\n    \n    Returns:\n    int: The total count of occurrences of list elements in the tuple.\n    \"\"\"\n    return sum(tup.count(item) for item in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of the list in the tuple.\n\n    Parameters:\n    tup (tuple): The tuple containing elements to count.\n    lst (list): The list containing elements to check for in the tuple.\n\n    Returns:\n    int: The total count of occurrences of the elements in the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tup (tuple): A tuple containing elements to count occurrences from.\n    lst (list): A list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of list elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Args:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in lst found in tup.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements in lst within the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple containing elements to check.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of list elements in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"Count the occurrence of all elements of list in a tuple.\n\n    Args:\n        tup (tuple): A tuple of elements.\n        lst (list): A list of elements to count in the tuple.\n\n    Returns:\n        int: The total count of occurrences of the list elements in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of the list in the tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: Total occurrences of all elements in the list found in the tuple.\n    \"\"\"\n    return sum(tup.count(item) for item in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of the list in the tuple.\n\n    Args:\n    tup (tuple): A tuple containing elements to be counted.\n    lst (list): A list of elements whose occurrences in the tuple are to be counted.\n\n    Returns:\n    int: The total count of occurrences of elements in the list found in the tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrences of all elements from the list in the tuple.\n    \n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count in the tuple.\n    \n    Returns:\n    int: The total count of occurrences of the elements in the list found in the tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tup (tuple): A tuple of elements.\n    lst (list): A list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of list elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    :param tup: Tuple containing elements to count occurrences from.\n    :param lst: List containing elements to count.\n    :return: Total count of occurrences of list elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n    \n    Parameters:\n    tup (tuple): A tuple containing elements.\n    lst (list): A list containing elements to count in the tuple.\n    \n    Returns:\n    int: The total count of occurrences of elements in the list found in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of the list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple containing elements.\n    lst (list): The list of elements to count.\n\n    Returns:\n    int: The total count of occurrences of list elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of the list elements in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the occurrence of all elements of a list in a tuple.\n\n    :param tup: Tuple containing elements to count.\n    :param lst: List containing elements to check for occurrences.\n    :return: The count of occurrences of elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrences of all elements of lst in the tuple tup.\n    \n    :param tup: Tuple containing elements to count from\n    :param lst: List of elements to count\n    :return: Total count of occurrences of elements in lst found in tup\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements in the list within the tuple.\n    \n    Args:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count in the tuple.\n    \n    Returns:\n    int: The total count of occurrences of the list elements in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    Args:\n    strings (list): A list of strings.\n\n    Returns:\n    list: A list of strings where each string is reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    This function takes a list of strings and returns a new list\n    with each string reversed.\n    \n    :param strings: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    Args:\n    string_list (list): A list of strings.\n\n    Returns:\n    list: A list of strings with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string in the given list of strings.\"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Parameters:\n    strings (list): A list of strings to be reversed.\n\n    Returns:\n    list: A list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"Reverse each string in a given list of string values.\"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"Reverse each string in the given list of strings.\"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    Parameters:\n    string_list (list): A list of strings to reverse.\n\n    Returns:\n    list: A list of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"Reverses each string in the provided list of strings.\"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    This function takes a list of strings and returns a new list\n    containing each string reversed.\n    \n    :param string_list: List of strings to reverse\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    :param strings: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"Reverses each string in the given list of strings.\"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n\n    Parameters:\n    string_list (list of str): A list containing strings to be reversed.\n\n    Returns:\n    list of str: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in the given list of string values.\n\n    Args:\n    string_list (list): A list of strings to be reversed.\n\n    Returns:\n    list: A list of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    Parameters:\n    string_list (list): A list of strings to reverse.\n\n    Returns:\n    list: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    This function takes a list of strings and returns a new list\n    with each string reversed.\n    \n    :param string_list: List of strings to be reversed\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n    string_list (list): A list of strings to be reversed.\n\n    Returns:\n    list: A list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n    \n    Parameters:\n        string_list (list): A list of strings to be reversed.\n        \n    Returns:\n        list: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    :param strings: List of strings to reverse\n    :return: A new list containing the reversed strings\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string in the given list of strings.\"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 50.67307692307692, "dps_norm": 81.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(nested_list):\n    \"\"\"Extract the first element of each sublist.\"\"\"\n    return [sublist[0] for sublist in nested_list if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(nested_list):\n    \"\"\"Extracts the first element from each sublist in the given nested list.\"\"\"\n    return [sublist[0] for sublist in nested_list]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    This function takes a list of lists and returns a list containing the first element of each sublist.\n\n    Parameters:\n    lst (list of list): A list containing sublists.\n\n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]  # Ensure sublist is not empty", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extract the first element of each sublist.\n\n    Args:\n        lst (list): A list of sublists.\n\n    Returns:\n        list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(nested_list):\n    \"\"\"Extracts the first element of each sublist.\"\"\"\n    return [sublist[0] for sublist in nested_list]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    This function takes a list of sublists and returns a list containing \n    the first element of each sublist.\n    \n    :param sublists: List of sublists\n    :return: List of first elements from each sublist\n    \"\"\"\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"Returns the first element of each sublist.\"\"\"\n    return [sublist[0] for sublist in sublists if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extract the first element of each sublist.\n    \n    Parameters:\n    sublists (list of list): A list containing sublists.\n    \n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"Returns the first element of each sublist.\"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"Return the first element of each sublist in the given list of lists.\"\"\"\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(nested_list):\n    \"\"\"\n    This function takes a list of lists and returns a list containing\n    the first element of each sublist.\n    \n    Args:\n    nested_list (list of lists): A list where each element is a list.\n    \n    Returns:\n    list: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in nested_list]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"Extract the first element from each sublist.\"\"\"\n    return [sublist[0] for sublist in sublists if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"Return a list containing the first element of each sublist.\"\"\"\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"Extract the first element of each sublist.\"\"\"\n    return [sublist[0] for sublist in sublists if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"Return the first element of each sublist.\"\"\"\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"Return a list of the first element from each sublist.\"\"\"\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"Return the first element of each sublist.\"\"\"\n    return [sublist[0] for sublist in sublists if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(nested_list):\n    \"\"\"\n    Extract the first element of each sublist.\n    \n    :param nested_list: A list of lists from which to extract the first elements.\n    :return: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in nested_list]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extracts the first element of each sublist.\n\n    Parameters:\n    sublists (list of lists): A list containing sublists.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(nested_list):\n    \"\"\"Return the first element of each sublist in the nested list.\"\"\"\n    return [sublist[0] for sublist in nested_list if sublist]", "matching_cluster_idx": 3}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char in string s with new_char.\n    \n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: A new string with characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of old character with new character in the given string.\n\n    Parameters:\n    s (str): The input string where replacements will be made.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n\n    Returns:\n    str: A new string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old: str, new: str) -> str:\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n    \n    Parameters:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n    \n    Returns:\n    str: A new string with the specified characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char in input_string with new_char.\n    \n    Args:\n    input_string (str): The original string in which to replace characters.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char in string s with new_char.\n\n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: A new string with the replaced characters.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char in input_string with new_char.\n\n    Args:\n    input_string (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: A new string with old_char replaced by new_char.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(original_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of char_to_replace in original_string \n    with replacement_char and returns the new string.\n\n    :param original_string: The original string to be modified.\n    :param char_to_replace: The character to be replaced.\n    :param replacement_char: The character to replace with.\n    :return: A new string with the replaced characters.\n    \"\"\"\n    return original_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace occurrences of old_char with new_char in the string s.\n    \n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: A new string with the characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char in string s with new_char.\n\n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace old_char with.\n\n    Returns:\n    str: The modified string with all occurrences of old_char replaced by new_char.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n    \n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: The modified string with replacements made.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, target_char, replacement_char):\n    \"\"\"\n    Replace all occurrences of target_char in input_string with replacement_char.\n\n    Args:\n    input_string (str): The original string in which to replace characters.\n    target_char (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n\n    Returns:\n    str: A new string with the replacements made.\n    \"\"\"\n    return input_string.replace(target_char, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"Replace all occurrences of old_char with new_char in the string.\"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of `old` character in string `s` with `new` character.\n\n    Parameters:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n\n    Returns:\n    str: The modified string with `old` replaced by `new`.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char in the string s with new_char.\n    \n    Args:\n    s (str): The input string where characters need to be replaced.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: A new string with the specified characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(original_string, target_char, replacement_char):\n    \"\"\"\n    Replace occurrences of target_char in original_string with replacement_char.\n    \n    Args:\n    original_string (str): The string to modify.\n    target_char (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n    \n    Returns:\n    str: The modified string with the replacements made.\n    \"\"\"\n    return original_string.replace(target_char, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of char_to_replace in input_string with replacement_char.\n\n    Parameters:\n    input_string (str): The original string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with the specified character replaced.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(original: str, old_char: str, new_char: str) -> str:\n    \"\"\"\n    Replace all occurrences of old_char in original with new_char.\n\n    Parameters:\n    original (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return original.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of the character 'old' with 'new' in the string 's'.\n    \n    Parameters:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n    \n    Returns:\n    str: The modified string with the characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(original: str, old_char: str, new_char: str) -> str:\n    \"\"\"\n    Replace all occurrences of old_char in original with new_char.\n\n    Parameters:\n    original (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return original.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old: str, new: str) -> str:\n    \"\"\"\n    Replace all occurrences of old character with new character in the string s.\n\n    :param s: The original string\n    :param old: The character to be replaced\n    :param new: The character to replace with\n    :return: A new string with the characters replaced\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    \"\"\"Returns the sum of the largest and smallest values in the given array.\"\"\"\n    if not arr:  # Check if the array is empty\n        return 0\n    largest = max(arr)\n    smallest = min(arr)\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest value in the given array.\n    \n    Parameters:\n    arr (list): A list of numbers.\n    \n    Returns:\n    int or float: The sum of the largest and smallest numbers in the array.\n    \"\"\"\n    if not arr:  # Check if the array is empty\n        return 0\n    \n    largest = max(arr)\n    smallest = min(arr)\n    \n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Check if the array is empty\n    if not arr:\n        return 0  # Return 0 for an empty array\n\n    # Find the maximum and minimum values in the array\n    max_value = max(arr)\n    min_value = min(arr)\n\n    # Return the sum of the largest and smallest values\n    return max_value + min_value", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest value in the array.\n\n    Parameters:\n    arr (list): A list of numerical values.\n\n    Returns:\n    int/float: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array should not be empty\")\n\n    smallest = min(arr)\n    largest = max(arr)\n\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"Returns the sum of the largest and smallest values in the array.\"\"\"\n    if not arr:  # Check if the array is empty\n        return 0\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"Find the sum of the largest and smallest value in the given array.\"\"\"\n    if not arr:\n        raise ValueError(\"The input array cannot be empty.\")\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return 0\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Check for empty array\n        return 0\n    largest = max(arr)\n    smallest = min(arr)\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function returns the sum of the largest and smallest values in the given array.\n\n    :param arr: List of numbers\n    :return: Sum of the largest and smallest values\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array should not be empty.\")\n\n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of numerical values.\n    \n    Returns:\n    int/float: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:  # Check if the array is empty\n        raise ValueError(\"The array cannot be empty.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function takes an array as input and returns the sum of the largest \n    and smallest values in that array.\n    \n    Parameters:\n    arr (list): A list of numerical values.\n    \n    Returns:\n    int or float: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array should not be empty.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function returns the sum of the largest and smallest values in the given array.\n    \n    :param arr: List of numbers\n    :return: Sum of the largest and smallest numbers\n    \"\"\"\n    if not arr:  # Check for empty array\n        return 0\n    \n    largest = max(arr)\n    smallest = min(arr)\n    \n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of numbers\n    \n    Returns:\n    int: The sum of the largest and smallest values in the array\n    \"\"\"\n    if not arr:  # Check if the list is empty\n        return 0  # Return 0 for an empty list\n    \n    largest = max(arr)  # Find the largest value in the array\n    smallest = min(arr)  # Find the smallest value in the array\n    return largest + smallest  # Return the sum of largest and smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function returns the sum of the largest and smallest values in a given array.\n    \n    Parameters:\n    arr (list): A list of numerical values.\n    \n    Returns:\n    int/float: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array cannot be empty\")\n    \n    largest = max(arr)\n    smallest = min(arr)\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"Returns the sum of the largest and smallest value in the array.\"\"\"\n    if not arr:  # Check if the array is empty\n        return 0  # Return 0 for an empty array\n\n    largest = max(arr)  # Find the largest value\n    smallest = min(arr)  # Find the smallest value\n    return largest + smallest  # Return the sum of the largest and smallest values", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"Returns the sum of the largest and smallest value in the array.\"\"\"\n    if not arr:\n        raise ValueError(\"Array must not be empty.\")\n    \n    largest = max(arr)\n    smallest = min(arr)\n    \n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return 0  # Return 0 for an empty array\n    largest = max(arr)  # Find the largest value\n    smallest = min(arr)  # Find the smallest value\n    return largest + smallest  # Return the sum of the largest and smallest values", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of numeric values.\n    \n    Returns:\n    int/float: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array cannot be empty.\")\n\n    largest = max(arr)\n    smallest = min(arr)\n    \n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list): A list of numerical values.\n\n    Returns:\n    int or float: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:  # Check if the list is empty\n        return 0\n    \n    largest = max(arr)\n    smallest = min(arr)\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function returns the sum of the largest and smallest values in the given array.\n    \n    Parameters:\n    arr (list): A list of numerical values.\n    \n    Returns:\n    int or float: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        return None  # Handle empty list case\n    \n    largest = max(arr)\n    smallest = min(arr)\n    \n    return largest + smallest", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(s):\n    \"\"\"Converts the given string to lower case.\"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    s (str): The string to convert.\n\n    Returns:\n    str: The lowercase version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n    input_string (str): The string to be converted.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"Convert the given string to lower case.\"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"Convert the given string to lower case.\"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"Converts the given string to lower case.\"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"Convert the given string to lower case.\"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n    \n    :param s: The string to be converted.\n    :return: The lower case version of the string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n    \n    Parameters:\n    s (str): The string to be converted to lower case.\n    \n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Parameters:\n    input_string (str): The string to be converted to lower case.\n    \n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Args:\n    input_string (str): The string to be converted to lower case.\n    \n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    :param input_string: str - The string to convert\n    :return: str - The lower case version of the input string\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    :param s: The input string to be converted.\n    :return: The lower case version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Convert the given string to lower case.\"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Args:\n    s (str): The string to convert.\n    \n    Returns:\n    str: The lower case version of the string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    s (str): The string to be converted.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Args:\n    s (str): The input string to convert.\n\n    Returns:\n    str: The converted lower case string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n    input_string (str): The string to be converted.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 85.24590163934427, "dps_norm": 81.81818181818181, "pass@1": 94.0, "profiled": [{"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    \"\"\"\n    Extracts values between quotation marks from the input string.\n\n    Args:\n    s (str): The input string containing quoted values.\n\n    Returns:\n    list: A list of extracted values without the quotation marks.\n    \"\"\"\n    import re\n    # Use regex to find all occurrences of strings in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    # Import regular expression module\n    import re\n    # Use regex to find all occurrences of strings within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    import re\n    # Use regex to find all occurrences of text between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    import re\n    # Use regex to find all occurrences of text within quotation marks\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    \"\"\"\n    Extracts values between quotation marks from the given string.\n\n    Args:\n        s (str): The input string containing values in quotation marks.\n\n    Returns:\n        list: A list of extracted values without the quotation marks.\n    \"\"\"\n    import re\n    # Use regex to find all occurrences of text within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    import re\n    # Use regex to find all occurrences of values within double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Parameters:\n    s (str): The input string containing quoted values.\n\n    Returns:\n    List[str]: A list of extracted values.\n    \"\"\"\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"Extract values between quotation marks from a string.\"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regex to find all occurrences of strings within quotes\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regex to find all occurrences of text within double quotes\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regex to find all occurrences of text within quotation marks\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    import re\n    # Use a regular expression to find all occurrences of text between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    \"\"\"\n    Extract values between quotation marks from a given string.\n    \n    Args:\n    s (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of values extracted from the quotation marks.\n    \"\"\"\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values between quotation marks from a given string.\n    \n    Args:\n    input_string (str): The string to extract values from.\n    \n    Returns:\n    List[str]: A list of extracted values between quotation marks.\n    \"\"\"\n    # Use regular expression to find all occurrences of strings in quotes\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    import re\n    # Use regular expression to find all occurrences of text within quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    # Importing the regular expression module\n    import re\n    # Using regex to find all occurrences of text within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    import re\n    # Use regex to find all occurrences of text within quotation marks\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    \"\"\"\n    Extracts values between quotation marks from the given string.\n\n    Args:\n    s (str): The input string containing values enclosed in quotation marks.\n\n    Returns:\n    list: A list of extracted values.\n    \"\"\"\n    import re\n    # Using regular expression to find all occurrences of quoted strings\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    import re\n    # Use regex to find all occurrences of text within double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 96.0493827160494, "dps_norm": 88.57142857142857, "pass@1": 100.0, "profiled": [{"solution": "def two_unique_nums(nums):\n    \"\"\"\n    This function takes a list of numbers and returns a list of numbers\n    that appear exactly once in the given list.\n    \n    Parameters:\n    nums (list): A list of integers\n    \n    Returns:\n    list: A list containing the unique integers from the input list\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    \n    # Count each number in the list\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, cnt in count.items() if cnt == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list and return only those numbers which appear exactly once.\n\n    :param nums: List of integers.\n    :return: List of integers that appear exactly once.\n    \"\"\"\n    from collections import Counter\n\n    # Count the frequency of each number in the list\n    num_counts = Counter(nums)\n\n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, count in num_counts.items() if count == 1]\n\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "def two_unique_nums(numbers):\n    # Create a frequency dictionary to count occurrences of each number\n    frequency = {}\n    \n    # Count occurrences of each number in the list\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n            \n    # Collect numbers that occur exactly once\n    unique_nums = [num for num, count in frequency.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    This function takes a list of numbers and returns a list containing\n    only the numbers that appear exactly once in the input list.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    list: A list of integers that are unique (appear only once).\n    \"\"\"\n    from collections import Counter\n    \n    # Count the occurrences of each number in the list\n    count = Counter(nums)\n    \n    # Extract the numbers that occur exactly once\n    unique_nums = [num for num, cnt in count.items() if cnt == 1]\n    \n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    This function takes a list of numbers and returns a new list containing\n    only the numbers that appear exactly once in the input list.\n\n    :param nums: List of integers\n    :return: List of integers that appear exactly once\n    \"\"\"\n    from collections import Counter\n\n    # Count the occurrences of each number\n    num_count = Counter(nums)\n\n    # Filter and keep only the numbers that appear exactly once\n    unique_nums = [num for num, count in num_count.items() if count == 1]\n\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    This function takes a list of numbers and returns a list of numbers\n    that appear exactly once (unique numbers) in the input list.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    list: A list of unique integers.\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    \n    # Extract numbers that appear exactly once\n    unique_nums = [num for num, cnt in count.items() if cnt == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Count occurrences of each number in the list\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Collect numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list and return only the numbers that appear exactly once.\n    \n    Args:\n    nums (list): A list of integers.\n    \n    Returns:\n    list: A list of integers that appear exactly once in the input list.\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    counts = {}\n    \n    # Count occurrences of each number\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    \n    # Collect numbers that appear exactly once\n    unique_nums = [num for num, count in counts.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    \"\"\"\n    This function takes a list of numbers and returns a new list containing \n    only the numbers that are unique (appear exactly once) in the input list.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    list: A list containing numbers that appear exactly once in the input list.\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Collect only the numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    \n    # Count occurrences of each number in the list\n    for num in lst:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Extract numbers that appear only once\n    unique_nums = [num for num, cnt in count.items() if cnt == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    \n    # Count each number's occurrences\n    for num in lst:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    # Filter the numbers that occur exactly once\n    unique_nums = [num for num, cnt in count.items() if cnt == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a list containing only the unique numbers\n    that appear exactly once in the input list.\n\n    :param numbers: List of integers\n    :return: List of unique integers appearing exactly once\n    \"\"\"\n    from collections import Counter\n\n    # Count the occurrences of each number in the list\n    counts = Counter(numbers)\n\n    # Collect numbers that appear exactly once\n    unique_nums = [num for num, count in counts.items() if count == 1]\n\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "def two_unique_nums(nums):\n    \"\"\"Remove duplicate numbers and return a list of unique numbers that appear only once.\"\"\"\n    from collections import Counter\n    \n    # Count occurrences of each number\n    count = Counter(nums)\n    \n    # Create a list of numbers that appear exactly once\n    unique_nums = [num for num in nums if count[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    \n    # Count each number's occurrences\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n\n    # Collect numbers that occur exactly once\n    unique_nums = [num for num in nums if count[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Create a dictionary to count occurrences of each number\n    num_count = {}\n    \n    # Count the occurrences of each number in the list\n    for num in numbers:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n            \n    # Create a list for unique numbers (occurs exactly once)\n    unique_nums = [num for num, count in num_count.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    \"\"\"\n    This function takes a list of numbers and returns a new list \n    containing only the unique numbers from the input list.\n    \n    Parameters:\n    lst (list): A list of integers which may contain duplicates.\n\n    Returns:\n    list: A list containing only the unique integers from the input list.\n    \"\"\"\n    # Count occurrences of each number\n    num_count = {}\n    \n    for num in lst:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    \n    # Collect numbers that appear exactly once\n    unique_nums = [num for num, count in num_count.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    \n    # Count the occurrences of each number in the list\n    for num in lst:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in lst if count[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    \"\"\"\n    This function takes a list of numbers and returns a list of numbers\n    that appear exactly once in the original list.\n    \n    :param lst: List of integers\n    :return: List of integers that are unique\n    \"\"\"\n    num_count = {}\n    \n    # Count occurrences of each number\n    for num in lst:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    \n    # Collect numbers that appear exactly once\n    unique_nums = [num for num, count in num_count.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    \n    # Count each number in the list\n    for num in numbers:\n        count[num] = count.get(num, 0) + 1\n    \n    # Extract only the numbers that appear exactly once\n    unique_nums = [num for num in count if count[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Count occurrences of each number\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n            \n    # Collect the numbers that occur exactly once\n    unique_numbers = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_numbers", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 83.38095238095238, "dps_norm": 69.54545454545455, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Args:\n    list1: The first list to interleave.\n    list2: The second list to interleave.\n    list3: The third list to interleave.\n    \n    Returns:\n    A list containing the elements of list1, list2, and list3 interleaved.\n    \"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must be of the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must be of the same length.\")\n    \n    # Initialize an empty list to hold the interleaved result\n    interleaved = []\n    \n    # Iterate through the indices of the lists and interleave the elements\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleave three lists of the same length into a single flat list.\"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    result = []\n    for a, b, c in zip(list1, list2, list3):\n        result.extend([a, b, c])\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length.\")\n    \n    # Interleave the lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if all lists have the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length\")\n\n    # Initialize an empty list for the result\n    interleaved_list = []\n\n    # Interleave the lists\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Args:\n    list1 (list): The first list to interleave.\n    list2 (list): The second list to interleave.\n    list3 (list): The third list to interleave.\n\n    Returns:\n    list: A single list containing elements from list1, list2, and list3 interleaved.\n    \n    Raises:\n    ValueError: If the lists are not of the same length.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length\")\n\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    :param list1: The first list\n    :param list2: The second list\n    :param list3: The third list\n    :return: A single list with elements from list1, list2, and list3 interleaved\n    \"\"\"\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleave three lists into a single flat list.\"\"\"\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check that all lists are of the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleave three lists of the same length into a single flat list.\"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must be of the same length.\")\n    \n    # Use a list comprehension to interleave the lists\n    interleaved = [item for group in zip(list1, list2, list3) for item in group]\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    list3 (list): The third list.\n\n    Returns:\n    list: A new list containing the elements of the input lists interleaved.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must be of the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleave three lists into a single flat list.\"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    list3 (list): The third list.\n    \n    Returns:\n    list: A new list containing elements of list1, list2, and list3 interleaved.\n    \"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Parameters:\n    list1 (list): First list.\n    list2 (list): Second list.\n    list3 (list): Third list.\n    \n    Returns:\n    list: A new list with elements of the three lists interleaved.\n    \n    Raises:\n    ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if all lists are of the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must have the same length\")\n\n    # Interleave the lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    \n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    list3 (list): The third list.\n\n    Returns:\n    list: A single list with elements from list1, list2, and list3 interleaved.\n    \"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n        \n    return interleaved", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 27.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    # Split the array into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    # Combine the second part with the first part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after the split and append operation.\n    \"\"\"\n    # Split the list at the nth index\n    first_part = arr[:n]\n    second_part = arr[n:]\n\n    # Combine the two parts: second part followed by first part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split the list at the nth element and append the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The new list after the split and append operation.\n    \"\"\"\n    # Handle edge cases\n    if not arr or n < 0 or n >= len(arr):\n        return arr\n\n    # Split the array into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n\n    # Append the first part to the end of the second part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the array at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after the split and append operation.\n    \"\"\"\n    # Split the list into two parts\n    first_part = arr[:n]   # elements from start to nth element (exclusive)\n    second_part = arr[n:]  # elements from nth element to end\n\n    # Combine the second part with the first part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and rearranging.\n    \"\"\"\n    # Handle cases where n is greater than the length of the array\n    if n >= len(arr):\n        return arr\n    \n    # Split the list at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the two parts with the first part at the end\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the array at the nth element and adds the first part to the end.\n\n    :param arr: List of elements to be split.\n    :param n: The index at which to split the array.\n    :return: A new list with the first part added to the end.\n    \"\"\"\n    # Validate input\n    if not isinstance(arr, list):\n        raise ValueError(\"First argument must be a list.\")\n    if not isinstance(n, int) or n < 0 or n > len(arr):\n        raise ValueError(\"Second argument must be a valid index.\")\n\n    # Split the array\n    first_part = arr[:n]\n    second_part = arr[n:]\n\n    # Return the new list with first part added to the end\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n    \n    Parameters:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list with the first part added to the end.\n    \"\"\"\n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part at the end\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after the split.\n    \"\"\"\n    # Validate the index n\n    if n < 0 or n > len(arr):\n        raise ValueError(\"Index n must be in the range of the list length.\")\n\n    # Split the list at the nth element\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the input list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: A new list with the elements from index n to the end, followed by the elements from the start to index n-1.\n    \"\"\"\n    # Handle the case when n is greater than the length of the list\n    n = n % len(arr) if len(arr) > 0 else 0\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: A new list with the first part added to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n    \n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list after splitting and reordering.\n    \"\"\"\n    # Ensure the index is within the bounds of the list\n    if n < 0 or n > len(arr):\n        raise ValueError(\"Index n must be within the range of the list.\")\n    \n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Concatenate the second part with the first part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the input list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list with the first part added to the end.\n    \"\"\"\n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the two parts with the first part at the end\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after the split and reordering.\n    \"\"\"\n    # Ensure the index is within the bounds of the list\n    n = n % len(arr) if arr else 0  # Handle cases where n is greater than the list length\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list with the first part added to the end.\n    \"\"\"\n    # Handle cases where n is greater than the length of the list\n    n = n % len(arr) if arr else 0\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits the list at the nth element and adds the first part to the end.\"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the array at the nth element and adds the first part to the end.\n\n    :param arr: List of elements to be split\n    :param n: The index at which to split the list\n    :return: A new list with the elements rearranged\n    \"\"\"\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be between 0 and the length of the array\")\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list with the first part added to the end.\n    \"\"\"\n    # Ensure n is within the bounds of the list\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be between 0 and the length of the list.\")\n\n    # Split the list and concatenate\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split the list at the nth element and add the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list with the first part moved to the end.\n    \"\"\"\n    # Handle cases where n is out of bounds\n    if n < 0 or n >= len(arr):\n        return arr\n    \n    # Split the array into two parts and rearrange\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list `arr` at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The rearranged list after the split.\n    \"\"\"\n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    # Concatenate the second part with the first part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: A new list with the first part moved to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Parameters:\n    lst (list): A list of elements to be converted.\n    \n    Returns:\n    tuple: A tuple containing the elements of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Parameters:\n    input_list (list): The list to be converted to a tuple.\n    \n    Returns:\n    tuple: A tuple containing the elements of the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): A list to be converted to a tuple.\n\n    Returns:\n    tuple: A tuple containing the elements of the input list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"Convert a list to a tuple.\"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"Convert a list to a tuple.\"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"Convert a list to a tuple.\"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to convert.\n\n    Returns:\n    tuple: A tuple representation of the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Parameters:\n    lst (list): The list to be converted to a tuple.\n    \n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"Convert a list to a tuple.\"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Parameters:\n    lst (list): The list to be converted to a tuple.\n    \n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"Convert a list to a tuple.\"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"Convert a list to a tuple.\"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"Convert a list to a tuple.\"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"Convert a list to a tuple.\"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Args:\n    lst (list): The list to be converted.\n    \n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"Convert a list to a tuple.\"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(numbers):\n    \"\"\"Calculate the difference between the largest and smallest value in a list.\"\"\"\n    if not numbers:  # Check if the list is empty\n        raise ValueError(\"The list should not be empty.\")\n    \n    largest = max(numbers)\n    smallest = min(numbers)\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a list.\n\n    Args:\n    numbers (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest values.\n    \"\"\"\n    if not numbers:  # Check for empty list\n        return 0\n    \n    max_value = max(numbers)\n    min_value = min(numbers)\n    return max_value - min_value", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns the difference \n    between the largest and smallest values in the list.\n    \n    Parameters:\n    numbers (list): A list of integers or floats.\n    \n    Returns:\n    int or float: The difference between the largest and smallest numbers.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    largest = max(numbers)\n    smallest = min(numbers)\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"Return the difference between the largest and smallest values in the list.\"\"\"\n    if not nums:  # Handle the case of an empty list\n        raise ValueError(\"The list must not be empty\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Returns the difference between the largest and smallest values in a list.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int: The difference between the largest and smallest numbers.\n    \"\"\"\n    if not numbers:  # Check for an empty list\n        return 0  # or raise an exception depending on the desired behavior\n    \n    largest = max(numbers)\n    smallest = min(numbers)\n    \n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"Return the difference between the largest and smallest values in the list.\"\"\"\n    if not nums:  # Check for empty list\n        raise ValueError(\"The list cannot be empty.\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    This function returns the difference between the largest and smallest\n    values in a given list of numbers.\n    \n    Args:\n    nums (list of int): A list of integers.\n\n    Returns:\n    int: The difference between the largest and smallest integers in the list.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n\n    Parameters:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The difference between the largest and smallest integer in the list.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    largest = max(nums)\n    smallest = min(nums)\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in the list.\n\n    Args:\n    nums (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest values.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"List must not be empty\")\n    \n    max_value = max(nums)\n    min_value = min(nums)\n    \n    return max_value - min_value", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a list.\n    \n    Args:\n    nums (list): A list of numbers.\n    \n    Returns:\n    int: The difference between the largest and smallest numbers.\n    \"\"\"\n    if not nums:  # Check if the list is empty\n        raise ValueError(\"The list should not be empty.\")\n    \n    max_value = max(nums)\n    min_value = min(nums)\n    \n    return max_value - min_value", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Find the difference between the largest and smallest value in the given list.\n    \n    Parameters:\n    nums (list): A list of numeric values.\n    \n    Returns:\n    int: The difference between the largest and smallest values.\n    \"\"\"\n    if not nums:  # Check if the list is empty\n        raise ValueError(\"The list should not be empty.\")\n        \n    largest = max(nums)\n    smallest = min(nums)\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the given list.\n    \n    Args:\n    nums (list of int): A list of integers.\n    \n    Returns:\n    int: The difference between the largest and smallest values.\n    \"\"\"\n    if not nums:  # Check for empty list\n        raise ValueError(\"The list cannot be empty\")\n        \n    max_value = max(nums)\n    min_value = min(nums)\n    \n    return max_value - min_value", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The difference between the largest and smallest integers.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list should not be empty.\")\n    \n    largest = max(nums)\n    smallest = min(nums)\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    nums (list): A list of numerical values.\n\n    Returns:\n    int: The difference between the largest and smallest values.\n    \"\"\"\n    if not nums:  # Check if the list is empty\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    This function returns the difference between the largest and smallest value in a given list.\n    \n    Args:\n    numbers (list): A list of numerical values.\n    \n    Returns:\n    int: The difference between the largest and smallest numbers.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    max_value = max(numbers)\n    min_value = min(numbers)\n    \n    return max_value - min_value", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"Returns the difference between the largest and smallest value in the list.\"\"\"\n    if not numbers:\n        raise ValueError(\"The list should not be empty.\")\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n    \n    Args:\n    nums (list): A list of numbers.\n    \n    Returns:\n    int: The difference between the largest and smallest number in the list.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list cannot be empty\")\n    \n    largest = max(nums)\n    smallest = min(nums)\n    \n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"Return the difference between the largest and smallest numbers in a list.\"\"\"\n    if not nums:\n        raise ValueError(\"The list cannot be empty\")\n    \n    largest = max(nums)\n    smallest = min(nums)\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    This function returns the difference between the largest and smallest \n    values in a given list.\n    \n    Parameters:\n    lst (list): A list of numerical values.\n    \n    Returns:\n    int or float: The difference between the largest and smallest value.\n    \"\"\"\n    if not lst:  # Check if the list is empty\n        raise ValueError(\"The list cannot be empty.\")\n    \n    largest = max(lst)\n    smallest = min(lst)\n    \n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Returns the difference between the largest and smallest values in a given list.\n    \n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int: The difference between the largest and smallest number.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty.\")\n    \n    largest = max(numbers)\n    smallest = min(numbers)\n    return largest - smallest", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 74.13333333333334, "dps_norm": 55.5, "pass@1": 26.0, "profiled": [{"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient C(n, k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients.\"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient C(n, k).\"\"\"\n    if k > n or k < 0:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients up to n.\"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient C(n, k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    num = den = 1\n    for i in range(k):\n        num *= (n - i)\n        den *= (i + 1)\n    return num // den\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients.\"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum", "matching_cluster_idx": 1}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        # Calculate the product of C(n, k) * C(n, k + 1)\n        product = comb(n, k) * comb(n, k + 1)\n        total_sum += product\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        # Calculate the product of consecutive binomial coefficients\n        product = comb(n, k) * comb(n, k + 1)\n        total_sum += product\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient C(n, k).\"\"\"\n    return math.comb(n, k)\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients.\"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        # Calculate the product of consecutive binomial coefficients\n        product = comb(n, k) * comb(n, k + 1)\n        total_sum += product\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient C(n, k)\"\"\"\n    return math.comb(n, k)\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients for n.\"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        # Calculate the product of consecutive binomial coefficients C(n, k) * C(n, k + 1)\n        product = comb(n, k) * comb(n, k + 1)\n        total_sum += product\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients\n    for a given integer n.\n    \n    Args:\n    n (int): The input integer to compute the sum of products of binomial coefficients.\n    \n    Returns:\n    int: The calculated sum.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        product = comb(n, k) * comb(n, k + 1)\n        total_sum += product\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        product = comb(n, k) * comb(n, k + 1)\n        total_sum += product\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        # Calculate the product of consecutive binomial coefficients\n        product = comb(n, k) * comb(n, k + 1)\n        total_sum += product\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}]}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 95.0, "profiled": [{"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverse the words in a given string.\n\n    :param input_string: A string containing words separated by spaces\n    :return: A string with the words in reverse order\n    \"\"\"\n    # Split the string into words\n    words = input_string.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list of words into a single string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string.\n    \n    :param s: A string containing words separated by spaces.\n    :return: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the words in the given string.\n    \n    Parameters:\n    s (str): A string containing words separated by spaces.\n    \n    Returns:\n    str: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into words and reverse the list of words\n    words = s.split()\n    reversed_words = words[::-1]\n    # Join the reversed list of words back into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words using spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list of words back into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the words in a given string separated by spaces.\n\n    Args:\n    s (str): The input string containing words to be reversed.\n\n    Returns:\n    str: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"Reverse the order of words in a given string.\"\"\"\n    # Split the string by spaces to get individual words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a single string with spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverse the words in a given string.\n\n    :param s: A string containing words separated by spaces.\n    :return: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    # Split the input string into words using spaces\n    words = input_string.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list of words back into a string with spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"Reverse the order of words in a given string.\"\"\"\n    words = s.split()  # Split the string into words\n    reversed_words = words[::-1]  # Reverse the list of words\n    return ' '.join(reversed_words)  # Join the reversed list into a string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the order of words reversed.\n    \"\"\"\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the words in the input string.\n\n    Parameters:\n    input_string (str): The string containing words to reverse.\n\n    Returns:\n    str: A new string with the words reversed.\n    \"\"\"\n    # Split the input string by spaces and reverse the list of words\n    reversed_words = input_string.split()[::-1]\n    # Join the reversed list of words back into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"Reverses the words in a given string separated by spaces.\"\"\"\n    # Split the string into words, reverse the list of words, and then join them back into a string\n    return ' '.join(input_string.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the words in the input string that are separated by spaces.\n\n    Args:\n        input_string (str): The string containing words to be reversed.\n\n    Returns:\n        str: A string with the words in reverse order.\n    \"\"\"\n    # Split the input string into words\n    words = input_string.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list of words back into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the words in a given string that are separated by spaces.\n\n    Args:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into words and reverse the list of words\n    words = s.split()\n    reversed_words = words[::-1]\n    # Join the reversed list of words into a single string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"Reverses the order of words in a given string.\"\"\"\n    # Split the string into words using space as the delimiter\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string with space as the delimiter\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverse the words in a given string separated by spaces.\n    \n    :param s: Input string\n    :return: String with words reversed\n    \"\"\"\n    # Split the string into words and reverse the list of words\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the words in a given string separated by spaces.\n\n    Args:\n    s (str): The input string containing words to be reversed.\n\n    Returns:\n    str: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverse the words in a given string separated by spaces.\n    \n    :param input_string: str, the string containing words to reverse\n    :return: str, the string with words in reverse order\n    \"\"\"\n    # Split the input string into words, reverse the list of words, and join them back into a string\n    return ' '.join(input_string.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string with spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    # Split the input string into words\n    words = input_string.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list of words back into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 11.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n-th column in the given matrix.\n\n    :param matrix: List of lists representing the matrix\n    :param n: Index of the column (0-based)\n    :return: Maximum value in the n-th column\n    \"\"\"\n    # Extract the n-th column using a list comprehension\n    nth_column = [row[n] for row in matrix if len(row) > n]\n    \n    # Return the maximum value from the n-th column\n    return max(nth_column) if nth_column else None", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of a matrix.\n    \n    Args:\n    matrix (list of lists): The input matrix.\n    n (int): The column index (0-based) to find the maximum value in.\n    \n    Returns:\n    int or float: The maximum value in the n-th column.\n    \"\"\"\n    # Extract the n-th column using a list comprehension\n    column_values = [row[n] for row in matrix if n < len(row)]\n    \n    # Return the maximum value from the column\n    return max(column_values)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value from the nth column of a given matrix.\n    \n    Parameters:\n    matrix (list of lists): The input matrix.\n    n (int): The index of the column for which to find the maximum value.\n    \n    Returns:\n    int or float: The maximum value in the nth column.\n    \"\"\"\n    # Extract the nth column and find its maximum\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix to be evaluated.\n    n (int): The index of the column to find the maximum value.\n\n    Returns:\n    int: The maximum value found in the nth column.\n    \"\"\"\n    # Extract the nth column using a list comprehension\n    nth_column = [row[n] for row in matrix if n < len(row)]\n    # Return the maximum value from the extracted column\n    return max(nth_column) if nth_column else None", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of a given matrix.\n\n    Parameters:\n    matrix (list of lists): A 2D list where each sublist represents a row.\n    n (int): The index of the column to find the maximum value from.\n\n    Returns:\n    int: The maximum value in the nth column.\n    \"\"\"\n    # Extract the nth column and find the maximum value\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function returns the maximum value from the n-th column of a given matrix.\n    \n    Parameters:\n    matrix (list of lists): The input matrix.\n    n (int): The column index (0-based) for which the maximum value is to be found.\n    \n    Returns:\n    int: The maximum value in the n-th column.\n    \n    Raises:\n    IndexError: If the column index n is out of range for any row in the matrix.\n    \"\"\"\n    # Check if matrix is empty\n    if not matrix or not matrix[0]:\n        raise ValueError(\"The matrix must not be empty.\")\n    \n    # Check if the column index is valid\n    for row in matrix:\n        if n >= len(row):\n            raise IndexError(f\"Column index {n} is out of range for the given matrix.\")\n\n    # Extract the n-th column and find the maximum value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the nth column in a matrix.\n\n    :param matrix: List of lists representing the matrix\n    :param n: Index of the column to find the maximum value from\n    :return: Maximum value in the nth column\n    \"\"\"\n    # Extract the nth column\n    nth_column = [row[n] for row in matrix if n < len(row)]\n    \n    # Return the maximum value from the extracted column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of a given matrix.\n    \n    :param matrix: List of lists representing the matrix\n    :param n: The index of the column to check\n    :return: Maximum value in the nth column\n    \"\"\"\n    # Extract the nth column using a list comprehension\n    nth_column = [row[n] for row in matrix if len(row) > n]\n    # Return the maximum value from the nth column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n    \n    :param matrix: List of lists representing the matrix\n    :param n: The column index (0-based) for which to find the maximum value\n    :return: The maximum value in the nth column\n    \"\"\"\n    # Extract the nth column using a list comprehension\n    column_values = [row[n] for row in matrix if len(row) > n]\n    \n    # Return the maximum value from the column\n    return max(column_values)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the nth column in the given matrix.\n\n    Parameters:\n    matrix (list of lists): A 2D list where each sublist represents a row.\n    n (int): The index of the column to check (0-based).\n\n    Returns:\n    int: The maximum value in the nth column.\n    \"\"\"\n    # Check if the matrix is empty\n    if not matrix or not matrix[0]:\n        return None  # Return None if the matrix is empty\n\n    # Extract the nth column and find its maximum value\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of a given matrix.\n\n    Parameters:\n    matrix (list of lists): The input matrix.\n    n (int): The column index (0-based) for which to find the maximum value.\n\n    Returns:\n    int: The maximum value in the nth column.\n    \"\"\"\n    # Extract the nth column from the matrix\n    nth_column = [row[n] for row in matrix if len(row) > n]\n    \n    # Return the maximum value from the nth column\n    return max(nth_column)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 38.95833333333333, "dps_norm": 43.75, "pass@1": 67.0, "profiled": [{"solution": "def replace_spaces(s: str) -> str:\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with whitespaces replaced by underscores and underscores replaced by whitespaces.\n    \"\"\"\n    return ''.join('_' if char == ' ' else ' ' if char == '_' else char for char in s)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string):\n    # Replace spaces with underscores and underscores with spaces\n    result = []\n    for char in input_string:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string):\n    # Create a new string with spaces replaced by underscores and underscores replaced by spaces\n    output_string = ''\n    for char in input_string:\n        if char == ' ':\n            output_string += '_'\n        elif char == '_':\n            output_string += ' '\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    # Replace spaces with underscores and underscores with spaces\n    return ''.join('_' if char == ' ' else ' ' if char == '_' else char for char in input_string)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    # Initialize an empty result string\n    result = []\n    \n    for char in s:\n        if char == ' ':\n            result.append('_')  # Replace space with underscore\n        elif char == '_':\n            result.append(' ')  # Replace underscore with space\n        else:\n            result.append(char)  # Keep other characters unchanged\n    \n    # Join the list into a single string and return\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string):\n    # Create a new string by replacing spaces with underscores and underscores with spaces\n    result = \"\"\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(input_string):\n    # Replace spaces with underscores and underscores with spaces\n    return ''.join('_' if char.isspace() else ' ' if char == '_' else char for char in input_string)", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n\n    Args:\n    input_string (str): The string to be processed.\n\n    Returns:\n    str: The processed string with whitespaces and underscores swapped.\n    \"\"\"\n    return ''.join('_' if char.isspace() else ' ' if char == '_' else char for char in input_string)", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    # Replace whitespaces with underscores and vice versa\n    output_string = ''\n    for char in input_string:\n        if char == ' ':\n            output_string += '_'\n        elif char == '_':\n            output_string += ' '\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(s: str) -> str:\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The modified string with whitespaces replaced by underscores and underscores replaced by whitespaces.\n    \"\"\"\n    return ''.join('_' if char.isspace() else ' ' if char == '_' else char for char in s)", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n\n    Parameters:\n    input_string (str): The input string to be modified.\n\n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Create a translation table\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    # Translate the input string using the translation table\n    return input_string.translate(translation_table)", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(s: str) -> str:\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The modified string with whitespaces and underscores swapped.\n    \"\"\"\n    return ''.join('_' if char.isspace() else ' ' if char == '_' else char for char in s)", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    # Create a new string to store the result\n    result = []\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        if char == ' ':\n            # Replace space with underscore\n            result.append('_')\n        elif char == '_':\n            # Replace underscore with space\n            result.append(' ')\n        else:\n            # Keep the character unchanged\n            result.append(char)\n    \n    # Join the list of characters into a single string and return it\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replace whitespaces with underscores and underscores with whitespaces in a given string.\"\"\"\n    # Create a translation table to swap characters\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    # Use the translate method to replace the characters\n    return input_string.translate(translation_table)", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(input_string):\n    # Create a new string where we replace spaces with underscores\n    # and underscores with spaces\n    output_string = ''\n    for char in input_string:\n        if char == ' ':\n            output_string += '_'\n        elif char == '_':\n            output_string += ' '\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(input_string):\n    # Create a new string where spaces are replaced with underscores\n    # and underscores are replaced with spaces\n    result = []\n    for char in input_string:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string):\n    # Initialize an empty list to collect characters\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in input_string:\n        if char == ' ':\n            result.append('_')  # Replace space with underscore\n        elif char == '_':\n            result.append(' ')  # Replace underscore with space\n        else:\n            result.append(char)  # Keep the character unchanged\n    \n    # Join the list into a string and return it\n    return ''.join(result)", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    # Create a new string to hold the transformed characters\n    transformed_string = ''\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        if char == ' ':\n            # Replace whitespace with underscore\n            transformed_string += '_'\n        elif char == '_':\n            # Replace underscore with whitespace\n            transformed_string += ' '\n        else:\n            # Keep other characters unchanged\n            transformed_string += char\n    \n    return transformed_string", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces.\n\n    Parameters:\n    input_string (str): The string to process.\n\n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Create a translation table\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    # Translate the input string using the translation table\n    return input_string.translate(translation_table)", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(input_string):\n    # Replace spaces with underscores and underscores with spaces\n    result = ''\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}]}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    Args:\n    lst (list): A list of integers.\n    \n    Returns:\n    list: A list with all zeroes moved to the end.\n    \"\"\"\n    # Initialize a list to hold non-zero elements\n    non_zero = [num for num in lst if num != 0]\n    \n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    \n    # Extend the non-zero list with zeroes\n    non_zero.extend([0] * zero_count)\n    \n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    :param lst: List of integers\n    :return: List with all zeroes moved to the end\n    \"\"\"\n    # Create a new list to hold non-zero elements\n    non_zeroes = [x for x in lst if x != 0]\n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    # Extend the non-zero list with zeroes\n    return non_zeroes + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    :param lst: List of integers\n    :return: List with all zeroes moved to the end\n    \"\"\"\n    # Create a new list for non-zero elements\n    non_zero_list = [num for num in lst if num != 0]\n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    # Extend the non-zero list with the zeroes\n    non_zero_list.extend([0] * zero_count)\n    return non_zero_list", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Initialize a list to hold non-zero elements\n    non_zero_elements = [x for x in lst if x != 0]\n    # Count the number of zero elements\n    zero_count = lst.count(0)\n    # Append the zero elements at the end\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Moves all zeroes in the input list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    arr (list): A list of integers\n    \n    Returns:\n    list: A new list with all zeroes moved to the end\n    \"\"\"\n    # Create a new list for non-zero elements\n    non_zero_elements = [x for x in arr if x != 0]\n    \n    # Count the number of zeroes\n    zero_count = arr.count(0)\n    \n    # Return the new list with non-zero elements followed by the zeroes\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes in the given list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (list): The input list containing integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    # Create a new list that only contains non-zero elements\n    non_zero_elements = [num for num in lst if num != 0]\n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    # Extend the non-zero list with zeroes at the end\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Parameters:\n    nums (list): The list of integers to process.\n\n    Returns:\n    list: The modified list with all zeroes moved to the end.\n    \"\"\"\n    non_zero_nums = [num for num in nums if num != 0]\n    zero_count = nums.count(0)\n    return non_zero_nums + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Parameters:\n    lst (list): The input list containing integers.\n\n    Returns:\n    list: The list with all zeroes moved to the end.\n    \"\"\"\n    # Filter out non-zero elements\n    non_zero_elements = [x for x in lst if x != 0]\n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    # Return the non-zero elements followed by the zeroes\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n    lst (list): A list of integers.\n\n    Returns:\n    list: A list with all zeroes moved to the end.\n    \"\"\"\n    # Create a new list for non-zero elements\n    non_zero_elements = [x for x in lst if x != 0]\n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    # Extend the non-zero elements list with the zeroes at the end\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Parameters:\n    nums (list): A list of integers which may contain zeroes.\n\n    Returns:\n    list: The list with all zeroes moved to the end.\n    \"\"\"\n    non_zero_nums = [num for num in nums if num != 0]\n    zero_count = nums.count(0)\n    return non_zero_nums + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of the given list while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (list): A list of integers\n    \n    Returns:\n    list: A list with all zeroes moved to the end\n    \"\"\"\n    # Create a new list to hold non-zero elements\n    non_zero = [x for x in lst if x != 0]\n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    # Extend the non-zero list by the number of zeroes\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Create a new list that will contain non-zero elements\n    non_zeroes = [num for num in lst if num != 0]\n    # Count the number of zeroes\n    zeroes_count = lst.count(0)\n    # Append zeroes to the end of the non-zero elements list\n    return non_zeroes + [0] * zeroes_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    :param lst: List of integers\n    :return: List with all zeroes moved to the end\n    \"\"\"\n    non_zeroes = [x for x in lst if x != 0]\n    zeroes = [0] * (len(lst) - len(non_zeroes))\n    return non_zeroes + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    Args:\n    lst (list): A list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero_elements = [num for num in lst if num != 0]\n    zero_count = lst.count(0)\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Move all zeroes to the end of the list while maintaining the order of non-zero elements.\n\n    Args:\n    arr (list): A list of integers which may contain zeroes.\n\n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zeroes = [x for x in arr if x != 0]  # Collect non-zero elements\n    zeroes = [0] * (len(arr) - len(non_zeroes))  # Count the zeroes\n    return non_zeroes + zeroes  # Combine non-zero elements with zeroes at the end", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list while maintaining the order\n    of non-zero elements.\n    \n    Args:\n    lst (list): A list of integers.\n\n    Returns:\n    list: The modified list with all zeroes moved to the end.\n    \"\"\"\n    # Initialize a list to hold non-zero elements\n    non_zero = [x for x in lst if x != 0]\n    # Count how many zeroes there are\n    zero_count = lst.count(0)\n    # Create the final list by adding non-zero elements and the zeroes at the end\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list while maintaining the order of non-zero elements.\n    \n    Args:\n    lst (list): The input list containing integers.\n    \n    Returns:\n    list: A list with all zeroes moved to the end.\n    \"\"\"\n    # Create a new list for non-zero elements\n    non_zero = [x for x in lst if x != 0]\n    \n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    \n    # Append the zeroes to the end of the non-zero list\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (list): The input list containing integers.\n    \n    Returns:\n    list: A list with all zeroes moved to the end.\n    \"\"\"\n    # Create a new list for non-zero elements\n    non_zero_list = [x for x in lst if x != 0]\n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    # Extend the non-zero list with the appropriate number of zeroes\n    return non_zero_list + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (list): The list to process.\n\n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    # Create a new list with all non-zero elements\n    non_zero_elements = [x for x in lst if x != 0]\n    # Count the number of zeroes in the original list\n    zero_count = lst.count(0)\n    # Append zeroes at the end of the non-zero elements\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n\n    Parameters:\n    lst (list): The list of integers.\n\n    Returns:\n    list: The list with all zeroes moved to the end.\n    \"\"\"\n    # Initialize a list to hold non-zero elements\n    non_zero = [num for num in lst if num != 0]\n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    # Extend the non-zero list with the zeroes\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 94.3089430894309, "dps_norm": 50.0, "pass@1": 22.0, "profiled": [{"solution": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]\n    \n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    \n    # Iterate through each pair of numbers\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]  # XOR the pair and add to total sum\n    \n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    \n    # Iterate through all unique pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]\n    \n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the XOR of the pair and add to xor_sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    total_xor_sum = 0\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += numbers[i] ^ numbers[j]  # Calculate XOR and add to sum\n            \n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n\n    # Iterate through each pair of indices\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]  # Compute XOR and add to total\n\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    \n    # Iterate through each pair of numbers in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the XOR of the pair and add to the total sum\n            total_xor_sum += arr[i] ^ arr[j]\n    \n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    \n    # Iterate through each pair (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]  # XOR and add to total\n            \n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_sum = 0\n    \n    # Iterate through all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += arr[i] ^ arr[j]  # Calculate XOR and add to total_sum\n    \n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_sum = 0\n    # Iterate through all pairs (i, j) with i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += arr[i] ^ arr[j]  # XOR and add to total_sum\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    # Iterate through all pairs of numbers\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]  # XOR of the pair (arr[i], arr[j])\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum of XORs to 0\n    xor_sum = 0\n    \n    # Iterate through all pairs of elements\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n\n    # Calculate XOR for every pair (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]\n\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    \n    # Iterate through all possible pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]\n    \n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_sum = 0\n    \n    # Loop through each pair of numbers\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += arr[i] ^ arr[j]  # Calculate XOR and add to total sum\n    \n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n\n    # Iterate through each pair of elements\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate XOR of the pair and add it to the total sum\n            total_xor_sum += arr[i] ^ arr[j]\n\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs in the given list.\n    \n    :param arr: List of integers\n    :param n: Length of the list\n    :return: Sum of XOR of all pairs\n    \"\"\"\n    total_sum = 0\n    \n    # Iterate through all pairs of indices\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += arr[i] ^ arr[j]\n    \n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_sum = 0\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += arr[i] ^ arr[j]  # Calculate XOR and add to the total sum\n            \n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    \n    # Calculate the XOR for all pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]\n    \n    return total_xor_sum", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 74.65425531914893, "dps_norm": 76.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the elements of an array up to the specified position k.\n\n    Parameters:\n    arr (list): The array to be reversed.\n    k (int): The position up to which the array should be reversed (1-indexed).\n\n    Returns:\n    list: The array with elements reversed up to the position k.\n    \"\"\"\n    # Ensure k does not exceed the length of the array\n    if k > len(arr):\n        k = len(arr)\n\n    # Reverse the elements up to k\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array `arr` up to the index `k`.\n    \n    Parameters:\n    arr (list): The array to reverse.\n    k (int): The position up to which the array should be reversed (1-indexed).\n    \n    Returns:\n    list: The array with elements reversed up to position `k`.\n    \"\"\"\n    # Convert k to 0-indexed\n    k -= 1\n    \n    # Reverse the segment of the array up to index k\n    return arr[:k + 1][::-1] + arr[k + 1:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the k-th position (1-based index).\n    \n    Parameters:\n    arr (list): The list to reverse.\n    k (int): The position up to which the array should be reversed (1-based index).\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    # Check if k is within the valid range\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k must be between 1 and the length of the array.\")\n    \n    # Reverse the first k elements\n    reversed_part = arr[:k][::-1]\n    # Concatenate the reversed part with the rest of the array\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position (1-indexed).\n    \n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The position up to which the list should be reversed (1-indexed).\n    \n    Returns:\n    list: The modified list with the elements reversed up to the k-th position.\n    \"\"\"\n    # Ensure k is within the bounds of the array length\n    if k > len(arr) or k < 1:\n        raise ValueError(\"k must be between 1 and the length of the array\")\n    \n    # Reverse the subarray from 0 to k-1 (0-indexed)\n    reversed_subarray = arr[:k][::-1]\n    # Concatenate the reversed subarray with the rest of the array\n    return reversed_subarray + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array 'arr' up to the index 'k'.\n\n    :param arr: List of elements to be reversed\n    :param k: Position up to which the array should be reversed\n    :return: The modified array with elements reversed up to position k\n    \"\"\"\n    if k > len(arr):\n        k = len(arr)  # If k is greater than array length, adjust it\n    \n    # Reverse the subarray from index 0 to k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the elements of the array up to the k-th position.\n\n    :param arr: List of elements to be reversed.\n    :param k: Position up to which to reverse the array (1-based index).\n    :return: The modified array with elements up to k reversed.\n    \"\"\"\n    # Adjust k to be 0-based for Python indexing\n    k = min(k, len(arr))  # Ensure k does not exceed the array length\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n\n    Parameters:\n    arr (list): The list of elements to reverse.\n    k (int): The position up to which the array should be reversed (1-based index).\n\n    Returns:\n    list: The modified array with elements reversed up to position k.\n    \"\"\"\n    if k > len(arr) or k < 1:\n        raise ValueError(\"k must be between 1 and the length of the array\")\n\n    # Reverse the subarray from the start to position k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n\n    Parameters:\n    arr (list): The list of elements to reverse.\n    k (int): The position up to which to reverse the array (1-based index).\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    # Adjust k for 0-based indexing\n    k = min(k, len(arr))  # Ensure k does not exceed array length\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position (1-indexed).\n    \n    Args:\n    arr (list): The array to be reversed.\n    k (int): The position up to which to reverse the array (1-indexed).\n    \n    Returns:\n    list: The array with elements reversed up to the k-th position.\n    \"\"\"\n    # Convert k from 1-indexed to 0-indexed\n    k = k - 1\n    # Reverse the segment of the array up to the k-th index\n    reversed_segment = arr[:k + 1][::-1]\n    # Combine the reversed segment with the rest of the array\n    return reversed_segment + arr[k + 1:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the k-th position.\n    \n    Parameters:\n    arr (list): The list to reverse.\n    k (int): The position up to which to reverse the list (1-based index).\n    \n    Returns:\n    list: The modified list with elements reversed up to the k-th position.\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k must be between 1 and the length of the array.\")\n\n    # Reverse the first k elements\n    reversed_part = arr[:k][::-1]\n    # Concatenate the reversed part with the rest of the array\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k (1-based index).\n    \n    :param arr: List of elements to be reversed.\n    :param k: Position up to which the array will be reversed (1-based index).\n    :return: List with elements reversed up to position k.\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k must be between 1 and the length of the array.\")\n    \n    # Reverse the first k elements\n    reversed_part = arr[:k][::-1]\n    \n    # Concatenate the reversed part with the rest of the array\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n    \n    Parameters:\n    arr (list): The input array to reverse.\n    k (int): The position up to which to reverse the array (1-based index).\n    \n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    # Convert k to a 0-based index\n    k = min(k, len(arr))  # Ensure k does not exceed the array length\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position (1-based index).\n    \n    Parameters:\n    arr (list): The list of elements to reverse.\n    k (int): The position up to which to reverse the list (1-based index).\n\n    Returns:\n    list: The list with elements reversed up to the k-th position.\n    \"\"\"\n    # Handle cases where k is out of bounds\n    if k > len(arr):\n        k = len(arr)\n    elif k < 1:\n        return arr  # If k is less than 1, return the array as is\n\n    # Reverse the subarray from the start to the k-th position\n    reversed_part = arr[:k][::-1]\n    rest_of_array = arr[k:]\n\n    return reversed_part + rest_of_array", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n    \n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The position up to which the list should be reversed (1-indexed).\n    \n    Returns:\n    list: The array with elements reversed up to the k-th position.\n    \"\"\"\n    if k > len(arr) or k < 1:\n        raise ValueError(\"k must be between 1 and the length of the array\")\n    \n    # Reverse the elements up to the k-th position\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Parameters:\n    arr (list): The input array to be reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array.\")\n\n    # Reverse the subarray from start to k-1 (inclusive)\n    reversed_part = arr[:k][::-1]\n    # Combine the reversed part with the rest of the array\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n\n    Parameters:\n    arr (list): The input array to be reversed up to position k.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    if k > len(arr):\n        k = len(arr)  # Adjust k if it exceeds array length\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n    \n    Parameters:\n    arr (list): The input array to reverse.\n    k (int): The position up to which to reverse the array (1-indexed).\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    # Validate k to ensure it is within the bounds of the array\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k must be between 1 and the length of the array\")\n    \n    # Reverse the first k elements\n    reversed_part = arr[:k][::-1]\n    # Combine the reversed part with the rest of the array\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the elements of an array up to a given position k.\n\n    Parameters:\n    arr (list): The input array to be reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    # Check if k is greater than the length of the array\n    if k > len(arr):\n        k = len(arr)\n    \n    # Reverse the sub-array from the start to k\n    reversed_subarray = arr[:k][::-1]\n    \n    # Concatenate the reversed sub-array with the remainder of the array\n    return reversed_subarray + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n\n    Parameters:\n    arr (list): The input array to be modified.\n    k (int): The position up to which to reverse the array.\n\n    Returns:\n    list: The array with elements reversed up to the k-th position.\n    \"\"\"\n    # Check if k is within the bounds of the array\n    if k > len(arr) or k < 1:\n        raise ValueError(\"k must be between 1 and the length of the array\")\n\n    # Reverse the sub-array from the start to the k-th position (exclusive of k)\n    arr[:k] = reversed(arr[:k])\n    return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the elements of the array up to the specified position k.\n\n    :param arr: List of elements to reverse\n    :param k: The position up to which to reverse the elements (1-based index)\n    :return: List with elements reversed up to position k\n    \"\"\"\n    # Check if k is greater than the length of the array\n    if k > len(arr):\n        raise ValueError(\"k should not be greater than the length of the array.\")\n\n    # Reverse the first k elements\n    reversed_part = arr[:k][::-1]\n    # Concatenate with the remaining elements\n    result = reversed_part + arr[k:]\n\n    return result", "matching_cluster_idx": 10}]}, "Mbpp/720": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to a tuple and returns a new tuple.\n\n    Args:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to be added.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple and the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the resulting tuple.\n    \n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to be added.\n    \n    Returns:\n    tuple: The resulting tuple with the dictionary added.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the new tuple.\n    \n    Args:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple containing the original tuple elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Add a dictionary to a tuple.\n    \n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing all elements of the original tuple and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(original_tuple, dictionary):\n    \"\"\"\n    Add a dictionary to the tuple.\n\n    Parameters:\n    original_tuple (tuple): The original tuple to which the dictionary will be added.\n    dictionary (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple that includes the original elements and the dictionary.\n    \"\"\"\n    return original_tuple + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to the tuple.\n    \n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to be added.\n    \n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(original_tuple, dictionary):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the new tuple.\n    \n    Args:\n    original_tuple (tuple): The original tuple to which the dictionary will be added.\n    dictionary (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing the original elements plus the dictionary.\n    \"\"\"\n    return original_tuple + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to a tuple and returns a new tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to be added.\n\n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Add a dictionary to the tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to which the dictionary will be added.\n    dictionary (dict): The dictionary to be added.\n\n    Returns:\n    tuple: A new tuple that includes the original tuple elements and the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Add a dictionary to a tuple and return the new tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to a tuple and returns a new tuple.\n    \n    Args:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the new tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Add a dictionary to a tuple and return a new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added.\n\n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(original_tuple, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n    \n    Args:\n    original_tuple (tuple): The tuple to which the dictionary will be added.\n    dictionary (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return original_tuple + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Add a dictionary to the tuple.\n    \n    Parameters:\n    input_tuple (tuple): The tuple to which the dictionary will be added.\n    input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple that includes the original tuple elements followed by the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Add a dictionary to the tuple.\n\n    Args:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary added as the last element.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n\n    Args:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns a new tuple.\n    \n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the resulting tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 64.72677595628414, "dps_norm": 70.0, "pass@1": 99.0, "profiled": [{"solution": "def extract_quotation(s):\n    \"\"\"\n    Extracts values between quotation marks from the given string.\n\n    Parameters:\n    s (str): The input string containing quoted values.\n\n    Returns:\n    list: A list of values found between quotation marks.\n    \"\"\"\n    import re\n    # Use regular expression to find all occurrences of text within quotation marks\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(input_string):\n    \"\"\"\n    Extract values between quotation marks from the given string.\n\n    Args:\n    input_string (str): The string to extract quoted values from.\n\n    Returns:\n    list: A list of strings found between quotation marks.\n    \"\"\"\n    import re\n    \n    # Use regular expression to find all occurrences of text within quotation marks\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(input_string):\n    import re\n    # Use a regular expression to find all substrings within quotation marks\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    \"\"\"Extracts values between quotation marks in the given string.\"\"\"\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    \"\"\"\n    Extract values between quotation marks \" \" from the given string.\n\n    :param s: Input string from which to extract quoted values.\n    :return: A list of strings found between quotation marks.\n    \"\"\"\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(input_string):\n    # List to hold extracted values\n    extracted_values = []\n    # Variable to track whether we are currently inside quotes\n    inside_quotes = False\n    # Variable to hold the current value being constructed\n    current_value = ''\n    \n    for char in input_string:\n        if char == '\"':\n            if inside_quotes:\n                # We are closing a quote; add the current value to the list\n                extracted_values.append(current_value)\n                current_value = ''\n            # Toggle the inside_quotes flag\n            inside_quotes = not inside_quotes\n        elif inside_quotes:\n            # If we are inside quotes, append the character to the current value\n            current_value += char\n    \n    return extracted_values", "matching_cluster_idx": 2}, {"solution": "def extract_quotation(s):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n\n    Args:\n    s (str): The input string from which to extract quoted values.\n\n    Returns:\n    list: A list of strings that were found within quotation marks.\n    \"\"\"\n    import re\n    \n    # Use regular expression to find all occurrences of text within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n    \n    Args:\n    s (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of values found between the quotation marks.\n    \"\"\"\n    import re\n    \n    # Using regex to find all occurrences of text within quotation marks\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(input_string):\n    \"\"\"\n    Extract values between quotation marks \" \" from the given string.\n\n    Args:\n        input_string (str): The string from which to extract quoted values.\n\n    Returns:\n        List[str]: A list of values found between quotation marks.\n    \"\"\"\n    import re\n    # Use regular expression to find all occurrences of text within quotes\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s: str) -> list:\n    \"\"\"\n    Extracts values between quotation marks in the given string.\n\n    Parameters:\n    s (str): The input string from which to extract quoted values.\n\n    Returns:\n    list: A list of extracted values from within quotation marks.\n    \"\"\"\n    import re\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(s):\n    \"\"\"\n    Extract values between quotation marks \" \" from the given string.\n    \n    Parameters:\n    s (str): The input string from which to extract quoted values.\n    \n    Returns:\n    List[str]: A list of strings extracted from within quotation marks.\n    \"\"\"\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    \"\"\"\n    Extracts values between quotation marks from the given string.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of strings found between the quotation marks.\n    \"\"\"\n    import re\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(input_string):\n    # Importing regular expressions library\n    import re\n    \n    # Using regular expression to find all occurrences of text within double quotes\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n\n    Args:\n    s (str): The input string from which to extract quoted values.\n\n    Returns:\n    list: A list of strings that were found between the quotation marks.\n    \"\"\"\n    import re\n    # Use a regular expression to find all occurrences of text within quotation marks\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(text):\n    \"\"\"\n    Extract values between quotation marks \" \" from the given string.\n\n    Args:\n    text (str): The input string containing quoted values.\n\n    Returns:\n    list: A list of extracted values between quotation marks.\n    \"\"\"\n    import re\n    # Use a regular expression to find all occurrences of text within quotation marks\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    \"\"\"\n    Extracts values between quotation marks in the given string.\n\n    Parameters:\n    s (str): The input string to extract values from.\n\n    Returns:\n    List[str]: A list of values found between quotation marks.\n    \"\"\"\n    import re\n    # Find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    \"\"\"Extracts values between quotation marks from the given string.\"\"\"\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts values between quotation marks \" \" from the given string.\n\n    Parameters:\n    s (str): The input string from which to extract quoted values.\n\n    Returns:\n    list: A list of strings found between quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    \"\"\"\n    Extract values between quotation marks \" \" from the given string.\n\n    Parameters:\n    s (str): The input string containing quoted values.\n\n    Returns:\n    list: A list of strings extracted from the quoted values.\n    \"\"\"\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    \"\"\"\n    Extracts values between quotation marks in the given string.\n    \n    Args:\n    s (str): The input string to extract values from.\n    \n    Returns:\n    list: A list of strings that are found between the quotation marks.\n    \"\"\"\n    import re\n    # Use regular expression to find all occurrences of text within quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}]}, "Mbpp/732": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with a colon\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with colons\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon in the input text.\n    \n    Parameters:\n    text (str): The input string to modify.\n    \n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \n    Parameters:\n    text (str): The input string to process.\n    \n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with a colon\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in the given text with a colon.\n    \n    Parameters:\n    text (str): The input string to process.\n    \n    Returns:\n    str: The processed string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Parameters:\n    text (str): The input string.\n\n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon in the given string.\n    \n    Args:\n    text (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon in the given text.\n    \n    Args:\n    text (str): The input string from which to replace characters.\n    \n    Returns:\n    str: The modified string with specified characters replaced by a colon.\n    \"\"\"\n    # Replace spaces, commas, and dots with a colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon in the given text.\n    \n    Args:\n    text (str): The input string to process.\n    \n    Returns:\n    str: The modified string with replacements.\n    \"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n    text (str): The input string.\n\n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with colons\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots in the input string with a colon.\n\n    Args:\n    text (str): The input string to process.\n\n    Returns:\n    str: The modified string with specified characters replaced by colons.\n    \"\"\"\n    # Replace spaces, commas, and dots with colons\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with a colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with colons\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with a colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots in the given text with a colon.\n\n    Args:\n    text (str): The input string.\n\n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with colons\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with colons\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in the input text with a colon.\n\n    Args:\n    text (str): The input string to be processed.\n\n    Returns:\n    str: The modified string with specified characters replaced by a colon.\n    \"\"\"\n    # Replace spaces, commas, and dots with a colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 86.9090909090909, "dps_norm": 73.33333333333334, "pass@1": 95.0, "profiled": [{"solution": "def tuple_to_dict(tup):\n    \"\"\"Convert a given tuple to a key-value dictionary using adjacent elements.\"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): A tuple containing elements where even indexed elements are keys \n                 and odd indexed elements are values.\n    \n    Returns:\n    dict: A dictionary with keys and values from the tuple.\n    \"\"\"\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Convert a given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    input_tuple (tuple): A tuple containing elements.\n    \n    Returns:\n    dict: A dictionary with adjacent elements as key-value pairs.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"The input tuple must contain an even number of elements.\")\n    \n    it = iter(input_tuple)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    :param tup: A tuple containing elements to be converted.\n    :return: A dictionary with keys and values from the tuple.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): A tuple of elements where elements at even indices become keys\n                 and elements at odd indices become values.\n    \n    Returns:\n    dict: A dictionary with keys and values formed from adjacent elements of the tuple.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The input tuple must contain an even number of elements.\")\n    \n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Parameters:\n    tup (tuple): A tuple with an even number of elements.\n\n    Returns:\n    dict: A dictionary created from the tuple.\n    \n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements.\")\n    \n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): A tuple of elements to be converted to a dictionary.\n    \n    Returns:\n    dict: A dictionary with keys and values from adjacent elements in the tuple.\n    \n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Create a dictionary by using slice to pair up adjacent elements\n    return {tup[i]: tup[i+1] for i in range(0, len(tup)-1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Convert the tuple to a list to access pairs of elements\n    it = iter(tup)\n    # Create a dictionary by zipping the iterator with itself offset by one\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    Args:\n    tup (tuple): A tuple of elements.\n    \n    Returns:\n    dict: A dictionary created from adjacent elements in the tuple.\n    \"\"\"\n    # Use dictionary comprehension to create the dictionary\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Create an empty dictionary\n    result_dict = {}\n    # Iterate over the tuple in steps of 2\n    for i in range(0, len(tup) - 1, 2):\n        # Use the current element as key and the next element as value\n        result_dict[tup[i]] = tup[i + 1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a given tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n    tup (tuple): A tuple containing elements to be converted.\n\n    Returns:\n    dict: A dictionary with adjacent elements of the tuple as key-value pairs.\n    \"\"\"\n    # Create an empty dictionary\n    result_dict = {}\n    \n    # Iterate through the tuple in steps of 2\n    for i in range(0, len(tup) - 1, 2):\n        key = tup[i]\n        value = tup[i + 1]\n        result_dict[key] = value\n    \n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"Convert a tuple to a dictionary using adjacent elements as key-value pairs.\"\"\"\n    # Ensure the tuple has an even number of elements for key-value pairs\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    # Create a dictionary using a dictionary comprehension\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"Convert a tuple to a dictionary using adjacent elements as key-value pairs.\"\"\"\n    if len(t) < 2:\n        return {}\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"Convert a tuple to a key-value dictionary using adjacent elements.\"\"\"\n    it = iter(tup)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): A tuple containing elements to be converted.\n\n    Returns:\n    dict: A dictionary with adjacent elements from the tuple as key-value pairs.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    # Ensure the tuple has an even number of elements to form key-value pairs\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements.\")\n    \n    # Create a dictionary using adjacent elements as key-value pairs\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a given tuple to a key-value dictionary using adjacent elements.\n\n    Args:\n    t (tuple): A tuple containing elements where adjacent elements represent key-value pairs.\n\n    Returns:\n    dict: A dictionary formed from the adjacent elements of the tuple.\n    \n    Example:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    # Create a dictionary from adjacent elements in the tuple\n    return {t[i]: t[i + 1] for i in range(0, len(t) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a given tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    Args:\n    tup (tuple): A tuple containing elements to be converted.\n    \n    Returns:\n    dict: A dictionary with adjacent tuple elements as key-value pairs.\n    \"\"\"\n    # Create a dictionary from the tuple using a comprehension\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"Convert a given tuple to a dictionary using adjacent elements.\"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements to form key-value pairs.\")\n    \n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Check if the length of the tuple is even, if not, ignore the last element\n    if len(tup) % 2 != 0:\n        tup = tup[:-1]\n    \n    # Convert the tuple to a dictionary using adjacent elements\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}]}, "Mbpp/744": {"dps": 32.054794520547944, "dps_norm": 50.833333333333336, "pass@1": 100.0, "profiled": [{"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    input_tuple (tuple): The tuple to check.\n    \n    Returns:\n    bool: True if there is at least one None value, otherwise False.\n    \"\"\"\n    return any(item is None for item in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Checks if the given tuple contains any None values.\n\n    Args:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    tup (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Checks if the given tuple has any None values.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None values.\n\n    Parameters:\n    tup (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return any(elem is None for elem in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"Check if the given tuple contains any None values.\"\"\"\n    return any(item is None for item in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n        input_tuple (tuple): The tuple to check.\n    \n    Returns:\n        bool: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    input_tuple (tuple): The tuple to check.\n\n    Returns:\n    bool: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    input_tuple (tuple): The tuple to check for None values.\n    \n    Returns:\n    bool: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    input_tuple (tuple): The tuple to check.\n\n    Returns:\n    bool: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    input_tuple (tuple): The tuple to check.\n\n    Returns:\n    bool: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"Check if the given tuple has any None value.\n\n    Args:\n        t (tuple): The tuple to check.\n\n    Returns:\n        bool: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"Check if the given tuple contains any None value.\"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    input_tuple (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    input_tuple (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"Check if the given tuple has any None value.\"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    :param tup: A tuple to check for None values.\n    :return: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return any(value is None for value in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    input_tuple (tuple): The tuple to check.\n\n    Returns:\n    bool: True if the tuple contains None, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"Check if the given tuple has any None values.\"\"\"\n    return any(item is None for item in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    tup (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if there is at least one None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}]}, "Mbpp/750": {"dps": 71.63265306122449, "dps_norm": 74.16666666666667, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Args:\n    lst (list): The list to which the elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with elements from the tuple appended.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list containing the original elements plus the tuple elements.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"Adds the elements of a tuple to the end of a list.\"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple to the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: The list after adding the elements of the tuple.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to add to the list.\n\n    Returns:\n    list: The updated list with the elements of the tuple added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the given tuple to the given list and return the new list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tup (tuple): The tuple that will be added to the list.\n\n    Returns:\n    list: The updated list with elements of the tuple added.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with elements of the tuple added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the elements of the tuple added.\n    \"\"\"\n    # Extend the list with the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The list with the elements of the tuple added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list containing the elements of the tuple.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Add the given tuple to the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to add to the list.\n    \n    Returns:\n    list: The updated list with the tuple elements added.\n    \"\"\"\n    lst.extend(tpl)  # Extend the list by appending elements from the tuple\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"Add the elements of the tuple to the end of the list.\"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    This function adds the elements of a tuple to a list.\n    \n    Parameters:\n    lst (list): The original list to which elements will be added.\n    tpl (tuple): The tuple containing elements to add to the list.\n    \n    Returns:\n    list: The updated list with elements from the tuple added.\n    \"\"\"\n    # Extend the list with elements from the tuple\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"Add the elements of a tuple to a list and return the new list.\"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which elements will be added.\n    tup (tuple): The tuple containing elements to be added to the list.\n    \n    Returns:\n    list: The updated list with elements from the tuple added.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Add the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to add to the list.\n\n    Returns:\n    list: The updated list with elements from the tuple added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"Add the given tuple to the given list.\"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Args:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple containing elements to be added.\n\n    Returns:\n    list: The updated list with elements from the tuple added.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The list with the elements of the tuple added.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tup (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: A new list containing elements of the original list followed by elements of the tuple.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 1}]}, "Mbpp/753": {"dps": 39.73154362416108, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def min_k(records, k):\n    \"\"\"\n    Find minimum k records from a list of tuples based on the second element.\n    \n    Parameters:\n    records (list of tuples): A list of tuples where each tuple contains a name and a number.\n    k (int): The number of minimum records to return.\n    \n    Returns:\n    list of tuples: A list containing the k records with the smallest second elements.\n    \"\"\"\n    # Sort the records based on the second element of the tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Function to find minimum k records from a tuple list.\n    \n    Parameters:\n    records (list): A list of tuples where each tuple contains a name and a score.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list: A list of the k records with the smallest scores.\n    \"\"\"\n    # Sort the records based on the score (second element of the tuple)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find minimum k records from a list of tuples.\n\n    Parameters:\n    records (list of tuples): A list of tuples where each tuple contains a name and a number.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: A list containing the k records with the smallest numbers.\n    \"\"\"\n    # Sort the records based on the second element of the tuple (the number)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k,\n    and returns the k records with the smallest second elements.\n    \n    Parameters:\n    records (list of tuples): A list where each tuple contains a name and a score.\n    k (int): The number of records to return.\n\n    Returns:\n    list of tuples: The k records with the smallest scores.\n    \"\"\"\n    # Sort the records by the second element (score) in each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    This function returns the minimum k records from a list of tuples based on the second element of each tuple.\n    \n    :param records: List of tuples, where each tuple contains a name and a corresponding value.\n    :param k: Integer, the number of minimum records to return.\n    :return: List of tuples containing the k records with the smallest second elements.\n    \"\"\"\n    # Sort the records based on the second element of the tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    This function finds the minimum k records from a list of tuples based on the second element of each tuple.\n    \n    :param records: List of tuples, where each tuple contains a name and an integer.\n    :param k: The number of minimum records to return.\n    :return: A list of the k tuples with the smallest integer values.\n    \"\"\"\n    # Sort the records based on the second element of each tuple (the integer value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element.\n    \n    Args:\n    records (list of tuple): A list of tuples where each tuple contains a name and a value.\n    k (int): The number of minimum records to return.\n    \n    Returns:\n    list of tuple: A list containing the minimum k records sorted by the second element.\n    \"\"\"\n    # Sort the records by the second element (the value) and then return the first k records.\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find minimum k records from a list of tuples.\n\n    :param records: List of tuples where each tuple contains a name and a value.\n    :param k: The number of minimum records to retrieve.\n    :return: A list of the k records with the smallest values.\n    \"\"\"\n    # Sort the records based on the second element of the tuples (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element.\n\n    Parameters:\n    records (list of tuples): A list of tuples where each tuple contains a name and a score.\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list of tuples: A list containing the k tuples with the smallest second elements.\n    \"\"\"\n    # Sort the records based on the second element of the tuples (the score)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    This function returns the minimum k records based on the second element of the tuples.\n    \n    :param records: List of tuples, where each tuple contains (name, value)\n    :param k: The number of minimum records to return\n    :return: A list of the k tuples with the smallest second element\n    \"\"\"\n    # Sort records based on the second element of the tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Function to find the minimum k records from a list of tuples.\n\n    Parameters:\n    records (list of tuples): List of tuples containing records.\n    k (int): Number of minimum records to return.\n\n    Returns:\n    list of tuples: Minimum k records sorted by their second element.\n    \"\"\"\n    # Sort records by the second element of the tuples\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records based on the second element of each tuple.\n\n    Parameters:\n    records (list): A list of tuples, where each tuple contains (name, value).\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list: A list of tuples containing the k minimum records.\n    \"\"\"\n    # Sort the records based on the second element of the tuples (the values)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find minimum k records from a tuple list based on the second element of each tuple.\n\n    Parameters:\n    records (list of tuple): A list of tuples where each tuple contains a name and a score.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuple: A list containing the minimum k records sorted by the score.\n    \"\"\"\n    # Sort the records based on the second element (the score)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Parameters:\n    records (list of tuples): A list of tuples where each tuple contains a name and a value.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: A list of the k tuples with the smallest second element.\n    \"\"\"\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Parameters:\n    records (list of tuple): A list of tuples where each tuple contains a name and a score.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuple: A list containing the k tuples with the smallest second elements.\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find minimum k records from a tuple list.\n\n    :param records: List of tuples, where each tuple contains (name, value)\n    :param k: Number of minimum records to return\n    :return: List of k tuples with the smallest values\n    \"\"\"\n    # Sort the records based on the second element of the tuples (the values)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples.\n\n    Args:\n    records (list of tuples): A list of tuples where each tuple contains a name and a score.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: The minimum k records based on the second element of each tuple.\n    \"\"\"\n    # Sort records based on the second element (score) of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a tuple list based on the second element of the tuples.\n    \n    Parameters:\n    records (list of tuple): List containing tuples where each tuple has two elements.\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list of tuple: The list containing the minimum k records.\n    \"\"\"\n    # Sort records based on the second element (the value) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of the tuple.\n\n    Parameters:\n    records (list of tuples): A list where each tuple contains a name and a score.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: A list containing the minimum k records sorted by the score.\n    \"\"\"\n    # Sort the records based on the score (second element of the tuple) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples.\n\n    Args:\n    records (list of tuple): A list of tuples where each tuple contains a name and a score.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuple: A list of the k records with the smallest scores, sorted by score.\n    \"\"\"\n    # Sort the records based on the score (second item of the tuple)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 1}]}, "Mbpp/754": {"dps": 90.6896551724138, "dps_norm": 88.75, "pass@1": 100.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function takes three lists as input and returns a list of elements \n    that are common among the three lists at the same indices.\n\n    Parameters:\n    l1 (list): The first list\n    l2 (list): The second list\n    l3 (list): The third list\n\n    Returns:\n    list: A list of common elements at the same index\n    \"\"\"\n    common_elements = []\n    \n    # Iterate through the indices of the shortest list to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Find the minimum length of the three lists to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the index range of the shortest list\n    for i in range(min_length):\n        # Check if elements at the same index in all three lists are equal\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])  # or l2[i] or l3[i] since they are the same\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function takes three lists and returns a list of elements that \n    are common in all three lists at the same index.\n    \n    :param l1: First list\n    :param l2: Second list\n    :param l3: Third list\n    :return: List of common elements found at the same index in all three lists\n    \"\"\"\n    common_elements = []\n    \n    # Find the minimum length of the three lists to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists at the same index.\n    \n    Args:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n    \n    Returns:\n    list: A list of common elements found at the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    # Iterate through the indices of the shortest list to avoid index errors\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate over the indices of the lists, assuming they are of the same length\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Use zip to iterate through the three lists simultaneously\n    for a, b, c in zip(l1, l2, l3):\n        # Check if the elements at the current index are the same\n        if a == b == c:\n            common_elements.append(a)\n    \n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    # Iterate through the indices of the lists\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"Finds common elements in three lists at the same index.\"\"\"\n    return [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function takes three lists as input and returns a list of elements that \n    are common among the three lists at the same indices.\n    \n    Parameters:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n    \n    Returns:\n    list: A list of common elements found at the same index in all three lists.\n    \"\"\"\n    # Use list comprehension to find common elements at the same index\n    common_elements = [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function finds common elements from three lists l1, l2, and l3\n    that appear at the same indices and returns them as a list.\n    \n    Args:\n    l1 (list): The first list of elements.\n    l2 (list): The second list of elements.\n    l3 (list): The third list of elements.\n    \n    Returns:\n    list: A list of common elements found at the same indices in all three lists.\n    \"\"\"\n    common_elements = []\n    # Iterate over the indices of the lists\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # Check if the elements at index i are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Using list comprehension to find common elements at the same index\n    return [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to hold common elements\n    common_elements = []\n    \n    # Iterate through the indices of the lists\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # Check if the elements at the same index are equal\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear under the same index.\n    \n    Args:\n    l1, l2, l3: Lists of elements.\n\n    Returns:\n    A list containing elements that are common to all three lists at the same index.\n    \"\"\"\n    # Use a list comprehension to find common elements at the same index\n    common_elements = [l1[i] for i in range(min(len(l1), len(l2), len(l3))) \n                       if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear in the same index.\n    \n    Parameters:\n    l1 (list): First list.\n    l2 (list): Second list.\n    l3 (list): Third list.\n    \n    Returns:\n    list: A list of common elements from all three lists at the same indices.\n    \"\"\"\n    common_elements = []\n    \n    # Find the minimum length of the lists to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"Finds common elements from three lists that appear at the same index.\n\n    Args:\n    l1 (list): The first list of elements.\n    l2 (list): The second list of elements.\n    l3 (list): The third list of elements.\n\n    Returns:\n    list: A list containing elements that are common in all three lists at the same index.\n    \"\"\"\n    common_elements = []\n    # Iterate through the indices of the shortest list to avoid IndexError\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function takes three lists as input and returns a list of elements that are common\n    across all three lists at the same indices.\n    \n    Parameters:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n\n    Returns:\n    list: A list of common elements at the same indices in all three lists.\n    \"\"\"\n    common_elements = []\n    \n    # Iterate through the lists using zip to pair elements from each list\n    for a, b, c in zip(l1, l2, l3):\n        if a == b == c:  # Check if the elements are the same\n            common_elements.append(a)  # If they are, add to the result list\n    \n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Use a list comprehension to find elements that are the same in all three lists at the same index\n    return [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function finds common elements from three lists l1, l2, and l3\n    that appear at the same index in all three lists. It returns a list\n    of these common elements.\n    \n    :param l1: First list of elements\n    :param l2: Second list of elements\n    :param l3: Third list of elements\n    :return: A list of common elements at the same index\n    \"\"\"\n    # Use a list comprehension to find common elements at the same index\n    common_elements = [l1[i] for i in range(min(len(l1), len(l2), len(l3))) \n                       if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find elements that are common for lists l1, l2, l3 \n    if they appear at the same index in all three lists.\n    \n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n    l3 (list): Third list of elements.\n    \n    Returns:\n    list: A list of common elements at the same indices.\n    \"\"\"\n    # Use list comprehension to find common elements at the same indices\n    common_elements = [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function takes three lists and returns a list of elements that\n    are common to all three lists at the same index.\n    \n    Args:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n    \n    Returns:\n    list: A list of common elements at the same index.\n    \"\"\"\n    common_elements = []\n    \n    # Iterate over the indices of the shortest list\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 91.85840707964601, "dps_norm": 96.66666666666667, "pass@1": 22.0, "profiled": [{"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # If there are less than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the second smallest number\n    return sorted_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting to a set and back to a sorted list\n    unique_numbers = sorted(set(numbers))\n    # Return the second smallest number if it exists\n    return unique_numbers[1] if len(unique_numbers) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Create a set to store unique numbers\n    unique_numbers = set(numbers)\n    \n    # If there are less than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the second smallest number\n    return sorted_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"Return the second smallest number in the list.\"\"\"\n    # Create a set to remove duplicates\n    unique_numbers = set(numbers)\n    \n    # If there are less than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Remove the smallest number\n    unique_numbers.remove(min(unique_numbers))\n    \n    # Return the new minimum, which is the second smallest\n    return min(unique_numbers)", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set\n    unique_numbers = list(set(numbers))\n    \n    # If there are less than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n\n    # Sort the unique numbers\n    unique_numbers.sort()\n    \n    # Return the second smallest number\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting to a set\n    unique_numbers = list(set(numbers))\n    \n    # If there are less than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers\n    unique_numbers.sort()\n    \n    # Return the second smallest number\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set\n    unique_numbers = list(set(numbers))\n    \n    # If there are less than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers\n    unique_numbers.sort()\n    \n    # Return the second smallest number\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set\n    unique_numbers = list(set(numbers))\n    \n    # If there are fewer than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers\n    unique_numbers.sort()\n    \n    # Return the second smallest\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting to a set\n    unique_numbers = set(numbers)\n    \n    # If there are less than 2 unique numbers, we cannot find the second smallest\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers and return the second smallest\n    sorted_numbers = sorted(unique_numbers)\n    return sorted_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates and sort the list\n    unique_numbers = sorted(set(numbers))\n    \n    # Check if there are at least two unique numbers\n    if len(unique_numbers) < 2:\n        return None  # or raise an exception if desired\n    \n    # Return the second smallest number\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # If there are less than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Convert the set back to a sorted list\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the second smallest number\n    return sorted_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Initialize two variables to hold the smallest and second smallest values\n    first = second = float('inf')\n    \n    for number in numbers:\n        # If the current number is less than the first smallest\n        if number < first:\n            second = first  # Update second to be the old first\n            first = number   # Update first to the new smallest\n        # If the current number is between first and second\n        elif first < number < second:\n            second = number\n            \n    # If second is still infinity, it means we didn't find a valid second smallest\n    if second == float('inf'):\n        return None  # Or raise an error depending on your requirements\n    \n    return second", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting to a set, then back to a list\n    unique_numbers = list(set(numbers))\n    \n    # Sort the unique numbers\n    unique_numbers.sort()\n    \n    # Return the second smallest number if it exists\n    return unique_numbers[1] if len(unique_numbers) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # If there are fewer than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers and return the second smallest\n    sorted_numbers = sorted(unique_numbers)\n    return sorted_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting to a set and then back to a list\n    unique_numbers = list(set(numbers))\n    \n    # If there are less than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers\n    unique_numbers.sort()\n    \n    # Return the second smallest number\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # If there are less than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Remove the smallest number to find the second smallest\n    unique_numbers.remove(min(unique_numbers))\n    \n    # Return the smallest number from the remaining numbers, which is the second smallest\n    return min(unique_numbers)", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n\n    # If there are less than 2 unique numbers, return None or raise an error\n    if len(unique_numbers) < 2:\n        return None\n\n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n\n    # Return the second smallest number\n    return sorted_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set\n    unique_numbers = list(set(numbers))\n    \n    # If there are less than 2 unique numbers, we can't find a second smallest\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers\n    unique_numbers.sort()\n    \n    # Return the second smallest number\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # If there are less than two unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n\n    # Sort the unique numbers and return the second smallest\n    sorted_numbers = sorted(unique_numbers)\n    return sorted_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Function to find the second smallest number in a list.\n    If there are not enough unique elements, it returns None.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_numbers = list(set(numbers))\n    \n    # Check if we have at least two unique numbers\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers\n    unique_numbers.sort()\n    \n    # Return the second smallest number\n    return unique_numbers[1]", "matching_cluster_idx": 5}]}, "Mbpp/757": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/758": {"dps": 84.6042471042471, "dps_norm": 83.125, "pass@1": 100.0, "profiled": [{"solution": "def unique_sublists(lst):\n    count_dict = {}\n    \n    for sublist in lst:\n        # Convert the sublist to a tuple\n        sublist_tuple = tuple(sublist)\n        \n        # Count occurrences\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n            \n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n    \n    Parameters:\n    lst (list of lists): The input list containing sublists.\n    \n    Returns:\n    dict: A dictionary with tuples as keys representing the sublists\n          and their corresponding counts as values.\n    \"\"\"\n    count_dict = {}\n    \n    for sublist in lst:\n        # Convert the sublist to a tuple for immutability and hashability\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n            \n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(input_list):\n    \"\"\"\n    Count lists within a list and return a dictionary where every list is converted to a tuple\n    and the value of such tuple is the number of its occurrences in the original list.\n\n    :param input_list: List of lists to be counted.\n    :return: Dictionary with tuples as keys and their counts as values.\n    \"\"\"\n    count_dict = {}\n    \n    for sublist in input_list:\n        # Convert the sublist to a tuple\n        sublist_tuple = tuple(sublist)\n        # Count occurrences\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(nested_list):\n    \"\"\"\n    Count the occurrences of each list within a list.\n    \n    Parameters:\n    nested_list (list of list): A list containing lists to count.\n    \n    Returns:\n    dict: A dictionary where each unique list is converted to a tuple,\n          and the value is the number of occurrences of that list.\n    \"\"\"\n    count_dict = {}\n    for sublist in nested_list:\n        # Convert the list to a tuple to use as a dictionary key\n        key = tuple(sublist)\n        if key in count_dict:\n            count_dict[key] += 1\n        else:\n            count_dict[key] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the count of each sublist\n    count_dict = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to make it hashable\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            # Otherwise, add it to the dictionary with a count of 1\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"Count occurrences of each sublist in a list and return as a dictionary.\"\"\"\n    count_dict = {}\n    \n    for sublist in lst:\n        # Convert the sublist to a tuple to use as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # Increment the count for the tuple\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Count occurrences of lists within a list.\n    \n    Parameters:\n    lst (list): A list containing sublists to be counted.\n    \n    Returns:\n    dict: A dictionary where each unique sublist (as a tuple) is a key,\n          and its occurrence count in the original list is the value.\n    \"\"\"\n    from collections import Counter\n    \n    # Convert each sublist to a tuple\n    tuple_list = [tuple(sublist) for sublist in lst]\n    \n    # Count occurrences of each tuple\n    count = Counter(tuple_list)\n    \n    # Return the dictionary of counts\n    return dict(count)", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    This function takes a list of lists as input and returns a dictionary \n    where each unique list is converted to a tuple and its value \n    represents the number of occurrences in the original list.\n    \n    Args:\n    lst (list of list): A list containing lists to count.\n    \n    Returns:\n    dict: A dictionary with tuples as keys and their occurrence counts as values.\n    \"\"\"\n    count_dict = {}\n    \n    for sublist in lst:\n        # Convert the sublist to a tuple\n        tuple_sublist = tuple(sublist)\n        # Count occurrences\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n            \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(nested_list):\n    \"\"\"\n    Write a function to count lists within a list. The function should return a dictionary\n    where every list is converted to a tuple and the value of such tuple is the number of its \n    occurrences in the original list.\n    \n    :param nested_list: List of lists to be counted\n    :return: Dictionary with tuples as keys and their occurrences as values\n    \"\"\"\n    count_dict = {}\n    \n    for sublist in nested_list:\n        # Convert sublist to a tuple to use as a dictionary key\n        tuple_key = tuple(sublist)\n        if tuple_key in count_dict:\n            count_dict[tuple_key] += 1\n        else:\n            count_dict[tuple_key] = 1\n    \n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Count occurrences of lists within a list, returning a dictionary \n    where each list is converted to a tuple.\n    \n    Args:\n    lst (list): A list of lists to be counted.\n    \n    Returns:\n    dict: A dictionary where keys are tuples representing the lists, \n          and values are the counts of those lists in the original list.\n    \"\"\"\n    count_dict = {}\n    for sublist in lst:\n        # Convert the list to a tuple for use as a dictionary key\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(input_list):\n    \"\"\"\n    Count occurrences of sublists within a list.\n    \n    Args:\n        input_list (list of list): A list containing sublists.\n    \n    Returns:\n        dict: A dictionary where each unique sublist is a tuple and its value is the count of occurrences.\n    \"\"\"\n    count_dict = {}\n    \n    for sublist in input_list:\n        # Convert the list to a tuple for immutability and as a key\n        sublist_tuple = tuple(sublist)\n        \n        # Count occurrences\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Count occurrences of lists within a list and return a dictionary\n    with tuples as keys representing the lists and their counts as values.\n\n    :param lst: List of lists to count.\n    :return: Dictionary with tuple representations of lists as keys and their counts as values.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        # Convert the list to a tuple so it can be used as a key in the dictionary\n        key = tuple(sublist)\n        # Increment the count for the key in the dictionary\n        if key in counts:\n            counts[key] += 1\n        else:\n            counts[key] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(input_list):\n    \"\"\"\n    Count occurrences of sublists in a list and return a dictionary\n    where each sublist is represented as a tuple.\n\n    Parameters:\n    input_list (list): A list of lists.\n\n    Returns:\n    dict: A dictionary with tuples as keys and their counts as values.\n    \"\"\"\n    count_dict = {}\n    \n    for sublist in input_list:\n        # Convert the sublist to a tuple\n        sublist_tuple = tuple(sublist)\n        \n        # Count occurrences using dictionary\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n            \n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Create a dictionary to hold the counts\n    counts = {}\n    \n    # Iterate over the lists in the input list\n    for sublist in lst:\n        # Convert the list to a tuple\n        sublist_tuple = tuple(sublist)\n        # Update the count in the dictionary\n        if sublist_tuple in counts:\n            counts[sublist_tuple] += 1\n        else:\n            counts[sublist_tuple] = 1\n    \n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Count occurrences of lists within a list and return a dictionary \n    where each list is converted to a tuple.\n\n    Args:\n    lst (list): A list containing sublists.\n\n    Returns:\n    dict: A dictionary with tuples as keys and their counts as values.\n    \"\"\"\n    count_dict = {}\n    \n    for sublist in lst:\n        # Convert list to tuple for hashing\n        key = tuple(sublist)\n        if key in count_dict:\n            count_dict[key] += 1\n        else:\n            count_dict[key] = 1\n            \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    This function takes a list of lists and returns a dictionary where each unique list\n    is converted to a tuple and the value is the count of its occurrences in the original list.\n\n    :param lst: List of lists\n    :return: Dictionary with tuples as keys and their occurrences as values\n    \"\"\"\n    count_dict = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple\n        sublist_tuple = tuple(sublist)\n        # Increment the count for this tuple\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(nested_list):\n    \"\"\"\n    Count occurrences of lists within a list. Convert each inner list to a tuple\n    and return a dictionary with tuples as keys and their counts as values.\n    \n    Parameters:\n    nested_list (list of list): A list containing lists to be counted.\n    \n    Returns:\n    dict: A dictionary where keys are tuples (converted from lists) and values are counts.\n    \"\"\"\n    count_dict = {}\n    \n    for sublist in nested_list:\n        # Convert the list to a tuple for immutability and hashing\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts occurrences of each sublist in the list and returns a dictionary\n    where the keys are tuples of the sublists and the values are their counts.\n\n    Args:\n    lst (list of list): A list of lists.\n\n    Returns:\n    dict: A dictionary with tuples as keys and their counts as values.\n    \"\"\"\n    count_dict = {}\n    \n    for sublist in lst:\n        # Convert the sublist to a tuple\n        tuple_sublist = tuple(sublist)\n        \n        # Count occurrences using the dictionary\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n            \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Count occurrences of lists within a list, returning a dictionary where\n    each list is converted to a tuple and the value is the number of its occurrences.\n    \n    Args:\n    lst (list of list): A list containing sublists.\n\n    Returns:\n    dict: A dictionary where keys are tuples of sublists and values are their counts.\n    \"\"\"\n    count_dict = {}\n    \n    for sublist in lst:\n        # Convert sublist to a tuple to use it as a dictionary key\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n            \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    \n    for sublist in lst:\n        # Convert the list to a tuple so it can be used as a dictionary key\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n            \n    return count_dict", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 99.27007299270073, "dps_norm": 87.5, "pass@1": 44.0, "profiled": [{"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether the list contains only one distinct element.\n    \n    :param numbers: List of numbers\n    :return: True if only one distinct element, False otherwise\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if the list of numbers contains only one distinct element.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        bool: True if the list has only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if the given list of numbers contains only one distinct element.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"Check whether the list contains only one distinct element.\"\"\"\n    if not lst:  # Check if the list is empty\n        return False\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not numbers:  # Handle empty list case\n        return False\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Check whether the list contains only one distinct element.\n    \n    :param nums: List of numbers\n    :return: True if there is only one distinct element, otherwise False\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    bool: True if there is only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:  # handle the case of an empty list\n        return False\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    bool: True if there is only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"Check if the list contains only one distinct element.\"\"\"\n    if not numbers:  # Handle empty list case\n        return False\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"Check if a list contains only one distinct element.\"\"\"\n    if not numbers:  # Check if the list is empty\n        return False\n    return len(set(numbers)) == 1  # Use a set to check for distinct elements", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Check whether the list of numbers contains only one distinct element.\n\n    Parameters:\n    nums (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle the case of an empty list\n        return False\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if the list contains only one distinct element.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n\n    Returns:\n    bool: True if there is only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Parameters:\n    numbers (list): A list of numbers to check.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Convert the list to a set to get distinct elements\n    distinct_elements = set(numbers)\n    # Check if there is only one distinct element\n    return len(distinct_elements) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    bool: True if there is only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Checks whether a list of numbers contains only one distinct element.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    bool: True if there is only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Checks whether the list contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:  # Check if the list is empty\n        return False\n    return len(set(lst)) == 1  # A set will have only one element if all are the same", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    bool: True if there is only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether the list of numbers contains only one distinct element.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    bool: True if there is only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(s):\n    \"\"\"Count the number of digits in the given string.\"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Parameters:\n    input_string (str): The string to be analyzed.\n\n    Returns:\n    int: The count of digits in the input string.\n    \"\"\"\n    return sum(char.isdigit() for char in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"Count the number of digits in the given string.\"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"Count the number of digits in the given string.\"\"\"\n    return sum(1 for char in input_string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in the given string.\n    \n    :param input_string: The string to be examined\n    :return: The count of digit characters in the string\n    \"\"\"\n    return sum(c.isdigit() for c in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Parameters:\n    input_string (str): The string to be analyzed.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    :param input_string: The string to be analyzed\n    :return: The count of digits in the string\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in the given string.\n\n    :param s: Input string\n    :return: Count of digits in the string\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"Count the number of digits in the given string.\"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"Count the number of digits in the given string.\"\"\"\n    return sum(c.isdigit() for c in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Parameters:\n    input_string (str): The string to be checked for digits.\n\n    Returns:\n    int: The count of digits in the input string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"Counts the number of digits in the given string.\"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Parameters:\n    input_string (str): The string to be evaluated.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    digit_count = sum(1 for char in input_string if char.isdigit())\n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"Count the number of digits in the input string.\"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Parameters:\n    input_string (str): The string to be analyzed.\n\n    Returns:\n    int: The count of digits in the input string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Parameters:\n    s (str): The string to be evaluated.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"Count the number of digits in the given string.\"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 60.18691588785047, "dps_norm": 53.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n    lst (list): A list of items.\n\n    Returns:\n    list: A list of tuples containing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst: List of items.\n    \n    Returns:\n    List of tuples containing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in a given list.\n\n    Args:\n    lst: List of items.\n\n    Returns:\n    List of tuples containing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of tuples containing all pairs of consecutive items in the given list.\n    \n    Args:\n    lst (list): A list of items.\n\n    Returns:\n    list: A list of tuples containing pairs of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"Return a list of all pairs of consecutive items in the given list.\"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n    \n    Args:\n    lst (list): A list of items.\n    \n    Returns:\n    list: A list of tuples where each tuple contains consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"Return a list of all pairs of consecutive items in the given list.\"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n    lst (list): A list of elements.\n\n    Returns:\n    list: A list of tuples, where each tuple contains consecutive elements from the input list.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"Returns a list of all pairs of consecutive items in the given list.\"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"Return a list of all pairs of consecutive items in the given list.\"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"Return a list of all pairs of consecutive items in the given list.\"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Parameters:\n    lst (list): The input list of items.\n    \n    Returns:\n    list: A list of tuples containing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n    lst (list): A list of items.\n\n    Returns:\n    list: A list of tuples containing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"Return a list of all pairs of consecutive items in the given list.\"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n    lst (list): The input list of items.\n\n    Returns:\n    list: A list of tuples, each containing pairs of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n    lst (list): The input list from which to form pairs.\n\n    Returns:\n    list: A list of tuples, each containing a pair of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): A list of items.\n    \n    Returns:\n    list: A list of tuples, each containing a pair of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of tuples containing all pairs of consecutive items in the given list.\n\n    Args:\n    lst (list): The input list.\n\n    Returns:\n    list: A list of tuples containing consecutive pairs.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n        lst (list): A list of items.\n\n    Returns:\n        list: A list of tuples containing pairs of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    This function takes a list and returns a list of all pairs of consecutive items.\n    \n    Args:\n    input_list (list): The list from which to generate pairs.\n\n    Returns:\n    list: A list of tuples where each tuple contains consecutive items from the input list.\n    \"\"\"\n    # Initialize an empty list to store pairs\n    pairs = []\n    \n    # Loop through the list and create pairs of consecutive items\n    for i in range(len(input_list) - 1):\n        pairs.append((input_list[i], input_list[i + 1]))\n    \n    return pairs", "matching_cluster_idx": 2}]}, "Mbpp/775": {"dps": 93.24, "dps_norm": 70.71428571428572, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 (odd indices)\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True  # If all odd indices contain odd numbers", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers.\n\n    Args:\n    lst (list): The input list of numbers.\n\n    Returns:\n    bool: True if every odd index contains odd numbers, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):  # Start from index 1 and go to the end, stepping by 2\n        if lst[index] % 2 == 0:  # Check if the number at the odd index is even\n            return False  # If it's even, return False\n    return True  # All odd indices contain odd numbers", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in the given list.\n\n    Args:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):  # Start from index 1 and increment by 2\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in the given list.\n    \n    Args:\n    lst (list): A list of integers.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):  # Start at index 1 and step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains odd numbers.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if every odd index contains odd numbers, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[index] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers.\n\n    Parameters:\n    lst (list): The input list of numbers.\n\n    Returns:\n    bool: True if all odd indices contain odd numbers, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):  # Check odd indices (1, 3, 5, ...)\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every odd index in the list contains an odd number.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):  # Start from index 1 and step by 2 (odd indices)\n        if lst[index] % 2 == 0:  # Check if the number at the odd index is even\n            return False  # If any even number is found, return False\n    return True  # If all checks are passed, return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every odd index in the list contains odd numbers.\n    \n    Args:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if all odd indices contain odd numbers, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):  # Start from index 1 and increment by 2 (odd indices)\n        if lst[index] % 2 == 0:  # Check if the number at the odd index is even\n            return False  # If an even number is found, return False\n    return True  # If all odd indices are odd, return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if every odd index contains odd numbers, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):  # Start from index 1 and check every second index\n        if lst[index] % 2 == 0:  # If the number at the odd index is even\n            return False\n    return True  # All odd indices contain odd numbers", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers.\n\n    Parameters:\n    lst (list): The input list of numbers.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):  # Start from index 1 and check every second index\n        if lst[index] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every odd index in the list contains odd numbers.\n    \n    Args:\n    lst: List of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in the given list.\n\n    :param lst: List of integers\n    :return: True if every odd index contains odd numbers, False otherwise\n    \"\"\"\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 (odd indices)\n        if lst[i] % 2 == 0:  # Check if the number is even\n            return False\n    return True  # All odd indices have odd numbers", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    \"\"\"Check if every odd index contains odd numbers in the list.\"\"\"\n    for index in range(1, len(numbers), 2):  # Start from index 1 and increment by 2\n        if numbers[index] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains odd numbers.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if every odd index contains odd numbers, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):  # Start at index 1 and step by 2\n        if lst[i] % 2 == 0:           # Check if the number at odd index is even\n            return False               # If even, return False\n    return True                        # If all checks pass, return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if every odd index contains odd numbers, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[index] % 2 == 0:  # Check if the number is even\n            return False\n    return True  # All odd indexed numbers are odd", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Check whether every odd index contains odd numbers in the given list.\n    \n    :param numbers: List of integers\n    :return: True if every odd index contains odd numbers, False otherwise\n    \"\"\"\n    for index in range(1, len(numbers), 2):  # Start from index 1 and step by 2 to get odd indices\n        if numbers[index] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"Check if every odd index contains odd numbers in the list.\"\"\"\n    for i in range(1, len(lst), 2):  # Start from index 1 and increment by 2\n        if lst[i] % 2 == 0:  # Check if the number at odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n    \n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if all odd indices contain odd numbers, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):  # Start from index 1 and go in steps of 2 (odd indices)\n        if lst[index] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in the given list.\n    \n    :param lst: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for index in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[index] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/781": {"dps": 85.39370078740157, "dps_norm": 68.0, "pass@1": 75.0, "profiled": [{"solution": "def count_divisors(n):\n    \"\"\"Returns True if the count of divisors of n is even, False otherwise.\"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # Count the divisor\n            if i != n // i:\n                count += 1  # Count the complementary divisor\n\n    return count % 2 == 0  # Check if count of divisors is even", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors of n and check if the count is even.\n    \n    :param n: Integer to count divisors for.\n    :return: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    \n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"Return True if the count of divisors of n is even, otherwise False.\"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # Count the divisor i\n            if i != n // i:\n                count += 1  # Count the corresponding divisor n // i\n    return count % 2 == 0  # Check if the count of divisors is even", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"Returns True if the count of divisors of n is even, otherwise False.\"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function returns True if the count of divisors of n is even, \n    and False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # i is a divisor\n            if i != n // i:\n                count += 1  # n // i is also a divisor\n    return count % 2 == 0  # True if count is even, False if odd", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    if n <= 0:\n        return False  # We do not count divisors for non-positive integers\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0  # Return True if count is even, otherwise False", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check if the count of divisors of the given integer n is even.\n\n    Parameters:\n    n (int): The integer for which to count the divisors.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    # Count divisors by iterating from 1 to sqrt(n)\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # If i is a divisor\n            count += 1  # Count i\n            if i != n // i:  # Count the complementary divisor if it's different\n                count += 1\n\n    return count % 2 == 0  # Return True if even, False if odd", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function returns True if the count of divisors of n is even,\n    otherwise returns False.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # Count the divisor\n            if i != n // i:\n                count += 1  # Count the complementary divisor\n    return count % 2 == 0  # Return True if count is even", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to count the number of divisors of a given integer n.\n    Returns True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # i is a divisor\n            count += 1\n            if i != n // i:  # n/i is also a divisor\n                count += 1\n    return count % 2 == 0  # Check if the count of divisors is even", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"Return True if the count of divisors of n is even, otherwise False.\"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:  # Count the complement divisor if it's different\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"Returns True if the count of divisors of n is even, otherwise False.\"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    divisor_count = 0\n    \n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisor_count += 1  # Count the divisor\n            if i != n // i:\n                divisor_count += 1  # Count the complementary divisor\n\n    return divisor_count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"Return True if the count of divisors of n is even, else False.\"\"\"\n    if n <= 0:\n        return False  # or raise an exception for invalid input\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # i is a divisor\n            if i != n // i:\n                count += 1  # n // i is also a divisor if it's different from i\n    \n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function counts the number of divisors of a given integer n.\n    It returns True if the count of divisors is even, otherwise False.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n\n    return count % 2 == 0  # Return True if count of divisors is even", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    if n <= 0:\n        return False  # We can consider count of divisors for positive integers only\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:  # Count the complementary divisor\n                count += 1\n\n    return count % 2 == 0  # Return True if the count is even", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Returns True if the count of divisors of n is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Counts the number of divisors of a given number n and checks\n    whether that count is even.\n    \n    Args:\n    n (int): The number for which to count divisors.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    # Count divisors by checking each number from 1 to n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n            \n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to count the number of divisors of a given integer n\n    and check if that count is even or odd.\n    \n    Parameters:\n    n (int): The number for which to count divisors\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # i is a divisor\n            count += 1  # Count i\n            if i != n // i:\n                count += 1  # Count the complementary divisor\n    \n    return count % 2 == 0  # Check if the count is even", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function returns True if the count of divisors of n is even,\n    otherwise returns False.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:  # Count the complementary divisor only if it's different\n                count += 1\n\n    return count % 2 == 0  # Check if the count of divisors is even", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"Return True if the count of divisors of n is even, False otherwise.\"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n        \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # i is a divisor\n            if i != n // i:\n                count += 1  # n // i is also a divisor\n    return count % 2 == 0  # Return True if even, False if odd", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to count the number of divisors of a given number n.\n    It returns True if the count is even, otherwise False.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # i is a divisor\n            if i != n // i:\n                count += 1  # n // i is also a divisor\n\n    return count % 2 == 0  # Check if count is even", "matching_cluster_idx": 3}]}, "Mbpp/800": {"dps": 97.83582089552239, "dps_norm": 99.0, "pass@1": 22.0, "profiled": [{"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the given string.\n    \n    Args:\n    input_string (str): The string from which to remove whitespaces.\n    \n    Returns:\n    str: The input string without any whitespaces.\n    \"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Remove all whitespaces from the input string.\"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Remove all whitespaces from the given string.\"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    This function removes all whitespaces from the input string.\n\n    Args:\n    input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n    str: The input string without any whitespaces.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the input string.\n\n    Args:\n    input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Remove all whitespaces from the input string.\"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the input string.\n    \n    Parameters:\n    input_string (str): The string from which to remove whitespaces.\n    \n    Returns:\n    str: The input string without any whitespace characters.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Remove all whitespaces from the input string.\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string: str) -> str:\n    \"\"\"Remove all whitespaces from the input string.\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string: str) -> str:\n    \"\"\"\n    Remove all whitespaces from the given string.\n    \n    Parameters:\n    input_string (str): The string from which to remove whitespaces.\n    \n    Returns:\n    str: The string without any whitespaces.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Remove all whitespaces from the input string.\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespaces from the given string.\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Remove all whitespaces from the input string.\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which to remove whitespaces.\n    \n    Returns:\n    str: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Remove all whitespaces from the input string.\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Remove all whitespaces from the input string.\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Remove all whitespaces from the given string.\"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the input string.\n    \n    Parameters:\n    input_string (str): The string from which to remove whitespaces.\n    \n    Returns:\n    str: The input string without any whitespaces.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from the given string.\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Remove all whitespaces from the given string.\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(lists):\n    # Initialize variables to keep track of the list with the maximum sum\n    max_sum = float('-inf')\n    max_list = None\n    \n    # Iterate through each list in the input\n    for lst in lists:\n        current_sum = sum(lst)  # Calculate the sum of the current list\n        # Check if the current sum is greater than the maximum sum found so far\n        if current_sum > max_sum:\n            max_sum = current_sum  # Update the maximum sum\n            max_list = lst         # Update the list with the maximum sum\n            \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in the input list of lists whose sum of elements is the highest.\n    \n    Args:\n    lists (list of list of int): A list containing multiple lists of integers.\n    \n    Returns:\n    list of int: The list with the highest sum of elements.\n    \"\"\"\n    if not lists:\n        return []\n    \n    # Use max with a key that sums the elements of each sublist\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize variables to track the maximum sum and the corresponding sublist\n    max_sum = float('-inf')\n    max_list = []\n\n    # Iterate through each sublist\n    for sublist in lists:\n        current_sum = sum(sublist)  # Calculate the sum of the current sublist\n        \n        # Update if current sum is greater than the max sum found so far\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize variables to keep track of the max sum and corresponding sublist\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each sublist\n    for sublist in lists:\n        current_sum = sum(sublist)  # Calculate the sum of the current sublist\n        # Check if the current sum is greater than the max sum found so far\n        if current_sum > max_sum:\n            max_sum = current_sum  # Update the max sum\n            max_list = sublist      # Update the corresponding sublist\n    \n    return max_list  # Return the sublist with the highest sum", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n    lists (list of list of int): A list containing lists of integers.\n\n    Returns:\n    list of int: The list with the highest sum of its elements.\n    \"\"\"\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the sublist with the highest sum of its elements.\n\n    Args:\n    lists (list of lists): A list containing lists of integers.\n\n    Returns:\n    list: The list with the highest sum of its elements.\n    \"\"\"\n    if not lists:\n        return []\n\n    # Find the list with the maximum sum\n    max_list = max(lists, key=sum)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list with the highest sum of elements from a list of lists.\n\n    Parameters:\n    lists (list of list of int): A list containing multiple lists of integers.\n\n    Returns:\n    list: The list with the highest sum of elements.\n    \"\"\"\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n    lists (list of list of int): A list of lists of integers.\n\n    Returns:\n    list: The list with the highest sum of elements.\n    \"\"\"\n    if not lists:\n        return None  # Return None if the input list is empty\n\n    # Use max() with a key argument to find the sublist with the maximum sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"Returns the list with the highest sum of its elements from a list of lists.\"\"\"\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    :param lists: List of lists of integers\n    :return: List with the highest sum of its elements\n    \"\"\"\n    if not lists:\n        return []  # Return an empty list if the input is empty\n\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Parameters:\n    lists (list of list of int): A list containing sublists of integers.\n\n    Returns:\n    list: The sublist with the highest sum of its elements.\n    \"\"\"\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in the list of lists whose sum of elements is the highest.\n    \n    Args:\n    lists (list of list of int): A list containing sublists of integers.\n    \n    Returns:\n    list: The sublist with the highest sum of its elements.\n    \"\"\"\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n\n    # Iterate through each list in the provided list of lists\n    for sublist in lists:\n        current_sum = sum(sublist)  # Calculate the sum of the current sublist\n        # Update max_sum and max_list if the current sum is greater than max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    :param lists: List of lists containing numeric elements\n    :return: The list with the highest sum of its elements\n    \"\"\"\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Parameters:\n    lists (list of list of int): A list containing lists of integers.\n    \n    Returns:\n    list: The list with the highest sum of its elements.\n    \"\"\"\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n    lists (list of list of int): A list containing sublists of integers.\n    \n    Returns:\n    list: The sublist with the highest sum of elements.\n    \"\"\"\n    # Check if the input list is empty\n    if not lists:\n        return []\n\n    # Find the sublist with the maximum sum using the built-in max function\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the sub-list with the highest sum of elements from a list of lists.\n\n    :param lists: A list of lists containing numerical values.\n    :return: A list that has the highest sum of its elements.\n    \"\"\"\n    # Check if the input is empty\n    if not lists:\n        return []\n\n    # Initialize variables to track the maximum sum and the corresponding sub-list\n    max_sum = float('-inf')\n    max_list = []\n\n    # Iterate through each sub-list\n    for sub_list in lists:\n        current_sum = sum(sub_list)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sub_list\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    \"\"\"Returns the list with the highest sum from a list of lists.\"\"\"\n    if not lst:\n        return []\n    \n    # Find the list with the maximum sum\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the input\n    for lst in lists:\n        current_sum = sum(lst)  # Calculate the sum of the current list\n        \n        # Update max_sum and max_list if current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n            \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n    lists (list of list of int): A list containing sublists of integers.\n\n    Returns:\n    list: The sublist with the highest sum of its elements.\n    \"\"\"\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n\n    # Iterate through each sublist\n    for sublist in lists:\n        current_sum = sum(sublist)\n        # Update if the current sum is greater than the max sum found so far\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 93.0701754385965, "dps_norm": 98.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    k: The value to check for in the tuple.\n\n    Returns:\n    bool: True if k is in tup, otherwise False.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the value k is present in the given tuple.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    k: The value to look for in the tuple.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Parameters:\n    tup (tuple): The tuple to check.\n    k (any): The value to find in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    k: The value to check for.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Parameters:\n    tup (tuple): The tuple to check.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Args:\n    tup (tuple): The tuple to check.\n    k: The value to find in the tuple.\n    \n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if the given tuple contains the value k.\n    \n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k: The value to check for in the tuple.\n    \n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Parameters:\n    tup (tuple): The tuple to check.\n    k (any): The value to search for in the tuple.\n    \n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Parameters:\n    tup (tuple): The tuple to check.\n    k (any): The value to search for in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tup (tuple): The tuple to check.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Parameters:\n    tup (tuple): A tuple of values.\n    k: The value to check for in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    k: The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if the given tuple contains the value k.\n    \n    Parameters:\n    tup (tuple): The tuple to check.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    k: The value to look for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Parameters:\n    tup (tuple): The tuple to check.\n    k (any): The value to check for in the tuple.\n    \n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given integer k is present in the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    k (int): The integer to search for.\n\n    Returns:\n    bool: True if k is found in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuples contain the k or not.\n    \n    Parameters:\n    tup (tuple): The tuple to check.\n    k (any): The value to search for in the tuple.\n    \n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the specified value k.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    k: The value to check for.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Parameters:\n    tup (tuple): The tuple to check.\n    k: The value to search for in the tuple.\n    \n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}]}}}
