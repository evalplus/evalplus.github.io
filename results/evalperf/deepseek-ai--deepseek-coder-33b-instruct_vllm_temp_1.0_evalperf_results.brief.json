{"date": "2024-10-19 16:31", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 82.65680460618937, "dps_norm": 77.67106700323255, "pass@1": 77.50847457627118}, "eval": {"HumanEval/9": {"dps": 80.50473186119874, "dps_norm": 80.0, "pass@1": 92.0, "profiled": [{"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a given list of integers, generate a list of rolling maximum \n    element found until given moment in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    roll_max = [numbers[0]]\n    for num in numbers[1:]:\n        if num > roll_max[-1]:\n            roll_max.append(num)\n        else:\n            roll_max.append(roll_max[-1])\n    return roll_max", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Parameters:\n    numbers (List[int]): a list of integers\n\n    Returns:\n    List[int]: list of rolling maximum values\n    \"\"\"\n    result = []\n    max_so_far = float('-inf')\n    for num in numbers:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a given list of integers, generate a list of rolling maximum element found until given moment \n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    max_so_far = numbers[0]\n\n    for num in numbers:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_numbers = [numbers[0]]\n    for num in numbers[1:]:\n        max_numbers.append(max(max_numbers[-1], num))\n\n    return max_numbers", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a given list of integers, generate a list of rolling maximum \n    element found until given moment in the sequence. \n    \"\"\"\n    if not numbers:\n        return []\n\n    max_num = numbers[0]\n    result = [max_num]\n\n    for num in numbers[1:]:\n        if num > max_num:\n            max_num = num\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_val = float('-inf')\n\n    for num in numbers:\n        if num > max_val:\n            max_val = num\n        result.append(max_val)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if len(numbers) == 0:\n        return []\n\n    max_numbers = [numbers[0]]\n    for number in numbers[1:]:\n        if number > max_numbers[-1]:\n            max_numbers.append(number)\n        else:\n            max_numbers.append(max_numbers[-1])\n\n    return max_numbers", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_values = [numbers[0]]\n    for num in numbers[1:]:\n        rolling_max_values.append(max(rolling_max_values[-1], num))\n\n    return rolling_max_values", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    max_number = float('-inf')\n    for num in numbers:\n        if num > max_number:\n            max_number = num\n        rolling_max_list.append(max_number)\n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if len(numbers) == 0: \n        return [] \n\n    max_list = [numbers[0]]\n    for i in range(1, len(numbers)):\n        max_list.append(max(max_list[i-1], numbers[i]))\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    max_nums = []\n    current_max = None\n\n    for num in numbers:\n        if current_max is None or num > current_max:\n            current_max = num\n        max_nums.append(current_max)\n\n    return max_nums", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if len(numbers) == 0:\n        return []\n\n    rolling_max_list = [numbers[0]]\n    for num in numbers[1:]:\n        rolling_max_list.append(max(rolling_max_list[-1], num))\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_numbers = [numbers[0]]\n    for num in numbers[1:]:\n        if num > max_numbers[-1]:\n            max_numbers.append(num)\n        else:\n            max_numbers.append(max_numbers[-1])\n    return max_numbers", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    This function generates a list of rolling maximum element found until given moment in the sequence.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input should be a list of integers\")\n    # Check if list is empty\n    if len(numbers) == 0:\n        return []\n    \n    result = []\n    max_so_far = numbers[0]\n    \n    for num in numbers:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n        \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    current_max = float('-inf')\n    rolling_max_list = []\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    maximum = numbers[0]\n    result = []\n\n    for num in numbers:\n        if num > maximum:\n            maximum = num\n        result.append(maximum)\n\n    return result\ntest_data = [1, 2, 3, 2, 3, 4, 2]\nresult = rolling_max(test_data)", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    maximum = numbers[0]\n    result = []\n    for num in numbers:\n        if num > maximum:\n            maximum = num\n        result.append(maximum)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n\n    if not numbers:  # return empty list if input is empty\n        return []\n    \n    # initialize the result with first element in the input\n    rolling_max_list = [numbers[0]]\n    \n    for num in numbers[1:]:\n        # append max between current num and previously calculated max\n        rolling_max_list.append(max(num, rolling_max_list[-1]))\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    max_num = numbers[0]\n    result = []\n\n    for num in numbers:\n        max_num = max(max_num, num)\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 4}]}, "HumanEval/0": {"dps": 72.09302325581395, "dps_norm": 75.71428571428572, "pass@1": 71.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    numbers.sort()\n\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        return False\n\n    numbers.sort()\n\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()  # Sort the list in ascending order.\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True  # If the difference is less than threshold, return True.\n    return False  # If no two close elements found, return False.", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not isinstance(numbers, list) or not isinstance(threshold, (int, float)):\n        raise ValueError('Invalid input type')\n\n    if len(numbers) < 2:\n        return False\n\n    numbers.sort()\n\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # sort the list\n    numbers.sort()\n    \n    # iterate over the list\n    for i in range(1, len(numbers)):\n        # check if the difference between two consecutive numbers is less than threshold\n        if abs(numbers[i] - numbers[i-1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list in ascending order\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    num_len = len(numbers)\n    for i in range(num_len):\n        for j in range(i + 1, num_len):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Sort the numbers\n    numbers.sort()\n\n    # Iterate over each pair of adjacent numbers\n    for i in range(len(numbers) - 1):\n        # If the difference between the numbers is less than the threshold,\n        # return True\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n\n    # If no such pair of numbers was found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the numbers\n    numbers.sort()\n\n    # Iterate over the sorted numbers\n    for i in range(len(numbers)-1):\n        # If the difference between two adjacent numbers is less than the threshold,\n        # then return True as they are close to each other\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n\n    # If no such pair is found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Iterate over the numbers with their indices\n    for i, num1 in enumerate(numbers):\n        # Iterate over the numbers after the current number\n        for num2 in numbers[i+1:]:\n            # Check if the difference between the numbers is less than the threshold\n            if abs(num1 - num2) < threshold:\n                # If it is, return True\n                return True\n    # If no close elements are found, return False\n    return False", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()  # Sort the list of numbers\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the numbers in ascending order\n    numbers.sort()\n    # Loop over the numbers and check if any two adjacent numbers differ by less than the threshold\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 74.27215189873418, "dps_norm": 86.66666666666667, "pass@1": 99.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviation from the mean for each number in the list\n    deviations = [abs(number - mean) for number in numbers]\n    \n    # Calculate the Mean Absolute Deviation (MAD)\n    mad = sum(deviations) / len(deviations)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean of the input list\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate absolute differences between each element and the mean\n    abs_diff = [abs(num - mean) for num in numbers]\n\n    # Calculate mean of these absolute differences\n    mad = sum(abs_diff) / len(abs_diff)\n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n    # calculate mean\n    mean = sum(numbers) / len(numbers)\n\n    # calculate absolute deviation for each element\n    abs_deviations = [abs(x - mean) for x in numbers]\n\n    # calculate mean of absolute deviations\n    mad = sum(abs_deviations) / len(abs_deviations)\n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(number - mean) for number in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n    # calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n\n    # calculate the absolute deviation from the mean for each number\n    deviations = [abs(x - mean) for x in numbers]\n\n    # calculate and return the mean of these deviations\n    return sum(deviations) / len(deviations)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean of the list\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate the absolute deviation from the mean for each element\n    abs_deviations = [abs(x - mean) for x in numbers]\n\n    # Return the mean of the absolute deviations\n    return sum(abs_deviations) / len(abs_deviations)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"List of numbers cannot be empty\")\n\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate absolute differences\n    absolute_differences = [abs(x - mean) for x in numbers]\n    \n    # Calculate and return Mean Absolute Deviation\n    return sum(absolute_differences) / len(absolute_differences)\nnumbers = [1.0, 2.0, 3.0, 4.0]", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    mean = sum(numbers) / n\n    return sum(abs(x - mean) for x in numbers) / n", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(num - mean) for num in numbers]\n    return sum(absolute_deviations) / len(numbers)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate the absolute differences\n    absolute_diffs = [abs(x - mean) for x in numbers]\n\n    # Calculate the Mean Absolute Deviation\n    mad = sum(absolute_diffs) / len(numbers)\n\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    def calculate_mean(numbers):\n        return sum(numbers) / len(numbers)\n\n    def calculate_abs_deviation(numbers, mean):\n        return [abs(number - mean) for number in numbers]\n\n    # Calculate the mean of the numbers\n    mean = calculate_mean(numbers)\n\n    # Calculate the absolute deviation from the mean\n    abs_deviations = calculate_abs_deviation(numbers, mean)\n\n    # Calculate the mean absolute deviation\n    mad = sum(abs_deviations) / len(abs_deviations)\n\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_diffs = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_diffs) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # First, we compute the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Then, we calculate the absolute differences from the mean for each number\n    abs_diffs = [abs(num - mean) for num in numbers]\n    \n    # Finally, the Mean Absolute Deviation is the average of these differences\n    mad = sum(abs_diffs) / len(abs_diffs)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(number - mean) for number in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport random\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    # Calculate the mean of the input list\n    mean = sum(numbers) / len(numbers)\n    # Calculate the absolute difference from the mean for each number\n    absolute_differences = [abs(number - mean) for number in numbers]\n    # Calculate the Mean Absolute Deviation\n    mad = sum(absolute_differences) / len(numbers)\n    return mad\nnumbers = [1.0, 2.0, 3.0, 4.0]", "matching_cluster_idx": 4}]}, "HumanEval/16": {"dps": 42.7906976744186, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert string to lowercase to make sure that 'a' and 'A' are treated as the same character\n    string_lower = string.lower()\n    # Create a set to remove duplicates, then return the size of the set\n    return len(set(string_lower))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n\n    # converting the string to lowercase to make the function case-insensitive\n    string = string.lower()\n\n    # using a set to automatically eliminate duplicate characters\n    distinct_characters = set(string)\n\n    # returning the length of the set\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # We convert the string to lowercase to make the function case-insensitive\n    string = string.lower()\n    \n    # We use a set to store the characters. Since sets only allow unique values, this automatically gives us the unique characters\n    unique_characters = set(string)\n    \n    # We return the length of the set, which is the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case sensitivity\n    string_lower = string.lower()\n    \n    # Initialize an empty set\n    distinct_chars = set()\n\n    # Iterate over the string, adding each character to the set\n    for char in string_lower:\n        distinct_chars.add(char)\n\n    # Return the length of the set\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitive comparison\n    string = string.lower()\n    # Initialize an empty set to store unique characters\n    unique_characters = set()\n    # Iterate over each character in the string\n    for char in string:\n        # Add the character to the set\n        unique_characters.add(char)\n    # The length of the set is the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) does it consist of \n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    lower_string = string.lower()\n    return len(set(lower_string))", "matching_cluster_idx": 7}]}, "HumanEval/20": {"dps": 96.30750605326877, "dps_norm": 99.44444444444444, "pass@1": 99.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    res = ()\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            res = (numbers[i-1], numbers[i])\n    return res", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list of numbers\n    numbers.sort()\n\n    # Initialize the minimum difference and closest pair\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    # Compare each pair of consecutive numbers\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i - 1], numbers[i])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n\n    # Sort the numbers list\n    numbers.sort()\n\n    # Initialize closest pair with the first two numbers\n    closest_pair = (numbers[0], numbers[1])\n    min_distance = abs(numbers[1] - numbers[0])\n\n    # Go through the list and check if a pair is closer than the current closest pair\n    for i in range(1, len(numbers) - 1):\n        distance = abs(numbers[i+1] - numbers[i])\n        if distance < min_distance:\n            min_distance = distance\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    closest_nums = (None, None)\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_nums = (numbers[i - 1], numbers[i])\n\n    return closest_nums", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # sort the numbers\n    numbers.sort()\n\n    # initialize the smallest difference\n    smallest_diff = float('inf')\n\n    # initialize the result tuple\n    result = (0.0, 0.0)\n\n    # iterate through the list of numbers\n    for i in range(1, len(numbers)):\n        # calculate the difference between current number and the previous one\n        diff = numbers[i] - numbers[i - 1]\n\n        # if the difference is smaller than the smallest difference seen so far,\n        # update the smallest difference and the result tuple\n        if diff < smallest_diff:\n            smallest_diff = diff\n            result = (numbers[i - 1], numbers[i])\n\n    # return the result tuple\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_difference = float('inf')\n    result = (None, None)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_difference:\n            min_difference = diff\n            result = (numbers[i-1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    closest = (numbers[0], numbers[1])\n    min_diff = abs(numbers[0] - numbers[1])\n\n    for i in range(1, len(numbers) - 1):\n        diff = abs(numbers[i] - numbers[i+1])\n        if diff < min_diff:\n            min_diff = diff\n            closest = (numbers[i], numbers[i+1])\n\n    return closest", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = None\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i-1], numbers[i])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    result = (None, None)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()  # Sort the numbers\n    min_diff = float('inf')\n    result = (None, None)\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    diff = float('inf')\n    result = (0, 0)\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < diff:\n            diff = numbers[i] - numbers[i-1]\n            result = (numbers[i-1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    res = (0, 0)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            res = (numbers[i-1], numbers[i])\n    return res", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    closest_tuple = min(((numbers[i], numbers[i+1]) for i in range(len(numbers)-1)), key=lambda pair: pair[1] - pair[0])\n    return closest_tuple", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Sort the list in ascending order\n    numbers.sort()\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (None, None)\n    \n    # Iterate over the sorted list to find the closest pair\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i-1], numbers[i])\n            \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError('Input list must have at least two numbers')\n    \n    numbers.sort()\n    closest_diff = float('inf')\n    closest_nums = None\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < closest_diff:\n            closest_diff = diff\n            closest_nums = (numbers[i - 1], numbers[i])\n    return closest_nums", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    result = (None, None)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i-1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    Finds the closest elements in a list of floats\n\n    Args:\n        numbers: List of floats\n\n    Returns:\n        The two closest floats in the list\n    \"\"\"\n    assert len(numbers) >= 2, \"numbers list must have at least 2 elements\"\n\n    numbers.sort()\n    closest_diff = float('inf')\n    closest_elements = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < closest_diff:\n            closest_diff = diff\n            closest_elements = (numbers[i], numbers[i+1])\n\n    return closest_elements", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers.sort()\n    min_diff, result = numbers[1] - numbers[0], (numbers[0], numbers[1])\n    for i in range(1, len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff, result = diff, (numbers[i], numbers[i+1])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = None\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i-1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two numbers.\")\n\n    sorted_numbers = sorted(numbers)\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_difference = abs(sorted_numbers[0] - sorted_numbers[1])\n\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = abs(sorted_numbers[i] - sorted_numbers[i+1])\n        if current_difference < min_difference:\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n            min_difference = current_difference\n\n    return closest_pair", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 65.71428571428572, "dps_norm": 25.0, "pass@1": 98.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Check if input is valid\n    if n <= 0 or not isinstance(n, int):\n        raise ValueError(\"Input must be a positive integer\")\n    \n    # The largest divisor of n that is less than n is always n/2 when n is even\n    # If n is odd, then the largest divisor is n-1\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n\n    # Start from the number less than n\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n    Args:\n        n (int): The number to find the largest divisor of.\n    Returns:\n        int: The largest divisor of n.\n    \"\"\"\n    # Start from n-1 and decrement until a divisor is found.\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return None\nn = 15", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Initialize the largest divisor to 1 (as it is the smallest possible divisor)\n    largest_divisor = 1\n    \n    # Iterate through each number from 2 to n\n    for i in range(2, n):\n        # If i divides n evenly, it's a divisor\n        if n % i == 0:\n            largest_divisor = i\n    \n    return largest_divisor", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n\n    # Start checking from n-1 down to 1\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            # If i divides n evenly, it is the largest number that divides n evenly, smaller than n\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    :param n: An integer\n    :return: The largest divisor of n less than n.\n    \"\"\"\n    # Initialize the largest divisor to None\n    largest_divisor = None\n\n    # Loop from n-1 to 1 to find the largest divisor\n    for i in range(n-1, 0, -1):\n        if n % i == 0:  # If i is a divisor of n\n            largest_divisor = i  # Update the largest divisor\n            break  # Exit the loop since we found the largest divisor\n\n    # Return the largest divisor\n    return largest_divisor", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Edge case for n = 0 or 1\n    if n <= 1:\n        return None\n\n    # Iterate from 2 to n/2 and find the largest divisor\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n-1, 0, -1):  # we iterate backwards from n-1 to 1\n        if n % i == 0:  # if n is evenly divisible by i, i is the largest divisor\n            return i  # return i\n    return None  # in case no divisor is found, return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    For a given number n, find the largest number that divides n evenly, and is less than n.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n < 2:\n        raise ValueError(\"Input should be an integer greater than 1\")\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n < 2:\n        raise ValueError('Input should be an integer greater than 1')\n\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}]}, "HumanEval/26": {"dps": 73.6, "dps_norm": 76.25, "pass@1": 44.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    result = []\n    count_dict = {}\n    for num in numbers:\n        if num not in count_dict:\n            count_dict[num] = 1\n            result.append(num)\n        else:\n            count_dict[num] += 1\n    return [x for x in result if count_dict[x] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            result.append(number)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 2, 4]\n    \"\"\"\n    unique_nums = []\n    counts = {}\n    \n    for num in numbers:\n        if num not in counts:\n            unique_nums.append(num)\n            counts[num] = 1\n        else:\n            counts[num] += 1\n            \n    return [num for num in unique_nums if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    result = []\n    counts = {}\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 1\n            result.append(num)\n        else:\n            counts[num] += 1\n    \n    return [num for num in result if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return [n for i, n in enumerate(numbers) if numbers.count(n) == 1]", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    counter = {}\n\n    for num in numbers:\n        if num not in counter:\n            counter[num] = 1\n            result.append(num)\n        else:\n            counter[num] += 1\n\n    return [num for num in result if counter[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 2, 4]\n    \"\"\"\n    num_dict = {}\n    result = []\n    for num in numbers:\n        if num not in num_dict:\n            result.append(num)\n            num_dict[num] = 1\n        else:\n            num_dict[num] += 1\n\n    return [num for num in result if num_dict[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    output_list = []\n    counter_dict = {}\n\n    for num in numbers:\n        if num not in counter_dict:\n            counter_dict[num] = 1\n            output_list.append(num)\n        else:\n            counter_dict[num] += 1\n\n    output_list = [num for num in output_list if counter_dict[num] == 1]\n    \n    return output_list", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    num_counts = {}\n    unique_numbers = []\n\n    for num in numbers:\n        if num not in num_counts:\n            num_counts[num] = 1\n            unique_numbers.append(num)\n        else:\n            num_counts[num] += 1\n\n    return [num for num in unique_numbers if num_counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    \n    seen = set()\n    result = []\n\n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n        else:\n            if num in result:\n                result.remove(num)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    result = []\n    counts = {}\n    \n    for num in numbers:\n        if num not in counts:\n            counts[num] = 1\n            result.append(num)\n        else:\n            counts[num] += 1\n    \n    return [num for num in result if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    result = []\n    counts = {}\n\n    # Count the occurrence of each number\n    for number in numbers:\n        if number in counts:\n            counts[number] += 1\n        else:\n            counts[number] = 1\n\n    # Add the number to the result list if it's not a duplicate\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    num_counter = {}\n    for num in numbers:\n        if num in num_counter:\n            num_counter[num] += 1\n        else:\n            num_counter[num] = 1\n    return [num for num in numbers if num_counter[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    number_dict = {}\n    result = []\n\n    for number in numbers:\n        if number in number_dict:\n            number_dict[number] += 1\n        else:\n            number_dict[number] = 1\n\n    for number in numbers:\n        if number_dict[number] == 1:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once. \n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # Use a dictionary to store the count of each number in the list.\n    counts = {}\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    # Iterate through the list and only add the number to the result if its count is 1.\n    result = []\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 76.39240506329114, "dps_norm": 81.875, "pass@1": 95.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # 0 and 1 are not prime numbers\n    if n < 2:\n        return False\n    # 2 is the only even prime number\n    if n == 2: \n        return True\n    # all other even numbers are not primes\n    if not n & 1: \n        return False\n    # range starts with 3 and only needs to go up the square root of n\n    # for all odd numbers\n    for x in range(3, int(n**0.5)+1, 2):\n        if n % x == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2: \n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # 0 and 1 are not prime numbers\n    if n < 2:\n        return False\n    # 2 is the only even prime number\n    if n == 2: \n        return True\n    # all other even numbers are not primes\n    if n % 2 == 0: \n        return False\n    # range starts with 3 and only needs to go up the square root of n\n    # for all odd numbers\n    for x in range(3, int(n**0.5)+1, 2):\n        if n % x == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while (i * i <= n):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": 46.423611111111114, "dps_norm": 71.81818181818181, "pass@1": 80.0, "profiled": [{"solution": "def sort_third(l):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are \n    equal to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_third = sorted(l[i] for i in range(len(l)) if i % 3 == 0)\n    l_prime = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l_prime.append(l_third.pop(0))\n        else:\n            l_prime.append(l[i])\n    return l_prime", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Separate the elements divisible by 3 and the rest\n    divisible_by_three = sorted([i for index, i in enumerate(l) if index % 3 == 0])\n    not_divisible_by_three = [i for index, i in enumerate(l) if index % 3 != 0]\n    \n    # Replace the elements at indicies divisible by 3\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = divisible_by_three.pop(0)\n\n    return l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\"\"\"\n    # Create a list of indices divisible by 3 and sort them\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    sorted_values = sorted([l[i] for i in indices])\n\n    # Create a copy of l with values at divisible indices replaced with sorted values\n    l_prime = l[:]\n    for i, sorted_value in zip(indices, sorted_values):\n        l_prime[i] = sorted_value\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    divisible_by_3 = [l[i] for i in range(len(l)) if i % 3 == 0]\n    divisible_by_3.sort()\n    j = 0\n    res = [None] * len(l)\n    for i in range(len(l)):\n        if i % 3 == 0:\n            res[i] = divisible_by_3[j]\n            j += 1\n        else:\n            res[i] = l[i]\n    return res", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Store the elements at indices divisible by 3\n    elems = sorted([x for i, x in enumerate(l) if i % 3 == 0])\n    \n    # Create a new list while keeping the elements at indices not divisible by 3\n    new_list = [elems.pop(0) if i % 3 == 0 else x for i, x in enumerate(l)]\n\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    divisible_by_three.sort()\n\n    new_l = l.copy()\n    for i in range(len(l)):\n        if i % 3 == 0:\n            new_l[i] = divisible_by_three.pop(0)\n    return new_l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    divisible_by_three = sorted([elem for i, elem in enumerate(l) if i % 3 == 0])\n    result = l.copy()\n    index = 0\n    for i, elem in enumerate(result):\n        if i % 3 == 0:\n            result[i] = divisible_by_three[index]\n            index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\"\"\"\n    # create a list of elements with indices divisible by 3\n    sorted_thirds = sorted(l[i] for i in range(len(l)) if i % 3 == 0)\n    # create a list of elements with indices not divisible by 3\n    others = [l[i] for i in range(len(l)) if i % 3 != 0]\n\n    # initialize an output list with size equal to the input list\n    res = [0]*len(l)\n    j = 0\n    # for every third element replace its value in the output list with a sorted value\n    for i in range(len(res)):\n        if i % 3 == 0:\n            res[i] = sorted_thirds[j]\n            j += 1\n        else:\n            res[i] = others.pop(0)\n    return res", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\"\"\"\n\n    divisible_by_three = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    sorted_l = l.copy()\n    for i in range(len(l)):\n        if i % 3 == 0:\n            sorted_l[i] = divisible_by_three.pop(0)\n    return sorted_l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    third_indices = [i for i in range(len(l)) if i % 3 == 0]\n    third_elements = [l[i] for i in third_indices]\n    third_elements.sort()\n    res = list(l)\n    for i, v in zip(third_indices, third_elements):\n        res[i] = v\n    return res", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    divisible_by_3_indices = [i for i in range(len(l)) if i % 3 == 0]\n    divisible_by_3_values = sorted([l[i] for i in divisible_by_3_indices])\n    result = l.copy()\n    for i, j in zip(divisible_by_3_indices, divisible_by_3_values):\n        result[i] = j\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n\n    # Creating a list to hold third elements\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n\n    # Sorting the list of third elements\n    third_elements.sort()\n\n    # Fill the third_elements in sorted order in the original list\n    for i in range(0, len(l), 3):\n        l[i] = third_elements.pop(0)\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    third_values = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third_values.sort()\n    result = l.copy()\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = third_values.pop(0)\n    return result", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Get values from input list where index is divisible by three\n    thirds = sorted([v for i, v in enumerate(l) if i % 3 == 0])\n\n    # Get values from input list where index is not divisible by three\n    rest = [v for i, v in enumerate(l) if i % 3 != 0]\n\n    # Create new list by placing sorted third values back at their original indexes\n    # And placing rest values in the remaining indexes\n    res = []\n    for i in range(len(l)):\n        if i % 3 == 0 and thirds:\n            res.append(thirds.pop(0))\n        else:\n            res.append(rest.pop(0))\n\n    return res", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    # Extract elements at indices that are divisible by three\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    elems = [l[i] for i in indices]\n\n    # Sort these elements\n    elems.sort()\n\n    # Replace elements at those indices with the sorted elements\n    for i, index in enumerate(indices):\n        l[index] = elems[i]\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Separate items at indices that are divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the separated items\n    divisible_by_three.sort()\n    # Replace items at indices that are divisible by three\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = divisible_by_three.pop(0)\n    return l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are \n    equal to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Collect all values that are at indices that are divisible by 3\n    div_by_3_vals = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n\n    # Replace the values at indices that are divisible by 3\n    j = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = div_by_3_vals[j]\n            j += 1\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l):\n    elements_at_indices_div_by_three = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    return [elements_at_indices_div_by_three.pop(0) if i % 3 == 0 else l[i] for i in range(len(l))]", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\"\"\"\n    # Get list of numbers that are divisible by three\n    divisible_by_three = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n\n    # Copy the original list\n    new_list = l.copy()\n    \n    # Replace numbers at positions that are divisible by three with sorted numbers\n    for i in range(len(l)):\n        if i % 3 == 0:\n            new_list[i] = divisible_by_three.pop(0)\n\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def sort_third(l):\n    div_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    div_three_values = sorted([l[i] for i in div_three_indices])\n    \n    l_prime = l.copy()\n    for index, value in zip(div_three_indices, div_three_values):\n        l_prime[index] = value\n    \n    return l_prime", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to get unique elements,\n    # then convert the set back to a list,\n    # and finally sort the list\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n\n    Args:\n        l (list): The list to find unique elements from.\n\n    Returns:\n        list: A sorted list of unique elements.\n\n    Example:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 86.0, "profiled": [{"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    counter = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            counter += str(i).count('7')\n    return counter", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    # Initialize a counter\n    counter = 0\n    \n    # Iterate through integers less than n\n    for i in range(n):\n        # If i is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Convert i to a string and count the number of times '7' appears\n            counter += str(i).count('7')\n            \n    return counter", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    \n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    def count_sevens(num: int):\n        return str(num).count('7')\n\n    total_sevens = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            total_sevens += count_sevens(i)\n\n    return total_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 95.18003273322422, "dps_norm": 90.5, "pass@1": 87.0, "profiled": [{"solution": "def sort_even(l):\n    # Store even-indexed elements of list in a sorted list\n    sorted_even = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Replace even-indexed elements of list with sorted elements\n    for i in range(0, len(l), 2):\n        l[i] = sorted_even.pop(0)\n    \n    # Return updated list\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even-indexed elements and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Insert the sorted elements back into the original list\n    for i, element in zip(range(0, len(l), 2), even_elements):\n        l[i] = element\n        \n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Extract even indexed elements and sort them\n    even_sorted = sorted(l[::2])\n    \n    # Construct result list\n    result = [None] * len(l)\n    result[::2] = even_sorted\n    result[1::2] = l[1::2]\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    sorted_even_idx_values = sorted(l[i] for i in range(0, len(l), 2))\n    for i in range(0, len(l), 2):\n        l[i] = sorted_even_idx_values.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = sorted([l[i] for i in range(0, len(l), 2)])\n    for i in range(0, len(l), 2):\n        l[i] = even_indices[i//2]\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_values = sorted(l[::2])\n    for i in range(0, len(l), 2):\n        l[i] = even_values.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    even_index_values = sorted(l[i] for i in range(0, len(l), 2))\n    result = [None] * len(l)\n    result[::2] = even_index_values\n    result[1::2] = l[1::2]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = sorted([l[i] for i in range(0, len(l), 2)])\n    for i in range(0, len(l), 2):\n        l[i] = even_indices.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    for i in range(0, len(l), 2):\n        l[i] = even_elements.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    even_index_values = sorted([value for i, value in enumerate(l) if i % 2 == 0])\n    new_list = [None]*len(l)\n\n    for i, value in enumerate(l):\n        if i % 2 == 0:\n            new_list[i] = even_index_values.pop(0)\n        else:\n            new_list[i] = value\n    return new_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n\n    # Extract even-indexed elements and sort them\n    sorted_even_indexed_elements = sorted([l[i] for i in range(0, len(l), 2)])\n\n    # Replace even-indexed elements in the original list\n    for i in range(0, len(l), 2):\n        l[i] = sorted_even_indexed_elements.pop(0)\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    sorted_even = sorted([val for idx, val in enumerate(l) if idx % 2 == 0])\n    result = [val if idx % 2 != 0 else sorted_even.pop(0) for idx, val in enumerate(l)]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    evens = sorted(l[::2])\n    for i in range(0, len(l), 2):\n        l[i] = evens.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Get the even indices\n    even_indices = [i for i in range(len(l)) if i % 2 == 0]\n    even_values = [l[i] for i in even_indices]\n    even_values.sort()\n    \n    # Replace the even indices in l with the sorted values\n    for i, value in zip(even_indices, even_values):\n        l[i] = value\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_list = sorted([l[i] for i in range(0, len(l), 2)])\n    for i in range(0, len(l), 2):\n        l[i] = even_list[i//2]\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # extract elements at even indices into a new list\n    even_index_list = [l[i] for i in range(0, len(l), 2)]\n\n    # sort the new list in ascending order\n    even_index_list.sort()\n\n    # replace the elements at even indices with sorted elements\n    for i in range(0, len(l), 2):\n        l[i] = even_index_list.pop(0)\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    result = l.copy()\n    for i in range(0, len(l), 2):\n        result[i] = even_elements[i // 2]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Create a copy of the list\n    result = l.copy()\n    # Extract the even-indexed elements of l and sort them\n    sorted_even_indices = sorted(l[i] for i in range(0, len(l), 2))\n\n    # Assign the sorted elements back to the even-indexed positions in the result\n    for i in range(0, len(l), 2):\n        result[i] = sorted_even_indices[i // 2]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_numbers = [l[i] for i in range(0, len(l), 2)]\n    even_numbers.sort()\n    for i in range(0, len(l), 2):\n        l[i] = even_numbers.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even index elements\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even indices elements\n    even_indices.sort()\n    \n    # Create a new list by replacing even indices with sorted elements and leaving odd indices as they are\n    new_list = [even_indices.pop(0) if i%2 == 0 else l[i] for i in range(len(l))]\n    \n    return new_list", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 90.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # calculate 2^n using the built-in function pow\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # calculate the result of 2**n modulo p\n    result = pow(2, n, p)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    new_text = ''\n\n    for char in text:\n        if char not in vowels:\n            new_text += char\n            \n    return new_text", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([ch for ch in text if ch not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    no_vowel_text = ''.join([char for char in text if char not in vowels])\n    return no_vowel_text", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([ch for ch in text if ch not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    return ''.join([i for i in text if i not in vowels])", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    result = ''\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return \"\".join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "HumanEval/58": {"dps": 88.66141732283464, "dps_norm": 80.0, "pass@1": 99.0, "profiled": [{"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    result = sorted(set(l1) & set(l2))\n    return result", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n\n    # Combine the two lists and filter out the unique values\n    common_list = list(set(l1) & set(l2))\n    \n    # Sort the common elements in ascending order\n    sorted_list = sorted(common_list)\n    \n    return sorted_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Converts lists to sets to make it easier to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Uses set intersection to find common elements\n    common_elements = set1 & set2\n\n    # Converts set back to list and sorts it\n    common_elements = list(common_elements)\n    common_elements.sort()\n    \n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_set = list(set(l1) & set(l2))\n    common_set.sort()\n    return common_set", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n\n    # Find intersection of both lists\n    common_elements = list(set(l1) & set(l2))\n\n    # Sort the list in ascending order\n    common_elements.sort()\n\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Converting lists to sets to get unique elements and then convert back to list\n    l1 = list(set(l1))\n    l2 = list(set(l2))\n    common_list = []\n\n    # Iterate over elements in both lists and add common elements to common_list\n    for i in l1:\n        if i in l2:\n            common_list.append(i)\n\n    # Sort and return common_list\n    return sorted(common_list)", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert the lists to sets to find the intersection.\n    # Convert the result back to a list for further operations.\n    common_elements = list(set(l1) & set(l2))\n    # Sort the common elements.\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Use list comprehension and set intersection\n    common_list = sorted(list(set(l1) & set(l2)))\n    return common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find the common elements by intersecting the two sets\n    common_set = set1.intersection(set2)\n\n    # Convert the common set to a list, sort it and return\n    common_list = list(common_set)\n    common_list.sort()\n    return common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to remove duplicates\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find the common elements\n    common_elements = set1 & set2\n\n    # Return the sorted common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    common_elements = list(set(l1) & set(l2))\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 91.14583333333333, "dps_norm": 93.33333333333333, "pass@1": 95.0, "profiled": [{"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = None\n    for i in range(2, n):\n        if n % i == 0 and is_prime(i):\n            largest_factor = i\n\n    return largest_factor", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    # Initializing the maximum prime number to 1\n    max_prime = -1\n\n    # Print the number of 2s that divide n\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1  # equivalent to n /= 2\n\n    # n is odd now, so a skip of 2 can be used\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n //= i\n\n    # If n is a prime number and n > 2, n will not get reduced to 1 in loop,\n    # so return n\n    if n > 2:\n        max_prime = n\n\n    return max_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(m: int):\n        \"\"\"Check if m is a prime number.\"\"\"\n        if m <= 1:\n            return False\n        if m <= 3:\n            return True\n        if m % 2 == 0 or m % 3 == 0:\n            return False\n        i = 5\n        while i * i <= m:\n            if m % i == 0 or m % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = -1\n    if n % 2 == 0:\n        largest_factor = 2\n        while n % 2 == 0:\n            n /= 2\n    if n % 3 == 0:\n        largest_factor = 3\n        while n % 3 == 0:\n            n /= 3\n    i = 5\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            while n % i == 0:\n                n /= i\n        if n % (i + 2) == 0:\n            largest_factor = i + 2\n            while n % (i + 2) == 0:\n                n /= (i + 2)\n        i += 6\n    if n > 1:\n        return int(n)\n    else:\n        return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n\n    i = 2\n    factors = []\n\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n\n    if n > 1:\n        factors.append(n)\n\n    return max(factors)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Helper function to check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = None\n    for i in range(2, n):\n        if n % i == 0 and is_prime(i):\n            largest_factor = i\n    return largest_factor", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return max(factors)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    assert n > 1, \"n must be greater than 1\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    # check for factor 2\n    while n % 2 == 0:\n        n /= 2\n    if n == 1:\n        return 2\n\n    # check for odd factor\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            max_prime = i\n            n /= i\n        i += 2\n\n    # if n is a prime number and n > 2\n    if n > 2:\n        max_prime = n\n\n    return max_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 66.77489177489177, "dps_norm": 51.041666666666664, "pass@1": 12.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum(1 for c in s if c in vowels)\n    # if 'y' is at the end, increment count\n    if s and s[-1] == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n\n    # Additional condition if y is at end of string\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = \"aeiou\"\n    count = 0\n    for char in s.lower():\n        if char in vowels:\n            count += 1\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowel_set = set('aeiou')\n    count = sum(1 for char in s if char in vowel_set)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define vowels\n    vowels = set(\"aeiou\")\n\n    # Initialize counter\n    count = 0\n\n    # Iterate over the string\n    for i in range(len(s)):\n        if s[i].lower() in vowels or (s[i].lower() == 'y' and i == len(s) - 1):\n            count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = 'aeiou'\n    count = sum(1 for c in s if c in vowels)\n    \n    # handle 'y' as a vowel when it's at the end\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = \"aeiou\"\n    count = 0\n    for letter in s.lower():\n        if letter in vowels:\n            count += 1\n    if s.endswith(\"y\") or s.endswith(\"Y\"):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    count = 0\n    vowels = \"aeiou\"\n\n    # Check vowels at beginning and end of string\n    for i in range(len(s)):\n        if s[i].lower() in vowels or (s[i].lower() == 'y' and i == len(s)-1):\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    count = sum(1 for c in s.lower() if c in 'aeiou')\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        if s[i].lower() in 'aeiou':\n            count += 1\n        elif i == len(s) - 1 and s[i].lower() == 'y':\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        if s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    vowels = \"aeiou\"\n    count = 0\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    # if 'y' is at the end, count it as a vowel\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 2}]}, "HumanEval/74": {"dps": 93.46341463414635, "dps_norm": 87.77777777777777, "pass@1": 86.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(x) for x in lst1)\n    sum2 = sum(len(x) for x in lst2)\n    \n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    \"\"\"\n    len1 = sum(len(x) for x in lst1)\n    len2 = sum(len(x) for x in lst2)\n\n    return lst1 if len1 < len2 else lst2 if len1 != len2 else lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 < len2:\n        return lst1\n    elif len2 < len1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    This function accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    len1 = sum(len(x) for x in lst1)\n    len2 = sum(len(x) for x in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    This function accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    \"\"\"\n    # calculating total number of chars in each list\n    total_chars1 = sum(len(x) for x in lst1)\n    total_chars2 = sum(len(x) for x in lst2)\n\n    # comparing and returning the correct list\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars1 > total_chars2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n\n    if count_chars(lst1) <= count_chars(lst2):\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    if sum(len(x) for x in lst1) <= sum(len(x) for x in lst2):\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Getting the total number of characters for both lists\n    total_chars1 = sum(len(word) for word in lst1)\n    total_chars2 = sum(len(word) for word in lst2)\n\n    # Comparing the total number of characters in the two lists and returning the list\n    # with fewer total characters. If they are the same, return the first list.\n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    lst1_total = sum(len(i) for i in lst1)\n    lst2_total = sum(len(i) for i in lst2)\n    if lst1_total == lst2_total:\n        return lst1\n    else:\n        return lst1 if lst1_total < lst2_total else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len_lst1 = sum(len(s) for s in lst1)\n    len_lst2 = sum(len(s) for s in lst2)\n\n    if len_lst1 < len_lst2:\n        return lst1\n    elif len_lst2 < len_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_lst1 = sum(len(word) for word in lst1)\n    sum_lst2 = sum(len(word) for word in lst2)\n    if sum_lst1 <= sum_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    A function that accepts two lists of strings and returns the list that has total \n    number of chars in the all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars1 = sum([len(s) for s in lst1])\n    total_chars2 = sum([len(s) for s in lst2])\n    \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(x) for x in lst1)\n    sum2 = sum(len(x) for x in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len_lst1 = sum([len(s) for s in lst1])\n    len_lst2 = sum([len(s) for s in lst2])\n\n    if len_lst1 <= len_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total1 = sum(len(x) for x in lst1)\n    total2 = sum(len(x) for x in lst2)\n    return lst1 if total1 < total2 else lst2 if total1 != total2 else lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    lst1_total_chars = sum(len(x) for x in lst1)\n    lst2_total_chars = sum(len(x) for x in lst2)\n\n    if lst1_total_chars <= lst2_total_chars:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n\n    if total_chars(lst1) < total_chars(lst2):\n        return lst1\n    elif total_chars(lst1) > total_chars(lst2):\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 5}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n    return lst1 if sum1 <= sum2 else lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 83.66336633663366, "dps_norm": 50.0, "pass@1": 98.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 != 0 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 != 0 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n\n    return sum(value for index, value in enumerate(lst) if index % 2 != 0 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\"\"\"\n    return sum([value for index, value in enumerate(lst) if index % 2 != 0 and value % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 != 0 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n\n    return sum(value for index, value in enumerate(lst) if index % 2 == 1 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 != 0 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) returns 2 \n    \"\"\"\n    # Initialize a sum to 0\n    sum = 0\n    \n    # For each index in the list\n    for i in range(len(lst)):\n        # If the index is odd and the element at that index is even\n        if i % 2 == 1 and lst[i] % 2 == 0:\n            # Add the element to the sum\n            sum += lst[i]\n    \n    # Return the sum\n    return sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n\n    return sum([n for i, n in enumerate(lst) if i % 2 == 1 and n % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    result = 0\n    for i in range(len(lst)):\n        # check if index is odd\n        if i % 2 != 0:\n            # check if element is even\n            if lst[i] % 2 == 0:\n                result += lst[i]\n    return result", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Parameters:\n        lst (list): a non-empty list of integers.\n\n    Returns:\n        (int): the sum of the even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) returns: 2\n        add([3, 1, 2, 4, 6, 7, 8]) returns: 10\n    \"\"\"\n    return sum(el for idx, el in enumerate(lst) if idx % 2 != 0 and el % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n    \n    :param lst: non-empty list of integers \n    :return: the sum of even elements at odd indices\n\n    Examples:\n        add([4, 2, 6, 7]) => 2\n    \"\"\"\n    \n    return sum(num for idx, num in enumerate(lst) if idx % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 1 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    sum_val = 0\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            sum_val += lst[i]\n    return sum_val", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Args:\n        lst: A list of integers.\n\n    Returns:\n        Sum of even numbers at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) \n        >>> 2\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7]) \n        2\n    \"\"\"\n\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 != 0 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum([val for i, val in enumerate(lst) if i % 2 != 0 and val % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 1 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 != 0 and value % 2 == 0)", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": 95.61224489795919, "dps_norm": 98.0, "pass@1": 51.0, "profiled": [{"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(\" \")\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    anti_shuffled = [''.join(sorted(word)) for word in words]\n    return ' '.join(anti_shuffled)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [\"\".join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    \n    # Split the string into words\n    words = s.split(' ')\n    \n    # Sort characters in each word\n    for i in range(len(words)):\n        words[i] = ''.join(sorted(words[i]))\n    \n    # Join sorted words back into a string\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_chars(word):\n        return ''.join(sorted(word))\n    \n    words = s.split(' ')\n    sorted_words = [sort_chars(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    return ' '.join(''.join(sorted(word, key=lambda x: ord(x))) for word in s.split(' '))", "matching_cluster_idx": 2}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    \n    # Split the string into a list of words\n    words = s.split(' ')\n    \n    # For each word in the list, sort the characters by ascii value and join them\n    # back together\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a string and return\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_chars(word):\n        \"\"\"Returns the word sorted by ASCII value.\"\"\"\n        return ''.join(sorted(word, key=ord))\n\n    # Split string into words\n    words = s.split(' ')\n\n    # Sort each word\n    sorted_words = [sort_chars(word) for word in words]\n\n    # Join words back into a string\n    sorted_s = ' '.join(sorted_words)\n\n    return sorted_s", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    return ' '.join(''.join(sorted(word)) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(\" \")\n    for i, word in enumerate(words):\n        words[i] = \"\".join(sorted(word))\n    return \" \".join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\n    words = s.split(' ')\n    ordered_words = [' '.join([''.join(sorted(word)) for word in words])]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(\" \")\n    new_words = []\n\n    for word in words:\n        chars = list(word)\n        chars.sort()\n        new_word = \"\".join(chars)\n        new_words.append(new_word)\n    \n    return \" \".join(new_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n\n    :param s: str\n    :return: str\n    \"\"\"\n\n    words = s.split(' ')\n    sorted_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    This function takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n\n    # Split the sentence into words by space\n    words = s.split(' ')\n    ordered_words = []\n    \n    for word in words:\n        # Sort characters of the word in ascending order and join them back into a string\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    \n    # Join the words back into a sentence and return\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\n    def order_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    ordered_words = [order_word(word) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Function that takes a string and returns an ordered version of it.\n    \"\"\"\n    # split the string into words\n    words = s.split(\" \")\n\n    # for each word, sort characters and join them back into a string\n    ordered_words = [''.join(sorted(word)) for word in words]\n\n    # join words back into a string and return it\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Function to return an ordered version of a string.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n\n    :param s: string\n    :return: string\n    \"\"\"\n    return \" \".join(\"\".join(sorted(word)) for word in s.split(\" \"))", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 53.371757925072046, "dps_norm": 49.285714285714285, "pass@1": 60.0, "profiled": [{"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, col in enumerate(row[::-1]):\n            if col == x:\n                coordinates.append((i, len(row) - j - 1))\n    coordinates.sort(key=lambda k: (k[0], -k[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        indices = [j for j, num in enumerate(row) if num == x]\n        for index in sorted(indices, reverse=True):\n            result.append((i, index))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda c: (c[0], -c[1]))\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    #Sort by rows in ascending order and then columns in descending order\n    coordinates.sort(key=lambda c: (c[0], -c[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find integers x in the list and return list of tuples,\n    [(x1, y1), (x2, y2) ...] such that each tuple is\n    a coordinate - (row, columns), starting with 0. Sort\n    coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \"\"\"\n    # Initialize an empty list to store coordinates\n    coords = []\n\n    # Loop through the rows and columns of the 2D list\n    for i, row in enumerate(lst):\n        # Get indices of x in the current row, starting from 0\n        indices = [i for i, v in enumerate(row) if v == x]\n\n        # If x is in the current row, add the coordinates to the list\n        if indices:\n            coords.extend([(i, j) for j in indices])\n\n    # Sort coordinates initially by rows in ascending order,\n    # then by columns in descending order\n    coords.sort(key=lambda x: (x[0], -x[1]))\n\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    return sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coords.append((i, j))\n    coords.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coords", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    \n    # Sorting by rows in ascending order and columns in descending order\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i,j))\n    return sorted(coordinates, key=lambda x: (x[0], -x[1]))", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for column_index in sorted([i for i, val in enumerate(row) if val == x], reverse=True):\n            coordinates.append((row_index, column_index))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coords = []\n\n    for row_index, row in enumerate(lst):\n        for column_index in reversed(range(len(row))):\n            if row[column_index] == x:\n                coords.append((row_index, column_index))\n\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Function to find a given number in a 2D list and return its indices\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                result.append((i, j))\n\n    # Sorting initially by rows in ascending order and then by columns in descending order\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    result = []\n    for i in range(len(lst)):\n        row = lst[i]\n        for j in range(len(row)):\n            if row[j] == x:\n                result.append((i, j))\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                result.append((i, j))\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Function to find integer x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Args:\n    lst: a 2 dimensional data, as a nested lists\n    x: an integer\n    \n    Returns:\n    A list of tuples with row and column coordinates of x sorted\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i]) - 1, -1, -1):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coords.append((i, j))\n    coords.sort(key=lambda x: (x[0], -x[1]))\n    return coords", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \"\"\"\n\n    coordinates = []\n    \n    for i in range(len(lst)):\n        row = lst[i]\n        for j in range(len(row)):\n            if row[j] == x:\n                coordinates.append((i, j))\n                \n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        row = lst[i]\n        indices = [(i, j) for j in range(len(row)) if row[j] == x]\n        indices.sort(key=lambda x: x[1], reverse=True)\n        coordinates.extend(indices)\n    return coordinates", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.70103092783506, "dps_norm": 31.42857142857143, "pass@1": 69.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Create a string of the alphabet\n    alpha = 'abcdefghijklmnopqrstuvwxyz'\n\n    # Create a variable to hold the output string\n    output_str = ''\n\n    # Iterate through each character in the input string\n    for char in s:\n        # If the character is in the alphabet, get the index and shift it down by 2*2\n        if char.lower() in alpha:\n            output_str += alpha[(alpha.index(char.lower()) + 2*2) % len(alpha)]\n        else:\n            output_str += char\n\n    # Return the output string\n    return output_str", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 2 * 2\n    result = \"\"\n\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted_char = chr((((ord(char) - ascii_offset) + shift) % 26) + ascii_offset)\n            result += encrypted_char\n        else:\n            result += char\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \"\"\"\n\n    encrypted_text = \"\"\n    for character in s:\n        ascii_val = ord(character)\n        if 65 <= ascii_val <= 90:  # For upper case characters\n            new_val = ((ascii_val - 65 + 2*2) % 26) + 65\n        elif 97 <= ascii_val <= 122:  # For lower case characters\n            new_val = ((ascii_val - 97 + 2*2) % 26) + 97\n        else:  # For any other characters that are not letters\n            new_val = ascii_val\n        encrypted_text += chr(new_val)\n\n    return encrypted_text", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n    for char in s:\n        if char in alphabet:\n            encrypted += alphabet[(alphabet.index(char) + 4) % len(alphabet)]\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \"\"\"\n    encrypted_s = ''\n    for char in s:\n        if char.isalpha():\n            shift = 4\n            if char.isupper():\n                encrypted_s += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            else:\n                encrypted_s += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n        else:\n            encrypted_s += char\n    return encrypted_s", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2*2\n            if char.isupper():\n                result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            else:\n                result += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n    for char in s:\n        if char in alphabet:\n            index = (alphabet.index(char) + 4) % 26\n            encrypted += alphabet[index]\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and \n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    \n    def rotate_char(c):\n        \"\"\"Rotate char c by two places.\n        If c is not a lowercase letter, return c as it is.\"\"\"\n        if 'a' <= c <= 'z':\n            return chr(((ord(c) - ord('a') + 4) % 26) + ord('a'))\n        else:\n            return c\n\n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \"\"\"\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    encrypted_text = \"\"\n    for char in s:\n        if char in alphabet:\n            index = (alphabet.index(char) + 2*2) % 26  # use modulus to make sure index stays within bounds\n            encrypted_text += alphabet[index]\n        else:\n            encrypted_text += char\n    return encrypted_text", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = ''\n    for char in s:\n        ascii_val = ord(char)\n        if 97 <= ascii_val <= 122:  # Lowercase a-z\n            result += chr((ascii_val - ord('a') + 2*2) % 26 + ord('a'))\n        elif 65 <= ascii_val <= 90:  # Uppercase A-Z\n            result += chr((ascii_val - ord('A') + 2*2) % 26 + ord('A'))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted_string += chr(((ord(char) - ascii_offset + 2*2) % 26) + ascii_offset)\n        else:\n            encrypted_string += char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Define the key for encryption\n    key = alphabet[2 * 2:] + alphabet[:2 * 2]\n    \n    # Create a translation table\n    table = str.maketrans(alphabet + alphabet.upper(), key + key.upper())\n    \n    # Return the encrypted string\n    return s.translate(table)", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = \"\"\n    for c in s:\n        if 'a' <= c <= 'z':\n            result += chr(((ord(c) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= c <= 'Z':\n            result += chr(((ord(c) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            result += c\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = \"\"\n    for letter in s:\n        if letter.isalpha():\n            ascii_value = ord(letter)\n            # Shift down by two multiplied to two places\n            new_ascii_value = ascii_value + (2 * 2)\n            if letter.isupper():\n                if new_ascii_value > ord('Z'):\n                    new_ascii_value -= 26\n                result += chr(new_ascii_value)\n            else:\n                if new_ascii_value > ord('z'):\n                    new_ascii_value -= 26\n                result += chr(new_ascii_value)\n        else:\n            result += letter\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_value = ord(char.lower())\n            if ascii_value + (2*2) > 122:\n                result += chr((ascii_value + (2*2)) % 123 + 97)\n            else:\n                result += chr(ascii_value + (2*2))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        ascii_code = ord(char)\n        if 97 <= ascii_code <= 122:  # check if the character is lowercase\n            result += chr(((ascii_code - 97 + 2*2) % 26) + 97)\n        elif 65 <= ascii_code <= 90:  # check if the character is uppercase\n            result += chr(((ascii_code - 65 + 2*2) % 26) + 65)\n        else:  # non-alphabetic character\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    \n    result = \"\"\n    for char in s:\n        # If character is a letter, shift it down by 2*2 places in the alphabet\n        if char.isalpha():\n            char_code = ord(char.lower())\n            new_char_code = (char_code - 97 + 4) % 26 + 97\n            new_char = chr(new_char_code).upper() if char.isupper() else chr(new_char_code)\n        else:\n            new_char = char\n        result += new_char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_s = ''\n    for char in s:\n        if char in alphabet:\n            new_char = alphabet[(alphabet.index(char) + 2*2) % len(alphabet)]\n            encrypted_s += new_char\n        else:\n            encrypted_s += char\n    return encrypted_s", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + 2*2) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            if char.isupper():\n                result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            else:\n                result += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 83.21011673151752, "dps_norm": 63.333333333333336, "pass@1": 80.0, "profiled": [{"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    else:\n        lst = list(set(lst))  # removing duplicates\n        lst.sort()\n        if len(lst) < 2:\n            return None\n        else:\n            return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Return the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    >>> next_smallest([1, 1])\n    \"\"\"\n\n    # convert the list to a set to remove duplicates\n    unique_lst = list(set(lst))\n    \n    # check if list has less than 2 unique elements\n    if len(unique_lst) < 2:\n        return None\n    \n    # sort the list and return the 2nd element\n    unique_lst.sort()\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n\n    if len(lst) < 2:\n        return None\n\n    smallest = min(lst)\n    next_smallest = None\n    for i in lst:\n        if i != smallest and (next_smallest is None or i < next_smallest):\n            next_smallest = i\n\n    return next_smallest", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:  # if there is only 0 or 1 item in list, 2nd smallest element does not exist\n        return None\n    else:\n        lst = sorted(lst)  # sort the list in ascending order\n        smallest = lst[0]  # find the smallest element\n        next_smallest = None\n        for num in lst[1:]:  # iterate through the rest of the list\n            if num > smallest:  # if an element is larger than the smallest one\n                next_smallest = num  # it's the next smallest number\n                break  # exit the loop, because we need only the 2nd smallest element\n        return next_smallest", "matching_cluster_idx": 9}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Function returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \"\"\"\n    if len(lst) < 2: \n        return None\n    else:\n        lst = list(set(lst))\n        lst.sort()\n        if len(lst) < 2: \n            return None\n        else:\n            return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Function that returns the 2nd smallest element of a list\n    \"\"\"\n    # Remove duplicates from the list\n    unique_lst = list(set(lst))\n    \n    # Sort the list in ascending order\n    unique_lst.sort()\n    \n    # Return None if there is no 2nd smallest element\n    if len(unique_lst) < 2:\n        return None\n    \n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    else:\n        lst = sorted(lst)\n        smallest = lst[0]\n        for num in lst:\n            if num != smallest:\n                return num\n        return None", "matching_cluster_idx": 10}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Function to return the 2nd smallest element of the list.\n    \"\"\"\n    # Remove duplicates\n    lst = list(set(lst))\n    # Check if there are at least 2 unique elements\n    if len(lst) < 2:\n        return None\n    else:\n        lst.sort()  # sort the list\n        return lst[1]  # return the 2nd smallest", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates\n    unique_lst = list(set(lst))\n    # Sort in ascending order\n    sorted_lst = sorted(unique_lst)\n    if len(sorted_lst) > 1:\n        return sorted_lst[1]\n    return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    # Create a set from the list to remove duplicates\n    distinct_elements = set(lst)\n    \n    # If the list has less than 2 distinct elements, there's no 2nd smallest element\n    if len(distinct_elements) < 2:\n        return None\n    \n    # Sort the set in ascending order and return the second element\n    sorted_elements = sorted(distinct_elements)\n    return sorted_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    else:\n        lst.sort()\n        smallest = lst[0]\n        for item in lst:\n            if item > smallest:\n                return item\n        return None", "matching_cluster_idx": 11}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) <= 1:\n        return None\n    else:\n        unique_numbers = list(set(lst))\n        unique_numbers.sort()\n        if len(unique_numbers) > 1:\n            return unique_numbers[1]\n        else:\n            return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    \"\"\"\n    unique_elements = sorted(set(lst))\n    return unique_elements[1] if len(unique_elements) >= 2 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # convert list to set to remove duplicates\n    unique_lst = set(lst)\n    # if there are 1 or 0 elements in unique list then there is no 2nd smallest\n    if len(unique_lst) <= 1:\n        return None\n    else:\n        # convert back to list and sort\n        sorted_lst = sorted(list(unique_lst))\n        # return 2nd element in sorted list\n        return sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Function to find the 2nd smallest element in a list\n\n    Returns:\n        The 2nd smallest element in the list or None if not available\n    \"\"\"\n    \n    # Convert list to set to remove duplicates, then convert back to list\n    lst = list(set(lst))\n\n    # Sort the list\n    lst.sort()\n\n    # If there are at least 2 elements in the list return the second smallest\n    if len(lst) > 1:\n        return lst[1]\n    else:\n        return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    # checking if the list contains at least 2 distinct elements\n    if len(set(lst)) < 2:\n        return None\n    else:\n        return sorted(set(lst))[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    If there is no such element, returns None.\n    \"\"\"\n    distinct_lst = list(set(lst))\n    if len(distinct_lst) < 2:\n        return None\n    else:\n        distinct_lst.sort()\n        return distinct_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    lst = list(set(lst))\n\n    # If there are less than 2 unique elements, return None\n    if len(lst) < 2:\n        return None\n    \n    # Sort the list and return the 2nd element (which is the 2nd smallest)\n    lst.sort()\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_sorted_lst = sorted(set(lst))\n    return unique_sorted_lst[1] if len(unique_sorted_lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    lst.sort()\n    smallest = lst[0]\n    for num in lst:\n        if num > smallest:\n            return num\n    return None", "matching_cluster_idx": 11}]}, "HumanEval/113": {"dps": 94.32048681541582, "dps_norm": 64.16666666666667, "pass@1": 84.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\"\"\"\n    return [f\"the number of odd elements {str(len([ch for ch in item if int(ch) % 2 != 0]))}n the str{len([ch for ch in item if int(ch) % 2 != 0])}ng {len([ch for ch in item if int(ch) % 2 != 0])} of the {len([ch for ch in item if int(ch) % 2 != 0])}nput.\" for item in lst]", "matching_cluster_idx": 0}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    res = []\n    for idx, string in enumerate(lst, 1):\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        replaced_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count)\n        res.append(replaced_string)\n    return res", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for i, string in enumerate(lst):\n        count = sum(1 for digit in string if int(digit) % 2 != 0)\n        output.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        string = lst[i]\n        count = sum(1 for digit in string if int(digit) % 2 != 0)\n        result.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count))\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, string in enumerate(lst):\n        num_odds = sum(int(char) % 2 for char in string)\n        result.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(num_odds, num_odds, num_odds, num_odds))\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    result = []\n    for i in range(len(lst)):\n        odd_digits_count = sum(1 for c in lst[i] if int(c) % 2 != 0)\n        result.append(\n            f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for c in s if int(c) % 2 == 1)\n\n    def generate_string(count, string):\n        return f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n\n    return [generate_string(count_odd_digits(s), s) for s in lst]", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n\n    for i in range(len(lst)):\n        count = sum(int(d) % 2 for d in lst[i])\n        temp_string = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(temp_string)\n        \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i, string in enumerate(lst):\n        count = sum(int(digit) % 2 for digit in string)\n        output.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i, string in enumerate(lst):\n        count_odd = sum(int(ch) % 2 for ch in string)\n        output.append(f\"the number of odd elements {count_odd}n the str{count_odd}ng {count_odd} of the {count_odd}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i in lst:\n        num_of_odds = sum(1 for digit in i if int(digit) % 2 != 0)\n        result.append(\n            f\"the number of odd elements {num_of_odds}n the str{num_of_odds}ng {num_of_odds} of the {num_of_odds}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst):\n        odd_digits_in_s = sum(int(c) % 2 for c in s)\n        temp = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n            odd_digits_in_s,\n            odd_digits_in_s,\n            odd_digits_in_s,\n            odd_digits_in_s\n        )\n        result.append(temp)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        odd_numbers = sum(1 for n in lst[i] if int(n) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_numbers}n the str{odd_numbers}ng {odd_numbers} of the {odd_numbers}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i in range(len(lst)):\n        str_ = lst[i]\n        count = sum(1 for char in str_ if int(char) % 2 != 0)\n        output.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\"\"\"\n    output = []\n    for i, string in enumerate(lst):\n        count_odd = sum([int(d) % 2 for d in string])\n        # Modify the template string\n        temp_string = \"the number of odd elements 4n the str4ng 4 of the 4nput.\"\n        temp_string = temp_string.replace(\"4\", str(count_odd))\n        output.append(temp_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output_list = []\n    for i, string in enumerate(lst):\n        count_odd = sum(1 for digit in string if int(digit) % 2 != 0)\n        output_string = f\"the number of odd elements {count_odd}n the str{count_odd}ng {count_odd} of the {count_odd}nput.\"\n        output_list.append(output_string)\n    return output_list", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        count = sum(int(c) % 2 for c in s)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for idx, string in enumerate(lst):\n        num_odd = sum(1 for digit in string if int(digit) % 2 != 0)\n        new_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n            num_odd, num_odd, num_odd, num_odd)\n        result.append(new_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, string in enumerate(lst):\n        count = sum(1 for digit in string if int(digit) % 2 != 0)\n        temp = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        result.append(temp)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        count = sum(int(c) % 2 for c in s)\n        s = s.replace('1', 'n')  # replace '1' with 'n'\n        s = s.replace('3', 'r')  # replace '3' with 'r'\n        s = s.replace('4', 'n')  # replace '4' with 'n'\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 85.81395348837209, "dps_norm": 95.0, "pass@1": 39.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    Given a list of two strings, both strings consist of open parentheses '(' or close parentheses ')',\n    the function checks if it is possible to concatenate the two strings in some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S are balanced.\n    Returns 'Yes' if there's a way to make a good string, and 'No' otherwise.\n    '''\n    def is_balanced(s):\n        '''\n        Helper function to check if a string s is balanced\n        '''\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    s1, s2 = lst\n\n    # Try all possible combinations of concatenations and see if any result in a good string\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    elif is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        count = 0\n        for i in s:\n            if i == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    a, b = lst\n    return 'Yes' if is_good(a+b) or is_good(b+a) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    # Function to check if the parentheses in the given string is balanced\n    def check_balance(s):\n        stack = []\n        for i in s:\n            if i == \"(\":\n                stack.append(i)\n            elif i == \")\":\n                if not stack:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    # Check for all combinations and return 'Yes' if any of them is good\n    for i in range(2):\n        if check_balance(lst[0] + lst[1]):\n            return \"Yes\"\n        lst[0], lst[1] = lst[1], lst[0]\n\n    return \"No\"", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def check(s):\n        cnt = 0\n        for i in s:\n            if i == '(':\n                cnt += 1\n            else:\n                if cnt == 0:\n                    return False\n                cnt -= 1\n        return cnt == 0\n\n    return 'Yes' if check(lst[0] + lst[1]) or check(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def check_good(s):\n        # Function to check if a string is good\n        cnt = 0\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            else:\n                if cnt == 0:\n                    return False\n                cnt -= 1\n        return cnt == 0\n\n    # Try all possible concatenations\n    if check_good(lst[0] + lst[1]) or check_good(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Check if it's possible to concatenate the two strings in some order,\n    so that the resulting string is good. A string is considered to be good\n    if and only if all parentheses in it are balanced.\n\n    Parameters:\n    lst (list): A list of two strings. Both strings consist of open parentheses '('\n    or close parentheses ')'.\n\n    Returns:\n    str: 'Yes' if there's a way to make a good string, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        '''\n        Check if a string is balanced.\n\n        Parameters:\n        s (str): The input string.\n\n        Returns:\n        bool: True if the string is balanced, False otherwise.\n        '''\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    for i in range(2):\n        if is_balanced(lst[0] + lst[1]):\n            return 'Yes'\n        lst = [lst[1], lst[0]]\n\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        cnt = 0\n        for ch in s:\n            if ch == '(':\n                cnt += 1\n            elif ch == ')':\n                cnt -= 1\n                if cnt < 0:\n                    return False\n        return cnt == 0\n\n    return 'Yes' if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        cnt = 0\n        for c in s:\n            if c == '(':\n                cnt += 1\n            else:\n                cnt -= 1\n            if cnt < 0:\n                return False\n        return cnt == 0\n\n    return 'Yes' if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def check_balance(s):\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            elif c == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    def dfs(idx, s1, s2):\n        if idx == len(lst):\n            return check_balance(s1 + s2)\n        return (dfs(idx + 1, s1 + lst[idx], s2) or \n                dfs(idx + 1, s1, s2 + lst[idx]))\n\n    return 'Yes' if dfs(0, \"\", \"\") else 'No'", "matching_cluster_idx": 2}, {"solution": "def match_parens(lst):\n    # Define a helper function to check if a string is balanced\n    def is_balanced(s):\n        stack = []\n        for ch in s:\n            if ch == '(':\n                stack.append(ch)\n            elif not stack:\n                return False\n            else:\n                stack.pop()\n        return not stack\n\n    # Use recursion to generate all permutations of the two strings\n    def permute(data, i, length):\n        # Base case\n        if i==length:\n            # Check if the concatenated string is balanced\n            if is_balanced(data[0] + data[1]):\n                return True\n        else:\n            # Generate permutations\n            for j in range(i,length):\n                # Swap the i-th and j-th element\n                data[j], data[i] = data[i], data[j]\n                # Recurse to generate the remaining permutations\n                if permute(data, i+1, length):\n                    return True\n                # Swap the i-th and j-th element back (to backtrack)\n                data[j], data[i] = data[i], data[j] \n        return False\n\n    return 'Yes' if permute(lst, 0, len(lst)) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            elif c == ')':\n                balance -= 1\n            if balance < 0:  # early stopping if there's a closing parenthesis before an opening one\n                return False\n        return balance == 0\n\n    a, b = lst\n    return 'Yes' if is_balanced(a + b) or is_balanced(b + a) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    if len(lst) != 2:\n        return 'Invalid input. Please provide exactly two strings.'\n\n    def check_string(string):\n        balance = 0\n        for character in string:\n            if character == '(':\n                balance += 1\n            elif character == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    str1, str2 = lst\n    return 'Yes' if check_string(str1 + str2) or check_string(str2 + str1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def check(s):\n        balance = 0\n        for ch in s:\n            if ch == '(':\n                balance += 1\n            else:\n                if balance == 0:\n                    return False\n                balance -= 1\n        return balance == 0\n\n    a, b = lst\n    if check(a + b) or check(b + a):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def check_balance(s):\n        balance = 0\n        for p in s:\n            if p == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    def concat_and_check(s1, s2):\n        return check_balance(s1+s2) or check_balance(s2+s1)\n\n    return 'Yes' if concat_and_check(lst[0], lst[1]) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def check_balance(s):\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            elif c == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    for i in range(2):\n        if check_balance(lst[0] + lst[1]):\n            return 'Yes'\n        lst = [lst[1], lst[0]]\n\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_good(s):\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            else:\n                if balance == 0:\n                    return False\n                balance -= 1\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it is possible to concatenate the two strings in some order, \n    that the resulting string will be good. A string S is considered to be good \n    if and only if all parentheses in S are balanced. For example: the string \n    '(())()' is good, while the string '())' is not. Returns 'Yes' if there's \n    a way to make a good string, and 'No' otherwise.\n    \n    Parameters:\n    lst (list of str): A list of two strings.\n\n    Returns:\n    str: 'Yes' if a good string can be formed. 'No' otherwise.\n    '''\n\n    s1, s2 = lst\n    def valid(s):\n        bal = 0\n        for c in s:\n            if c == '(':\n                bal += 1\n            else:\n                bal -= 1\n            if bal < 0:\n                return False\n        return bal == 0\n    \n    return 'Yes' if (valid(s1 + s2) or valid(s2 + s1)) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    # Join the two strings in a specific order and check if the resulting string is good.\n    def is_good(s):\n        '''Check if a string s is good.'''\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            else:\n                if balance == 0:\n                    return False\n                balance -= 1\n        return balance == 0\n\n    # Try all possible concatenation orders.\n    if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for p in s:\n            if p == '(':\n                balance += 1\n            elif p == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    return 'Yes' if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def balanced(s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    return 'Yes' if any(balanced(lst[0] + lst[1]) or balanced(lst[1] + lst[0]) for _ in lst) else 'No'", "matching_cluster_idx": 2}]}, "HumanEval/120": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 40.0, "profiled": [{"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    \n    # Sort the array in descending order\n    arr.sort(reverse=True)\n\n    # Get the first k elements\n    max_k = arr[:k]\n\n    # Sort the result in ascending order\n    max_k.sort()\n\n    return max_k", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n\n    # Return the first k elements\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # sort the array in descending order\n    arr.sort(reverse=True)\n    # return the first k elements\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in decreasing order\n    arr.sort(reverse=True)\n\n    # Return a sorted list with maximum k numbers\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n\n    # Return the first k elements\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    arr.sort(reverse=True) # Sort the array in descending order\n    return sorted(arr[:k]) # Return the first k elements of the sorted array", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 78.02690582959642, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(n for i, n in enumerate(lst) if i % 2 == 0 and n % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements \n    that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(val for i, val in enumerate(lst) if i % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    \n    return sum(val for i, val in enumerate(lst) if i % 2 == 0 and val % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n\n    return sum(val for i, val in enumerate(lst) if i % 2 == 0 and val % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \"\"\"\n    return sum(el for i, el in enumerate(lst) if i % 2 == 0 and el % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements \n    that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \"\"\"\n    result = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            result += value\n    return result", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum([num for index, num in enumerate(lst) if index % 2 == 0 and num % 2 != 0])", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \"\"\"\n    return sum([num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0])", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(val for i, val in enumerate(lst) if i % 2 == 0 and val % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum([num for index, num in enumerate(lst) if index % 2 == 0 and num % 2 != 0])", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(val for i, val in enumerate(lst) if i % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(val for i, val in enumerate(lst) if i % 2 == 0 and val % 2 == 1)", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 86.53543307086615, "dps_norm": 59.28571428571429, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filtering the list to only keep the strings with even length\n    lst = [x for x in lst if len(x) % 2 == 0]\n\n    # Sorting the list by length and alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter the list to only include words with even length\n    lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length and then lexicographically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Use list comprehension to filter out words of odd length\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort the list by length and then alphabetically\n    lst.sort(key = lambda x:(len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    even_length_lst = [string for string in lst if len(string) % 2 == 0]\n    sorted_lst = sorted(even_length_lst, key=lambda x: (len(x), x))\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word,\n    and you should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter the list to only include strings of even length\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length of the strings and then by the strings themselves\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Return a sorted list of strings of even length.\"\"\"\n    # Filter out strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort by length and then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter the list to exclude strings with odd lengths\n    lst = [x for x in lst if len(x) % 2 == 0]\n    \n    # Sort the list first by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    \"\"\"\n\n    # remove strings of odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # sort the list by length, then lexicographically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out the strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list by length and then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function takes a list of strings as input and:\n    1. Filters out the strings with odd lengths.\n    2. Sorts the list by length of words, and alphabetically for words of same length.\n    3. Returns the resulting sorted list.\n    \"\"\"\n    # Filter out strings with odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort the list by length of words and alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \"\"\"\n    \n    # filter out strings with odd length\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # sort by length then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \"\"\"\n    # Filter out strings with odd lengths\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # Sort the list by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter list by length\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort filtered list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    \n    even_length_list = [s for s in lst if len(s) % 2 == 0]\n    even_length_list.sort()\n    even_length_list.sort(key=len)\n    return even_length_list", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd length\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list by length of each word, then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # filter out words of odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # sort words by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes the strings that have odd lengths from list,\n    returns the resulted list with a sorted order.\n\n    Order of the list is ascending by length of each word, and alphabetically.\n\n    Args:\n    lst (list): a list of strings\n\n    Returns:\n    list: a list of strings sorted as described above\n    \"\"\"\n    result = [word for word in lst if len(word) % 2 == 0]\n    return sorted(result, key=lambda word: (len(word), word))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \"\"\"\n    # Delete the strings that have odd lengths from the list\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list by length of each word and then by alphabetically\n    lst = sorted(lst, key=lambda s: (len(s), s))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter list to contain only words of even length\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # Sort the list first by length and then alphabetically\n    lst.sort(key=lambda word: (len(word), word))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out the strings with odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 80.76271186440678, "dps_norm": 87.5, "pass@1": 88.0, "profiled": [{"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to check if a given number is not prime\n    \"\"\"\n    # if number is less than 2, it's not prime\n    if n < 2:\n        return True\n    # check divisibility starting from 2 up to n\n    for i in range(2, n):\n        if n % i == 0: # number is divisible - not prime\n            return True\n    # if no divisible number found - it's a prime number\n    return False", "matching_cluster_idx": 1}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while(i * i <= n):\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    \"\"\"\n    Helper function to check if a number is prime\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    \"\"\"\n    Main function to check if a number is not prime\n    \"\"\"\n    return not is_prime(n)", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \"\"\"\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    This function checks if a number is not a prime number.\n    \"\"\"\n    # 0 and 1 are not prime numbers\n    if n < 2:\n        return True\n    # 2 is the only even prime number\n    if n == 2: \n        return False\n    # all other even numbers are not primes\n    if n % 2 == 0: \n        return True\n    # range starts with 3 and only needs to go up the square root of n\n    # for all odd numbers\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \"\"\"\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \"\"\"\n    # 0 and 1 are not prime\n    if n < 2:\n        return True\n    \n    # 2 is prime\n    if n == 2:\n        return False\n\n    # check factors\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(num):\n    if num <= 1:\n        return True\n    elif num <= 3:\n        return False\n    elif num % 2 == 0 or num % 3 == 0:\n        return True\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i = i + 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1 or (n % 2 == 0 and n > 2): \n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to check if a number is not prime.\n\n    Parameters:\n        n (int): Number to be checked\n\n    Returns:\n        bool: Whether the number is not prime\n    \"\"\"\n    if n < 2:  # Numbers less than 2 are not prime\n        return True\n    for i in range(2, int(n**0.5) + 1):  # Checking for factors up to sqrt(n)\n        if n % i == 0:  # If n is divisible by any i, it is not prime\n            return True\n    return False  # If no factors found, n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1 or (n % 2 == 0 and n > 2): \n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to check if a number is not prime\n    \"\"\"\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}]}, "Mbpp/4": {"dps": 91.51877133105802, "dps_norm": 82.91666666666666, "pass@1": 92.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Function to find the n largest integers from a given list of numbers.\n    \"\"\"\n    # Using a heap data structure to find the n largest numbers\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq to find the n largest elements\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # use heapq's nlargest function\n    # it returns a list with n largest elements of the nums list\n    # in descending order\n    return heapq.nlargest(n, nums)\nnums = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"Returns the n largest integers from a given list, in descending order.\"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    import heapq\n    # Use heapq.nlargest to find the n largest numbers\n    # Negate the numbers to turn the problem into finding the n smallest numbers, and then negate them back to get the answer in descending order\n    return [-x for x in heapq.nsmallest(n, [-num for num in numbers])]", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    #Use heapq library to find the n largest integers\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Convert the list to a heap\n    heap = [-num for num in nums]\n    heapq.heapify(heap)\n    \n    # Find the n largest numbers\n    largest = [heapq.heappop(heap) for _ in range(n)]\n    \n    # Convert the results back to original values and return\n    return [-num for num in largest]", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        return None\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    \"\"\"Find the n largest integers from a given list of numbers, returned in descending order.\"\"\"\n    import heapq\n\n    if len(nums) < n:\n        return \"Error: n is larger than the list length\"\n    \n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(lst, n):\n    import heapq\n    heap = []\n    for num in lst:\n        heapq.heappush(heap, num)\n        if len(heap) > n:\n            heapq.heappop(heap)\n    return sorted(heap, reverse=True)", "matching_cluster_idx": 8}, {"solution": "def heap_queue_largest(nums, n):\n    \"\"\"\n    Function to find the n largest integers from a given list of numbers, \n    returned in descending order.\n    \"\"\"\n    # Checking if the list has enough elements to return n numbers\n    if len(nums) < n:\n        return \"Error: List has less than n elements\"\n\n    # Using list comprehension to handle possible invalid inputs\n    try:\n        nums = [int(i) for i in nums]\n    except ValueError:\n        return \"Error: List contains non-integer elements\"\n\n    # Sorting the list in descending order and returning the first n numbers\n    nums.sort(reverse=True)\n    return nums[:n]", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers from the list\n    # Include negative sign to turn the min-heap into a max-heap\n    # Since Python doesn't support max-heap, we are assuming we will consider max as min\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    if not lst or n > len(lst) or n < 1:\n        return None\n    \n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Function to find the n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    if n <= 0 or not nums:\n        return []\n\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 92.58503401360544, "dps_norm": 59.0, "pass@1": 72.0, "profiled": [{"solution": "def find_Rotations(s):\n    # Concatenate the string with itself\n    concatenated = s + s\n\n    # Search for the first occurrence of the original string in the concatenated string\n    for i in range(1, len(s) + 1):\n        if concatenated[i : i + len(s)] == s:\n            return i\n\n    # If no rotation equals the original string, return len(s)\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(string):\n    double_string = string + string\n    length = len(string)\n    for i in range(1, length + 1):\n        rotation = double_string[i : i+length]\n        if rotation == string:\n            return i\n    return length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(input_string):\n    # create a string that is double the original string\n    double_string = input_string + input_string\n    \n    # find the minimum number of rotations\n    for i in range(1, len(input_string) + 1):\n        if double_string[i : i + len(input_string)] == input_string:\n            return i\n    # return 0 if no rotations are possible\n    return 0", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(input_str):\n    temp = input_str + input_str\n    str_len = len(input_str)\n\n    for i in range(1, str_len + 1):\n        sub_str = temp[i : str_len + i]\n        if (input_str == sub_str):\n            return i\n\n    return str_len", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(str):\n    temp = str + str\n    n = len(str)\n    for i in range(1, n + 1):\n        substring = temp[i: i+n]\n        if substring == str:\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    temp = s + s\n    n = len(s)\n\n    for i in range(1, n+1):\n        substring = temp[i: n+i]\n        if (s == substring):\n            return i\n\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    check_string = s + s\n    for i in range(1, n + 1):\n        sub_string = check_string[i:n + i]\n        if sub_string == s:\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(input_string):\n    # Concatenate 'input_string' with itself\n    tmp = input_string + input_string\n    length = len(input_string)\n\n    for i in range(1, length + 1):\n        # Substring of length 'length' from index 'i' in 'tmp'\n        substring = tmp[i : i + length]\n\n        # If the substring is equal to the input_string, then return the rotation count\n        if substring == input_string:\n            return i\n\n    # If no rotation gives the input_string\n    return -1", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    temp = s + s\n    n = len(s)\n    for i in range(1, n + 1):\n        substring = temp[i: n + i]\n        if s == substring:\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(string):\n    if len(string) == 0:\n        return 0\n    temp = string + string\n    length = len(string)\n    for i in range(1, len(temp)-length+1):\n        rotation = temp[i : i+length]\n        if rotation == string:\n            return i\n    return len(string)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    temp = s + s\n    n = len(s)\n\n    for i in range(1, n+1):\n        substring = temp[i:n+i]\n        if (s == substring):\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(string):\n    temp = string + string\n    n = len(string)\n \n    for i in range(1, n + 1):\n        s = temp[i: n + i]\n        if s == string:\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # This is the basic string that we will be trying to rotate\n    basic = s\n\n    # For counting how many rotations we have made\n    count = 0\n\n    # We will keep repeating this process until we match the original string\n    while True:\n        # The first character of the string is removed and placed at the end\n        s = s[1:] + s[0]\n\n        # Increment the count\n        count += 1\n\n        # Check if the new string is same as the original\n        if s == basic:\n            # If yes, return the count of rotations\n            return count", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    n = len(s)\n    s2 = s + s\n    for i in range(1, n+1):\n        if s2[i:i+n] == s:\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    temp = s + s\n    n = len(s)\n\n    for i in range(1, n + 1):\n        substring = temp[i: n + i]\n        if substring == s:\n            return i\n\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Function to find the minimum number of rotations to get back the same string.\n    If there is no rotation possible, return -1\n    \"\"\"\n    double = s + s\n    n = len(s)\n\n    for i in range(1, n + 1):\n        substring = double[i : n + i]\n        if (s == substring):\n            return i\n\n    return -1", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(string):\n    # 2-pointer approach\n    i = 1\n    while i < len(string):\n        if string == string[i:] + string[:i]:\n            return i\n        i += 1\n    return len(string)", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(input_string):\n    temp = input_string + input_string\n    n = len(input_string)\n\n    for i in range(1, n + 1):\n        substring = temp[i : n + i]\n        if (input_string == substring):\n            return i\n\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    ss = s + s\n    n = len(s)\n\n    for i in range(1, n+1):\n        if ss[i : i+n] == s:\n            return i", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(strng):\n    # Copy the original string \n    temp = strng + strng\n    n = len(strng)\n\n    for i in range(1, n + 1):\n        # Get substring from index i and size n\n        substring = temp[i: n + i]\n        # If the constructed string is equal to the original string,\n        # break the loop\n        if (strng == substring):\n            break\n\n    # Return the number of rotations\n    return i", "matching_cluster_idx": 5}]}, "Mbpp/11": {"dps": 85.08960573476702, "dps_norm": 97.77777777777777, "pass@1": 31.0, "profiled": [{"solution": "def remove_Occ(s, char):\n    # Check if the character is present in the string\n    if char in s:\n        # Get the first and last occurrence of the character\n        first_occ = s.index(char)\n        last_occ = s.rindex(char)\n        # Remove first and last occurrences of the character\n        s = s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first_occurrence = s.find(c)\n    last_occurrence = s.rfind(c)\n\n    # If character doesn't exist in string\n    if first_occurrence == -1:\n        return s\n\n    # If the first and last occurrence are same, we return string removing all occurrences of character\n    if first_occurrence == last_occurrence:\n        return s.replace(c, \"\")\n\n    # Remove first and last occurrence of the character\n    return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    first_occurrence = string.find(char)\n    last_occurrence = string.rfind(char)\n    \n    if first_occurrence != -1 and last_occurrence != -1:\n        if first_occurrence == last_occurrence:\n            return string[:first_occurrence] + string[first_occurrence + 1:]\n        else:\n            return string[:first_occurrence] + string[first_occurrence + 1:last_occurrence] + string[last_occurrence + 1:]\n    else:\n        return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first_occurrence = s.find(c)\n    last_occurrence = s.rfind(c)\n    if first_occurrence != -1 and last_occurrence != -1:\n        s = s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first_occ = s.find(c)\n    if first_occ == -1:\n        return s\n    last_occ = s.rfind(c)\n    if first_occ == last_occ:\n        return s[:first_occ] + s[first_occ+1:]\n    return s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    first = s.find(ch)\n    if first == -1:\n        return s\n    last = s.rfind(ch)\n    if first == last:\n        return s[:first] + s[first+1:]\n    else:\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s,c):\n    first_occurrence = s.find(c)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(c)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence+1:]\n    else:\n        return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    first_occurrence = input_string.find(char)\n    if first_occurrence != -1:\n        input_string = input_string[:first_occurrence] + input_string[(first_occurrence+1):]\n    last_occurrence = input_string.rfind(char)\n    if last_occurrence != -1:\n        input_string = input_string[:last_occurrence] + input_string[(last_occurrence+1):]\n    return input_string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    first_occurrence = s.find(c)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(c)\n    s = s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    # check if the character is not in string\n    if c not in s:\n        return s\n    else:\n        # find the first and last occurrence of character\n        first_occur = s.index(c)\n        last_occur = s.rindex(c)\n\n        # remove first and last occurrence of character\n        s_modified = s[:first_occur] + s[first_occur+1:last_occur] + s[last_occur+1:]\n\n        return s_modified", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first_index = s.find(c)\n    last_index = s.rfind(c)\n    if first_index != -1 and last_index != -1:\n        s = s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    last = s.rfind(c)\n    if first != -1 and last != -1:\n        s = s[:first] + s[first+1:last] + s[last+1:]\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    first_occ = s.find(ch)\n    last_occ = s.rfind(ch)\n    \n    if first_occ == -1:\n        return s\n    \n    if first_occ == last_occ:\n        return s[:first_occ] + s[first_occ+1:]\n    else:\n        return s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(word, char):\n    # Empty string case\n    if not word:\n        return word\n\n    first_occ = word.find(char)\n    if first_occ == -1:\n        return word\n\n    last_occ = word.rfind(char)\n\n    # If only one occurrence, remove it\n    if first_occ == last_occ:\n        return word[:first_occ] + word[first_occ + 1:]\n\n    # If two occurrences\n    word_no_first = word[:first_occ] + word[first_occ + 1:]\n    word_no_both = word_no_first[:last_occ - 1] + word_no_first[last_occ:]\n    return word_no_both", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(input_str, char):\n    first_index = input_str.find(char)\n    last_index = input_str.rfind(char)\n    if first_index == -1 or last_index == -1:\n        return input_str  # Return string as is if char not found\n    else:\n        new_str = input_str[:first_index] + input_str[first_index+1:last_index] + input_str[last_index+1:]\n        return new_str", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    first_occ = s.find(ch)\n    if first_occ != -1:\n        s = s[:first_occ] + s[first_occ+1:]\n    last_occ = s.rfind(ch)\n    if last_occ != -1:\n        s = s[:last_occ] + s[last_occ+1:]\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, c: str) -> str:\n    first_occ = s.find(c)\n    last_occ = s.rfind(c)\n    if first_occ == -1:  # Character not in string\n        return s\n    elif first_occ == last_occ:  # Only one occurrence of character in string\n        return s.replace(c, '', 1)\n    else:  # More than one occurrence of character in string\n        return s[:first_occ] + s[first_occ:last_occ].replace(c, '', 1) + s[last_occ+1:]", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    first_occurrence = s.find(char)\n    last_occurrence = s.rfind(char)\n    \n    if first_occurrence == -1:\n        return s\n    \n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence+1:]\n    \n    return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string: str, char: str) -> str:\n    first = string.find(char)\n    last = string.rfind(char)\n    if first != -1 and last != -1:\n        if first == last:\n            return string[:first] + string[first+1:]\n        else:\n            part1 = string[:first]\n            part2 = string[first+1:last]\n            part3 = string[last+1:]\n            return part1 + part2 + part3\n    else:\n        return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_str, ch):\n    first_ch_pos = input_str.find(ch)\n    if first_ch_pos == -1:\n        return input_str\n    last_ch_pos = input_str.rfind(ch)\n    if last_ch_pos == first_ch_pos:\n        return input_str[:first_ch_pos] + input_str[first_ch_pos+1:]\n    else:\n        return input_str[:first_ch_pos] + input_str[first_ch_pos+1:last_ch_pos] + input_str[last_ch_pos+1:]", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Function to sort a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    # Zip the row sums and the matrix together, sort by the row sums,\n    # and then discard the row sums\n    sorted_matrix = [row for _, row in sorted(zip(row_sums, matrix))]\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of its rows\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix in ascending order according to the sum of its rows.\"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a matrix in ascending order according to the sum of its rows.\n    \n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n    \n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and store it in a tuple with the row\n    sum_matrix = [(sum(row), row) for row in matrix]\n    \n    # Sort the list of tuples based on the sum of rows\n    sum_matrix.sort()\n    \n    # Extract the sorted rows from the sorted tuples\n    sorted_matrix = [row for _, row in sum_matrix]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sorting the matrix according to the sum of its rows\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Function to compute sum of each row\n    def sum_row(row):\n        return sum(row)\n\n    # Sorting matrix based on sum of rows in ascending order\n    sorted_matrix = sorted(matrix, key=sum_row)\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Function to sort a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    \n    # Create a list of tuples where the first element is the sum and the second is the original row\n    row_sums_matrix = list(zip(row_sums, matrix))\n    \n    # Sort the list of tuples based on the sum\n    sorted_row_sums_matrix = sorted(row_sums_matrix)\n    \n    # Extract the sorted matrix\n    sorted_matrix = [row for _, row in sorted_row_sums_matrix]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sort the matrix by the sum of its rows.\"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 89.0548780487805, "dps_norm": 92.5, "pass@1": 48.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"\n    match = re.fullmatch(pattern, s)\n    return match is not None", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(input_string):\n    # Split the input string by underscore\n    sequences = input_string.split(\"_\")\n    # Check each sequence\n    for sequence in sequences:\n        # If the sequence contains characters other than lowercase letters, return False\n        if not sequence.islower():\n            return False\n    # If all sequences pass the check, return True\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n    \"\"\"\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    \"\"\"\n    A function to check if the input string contains sequences of lowercase letters joined with an underscore.\n\n    :param input_string: string - input string to be checked\n    :return: bool - True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise\n    \"\"\"\n    return bool(re.match('^[a-z]+(?:_[a-z]+)*$', input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Function to check if the input string contains sequences of lowercase letters joined with an underscore\n\n    Parameters:\n    text (str): The string to be checked\n\n    Returns:\n    bool: True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise\n    \"\"\"\n    return bool(re.search(r\"^[a-z]+(?:_[a-z]+)*$\", text))", "matching_cluster_idx": 3}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    \"\"\"\n    This function checks if the input_string contains sequences of lowercase letters joined with an underscore.\n    \n    :param input_string: The string to check.\n    :type input_string: str\n    :return: True if the string contains sequences of lowercase letters joined with an underscore; False otherwise.\n    :rtype: bool\n    \"\"\"\n    return bool(re.match('^[a-z]+(?:_[a-z]+)*$', input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(s):\n    parts = s.split('_')\n    for part in parts:\n        if not part.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    return bool(re.fullmatch(r'[a-z]+(?:_[a-z]+)*', s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    return bool(re.fullmatch(r'[a-z]+(?:_[a-z]+)*', s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    # Use regular expression to check if the string contains lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    if re.match(pattern, text):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(s: str) -> bool:\n    words = s.split('_')\n    for word in words:\n        if not word.islower() or not word.isalpha():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Function to check if the input string contains sequences of lowercase letters joined with an underscore\n    \"\"\"\n    pattern = '[a-z]+(_[a-z]+)*'\n    return re.fullmatch(pattern, s) is not None", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    # Searches for sequences of lowercase letters joined with an underscore\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n\n    # Returns True if the pattern is found, False otherwise\n    return bool(pattern.match(s))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(input_str):\n    sequence = input_str.split('_')\n    for seq in sequence:\n        if not seq.islower() or not seq.isalpha():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(input_str):\n    \"\"\"\n    Returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, input_str))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters joined with an underscore.\n    \"\"\"\n    pattern = '[a-z]+(_[a-z]+)*'\n    return re.fullmatch(pattern, s) is not None", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"\n    return bool(re.match(pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    pattern = re.compile(r'[a-z]+(_[a-z]+)*')\n    return pattern.fullmatch(text) is not None", "matching_cluster_idx": 7}]}, "Mbpp/19": {"dps": 62.601010101010104, "dps_norm": 80.33333333333333, "pass@1": 88.0, "profiled": [{"solution": "def test_duplicate(array):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    # Check if array is None or empty\n    if array is None or len(array) == 0:\n        return False\n\n    # Initialize empty set for tracking duplicates\n    num_set = set()\n\n    # Iterate through array elements\n    for num in array:\n        # If element is already in set, return True\n        if num in num_set:\n            return True\n        # Otherwise, add element to set\n        num_set.add(num)\n\n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 13}, {"solution": "def has_duplicate(arr):\n    return len(arr) != len(set(arr))\ndef test_duplicate(arr):\n    return has_duplicate(arr)", "matching_cluster_idx": 10}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if the array contains any duplicate elements.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    if len(nums) == len(set(nums)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks whether a given array of integers contains any duplicate element.\n    \"\"\"\n    # use set to check for duplicates\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Function to check if there are any duplicate elements in an integer array\n    \"\"\"\n    # convert the list to a set and compare the lengths.\n    # set removes duplicates, so if lengths are different, there must have been duplicates.\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def has_duplicate(nums):\n    return len(nums) != len(set(nums))\ndef test_duplicate(nums):\n    return has_duplicate(nums)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    :param arr: List[int]\n    :return: bool\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def contains_duplicate(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: bool\n    \"\"\"\n    return len(nums) != len(set(nums))\ndef test_duplicate(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: bool\n    \"\"\"\n    return contains_duplicate(nums)", "matching_cluster_idx": 11}, {"solution": "def has_duplicates(lst):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    return len(lst) != len(set(lst))\ndef test_duplicate(lst):\n    \"\"\"\n    Function to test the has_duplicates function.\n    \"\"\"\n    return has_duplicates(lst)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    \"\"\"\n    Checks whether the given array contains any duplicate element.\n    \"\"\"\n    # Create a set from the input array\n    # Set only contains unique elements, so duplicates will be removed\n    set_array = set(array)\n\n    # If the length of the set is not equal to the length of the array,\n    # then there were duplicates in the array\n    if len(set_array) != len(array):\n        return True\n    else:\n        return False", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    A function to check whether a given array of integers contains any duplicate element.\n    \"\"\"\n    if len(nums) == len(set(nums)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    A function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    # using set for duplicate checking. If size of set is less than array size means there are duplicates.\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"Function to find whether a given array of integers contains any duplicate element\"\"\"\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(numbers):\n    return len(numbers) != len(set(numbers))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Test whether a given array of integers contains any duplicate element.\n    \n    Parameters:\n    nums (List[int]): A list of integers.\n    \n    Returns:\n    bool: True if there is any duplicate element, False otherwise.\n    \"\"\"\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(input_array):\n    \"\"\"Function to check if given array contains any duplicate element\"\"\"\n    if len(input_array) == len(set(input_array)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 92.5, "dps_norm": 95.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find smallest number in a list.\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    This function returns the smallest number in a list.\n    \"\"\"\n    # The built-in Python function min() returns the smallest item in a iterable.\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    \"\"\"\n    A function to find the smallest number in a list.\n    \"\"\"\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    :param lst: a list of integers\n    :returns: the smallest number in the list\n    \"\"\"\n    # Setting initial smallest number as first number in the list\n    smallest = lst[0]\n    \n    # Iterating through each number in the list\n    for num in lst:\n        # If current number is smaller than smallest\n        if num < smallest:\n            # Set current number as smallest\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)\nnumbers = [10, 20, 1, 45, 99]", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n    \"\"\"\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"Function to find smallest number in a list\"\"\"\n    # Check if the list is not empty\n    if len(lst) == 0:\n        return None\n    else:\n        smallest = lst[0] # Initialize smallest with the first element\n        for num in lst:\n            if num < smallest:\n                smallest = num\n        return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Return the smallest number in a list\n    :param numbers: list of numbers\n    :return: smallest number\n    \"\"\"\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"Return the smallest number in the given list.\"\"\"\n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    \"\"\"Find smallest number in a list.\"\"\"\n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    \"\"\"Returns the smallest number in a list.\"\"\"\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"Returns the smallest number in a list.\"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function finds the smallest number in a list.\n    \"\"\"\n    # Initialize the smallest number as the first number in the list\n    smallest = lst[0]\n\n    # Iterate over the list\n    for num in lst:\n        # If a number is smaller than the current smallest number, update the smallest number\n        if num < smallest:\n            smallest = num\n\n    # Return the smallest number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(num_list):\n    \"\"\"Find smallest number in a list.\"\"\"\n    return min(num_list)", "matching_cluster_idx": 4}]}, "Mbpp/75": {"dps": 88.53571428571429, "dps_norm": 65.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Function to find tuples which have all elements divisible by k from the given list of tuples.\n    \"\"\"\n    return [t for t in list_of_tuples if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(input_tuples, k):\n    \"\"\"\n    This function finds tuples that have all elements divisible by k from a list of tuples.\n    \"\"\"\n    result = []\n    for tpl in input_tuples:\n        if all(map(lambda x: x % k == 0, tpl)):\n            result.append(tpl)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k.\n    \n    Args:\n        tuples_list: list of tuples.\n        k: integer value.\n    \n    Returns:\n        List of tuples which have all elements divisible by k.\n    \"\"\"\n    # Filter the list using the condition that all elements of the tuple are divisible by k\n    result = [t for t in tuples_list if all(e % k == 0 for e in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    :param tuples: A list of tuples of integers.\n    :param k: An integer.\n    :return: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    # List to store the tuples where all elements are divisible by k\n    divisible_tuples = []\n\n    # Check each tuple in the list\n    for t in tuples:\n        # If all elements of the tuple are divisible by k, add the tuple to the list\n        if all(el % k == 0 for el in t):\n            divisible_tuples.append(t)\n\n    # Return the list of tuples\n    return divisible_tuples", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    # list of result tuples\n    res = []\n    # iterate through list of tuples\n    for tup in list_of_tuples:\n        # check if all elements are divisible by k\n        if all([el % k == 0 for el in tup]):\n            res.append(tup)\n    return res", "matching_cluster_idx": 2}, {"solution": "def find_tuples(lst, k):\n    result = []\n    for t in lst:\n        if all(map(lambda x: x % k == 0, t)):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(input_list, k):\n    return [t for t in input_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    # Create an empty list to store the result\n    result = []\n    \n    # Iterate over all tuples in the list\n    for tpl in list_of_tuples:\n        # Check if all elements in the tuple are divisible by k\n        if all(x % k == 0 for x in tpl):\n            # If so, append it to the result list\n            result.append(tpl)\n    \n    # Return the final result\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"Find tuples in the list which all elements are divisible by k.\"\"\"\n    result = []\n    for t in lst:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]\ntuples_list = [(6, 24, 12), (7, 9, 6), (12, 18, 21)]\nk = 6", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    return [t for t in tuple_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    result = []\n    for tup in list_of_tuples:\n        if all(e % k == 0 for e in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(el % k == 0 for el in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        if all(el % k == 0 for el in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    def divisible(n):\n        return all(n % k == 0 for n in n)\n    return [n for n in tuples if divisible(n)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    A function to find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param list_of_tuples: List of tuples\n    :param k: Integer\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    result = []\n    for t in list_of_tuples:\n        if all(e % k == 0 for e in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    def is_divisible(n):\n        return n % k == 0\n    return [t for t in lst if all(map(is_divisible, t))]", "matching_cluster_idx": 6}, {"solution": "def find_tuples(lst, k):\n    \"\"\"Return a list of tuples in 'lst' where all elements are divisible by 'k'.\"\"\"\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.56862745098039, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(elements):\n    freq_dict = {}\n    for element in elements:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n\n    # Iterate over the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[item] = 1\n    \n    # Return the frequency dictionary\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(arr):\n    freq_dict = {}\n    for item in arr:\n        if (item in freq_dict):\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    freq_dict = {}\n    for item in input_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    dict_count = {}\n    for num in lst:\n        if num in dict_count:\n            dict_count[num] += 1\n        else:\n            dict_count[num] = 1\n    return dict_count", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    This function takes a list as input and returns a dictionary with the frequency count of each element in the list.\n    \"\"\"\n    # Create an empty dictionary\n    freq_dict = {}\n\n    # Iterate over the list\n    for i in input_list:\n        # If the element is already in the dictionary, increment its count by 1\n        if i in freq_dict:\n            freq_dict[i] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[i] = 1\n\n    # Return the dictionary\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(num_list):\n    freq_dict = {}\n    for i in num_list:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict\nnum_list = [10,10,10,10,20,20,20,20,40,40,50,50,30]", "matching_cluster_idx": 5}, {"solution": "def freq_count(arr):\n    freq_dict = {}\n    for i in arr:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Write a function to get the frequency of all the elements in a list, returned as a dictionary.\n    \"\"\"\n    frequency_dict = {}\n    for element in input_list:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    frequency = {}\n    for item in input_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Function to get the frequency of all the elements in a list,\n    returned as a dictionary.\n    \"\"\"\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    count_dict = {}\n    for i in input_list:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(arr):\n    freq_dict = {}\n    for item in arr:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(num_list):\n    count_dict = {}\n    for i in num_list:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if (item in freq_dict):\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 76.65853658536585, "dps_norm": 84.28571428571428, "pass@1": 100.0, "profiled": [{"solution": "def len_log(lst):\n    return max(len(word) for word in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(input_list):\n    max_len = 0\n    for i in input_list:\n        if len(i) > max_len:\n            max_len = len(i)\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    :param words: List of strings.\n    :return: Length of the longest word in the list.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    \"\"\"\n    Function to find the length of the longest word in a list of words.\n    \"\"\"\n    # Initialize the maximum length variable to 0\n    max_len = 0\n    # Loop through each word in the list\n    for word in word_list:\n        # Check the length of the current word and update max_len if necessary\n        if len(word) > max_len:\n            max_len = len(word)\n    # Return the maximum length\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    \"\"\"\n    Finds the length of the longest word\n    \"\"\"\n    return max(len(word) for word in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    return max([len(word) for word in word_list])", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Assert that the input is a list\n    assert isinstance(words, list), 'Input should be a list of words'\n    # Map the length function over the list and find the max\n    lengths = list(map(len, words))\n    return max(lengths)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    return max(len(word) for word in word_list)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    return max(len(word) for word in word_list)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    return max(len(word) for word in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        max_length = max(max_length, len(word))\n    return max_length", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    max_len = 0\n    for word in word_list:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word.\n    \"\"\"\n    return len(max(words, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    \"\"\"\n    This function returns the length of the longest word from a list of words.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    A function to find the length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 78.8719512195122, "dps_norm": 62.0, "pass@1": 96.0, "profiled": [{"solution": "def index_minimum(lst):\n    return min(lst, key = lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # returning the first value of the tuple with the smallest second value\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_tuples):\n    return min(list_tuples, key=lambda x:x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Function to return the first value of the tuple with the smallest second value.\n    \"\"\"\n    # Check if list is empty\n    if not lst:\n        return None\n\n    # Initialize minimum value with first element of list\n    min_value = lst[0][1]\n    min_index = 0\n\n    # Iterate over list to find the minimum\n    for i in range(1, len(lst)):\n        if lst[i][1] < min_value:\n            min_value = lst[i][1]\n            min_index = i\n\n    # Return the first value of tuple with smallest second value\n    return lst[min_index][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(lst, key = lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    # Return the first element of the tuple with the smallest second value.\n    return min(list_of_tuples, key = lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    min_tuple = min(lst, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(input_list):\n    \"\"\"\n    Function to find the first value of the tuple with the smallest second value.\n    \"\"\"\n    # Check if list is not empty\n    if len(input_list) == 0:\n        return None\n\n    min_value = input_list[0][1]\n    min_index = 0\n\n    # Iterate over list and find the smallest second value\n    for i in range(1, len(input_list)):\n        if input_list[i][1] < min_value:\n            min_value = input_list[i][1]\n            min_index = i\n\n    # Return the first value of the tuple with the smallest second value\n    return input_list[min_index][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Given a list of tuples, this function returns the first value of the tuple with the smallest second value.\n    \"\"\"\n\n    # Check if the list is not empty\n    if not list_of_tuples:\n        raise ValueError(\"The list is empty\")\n\n    # Initialize with the first tuple\n    min_tuple = list_of_tuples[0]\n\n    # Go through each tuple in the list\n    for tup in list_of_tuples:\n        # If the second value of this tuple is smaller than the second value of min_tuple\n        if tup[1] < min_tuple[1]:\n            # Update min_tuple\n            min_tuple = tup\n\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Check if the list is empty\n    if not lst:\n        return None\n\n    # Initialize the minimum value and the index\n    min_value = lst[0][1]\n    min_index = 0\n\n    # Loop through the list to find the minimum value\n    for i in range(1, len(lst)):\n        if lst[i][1] < min_value:\n            min_value = lst[i][1]\n            min_index = i\n\n    # Return the first value of the tuple with the smallest second value\n    return lst[min_index][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Sort the list of tuples based on second item in each tuple\n    lst.sort(key = lambda x: x[1])\n    # Return the first value (index 0) of the first tuple in the list\n    return lst[0][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(input_list):\n    # Edge case\n    if len(input_list) == 0:\n        return None\n\n    # Assume the first tuple has the smallest second value.\n    smallest_tuple = input_list[0]\n    \n    # Compare all tuples to find the tuple with the smallest second value.\n    for t in input_list:\n        if t[1] < smallest_tuple[1]:\n            smallest_tuple = t\n\n    # Return the first element (name) of the smallest tuple.\n    return smallest_tuple[0]\ninput_list = [('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples_list):\n    # Find the smallest second value and return the first value corresponding to that smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    return min(list_of_tuples, key = lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key = lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"Returns the first value of the tuple with the smallest second value.\"\"\"\n    # Assume the first tuple has the smallest second value\n    min_val = lst[0][1]\n    min_index = 0\n\n    # Traverse the list and check for smallest second value\n    for i in range(1, len(lst)):\n        if lst[i][1] < min_val:\n            min_val = lst[i][1]\n            min_index = i\n\n    return lst[min_index][0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 76.18055555555554, "dps_norm": 47.14285714285714, "pass@1": 80.0, "profiled": [{"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    i = 1\n    count = 0\n    while i <= n:\n        if n % i == 0:\n            count += 1\n        i += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def divisor(num):\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    This function takes an integer n and returns the number of divisors of n.\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    This function takes an integer n and returns the number of divisors of n.\n    \"\"\"\n    # Initialize count of divisors to 0\n    count = 0\n\n    # Loop through all numbers up to n and increment count if i divides n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer\n\n    :param n: an integer\n    :return: the number of divisors of the integer\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The number whose divisors we want to find.\n\n    Returns:\n    int: The number of divisors.\n    \"\"\"\n    assert n > 0, \"n should be greater than 0\"\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    divisors = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            if n / i == i:\n                divisors += 1\n            else:\n                divisors += 2\n    return divisors", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    This function takes an integer as input and returns the number of divisors of the integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/97": {"dps": 76.73504273504274, "dps_norm": 74.375, "pass@1": 99.0, "profiled": [{"solution": "from typing import List, Dict\ndef flatten_list(lst: List[List[int]]) -> List[int]:\n    \"\"\"Flattens a list of lists into a single list.\"\"\"\n    return [item for sublist in lst for item in sublist]\ndef frequency_elements(lst: List[int]) -> Dict[int, int]:\n    \"\"\"Counts the frequency of each element in a list.\"\"\"\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict\ndef frequency_lists(lst: List[List[int]]) -> Dict[int, int]:\n    \"\"\"Counts the frequency of each element in a flattened list of lists.\"\"\"\n    flattened_list = flatten_list(lst)\n    return frequency_elements(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    freq = {}\n    for sublist in lst:\n        for item in sublist:\n            if item not in freq:\n                freq[item] = 1\n            else:\n                freq[item] += 1\n    return freq", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    flattened_list = [element for sublist in nested_list for element in sublist]\n    frequency_dict = {}\n    for element in flattened_list:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(input_list):\n    flattened_list = [item for sublist in input_list for item in sublist]\n    freq_dict = {}\n    for item in flattened_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    freq_dict = {}\n    for sublist in lst:\n        for item in sublist:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List\ndef flatten(input_list: List[List[int]]) -> List[int]:\n    \"\"\"\n    Function to flatten a list of lists\n    \"\"\"\n    return [item for sublist in input_list for item in sublist]\ndef frequency_lists(input_list: List[List[int]]) -> dict:\n    \"\"\"\n    Function to find frequency of each element in a flattened list of lists\n    \"\"\"\n    flattened = flatten(input_list)\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "def flatten_lists(lst):\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst):\n    flattened = flatten_lists(lst)\n    return {i: flattened.count(i) for i in set(flattened)}", "matching_cluster_idx": 2}, {"solution": "def flatten_list(lst):\n    result = []\n    for sublist in lst:\n        for item in sublist:\n            result.append(item)\n    return result\ndef frequency_lists(lst):\n    flat_list = flatten_list(lst)\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    frequency_dict = {}\n    for sublist in nested_list:\n        for item in sublist:\n            if item not in frequency_dict:\n                frequency_dict[item] = 1\n            else:\n                frequency_dict[item] += 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from typing import List, Dict, Union\ndef frequency_lists(list_of_lists: List[List[Union[int, float, str]]]) -> Dict[Union[int, float, str], int]:\n    # Flatten the list of lists\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    # Find the frequency of each element\n    frequency_dict = {i: flattened_list.count(i) for i in flattened_list}\n    return frequency_dict", "matching_cluster_idx": 1}, {"solution": "from collections import Counter\nfrom typing import List, Dict, Union\ndef frequency_lists(lsts: List[List[Union[int, float, str]]]) -> Dict[Union[int, float, str], int]:\n    flattened = [item for sublist in lsts for item in sublist]\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Function to find frequency of each element in a flattened list of lists.\n    \"\"\"\n    flattened = [item for sublist in list_of_lists for item in sublist]\n    frequencies = {i: flattened.count(i) for i in flattened}\n    return frequencies", "matching_cluster_idx": 1}, {"solution": "from typing import List, Union\ndef flatten_list(nested_list):\n    \"\"\"Flatten a nested list\"\"\"\n    flat_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list\ndef frequency_lists(nested_list: List[List[Union[int, float, str]]]):\n    \"\"\"Find frequency of each element in a nested list\"\"\"\n    flat_list = flatten_list(nested_list)\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 4}, {"solution": "from typing import List, Dict\nfrom collections import defaultdict\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    flattened_list = [num for sublist in lists for num in sublist]\n    frequency_dict = defaultdict(int)\n    for num in flattened_list:\n        frequency_dict[num] += 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    frequency = {}\n    flatten_list = [elem for sublist in lst for elem in sublist]\n    for i in flatten_list:\n        if i in frequency:\n            frequency[i] += 1\n        else:\n            frequency[i] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    frequency_dict = {}\n    for i in flat_list:\n        if i in frequency_dict:\n            frequency_dict[i] += 1\n        else:\n            frequency_dict[i] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Flatten the list\n    flat_list = [item for sublist in lst for item in sublist]\n    \n    # Compute frequencies\n    freq = {}\n    for i in flat_list:\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n    return freq", "matching_cluster_idx": 6}, {"solution": "def flatten_list(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    return flat_list\ndef frequency_lists(lst):\n    flat_list = flatten_list(lst)\n    freq_dict = {i: flat_list.count(i) for i in flat_list}\n    return freq_dict", "matching_cluster_idx": 1}, {"solution": "def frequency_lists(nested_list):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n    Args:\n    nested_list: A list of lists\n\n    Returns:\n    A dictionary containing each element of the flattened list as keys and their frequency as values.\n    \"\"\"\n    flattened_list = [item for sublist in nested_list for item in sublist]\n    frequency_dict = {}\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    frequency_dict = {}\n    for i in flat_list:\n        if i in frequency_dict:\n            frequency_dict[i] += 1\n        else:\n            frequency_dict[i] = 1\n    return frequency_dict", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 34.61038961038961, "dps_norm": 79.16666666666666, "pass@1": 91.0, "profiled": [{"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Function to append the given list to the given tuple.\n    \"\"\"\n    # Convert the tuple to list, extend it with the input list and convert back to tuple\n    extended_tuple = tuple(list(input_tuple) + input_list)\n\n    return extended_tuple", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Append a list to a tuple.\n\n    Args:\n    lst (list): A list of elements.\n    tpl (tuple): A tuple of elements.\n\n    Returns:\n    tuple: A new tuple that combines the list and the tuple.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_add, tuple_to_append):\n    \"\"\"\n    This function appends the given list to the given tuple\n    \"\"\"\n    return tuple_to_append + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_, tuple_):\n    return tuple_ + tuple(list_)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_val, tuple_val):\n    \"\"\"\n    Append the given list to the given tuple.\n    \"\"\"\n    return tuple_val + tuple(list_val)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_add, tuple_to_add_to):\n    # Type checking\n    if not isinstance(list_to_add, list) or not isinstance(tuple_to_add_to, tuple):\n        raise TypeError(\"Expected a list and a tuple\")\n    \n    # Concatenate the list to the tuple using tuple unpacking and return the result\n    return tuple_to_add_to + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_, tuple_):\n    \"\"\"\n    Append the given list to the given tuple.\n    \"\"\"\n    result_list = list(tuple_) + list_\n    result_tuple = tuple(result_list)\n    return result_tuple", "matching_cluster_idx": 2}, {"solution": "def add_lists(list_to_add, tuple_to_append):\n    \"\"\"\n    This function appends a given list to a given tuple.\n    \"\"\"\n    return tuple_to_append + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_append, original_tuple):\n    return original_tuple + tuple(list_to_append)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_append, initial_tuple):\n    \"\"\"\n    Append the given list to the given tuple.\n    \"\"\"\n    return initial_tuple + tuple(list_to_append)", "matching_cluster_idx": 4}, {"solution": "def add_lists(my_list, my_tuple):\n    \"\"\"\n    Appends the given list to the given tuple\n    \"\"\"\n    return my_tuple + tuple(my_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Function to append the given list to the given tuple.\n    \"\"\"\n    return input_tuple + tuple(input_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list and add the elements of the list to it\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    \"\"\"Add list elements to the end of a tuple\"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_, tup):\n    return tup + tuple(list_)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_, tuple_):\n    # Convert tuple to list, because tuples are immutable in Python\n    tuple_list = list(tuple_)\n    \n    # Append the given list to the converted tuple list\n    tuple_list.extend(list_)\n    \n    # Convert the result list back to a tuple and return it\n    return tuple(tuple_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 4}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Function to merge three lists into a single sorted list.\n    \"\"\"\n    # Combine all the lists into one\n    combined_list = list1 + list2 + list3\n\n    # Sort the combined list in increasing order\n    sorted_list = sorted(combined_list)\n\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    return sorted(list1 + list2 + list3)\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged = list1 + list2 + list3\n    merged.sort()\n    return merged", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    result = list1 + list2 + list3\n    result.sort()\n    return result\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    merged_list = l1 + l2 + l3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\" Merges three sorted lists into a single sorted list. \"\"\"\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all lists into one\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    combined.sort()\n    return combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    combined_list = list1 + list2 + list3\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    \"\"\"Merge three sorted lists into a single sorted list.\"\"\"\n    result = lst1 + lst2 + lst3  # Combine lists\n    result.sort()  # Sort the combined list\n    return result", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    merged_lst = lst1 + lst2 + lst3\n    merged_lst.sort()\n    return merged_lst\nlst1 = [25, 24, 15, 4, 5, 29, 110]\nlst2 = [19, 20, 11, 56, 25, 233, 154]\nlst3 = [24, 26, 54, 48]", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges and sorts three lists into a single list.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    combined = list1 + list2 + list3\n    combined.sort()\n    return combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    result = lst1 + lst2 + lst3\n    result.sort()\n    return result", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    merged = l1 + l2 + l3\n    merged.sort()\n    return merged", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    \"\"\"\n    Merges three lists and sorts the merged list in ascending order\n    \"\"\"\n    # Merge the three lists\n    merged_list = l1 + l2 + l3\n    \n    # Sort the merged list\n    merged_list.sort()\n    \n    return merged_list", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 79.76923076923077, "dps_norm": 84.375, "pass@1": 90.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    sets = [set(lst) for lst in nested_lists]\n    common_elements = set.intersection(*sets)\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for sublist in nested_lists[1:]:\n        common_elements = common_elements.intersection(sublist)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    result = set(nested_lists[0])\n    for sublist in nested_lists[1:]:\n        result.intersection_update(sublist)\n    return list(result)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    result_set = set(nested_lists[0])\n    for sublist in nested_lists[1:]:\n        result_set &= set(sublist)\n    return list(result_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Converts nested lists to a set for each list and performs intersection of all sets\n    common_elements = set(nested_lists[0]).intersection(*[set(lst) for lst in nested_lists[1:]])\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n    \"\"\"\n    common_elements = set(nested_lists[0])\n    for l in nested_lists[1:]:\n        common_elements = common_elements.intersection(l)\n    return list(common_elements)\ntest_list = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]\ncommon_elements = common_in_nested_lists(test_list)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Function to find the common elements in given nested lists.\n    \"\"\"\n    # convert each list to a set\n    sets = [set(lst) for lst in nested_lists]\n    \n    # intersect all sets\n    common = sets[0]\n    for s in sets[1:]:\n        common = common & s\n\n    return list(common)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    common_set = set(nested_list[0])\n    for sub_list in nested_list[1:]:\n        common_set &= set(sub_list)\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    \"\"\"\n    This function takes a nested list as an input and returns a set of common elements.\n    \"\"\"\n    # The set.intersection() method is used to get common elements in the list\n    common_set = set(nested_list[0])\n\n    # Iterate over all nested lists in the given list\n    for l in nested_list[1:]:\n        # Calculate the intersection of the current common set and the current list\n        common_set = common_set.intersection(set(l))\n    \n    return common_set", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    function to find the common elements in given nested lists.\n    \"\"\"\n    result = None\n\n    for lst in nested_lists:\n        if result is None:\n            result = set(lst)\n        else:\n            result = result & set(lst)  # intersection of two sets\n\n        if not result:  # if intersection is empty\n            break\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_set = set(nested_lists[0])\n\n    for sublist in nested_lists[1:]:\n        common_set &= set(sublist)\n\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n\n    common_elements = set(nested_lists[0])\n    for sublist in nested_lists[1:]:\n        common_elements.intersection_update(sublist)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lst):\n    result_set = set(lst[0])\n    for sub_lst in lst[1:]:\n        result_set = result_set.intersection(sub_lst)\n    return list(result_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Get the first list as the common elements to start with\n    common_elements = set(nested_lists[0])\n\n    # For every other list, find the intersection with the current common elements\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Get first list of the nested lists\n    common_set = set(nested_lists[0])\n\n    # Iterate over the remaining lists\n    for lst in nested_lists[1:]:\n        # Keep only the common elements between current list and current common_set\n        common_set.intersection_update(lst)\n\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for sub_list in nested_lists[1:]:\n        common_elements.intersection_update(sub_list)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not isinstance(nested_lists, list) or not all(isinstance(i, list) for i in nested_lists):\n        raise ValueError(\"Input should be a list of lists.\")\n\n    common = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common &= set(lst)\n    return list(common)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Start with the first list in the nested_lists\n    common_elements = set(nested_lists[0])\n\n    # Iterate over the remaining lists in the nested_lists\n    for lst in nested_lists[1:]:\n        # Use the intersection method to get the common elements with the current list\n        common_elements = common_elements.intersection(lst)\n\n    # Return the set of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Function to find common elements in given nested lists.\n    \"\"\"\n    # Convert nested list to a set of sets\n    sets = [set(lst) for lst in nested_lists]\n\n    # Find intersection of all sets using built-in Python function\n    common_elements = set.intersection(*sets)\n\n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    \n    for lst in nested_lists[1:]:\n        common_elements = common_elements & set(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.63619402985074, "dps_norm": 86.07142857142857, "pass@1": 67.0, "profiled": [{"solution": "def sum_of_divisors(n):\n    sum = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i == (n / i):\n                sum = sum + i\n            else:\n                sum = sum + (i + n / i)\n    return sum\ndef amicable_numbers_sum(max_range):\n    sum = 0\n    for num in range(max_range+1):\n        div_sum = sum_of_divisors(num)\n        if (num != div_sum and sum_of_divisors(div_sum) == num):\n            sum += num\n    return sum", "matching_cluster_idx": 11}, {"solution": "def divisor_sum(n):\n    sum = 1\n    i = 2\n    while i * i <= n :\n        if n % i == 0 :\n            sum = sum + i + n/i\n        i += 1\n    return sum\ndef amicable_numbers_sum(limit):\n    sum = 0\n    for num in range(2, limit + 1):\n        temp = divisor_sum(num)\n        if (temp > num and divisor_sum(temp) == num):\n            sum += (num + temp)\n    return sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def divisors(n):\n        divs = [1]\n        for i in range(2, int(n**0.5)+1):\n            if n%i:\n                continue\n            if i*i != n:\n                divs.extend([i,n//i])\n            else:\n                divs.append(i)\n        return divs\n    \n    sum_amicable = 0\n    for a in range(2, limit + 1):\n        b = sum(divisors(a))\n        if b > a and sum(divisors(b)) == a:\n            sum_amicable += a + b\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    result = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            result += i\n            if n // i != i:\n                result += n // i\n    return result\ndef amicable_numbers_sum(n):\n    result = 0\n    for a in range(2, n+1):\n        b = sum_proper_divisors(a)\n        if b > a and sum_proper_divisors(b) == a:\n            result += a + b\n    return result", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    sum_divisors = [0] * (limit + 1)\n    for i in range(1, limit + 1):\n        for j in range(i * 2, limit + 1, i):\n            sum_divisors[j] += i\n    sum_amicable = 0\n    for i in range(1, limit + 1):\n        j = sum_divisors[i]\n        if j <= limit and j > i and sum_divisors[j] == i:\n            sum_amicable += i + j\n    return sum_amicable", "matching_cluster_idx": 12}, {"solution": "def sum_of_divisors(n):\n    total = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if n // i != i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    amicable_numbers = []\n    for a in range(limit + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            amicable_numbers.append(a)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_divisors(n):\n        result = 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                result += i\n                if n//i != i:\n                    result += n//i\n        return result\n\n    total = 0\n    for a in range(2, n+1):\n        b = sum_divisors(a)\n        if a != b and a == sum_divisors(b):\n            total += a\n    return total", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_proper_divisors(num):\n        divisors_sum = 1\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                if i == (num / i):\n                    divisors_sum += i\n                else:\n                    divisors_sum += (i + num / i)\n        return divisors_sum\n\n    def is_amicable(num):\n        sum_1 = sum_proper_divisors(num)\n        sum_2 = sum_proper_divisors(sum_1)\n        if sum_2 == num and sum_1 != sum_2:\n            return True\n        else:\n            return False\n\n    amicable_sum = 0\n    for i in range(1, n + 1):\n        if is_amicable(i):\n            amicable_sum += i\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    # function to get sum of divisors\n    sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                sum += i\n            else:\n                sum += i\n                sum += n // i\n    return sum\ndef amicable_numbers_sum(n):\n    # function to sum all amicable numbers\n    sum = 0\n    for i in range(2, n + 1):\n        divisor_sum = sum_of_divisors(i)\n        if (i != divisor_sum and i == sum_of_divisors(divisor_sum)):\n            sum += i\n    return sum", "matching_cluster_idx": 11}, {"solution": "def find_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.extend([i, n // i])\n    return list(set(divisors))\ndef amicable_numbers_sum(num):\n    result = 0\n    for i in range(2, num + 1):\n        divisors_sum = sum(find_divisors(i))\n        if i != divisors_sum and i == sum(find_divisors(divisors_sum)):\n            result += i\n    return result", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    result = 1\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            if n // i == i:\n                result += i\n            else:\n                result += i + n // i\n    return result\ndef is_amicable(a, b):\n    return (sum_of_divisors(a) == b and sum_of_divisors(b) == a)\ndef amicable_numbers_sum(n):\n    amicable_numbers = []\n    for a in range(1, n+1):\n        if a not in amicable_numbers:\n            b = sum_of_divisors(a)\n            if a != b and is_amicable(a, b):\n                amicable_numbers.extend([a, b])\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def proper_divisors(n):\n    \"\"\" Return a list with all proper divisors of n. \"\"\"\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i:\n            continue\n        if i*i != n:\n            divisors.extend([i, n // i])\n        else:\n            divisors.append(i)\n    return divisors\ndef amicable_numbers_sum(limit):\n    \"\"\" Sum all amicable numbers from 1 to the specified limit. \"\"\"\n    sum_amicable = 0\n    for a in range(4, limit):\n        b = sum(proper_divisors(a))\n        if a != b and sum(proper_divisors(a)) == b and sum(proper_divisors(b)) == a:\n            sum_amicable += a\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            sum = sum + i\n            other_divisor = n // i\n            if other_divisor != i:\n                sum = sum + other_divisor\n        i += 1\n    return sum\ndef amicable_numbers_sum(num):\n    sum = 0\n    for i in range(2, num+1):\n        div_sum = sum_of_divisors(i)\n        if sum_of_divisors(div_sum) == i and i != div_sum:\n            sum += i\n    return sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def sum_divisors(n):\n        sum = 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                if i == (n / i):\n                    sum += i\n                else:\n                    sum += (i + n//i)\n        return sum\n\n    result = 0\n    for i in range(2, limit+1):\n        sum_i = sum_divisors(i)\n        if sum_divisors(sum_i) == i and sum_i != i and sum_i <= limit:\n            result += i\n    return result", "matching_cluster_idx": 11}, {"solution": "def divisors(n):\n    divs = [1]\n    for i in range(2, int(n**0.5)+1):\n        if n%i == 0:\n            if n/i == i:\n                divs.append(i)\n            else:\n                divs.extend([i, n//i])\n    return divs\ndef amicable_numbers_sum(n):\n    def amicable(a):\n        b = sum(divisors(a))\n        return b != a and sum(divisors(b)) == a\n    return sum(a for a in range(1, n+1) if amicable(a))", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_divisors(num):\n        result = 1\n        i = 2\n        while i <= num**0.5:\n            if (num % i == 0):\n                if (i == (num / i)):\n                    result = result + i\n                else:\n                    result = result + (i + num//i)\n            i += 1\n        return result\n\n    amicable_sum = 0\n    for i in range(1, n+1):\n        sum_i = sum_divisors(i)\n        if sum_i > i and sum_divisors(sum_i) == i:\n            amicable_sum += i + sum_i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_proper_divisors(num):\n        result = 1\n        i = 2\n        while i * i <= num:\n            if (num % i == 0):\n                if (i == (num / i)):\n                    result = result + i\n                else:\n                    result = result + (i + num//i)\n            i += 1\n        return result\n\n    amicable_sum = 0\n    for num in range(2, n + 1):\n        sum_of_divisors = sum_proper_divisors(num)\n        if sum_of_divisors > num and sum_proper_divisors(sum_of_divisors) == num:\n            amicable_sum += num + sum_of_divisors\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def sum_divisors(n) :\n        result = 1\n        i = 2\n        while i <= n**0.5 :\n            if (n % i == 0) :\n                if (i == (n/i)) :\n                    result = result + i\n                else :\n                    result = result + (i + n//i)\n            i = i + 1\n        return result\n    \n    total = 0\n    for i in range(1, limit+1):\n        divisor_sum = sum_divisors(i)\n        if sum_divisors(divisor_sum) == i and divisor_sum != i:\n            total += i\n            \n    return total", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            if n//i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n//i])\n    return sum(divisors)\ndef amicable_numbers_sum(n):\n    amicable_numbers = []\n    for a in range(1, n+1):\n        b = sum_proper_divisors(a)\n        if a != b and sum_proper_divisors(b) == a:\n            if a not in amicable_numbers and b not in amicable_numbers:\n                amicable_numbers.append(a)\n                if b <= n:\n                    amicable_numbers.append(b)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def proper_divisors(n):\n    \"\"\"\n    Helper function to find proper divisors of a number\n    \"\"\"\n    result = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            result.extend([i, n//i])\n    return list(set(result))\ndef amicable_numbers_sum(num):\n    \"\"\"\n    Function to sum all amicable numbers from 1 to a specified number.\n    \"\"\"\n    result = 0\n    for i in range(1, num+1):\n        s1 = sum(proper_divisors(i))\n        if i != s1 and sum(proper_divisors(s1)) == i:\n            result += i\n    return result", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, sentence):\n    # Splitting the sentence into words\n    words = sentence.split()\n\n    # Filtering out words that are longer than n characters\n    long_words = [word for word in words if len(word) > n]\n\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    words = string.split(\" \")\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    words = string.split(' ')\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    \"\"\"\n    Function to find words that are longer than n characters from a given list of words.\n    \"\"\"\n    words = string.split()\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    return [word for word in s.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    words = string.split(' ')\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    return [word for word in str.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    \"\"\"\n    Find words that are longer than n characters from a given string.\n    \"\"\"\n    return [word for word in s.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Function to find words that are longer than n characters from a given sentence.\n    \"\"\"\n    words = sentence.split(' ')\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    return [word for word in s.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Splitting the sentence into words\n    words = sentence.split()\n\n    # Initializing an empty list for long words\n    long_words_list = []\n\n    # Iterate over each word in the list\n    for word in words:\n        # If the word is longer than 'n' characters, add it to the 'long_words_list'\n        if len(word) > n:\n            long_words_list.append(word)\n\n    # Return the list of long words\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 83.3545918367347, "dps_norm": 95.66666666666667, "pass@1": 57.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row\n    magic_const = sum(matrix[0])\n\n    # Check if each row adds up to the same value\n    for row in matrix:\n        if sum(row) != magic_const:\n            return False\n\n    # Check if each column adds up to the same value\n    for i in range(len(matrix)):\n        if sum(row[i] for row in matrix) != magic_const:\n            return False\n\n    # Check if both diagonals add up to the same value\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_const:\n        return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_const:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is a square matrix\n    if len(matrix) == 0 or len(matrix) != len(matrix[0]):\n        return False\n    # Calculate the sum of the first row\n    row_sum = sum(matrix[0])\n    # Check if all rows have the same sum\n    for row in matrix:\n        if sum(row) != row_sum:\n            return False\n    # Check if all columns have the same sum\n    for i in range(len(matrix)):\n        if sum(row[i] for row in matrix) != row_sum:\n            return False\n    # Check if the sum of the main diagonal is the same as the row sum\n    if sum(matrix[i][i] for i in range(len(matrix))) != row_sum:\n        return False\n    # Check if the sum of the other diagonal is the same as the row sum\n    if sum(matrix[i][len(matrix)-1-i] for i in range(len(matrix))) != row_sum:\n        return False\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # calculate the sum of the first row as the magic number\n    magic_num = sum(matrix[0])\n\n    # check row sums\n    for row in matrix:\n        if sum(row) != magic_num:\n            return False\n\n    # check column sums\n    for col in range(len(matrix[0])):\n        if sum(row[col] for row in matrix) != magic_num:\n            return False\n\n    # check diagonal sums\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_num:\n        return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_num:\n        return False\n\n    # if all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    if len(matrix) != len(matrix[0]):\n        return False\n    \n    # Calculate the magic constant\n    magic_constant = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check the sum of each column\n    for i in range(len(matrix)):\n        if sum([row[i] for row in matrix]) != magic_constant:\n            return False\n\n    # Check the sum of the diagonals\n    if sum([matrix[i][i] for i in range(len(matrix))]) != magic_constant or sum([matrix[i][len(matrix) - i - 1] for i in range(len(matrix))]) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # calculate sum of the first row\n    sum_ref = sum(matrix[0])\n\n    # check the sum of each row\n    for row in matrix:\n        if sum(row) != sum_ref:\n            return False\n\n    # check the sum of each column\n    for col in range(len(matrix[0])):\n        if sum(row[col] for row in matrix) != sum_ref:\n            return False\n\n    # check the sum of diagonal elements\n    if sum(matrix[i][i] for i in range(len(matrix))) != sum_ref:\n        return False\n    # check the sum of anti-diagonal elements\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != sum_ref:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Step 1: Determine the magic constant (the sum of each row, column, or diagonal)\n    magic_const = sum(matrix[0])\n\n    # Step 2: Check if all rows and columns have the same sum\n    for i in range(len(matrix)):\n        if sum(matrix[i]) != magic_const:\n            return False\n        if sum([row[i] for row in matrix]) != magic_const:\n            return False\n\n    # Step 3: Check the diagonals\n    if sum([matrix[i][i] for i in range(len(matrix))]) != magic_const:\n        return False\n    if sum([matrix[i][len(matrix)-i-1] for i in range(len(matrix))]) != magic_const:\n        return False\n\n    # If we've made it this far, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # get the sum of the first row\n    sum_target = sum(matrix[0])\n\n    # check rows\n    for row in matrix:\n        if sum(row) != sum_target:\n            return False\n\n    # check columns\n    for col in range(len(matrix[0])):\n        if sum(row[col] for row in matrix) != sum_target:\n            return False\n\n    # check diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != sum_target:\n        return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != sum_target:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    sum_list = []\n\n    # check if it's a square\n    if any(len(row) != n for row in matrix):\n        return False\n\n    # calculate sum of rows, columns and diagonals\n    sum_list.extend([sum(row) for row in matrix])\n    sum_list.extend([sum(col) for col in zip(*matrix)])\n    sum_list.append(sum(matrix[i][i] for i in range(n)))\n    sum_list.append(sum(matrix[i][n - i - 1] for i in range(n)))\n\n    # check if all sums are equal\n    return len(set(sum_list)) == 1", "matching_cluster_idx": 8}, {"solution": "def magic_square_test(matrix):\n    # Calculate sum of first row for comparison\n    sum_num = sum(matrix[0])\n\n    # Check each row sum\n    for row in matrix:\n        if sum(row) != sum_num:\n            return False\n\n    # Check each column sum\n    for col in range(len(matrix[0])):\n        if sum(row[col] for row in matrix) != sum_num:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != sum_num or \\\n       sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != sum_num:\n        return False\n\n    # If all checks pass, return True\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"Function to check if a given matrix is a magic square or not.\"\"\"\n    # Check if the matrix is empty\n    if len(matrix) == 0:\n        return True\n    \n    # Calculate the sum of the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check columns\n    for col in range(len(matrix[0])):\n        if sum(row[col] for row in matrix) != magic_sum:\n            return False\n    \n    # Check diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum:\n        return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_sum:\n        return False\n        \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    order = len(matrix)\n    diag_sum1 = 0\n    diag_sum2 = 0\n    for i in range(order):\n        if len(matrix[i]) != order:\n            return False\n        diag_sum1 += matrix[i][i]\n        diag_sum2 += matrix[i][order-i-1]\n        if sum(matrix[i]) != sum(row[i] for row in matrix):\n            return False\n    if diag_sum1 != diag_sum2:\n        return False\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # calculate the magic constant (e.g. 1+2+3+4 = 10)\n    magic_const = sum(matrix[0])\n    # the transpose of matrix\n    transpose = list(map(list, zip(*matrix)))\n\n    # check if all rows and columns sum up to the magic constant\n    for row in matrix:\n        if sum(row) != magic_const:\n            return False\n    for col in transpose:\n        if sum(col) != magic_const:\n            return False\n\n    # check if the sum of diagonal elements equals to the magic constant\n    diag_sum1 = sum(matrix[i][i] for i in range(len(matrix)))\n    diag_sum2 = sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix)))\n    if diag_sum1 != magic_const or diag_sum2 != magic_const:\n        return False\n\n    return True", "matching_cluster_idx": 10}, {"solution": "def magic_square_test(matrix):\n    # calculate sum of the first row\n    magic_const = sum(matrix[0])\n\n    # calculate sum of each row, if any is not equal to magic_const, return False\n    for row in matrix:\n        if sum(row) != magic_const:\n            return False\n\n    # calculate sum of each column, if any is not equal to magic_const, return False\n    for col in range(len(matrix[0])):\n        if sum(row[col] for row in matrix) != magic_const:\n            return False\n\n    # calculate sum of leading diagonal, if not equal to magic_const, return False\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_const:\n        return False\n\n    # calculate sum of counter diagonal, if not equal to magic_const, return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_const:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    This function checks if a given square matrix is a magic square.\n    A magic square is a square grid filled with distinct positive integers\n    such that each cell contains a different integer and the sum of the integers\n    in each row, each column, and both diagonals is the same.\n    \"\"\"\n    # Calculate the target sum\n    target_sum = sum(matrix[0])\n\n    # Check row sums\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check column sums\n    for column in range(len(matrix)):\n        if sum(matrix[row][column] for row in range(len(matrix))) != target_sum:\n            return False\n\n    # Check diagonal sums\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # First, we need to calculate the sum of the first row as the reference sum\n    first_row_sum = sum(matrix[0])\n    \n    # Verify the sum of each row, column, and diagonals\n    for row in matrix:\n        if sum(row) != first_row_sum:\n            return False\n    \n    for col in range(len(matrix)):\n        if sum(matrix[i][col] for i in range(len(matrix))) != first_row_sum:\n            return False\n    \n    if sum(matrix[i][i] for i in range(len(matrix))) != first_row_sum:\n        return False\n    \n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != first_row_sum:\n        return False\n    \n    # If we passed all tests, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square.\n    if len(matrix) != len(matrix[0]):\n        return False\n\n    # Calculate the sum of the first row.\n    magic_constant = sum(matrix[0])\n\n    # Check the sum of each row.\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check the sum of each column.\n    for i in range(len(matrix)):\n        if sum(row[i] for row in matrix) != magic_constant:\n            return False\n\n    # Check the sum of main diagonal.\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_constant:\n        return False\n\n    # Check the sum of antidiagonal.\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if it's a square matrix\n    if len(matrix) == 0 or len(matrix) != len(matrix[0]):\n        return False\n\n    # Sum of first row\n    magic_constant = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for col in range(len(matrix[0])):\n        if sum(row[col] for row in matrix) != magic_constant:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_constant or \\\n       sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    size = len(matrix)\n\n    # Calculate the magic constant (sum of first row)\n    magic_constant = sum(matrix[0])\n\n    # Check each row\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check each column\n    for i in range(size):\n        column_sum = sum(row[i] for row in matrix)\n        if column_sum != magic_constant:\n            return False\n\n    # Check diagonals\n    diagonal1 = sum(matrix[i][i] for i in range(size))\n    diagonal2 = sum(matrix[i][size - i - 1] for i in range(size))\n\n    if diagonal1 != magic_constant or diagonal2 != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # first check that the matrix is square\n    size = len(matrix)\n    for row in matrix:\n        if len(row) != size:\n            return False\n\n    # calculate the sum of the first row\n    magic_sum = sum(matrix[0])\n\n    # check rows and columns\n    for i in range(size):\n        if sum(matrix[i]) != magic_sum or sum([row[i] for row in matrix]) != magic_sum:\n            return False\n\n    # check diagonals\n    if sum([matrix[i][i] for i in range(size)]) != magic_sum or sum([matrix[i][size-i-1] for i in range(size)]) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n\n    # Calculate the magic constant (sum of first row)\n    magic_constant = sum(matrix[0])\n\n    # Check if all rows have the same sum\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check if all columns have the same sum\n    for col in range(n):\n        if sum(row[col] for row in matrix) != magic_constant:\n            return False\n\n    # Check if the sum of the main diagonal is the same\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n\n    # Check if the sum of the antidiagonal is the same\n    if sum(matrix[i][n - i - 1] for i in range(n)) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}]}, "Mbpp/130": {"dps": 74.91031390134529, "dps_norm": 67.5, "pass@1": 41.0, "profiled": [{"solution": "def max_occurrences(lst):\n    counts = {i: lst.count(i) for i in lst}\n    max_count = max(counts.values())\n    return next(key for key, value in counts.items() if value == max_count)", "matching_cluster_idx": 1}, {"solution": "def max_occurrences(lst):\n    count = {}  # Dictionary to store counts of elements\n    for item in lst:\n        if item in count:\n            count[item] += 1\n        else:\n            count[item] = 1\n    # Find item with max frequency\n    max_item = max(count, key=count.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(input_list):\n    # Create a dictionary to store the count of each element in the list\n    count_dict = {}\n    for item in input_list:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n\n    # Find the item with the maximum count\n    max_count_item = None\n    max_count = 0\n    for item, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_count_item = item\n\n    return max_count_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    freq_dict = dict(Counter(lst))\n    max_freq = max(freq_dict.values())\n    for key, value in freq_dict.items():\n        if value == max_freq:\n            return key", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    counter = Counter(lst)\n    return max(counter, key=counter.get)", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(input_list):\n    # Count frequencies using a dictionary\n    freq_dict = {}\n    for item in input_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    \n    # Find item with max frequency\n    max_freq = 0\n    max_item = None\n    for item, freq in freq_dict.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    return max(counts, key=counts.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n\n    # Create a dictionary with counts of each element\n    count_dict = Counter(lst)\n\n    # Get the maximum count\n    max_count = max(count_dict.values())\n\n    # Get the items which have the maximum count\n    max_count_items = [item for item, count in count_dict.items() if count == max_count]\n\n    # Return the first maximum occurring item (since the list is not sorted, we can return any of them)\n    return max_count_items[0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    count = Counter(lst)\n    return max(count.items(), key=lambda x: x[1])[0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Get the frequency of each item using a dictionary\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n\n    # Find the item with maximum frequency\n    max_item = max(freq_dict, key=freq_dict.get)\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    max_frequency = max(list(frequency_dict.values()))\n    items_with_max_frequency = [key for key, value in frequency_dict.items() if value == max_frequency]\n    return items_with_max_frequency[0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(arr):\n    \"\"\"\n    Finds the item with maximum frequency in the given list.\n    \"\"\"\n    num_dict = {}\n    for i in arr:\n        if i in num_dict:\n            num_dict[i] += 1\n        else:\n            num_dict[i] = 1\n\n    max_freq = max(num_dict.values())\n\n    for num, freq in num_dict.items():\n        if freq == max_freq:\n            return num", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    counts = {}\n    for item in lst:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    max_item = max(counts, key=counts.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(input_list):\n    \"\"\"Function to find the item with maximum frequency in a given list.\"\"\"\n    count_dict = {}\n    for item in input_list:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    max_key = max(count_dict, key=count_dict.get)\n    return max_key", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # create a dictionary to store each item and its frequency\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n\n    # find the item with maximum frequency\n    max_freq = 0\n    max_item = None\n    for item, freq in freq_dict.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    count_dict = {}\n    for i in lst:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    max_item = max(count_dict, key=count_dict.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    if not lst: \n        return None\n    frequency_dict = {}\n    for num in lst:\n        if num in frequency_dict:\n            frequency_dict[num] += 1\n        else:\n            frequency_dict[num] = 1\n\n    max_freq_item = max(frequency_dict, key=frequency_dict.get)\n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(input_list):\n    \"\"\"\n    Function to find the item with maximum frequency in a given list.\n    \"\"\"\n    # Create a dictionary to store item frequencies\n    item_freq = {}\n\n    # Iterate over the list\n    for item in input_list:\n        if item in item_freq:\n            item_freq[item] += 1\n        else:\n            item_freq[item] = 1\n\n    # Find item(s) with maximum frequency\n    max_freq = max(item_freq.values())\n    max_freq_items = [item for item, freq in item_freq.items() if freq == max_freq]\n\n    # If there is only one item with maximum frequency, return it\n    if len(max_freq_items) == 1:\n        return max_freq_items[0]\n    else:\n        # If there are multiple items with the same maximum frequency, return the first one\n        return max_freq_items[0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"Find the item with maximum frequency in a given list.\"\"\"\n    # create an empty dictionary\n    freq_dict = {}\n\n    # iterate through the list\n    for item in lst:\n        # if item is already in the dictionary, increment its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        # if item is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[item] = 1\n\n    # find the item with the maximum frequency\n    max_freq_item = max(freq_dict, key=freq_dict.get)\n\n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(num_list):\n    num_dict = {}\n    for num in num_list:\n        if num in num_dict:\n            num_dict[num] += 1\n        else:\n            num_dict[num] = 1\n\n    max_freq = 0\n    max_num = None\n\n    for num, freq in num_dict.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_num = num\n\n    return max_num", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": 53.1409168081494, "dps_norm": 67.76315789473684, "pass@1": 19.0, "profiled": [{"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Function to find the ratio of zeroes to non-zeroes in an array of integers.\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else math.inf\narr = [0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(array):\n    total = len(array)\n    zeroes = array.count(0)\n    non_zeroes = total - zeroes\n    ratio = zeroes/non_zeroes if non_zeroes != 0 else float('inf')\n    return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Returns the ratio of zeroes to non-zeroes in an array of integers.\n    \"\"\"\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    \n    if non_zeroes == 0:\n        return float('inf')  # assuming ratio of zeroes to non-zeroes is infinite\n    return zeroes / non_zeroes\narr = [0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(array):\n    \"\"\"Function to find the ratio of zeroes to non-zeroes in an array of integers\"\"\"\n\n    # Count zeroes and non-zeroes\n    zeroes = array.count(0)\n    non_zeroes = len(array) - zeroes\n\n    # Handle case when non-zeroes are 0\n    if non_zeroes == 0:\n        return float('inf')\n\n    # Calculate ratio\n    ratio = zeroes / non_zeroes\n\n    return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(array):\n    zero_count = sum(1 for i in array if i == 0)\n    non_zero_count = len(array) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else float('inf')", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(array):\n    zero_count = 0\n    non_zero_count = 0\n    for i in array:\n        if i == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    return zero_count / non_zero_count if non_zero_count != 0 else float('inf')", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport math\ndef zero_count(nums: List[int]) -> float:\n    zero_count = len([num for num in nums if num == 0])\n    non_zero_count = len([num for num in nums if num != 0])\n    return zero_count / non_zero_count if non_zero_count != 0 else math.inf", "matching_cluster_idx": 2}, {"solution": "import math\ndef zero_count(arr):\n    zero_count = sum(1 for i in arr if i==0)\n    non_zero_count = len(arr) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else float('inf')", "matching_cluster_idx": 5}, {"solution": "import math\nfrom typing import List\ndef zero_count(arr: List[int]) -> float:\n    zeroes = len([num for num in arr if num == 0])\n    non_zeroes = len([num for num in arr if num != 0])\n    return zeroes / non_zeroes if non_zeroes != 0 else float('inf')", "matching_cluster_idx": 2}, {"solution": "import math\ndef zero_count(arr):\n    total = len(arr)\n    zeroes = arr.count(0)\n    non_zeroes = total - zeroes\n    return zeroes / non_zeroes if non_zeroes != 0 else float('inf')", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(lst):\n    \"\"\"\n    Function that returns the ratio of zeroes to non-zeroes in a list of integers.\n    \"\"\"\n    if len(lst) == 0:\n        return 0.0\n    else:\n        zero_count = lst.count(0)\n        nonzero_count = len(lst) - zero_count\n        return zero_count / nonzero_count if nonzero_count != 0 else math.inf", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for num in arr if num == 0)\n    non_zeroes = sum(1 for num in arr if num != 0)\n    ratio = zeroes / non_zeroes if non_zeroes != 0 else float('inf')\n    return ratio", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = len([num for num in arr if num == 0])\n    non_zeroes = len(arr) - zeroes\n    return zeroes / non_zeroes if non_zeroes != 0 else float('inf')", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    return zeroes / non_zeroes if non_zeroes != 0 else float('inf')", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    return zeroes / non_zeroes if non_zeroes != 0 else float('inf')", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    zero_count = sum(1 for i in arr if i == 0)\n    non_zero_count = len(arr) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else float('inf')", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    if not arr:\n        return 0.0\n    zero_count = sum(1 for num in arr if num == 0)\n    nonzero_count = sum(1 for num in arr if num != 0)\n    return zero_count / nonzero_count if nonzero_count != 0 else math.inf", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Function to find the ratio of zeroes to non-zeroes in an array of integers.\n\n    :param arr: list of integers\n    :return: ratio of zeroes to non-zeroes\n    \"\"\"\n    # Check that arr is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"arr must be a list\")\n\n    # Check that all elements in arr are integers\n    if not all(isinstance(i, int) for i in arr):\n        raise ValueError(\"All elements in arr must be integers\")\n\n    # Count zeroes and non-zeroes\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n\n    # Handle division by zero\n    if non_zeroes == 0:\n        return float('inf')\n\n    return zeroes / non_zeroes\narr = [0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]", "matching_cluster_idx": 2}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = len(list(filter(lambda x: x == 0, arr)))\n    non_zeroes = len(arr) - zeroes\n    return zeroes / non_zeroes if non_zeroes != 0 else math.inf", "matching_cluster_idx": 2}]}, "Mbpp/140": {"dps": 45.559006211180126, "dps_norm": 64.375, "pass@1": 83.0, "profiled": [{"solution": "def extract_singly(list_of_lists):\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    return set(flat_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Function to flatten the list of lists into a single set of numbers.\n    \"\"\"\n    # Initializing empty set\n    extracted_set = set()\n    \n    # Iterate over each list in the nested list\n    for sub_list in nested_list:\n        # Iterate over each element in the sub_list\n        for element in sub_list:\n            # Add the element to the set\n            extracted_set.add(element)\n            \n    return extracted_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Takes a list of lists as input and returns a set of unique values from that list.\n    \"\"\"\n    flattened_list = []\n\n    for sublist in list_of_lists:\n        for item in sublist:\n            flattened_list.append(item)\n\n    # Converts the list to a set to remove duplicate values\n    flattened_set = set(flattened_list)\n    return flattened_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    result = []\n    for sublist in lst:\n        for item in sublist:\n            result.append(item)\n    return set(result)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"Flatten the list of lists into a single set of numbers.\n    \n    Parameters:\n    list_of_tuples (list): A list of tuples.\n\n    Returns:\n    set: A set of numbers.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    {1, 3, 4, 5, 7}\n    \"\"\"\n    result = set()\n    for tup in list_of_tuples:\n        for num in tup:\n            result.add(num)\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_singly(nested_lists):\n    \"\"\"Function to flatten the list of lists into a single set of numbers.\"\"\"\n    flat_list = []\n    for sublist in nested_lists:\n        for item in sublist:\n            flat_list.append(item)\n    return set(flat_list)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"Extracts and flattens list of tuples into a single list of numbers.\"\"\"\n    return [num for tup in list_of_tuples for num in tup]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    # Create an empty set to hold flattened elements\n    flattened_set = set()\n\n    # Iterate over each sub-list in the nested list\n    for sub_list in nested_list:\n        # Iterate over each item in the sub-list\n        for item in sub_list:\n            # Add the item to the set\n            flattened_set.add(item)\n\n    # Return the set of flattened elements\n    return flattened_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    return set([item for sublist in list_of_lists for item in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    return set(num for sublist in lst for num in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_tuples):\n    result = set()  # Create an empty set\n    for tuple_item in list_of_tuples:  # Go through each tuple in the list\n        for num in tuple_item:  # Go through each number in the tuple\n            result.add(num)  # Add the number to the set\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    return set([item for sublist in list_of_lists for item in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    # Initialize an empty set\n    singly_set = set()\n\n    # Iterate through each list in the input\n    for one_list in list_of_lists:\n        # Add each item in the list to the set\n        for item in one_list:\n            singly_set.add(item)\n            \n    # Return the populated set\n    return singly_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(lists):\n    \"\"\"\n    This function takes a list of tuples or lists and returns a single set of unique numbers.\n    \"\"\"\n    result = set()\n    for l in lists:\n        for item in l:\n            result.add(item)\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_tuples):\n    result = set()\n    for t in list_of_tuples:\n        for num in t:\n            result.add(num)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(input_list):\n    output_set = set()\n    for sublist in input_list:\n        for item in sublist:\n            output_set.add(item)\n    return output_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(input_list):\n    # initialize an empty set\n    result_set = set()\n    \n    # iterate over the list of tuples\n    for tup in input_list:\n        # add each element of the tuple to the set\n        result_set.update(tup)\n    \n    return result_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    result = set()\n    for t in list_of_tuples:\n        for x in t:\n            result.add(x)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    result = set()  # Define an empty set\n    for sub_list in list_of_lists:  # Iterate over each sublist in the main list\n        for element in sub_list:  # Iterate over each element in the sublist\n            result.add(element)  # Add each element to the result set\n    return result", "matching_cluster_idx": 4}]}, "Mbpp/141": {"dps": 82.38095238095238, "dps_norm": 45.625, "pass@1": 85.0, "profiled": [{"solution": "def pancake_sort(arr):\n    for size in reversed(range(len(arr))):\n        max_index = arr.index(max(arr[:size+1]))\n        if max_index != size:\n            arr = arr[max_index::-1] + arr[max_index+1:]\n            arr = arr[size::-1] + arr[size+1:]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    \"\"\"\n    Function to sort a list of elements.\n    \"\"\"\n    for size in reversed(range(len(lst))):\n        max_ind = max(range(size + 1), key=lst.__getitem__)\n        if max_ind != size:\n            # Perform pancake flip\n            lst[0:max_ind+1] = reversed(lst[0:max_ind+1])\n            lst[0:size+1] = reversed(lst[0:size+1])\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for size in reversed(range(len(lst))):\n        max_ind = max(range(size+1), key=lst.__getitem__)\n        if max_ind != size:\n            lst[0:max_ind+1] = reversed(lst[0:max_ind+1])\n            lst[0:size+1] = reversed(lst[0:size+1])\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n\n    n = len(lst)\n    for curr_size in reversed(range(2, n+1)):\n        max_index = lst.index(max(lst[:curr_size]))\n        if max_index != curr_size - 1:\n            flip(lst, max_index)\n            flip(lst, curr_size - 1)\n\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(list):\n    \"\"\"\n    This function sorts the list by repeatedly finding the maximum number in the unsorted part of the list\n    and moving it to the end. This process is done for the entire list, hence the name 'pancake sort'.\n    \"\"\"\n    # Get the length of the list\n    length = len(list)\n\n    # Loop through the list from the last to the first\n    for curr_size in reversed(range(length)):\n        # Get the index of maximum number in the list[0...curr_size]\n        max_idx = list.index(max(list[:curr_size+1]))\n\n        # If the maximum number is not at the end of the list\n        if max_idx != curr_size:\n            # If the maximum number is at the beginning, move it to the end\n            if max_idx != 0:\n                list[:max_idx+1] = reversed(list[:max_idx+1])\n            \n            # Reverse the list from 0 to curr_size\n            list[:curr_size+1] = reversed(list[:curr_size+1])\n    \n    # Return the sorted list\n    return list", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    \"\"\"\n    Function to sort a list of elements using pancake sort\n    \"\"\"\n    for size in reversed(range(len(lst))):\n        max_ind = max(range(size + 1), key = lst.__getitem__)\n        if max_ind != size:\n            lst[0:max_ind+1] = reversed(lst[0:max_ind+1])\n            lst[0:size+1] = reversed(lst[0:size+1])\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    # Base case\n    if len(lst) <= 1:\n        return lst\n    # Recursive case\n    else:\n        max_index = lst.index(max(lst))\n        if max_index != len(lst) - 1: \n            # flip the list so the max number is on the bottom\n            lst = lst[max_index::-1] + lst[max_index+1:]\n            # flip the list so the max number is on the top\n            lst = lst[::-1]\n        # recursively sort the rest of the list\n        return pancake_sort(lst[:-1]) + list(lst[-1:])", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    \"\"\"\n    Pancake sort function.\n    This function is a variant of bubble sort that uses the concept of 'pancakes' from the cooking analogy.\n    It is an efficient sorting algorithm, not requiring any nested loops, and is not adaptive (making it faster on sorted data).\n    \"\"\"\n    def flip(arr, i):\n        \"\"\"Flip arr[0..i]\"\"\"\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n\n    n = len(lst)\n\n    # Start from the complete array and one by one\n    # reduce current size by one\n    for curr_size in reversed(range(n)):\n        # Find index of the maximum element\n        # in lst[0..curr_size]\n        max_idx = lst.index(max(lst[:curr_size + 1]))\n\n        # Move the maximum element to end of\n        # current array if it's not already at\n        # the end\n        if max_idx != curr_size:\n            # To move at the end, first\n            # move maximum number to beginning\n            flip(lst, max_idx)\n\n            # Now move the maximum number\n            # to end by reversing current array\n            flip(lst, curr_size)\n\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(num_list):\n    # Length of list\n    n = len(num_list)\n\n    # Traverse through all list elements\n    for cur_size in reversed(range(2, n+1)):\n        max_index = num_list.index(max(num_list[0:cur_size]))\n        if max_index != cur_size-1:\n            # To move at the end, first move maximum number to beginning\n            num_list[0:max_index+1] = reversed(num_list[0:max_index+1])\n\n            # Now move the maximum number to end by reversing current array\n            num_list[0:cur_size] = reversed(num_list[0:cur_size])\n\n    return num_list", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    if len(lst) <= 1:\n        return lst\n    for size in reversed(range(len(lst))):\n        max_ind = max(range(size + 1), key=lst.__getitem__)\n        if max_ind != size:\n            lst = lst[:max_ind+1][::-1] + lst[max_ind+1:]\n            lst = lst[:size+1][::-1] + lst[size+1:]\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for size in reversed(range(len(lst))):\n        max_ind = max(range(size+1), key=lst.__getitem__)\n        if max_ind != size:\n            lst[0:max_ind+1] = reversed(lst[0:max_ind+1])\n            lst[0:size+1] = reversed(lst[0:size+1])\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    \"\"\"\n    This function implements the Pancake Sort algorithm.\n    This is a much-hyped sorting algorithm in competitive programming circles.\n    \"\"\"\n    def flip(arr, i):\n        \"\"\"\n        Reverse array elements from 0 to i\n        \"\"\"\n        start = 0\n        while start < i:\n            temp = arr[start]\n            arr[start] = arr[i]\n            arr[i] = temp\n            start += 1\n            i -= 1\n\n    n = len(lst)\n    # Start from the complete array and reduce current size by one\n    for curr_size in range(n-1, 0, -1):\n        # Find index of the maximum element in lst[0..curr_size]\n        max_index = 0\n        for i in range(1, curr_size + 1):\n            if lst[i] > lst[max_index]:\n                max_index = i\n\n        # If not already sorted, flip max element to beginning\n        if max_index != curr_size:\n            flip(lst, max_index)\n            flip(lst, curr_size)\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            temp = arr[start]\n            arr[start] = arr[i]\n            arr[i] = temp\n            start += 1\n            i -= 1\n\n    n = len(arr)\n    for curr_size in reversed(range(n)):\n        max_ind = arr.index(max(arr[:curr_size + 1]))\n        if max_ind != curr_size:\n            flip(arr, max_ind)\n            flip(arr, curr_size)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    # Loop through each element of the array\n    for curr_size in reversed(range(n)):\n        max_index = 0\n        # Find index of the max element in remaining unsorted array\n        for i in range(1, curr_size + 1):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        # Move max element to end of unsorted array\n        if max_index != curr_size:\n            arr = reverse_arr(arr, max_index)\n            arr = reverse_arr(arr, curr_size)\n    return arr\ndef reverse_arr(arr, i):\n    # Helper function to reverse array from 0 to i\n    start = 0\n    while start < i:\n        arr[start], arr[i] = arr[i], arr[start]\n        start += 1\n        i -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(nums):\n    for i in range(len(nums)-1, 0, -1):\n        max_index = nums.index(max(nums[:i+1]))\n        if max_index != i:\n            if max_index != 0:\n                nums[:max_index+1] = reversed(nums[:max_index+1])\n            nums[:i+1] = reversed(nums[:i+1])\n    return nums", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for size in reversed(range(len(lst))):\n        max_ind = max(range(size + 1), key = lst.__getitem__)\n        if max_ind != size:\n            # This indexed max needs moving\n            if max_ind != 0:\n                # Flip the max item to the left\n                lst[:max_ind+1] = reversed(lst[:max_ind+1])\n            # Then flip it to the right\n            lst[:size+1] = reversed(lst[:size+1])\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    for size in reversed(range(n)):\n        max_index = 0\n        for i in range(1, size + 1):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        if max_index != size:\n            arr[0:max_index+1] = reversed(arr[0:max_index+1])\n            arr[0:size+1] = reversed(arr[0:size+1])\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            temp = arr[start]\n            arr[start] = arr[i]\n            arr[i] = temp\n            start += 1\n            i -= 1\n\n    n = len(lst)\n    for curr_size in reversed(range(n)):\n        max_index = max(range(curr_size + 1), key=lst.__getitem__)\n        if max_index != curr_size:\n            flip(lst, max_index)\n            flip(lst, curr_size)\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    for size in reversed(range(len(arr))):\n        max_ind = max(range(size+1), key=arr.__getitem__)\n        if max_ind != size:\n            arr[0:max_ind+1] = reversed(arr[0:max_ind+1])\n            arr[0:size+1] = reversed(arr[0:size+1])\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for size in reversed(range(len(lst))):\n        max_ind = max(range(size+1), key=lst.__getitem__)\n        if max_ind != size:\n            lst[0:max_ind+1] = reversed(lst[0:max_ind+1])\n            lst[0:size+1] = reversed(lst[0:size+1])\n    return lst", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 97.71999999999998, "dps_norm": 81.25, "pass@1": 42.0, "profiled": [{"solution": "def find_even_pair(numbers):\n    even_count = len([num for num in numbers if num % 2 == 0])\n    odd_count = len(numbers) - even_count\n    return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    even = 0\n    odd = 0\n    for num in lst:\n        if num & 1:\n            odd += 1\n        else:\n            even += 1\n\n    return even * (even - 1) // 2 + odd * (odd - 1) // 2", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(lst):\n    even = sum(1 for num in lst if num % 2 == 0)\n    odd = len(lst) - even\n    return even * (even - 1) // 2 + odd * (odd - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    even = sum(num % 2 == 0 for num in nums)\n    odd = len(nums) - even\n    return even * (even - 1) // 2 + odd * (odd - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    even_count = len([i for i in nums if i % 2 == 0])\n    odd_count = len(nums) - even_count\n\n    # For any two numbers x and y, x XOR y is even if and only if x and y have the same parity (both even or both odd). \n    # This means the number of pairs x XOR y to be even is the sum of the counts of the even numbers and the counts of the odd numbers.\n    return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    even_count = len([i for i in lst if i % 2 == 0])\n    odd_count = len(lst) - even_count\n    return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    even = sum(1 for i in lst if i % 2 == 0)\n    odd = len(lst) - even\n    return even * (even - 1) // 2 + odd * (odd - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs in nums that xor to an even number\n    \"\"\"\n    even_count = len(list(filter(lambda x: x % 2 == 0, nums)))\n    odd_count = len(nums) - even_count\n\n    return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(lst):\n    even = sum(1 for num in lst if num % 2 == 0)\n    odd = len(lst) - even\n    return even * (even - 1) // 2 + odd * (odd - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    even_count = 0\n    odd_count = 0\n\n    for num in lst:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    even = sum(1 for num in arr if num % 2 == 0)\n    odd = len(arr) - even\n    return even * (even - 1) // 2 + odd * (odd - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    even_count = sum(x % 2 == 0 for x in nums)\n    return even_count * (even_count - 1) // 2 + (len(nums) - even_count) * (len(nums) - even_count - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    even_count = sum(1 for num in lst if num % 2 == 0)\n    odd_count = len(lst) - even_count\n    return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(num_list):\n    count = 0\n    for i in range(len(num_list)):\n        for j in range(i+1, len(num_list)):\n            if (num_list[i] ^ num_list[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # XOR operation\n            xor_result = lst[i] ^ lst[j]\n            # Check if the XOR result is even\n            if xor_result % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(num_list):\n    even_count = sum(1 for num in num_list if num % 2 == 0)\n    odd_count = len(num_list) - even_count\n    return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2", "matching_cluster_idx": 3}]}, "Mbpp/170": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 78.0, "profiled": [{"solution": "def sum_range_list(lst, start_idx, end_idx):\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start_idx, end_idx):\n    \"\"\"\n    Function to find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n\n    return sum(num_list[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n\n    :param lst: list of numbers\n    :param start: start index\n    :param end: end index\n    :return: sum of numbers within the range\n    \"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Given a list of integers and two indices, this function returns the sum\n    of all the numbers within the range specified by the two indices.\n    \"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(list_of_nums, start_index, end_index):\n    return sum(list_of_nums[start_index:end_index+1])\nlist_of_nums = [2,1,5,6,8,3,4,9,10,11,8,12]\nstart_index = 8\nend_index = 10", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, index1, index2):\n    return sum(nums[index1:index2+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    return sum(lst[start_index:end_index+1])\nlst = [2,1,5,6,8,3,4,9,10,11,8,12]\nstart_index = 8\nend_index = 10", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start, end):\n    return sum(num_list[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start, end):\n    return sum(num_list[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start_index, end_index):\n    \"\"\"\n    Function to find the sum of numbers in a list within a range specified by two indices.\n    :param num_list: list of numbers\n    :param start_index: start index\n    :param end_index: end index\n    :return: sum of numbers in num_list from start_index to end_index\n    \"\"\"\n    return sum(num_list[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    \"\"\"\n    This function takes a list of numbers and two indices and returns the sum of the numbers between these two indices.\n    \"\"\"\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start_index, end_index):\n    return sum(num_list[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start, end):\n    \"\"\"\n    Returns the sum of numbers within a list given start and end indices.\n    \"\"\"\n    return sum(num_list[start:end+1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 70.15503875968992, "dps_norm": 17.857142857142858, "pass@1": 98.0, "profiled": [{"solution": "def odd_values_string(input_str):\n    \"\"\"\n    Function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    return ''.join(char for index, char in enumerate(input_str) if index % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    return ''.join([input_str[i] for i in range(len(input_str)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    This function returns a new string containing the characters of the input string \n    which are at an even index position (considering 0 as the first index).\n    \"\"\"\n    return ''.join([char for index, char in enumerate(input_string) if index % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters from a given string with odd index values.\n    :param input_string: The string from which to remove characters.\n    :return: The resulting string.\n    \"\"\"\n    return ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(input_string):\n    return ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(input_string):\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    return ''.join(input_str[i] for i in range(len(input_str)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    return \"\".join([char for index, char in enumerate(input_string) if index % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    return ''.join([v for i, v in enumerate(input_string) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters with odd index values from a given string.\n\n    Parameters:\n    input_string (str): input string\n\n    Returns:\n    str: string after removing characters with odd index values\n    \"\"\"\n    # Return a string of characters with even index values\n    return ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(input_string):\n    return \"\".join([char for index, char in enumerate(input_string) if index % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Using list comprehension to get characters with even indices (0-indexed)\n    return ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    return ''.join([input_str[i] for i in range(len(input_str)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(input_string):\n    result_string = ''\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result_string += input_string[i]\n    return result_string", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(string, char):\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, c: str) -> str:\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    Replaces blank spaces in the string with the provided character.\n    \"\"\"\n    # Replace blank spaces in the string with the character\n    new_string = string.replace(' ', char)\n\n    # Return the result\n    return new_string", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_character):\n    # Replace each space with the replacement character\n    return input_string.replace(' ', replacement_character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(str_input, char_input):\n    return str_input.replace(' ', char_input)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_str, char):\n    \"\"\"\n    This function replaces blank spaces in the string with the specified character.\n\n    Parameters:\n    input_str (str): The input string.\n    char (str): The character to replace blank spaces.\n\n    Returns:\n    str: The modified string.\n    \"\"\"\n    return input_str.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    This function replaces all blank spaces in a string with a character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"Replace spaces in string s with character char and return the result.\"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, character):\n    return input_string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, character):\n    return input_string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_str: str, char: str) -> str:\n    \"\"\"\n    This function replaces blank spaces in the input string with the provided character and returns the string.\n    :param input_str: The input string to be processed.\n    :param char: The character to replace blank spaces with.\n    :return: The processed string.\n    \"\"\"\n    return input_str.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_str, replacement_char):\n    \"\"\"\n    Function that takes in a string and character, \n    replaces blank spaces in the string with the character, and returns the string.\n\n    :param input_str: The input string\n    :param replacement_char: Character to replace blank spaces with\n    :return: The modified string\n    \"\"\"\n    return input_str.replace(' ', replacement_char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": null, "dps_norm": null, "pass@1": 7.0, "profiled": []}, "Mbpp/240": {"dps": 73.47560975609757, "dps_norm": 83.33333333333333, "pass@1": 61.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(first_list, second_list):\n    first_list.pop() # Remove the last element of the first list\n    for i in second_list:\n        first_list.append(i) # Add the elements of the second list to the first list\n    return first_list", "matching_cluster_idx": 3}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n    list1 (list): The list where the last element is to be replaced.\n    list2 (list): The list containing elements to replace the last element of the first list.\n\n    Returns:\n    list: A new list where the last element of the first list is replaced by the elements of the second list.\n    \"\"\"\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Pop last element from list1\n    list1.pop()\n    # Append list2 to list1\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(first_list, second_list):\n    \"\"\"\n    Function to replace the last element of the first list with the elements of the second list\n    \"\"\"\n\n    # Replace the last element of first_list with elements of second_list\n    first_list[-1:] = second_list\n\n    # Return the modified list\n    return first_list", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Remove the last element of the first list\n    list1 = list1[:-1]\n    # Append elements of the second list to the end of the first list\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace last element of first list with second list.\n\n    Parameters:\n    list1 (list): Original list.\n    list2 (list): List to replace last element.\n\n    Returns:\n    list: Modified list.\n    \"\"\"\n    # Get all elements of list1 except the last one\n    first_part = list1[:-1]\n    # Add elements of list2 at the end\n    first_part.extend(list2)\n    return first_part", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    list1 = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Pop the last element of the first list\n    list1.pop()\n    # Add the elements of the second list\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    # Remove the last element of list1 and add list2's elements to the end of list1\n    list1 = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    list1 = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(first_list, second_list):\n    first_list[-1:] = second_list\n    return first_list", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # if list1 is not empty, replace its last element with elements of list2\n    if list1:\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}]}, "Mbpp/251": {"dps": 87.95977011494254, "dps_norm": 76.66666666666666, "pass@1": 95.0, "profiled": [{"solution": "def insert_element(input_list, element):\n    result = []\n    for i in input_list:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    result = []\n    for i in input_list:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    result = []\n    for i in input_list:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"Inserts the element before each element in the list and returns the resulting list.\"\"\"\n\n    # List comprehension solution\n    return [elem for pair in [[elem, item] for item in lst] for elem in pair]", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    result = []\n    for i in input_list:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Insert an element before each element in the list\n    \"\"\"\n    result = []\n    for i in input_list:\n        result.extend([element, i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for i in lst:\n        result.append(elem)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(my_list, element):\n    \"\"\"\n    This function takes in a list and an element and inserts the element before \n    each element in the list, and returns the resulting list.\n    \"\"\"\n    output = []\n    for item in my_list:\n        output.extend([element, item])\n    return output", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Insert an element before each element in the list and return the resulting list.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    new_list = []\n    for item in lst:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    result = []\n    for i in input_list:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elm):\n    result = []\n    for i in lst:\n        result.extend([elm, i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts an element before each element in the list and returns the resulting list.\n\n    Args:\n        lst (List): The list to insert elements into.\n        elem (Any): The element to insert.\n\n    Returns:\n        List: The list with elements inserted.\n    \"\"\"\n    # initialize an empty list\n    result = []\n\n    # loop through the input list\n    for i in lst:\n        # insert the element before each element\n        result.extend([elem, i])\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elm):\n    result = []\n    for item in lst:\n        result.append(elm)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for i in lst:\n        result.append(elem)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    new_list = []\n    for item in lst:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 68.83561643835617, "dps_norm": 63.529411764705884, "pass@1": 89.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    if n<2:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for current in range(2, int(n**0.5)+1):\n        if primes[current] == True:\n            for multiple in range(current*current, n, current):\n                primes[multiple] = False\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def is_prime(n):\n    \"\"\"\n    A helper function that checks if a number is prime\n    \"\"\"\n    if n == 0 or n == 1:\n        return False\n    for x in range(2, int(n**0.5) + 1):\n        if n % x == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Main function that counts the number of prime numbers less than n\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # zero and one are not prime numbers\n    if n < 2:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for current in range(2, int(n**0.5) + 1):\n        if primes[current]:\n            primes[current*current: n: current] = [False] * len(primes[current*current: n: current])\n    return sum(primes)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        \"\"\"\n        Helper function to check if a number is a prime number or not.\n        \"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):  # range starts from 2, not 1, because 1 is not a prime number\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for current in range(2, int(n ** 0.5) + 1):\n        if primes[current] == True:\n            for multiple in range(current*current, n, current):\n                primes[multiple] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    A python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    primes = [True] * (n)\n    primes[0] = primes[1] = False\n    for current in range(2, int(n ** 0.5) + 1):\n        if primes[current]:\n            for multiple in range(current * current, n, current):\n                primes[multiple] = False\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        elif num <= 3:\n            return True\n        elif num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i = i + 6\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(num):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5)+1):\n            if n % i == 0:\n                return False\n        return True\n    \n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2: return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    primes = [True]*n\n    primes[0] = primes[1] = False\n    for current in range(2, int(n ** 0.5) + 1):\n        if primes[current]:\n            primes[current*current: n: current] = [False] * len(primes[current*current: n: current])\n    return sum(primes)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(num):\n    # Function to check if a number is prime or not\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    # Counting the prime numbers\n    count = 0\n    for i in range(num):\n        if is_prime(i):\n            count += 1\n\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(n):\n        \"\"\"\n        Function to check if a number is prime.\n        \"\"\"\n        if n == 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    # if n is less than 2, there are no primes less than it\n    if n < 2:\n        return 0\n\n    # else, count the primes less than n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    return len([i for i in range(num) if is_prime(i)])", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    primes = [True]*n\n    primes[0] = primes[1] = False\n    for current in range(2, int(n**0.5) + 1):\n        if primes[current] == True:\n            for multiple in range(current*current, n, current):\n                primes[multiple] = False\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number.\n\n    Parameters:\n    n (int): The number upto which primes should be counted.\n\n    Returns:\n    int: The count of prime numbers less than n.\n    \"\"\"\n\n    def is_prime(num):\n        \"\"\"\n        Helper function to check if a number is prime.\n\n        Parameters:\n        num (int): The number to be checked.\n\n        Returns:\n        bool: True if the number is prime, False otherwise.\n        \"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    if n == 2 or n == 3: return True\n    if n < 2 or n%2 == 0: return False\n    if n < 9: return True\n    if n%3 == 0: return False\n    r = int(n**0.5)\n    f = 5\n    while f <= r:\n        if n%f == 0: return False\n        if n%(f+2) == 0: return False\n        f +=6\n    return True\ndef count_Primes_nums(num):\n    count = 0\n    for n in range(num):\n        if is_prime(n):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    # Function to check if a number is prime\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, num):\n            if num % i == 0:\n                return False\n        return True\n\n    # Initialize a counter\n    counter = 0\n\n    # Iterate from 2 to n (exclusive)\n    for i in range(2, n):\n        # If the number is prime, increment the counter\n        if is_prime(i):\n            counter += 1\n\n    # Return the final count of prime numbers\n    return counter", "matching_cluster_idx": 2}]}, "Mbpp/265": {"dps": 78.37209302325581, "dps_norm": 88.33333333333333, "pass@1": 97.0, "profiled": [{"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    output = [[] for _ in range(n)]\n    for i, el in enumerate(lst):\n        output[i%n].append(el)\n    return output", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    This function splits a list for every nth element\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    result = [[] for _ in range(n)]\n    for i, x in enumerate(lst):\n        result[i%n].append(x)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(list_input, n):\n    # Creates an empty list of lists\n    output_list = [[] for _ in range(n)]\n\n    # Fill each sublist with every nth element\n    for i in range(len(list_input)):\n        output_list[i % n].append(list_input[i])\n\n    return output_list", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    result_list = []\n    for i in range(n):\n        temp_list = []\n        for j in range(i, len(input_list), n):\n            temp_list.append(input_list[j])\n        result_list.append(temp_list)\n    return result_list", "matching_cluster_idx": 3}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    result = [[] for _ in range(n)]\n    for i in range(len(lst)):\n        result[i%n].append(lst[i])\n    return result\nlst = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    result = []\n    for i in range(n):\n        temp = []\n        for j in range(i, len(input_list), n):\n            temp.append(input_list[j])\n        result.append(temp)\n    return result", "matching_cluster_idx": 3}, {"solution": "def list_split(lst, n):\n    result = [[] for _ in range(n)]\n    for i, el in enumerate(lst):\n        result[i%n].append(el)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]\ninput_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nn = 3", "matching_cluster_idx": 5}, {"solution": "def list_split(input_list, n):\n    split_list = []\n    for i in range(n):\n        split_list.append([input_list[j] for j in range(i, len(input_list), n)])\n    return split_list", "matching_cluster_idx": 2}, {"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(input_list, n):\n    result_lists = [[] for _ in range(n)]\n    for index, item in enumerate(input_list):\n        result_lists[index % n].append(item)\n    return result_lists", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(input_list, n):\n    result = [[] for _ in range(n)]\n    for i, element in enumerate(input_list):\n        result[i%n].append(element)\n    return result", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"\n    Function to check if all elements in a list are unique.\n    \"\"\"\n    # By converting the list to a set, we remove any duplicate values\n    # and then we check if the length of the set equals the length of the list\n    # to determine if all elements were unique.\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\" \n    Checks if all elements of the given list are unique.\n    \n    Parameters:\n    lst (list): input list\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\" Check if the elements of a given list are unique \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Check if the elements in list are unique or not\"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n    \n    Parameters:\n    lst (list): The list to check.\n    \n    Returns:\n    bool: True if all elements in the list are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in the list are unique or not.\n\n    :param lst: list of elements\n    :return: True if all elements in the list are unique, False otherwise.\n    \"\"\"\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"This function checks if the elements of the given list are unique or not\"\"\"\n    if len(input_list) == len(set(input_list)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if elements in a list are unique.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Function to check if the elements of a given list are unique or not.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\" \n    This function checks if the elements of a given list are unique. \n    \n    Args:\n        lst (list): The list to check\n    \n    Returns:\n        bool: Returns True if all elements are unique, False otherwise\n    \"\"\"\n\n    # Convert the list to a set\n    # Sets in Python are inherently unique, meaning they cannot contain any duplicate elements\n    # Hence, if the length of the set is not equal to the length of the original list, there must be duplicates in the original list\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Check if the elements of a list are unique or not.\"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"Checks if all elements in a list are unique.\"\"\"\n    if len(input_list) == len(set(input_list)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Function to check if the elements of a list are unique or not.\n    \"\"\"\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Function to check if all elements in a list are unique.\n\n    Parameters:\n    input_list (list): Input list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Checking if length of set of list elements is same as list\n    if len(input_list) == len(set(input_list)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 46.15384615384615, "dps_norm": 75.0, "pass@1": 98.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n \n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inversion_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inversion_count += 1\n\n    return inversion_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inversionCount = 0\n    n = len(arr)\n\n    # Traverse through all array elements\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inversionCount += 1\n\n    return inversionCount", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0]*n\n    return _merge_sort(arr, temp_arr, 0, n-1)\ndef _merge_sort(arr, temp_arr, left, right):\n    inv_count = 0\n\n    if left < right:\n        mid = (left + right)//2\n        inv_count = _merge_sort(arr, temp_arr, left, mid)\n        inv_count += _merge_sort(arr, temp_arr, mid + 1, right)\n        inv_count += merge(arr, temp_arr, left, mid, right)\n    return inv_count\ndef merge(arr, temp_arr, left, mid, right):\n    i = left    \n    j = mid + 1\n    k = left     \n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            k += 1\n            j += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n        \n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def mergeSort(arr, n):\n    temp_arr = [0]*n\n    return _mergeSort(arr, temp_arr, 0, n-1)\ndef _mergeSort(arr, temp_arr, left, right):\n    inv_count = 0\n\n    if left < right:\n        mid = (left + right)//2\n        inv_count = _mergeSort(arr, temp_arr,left, mid)\n        inv_count += _mergeSort(arr, temp_arr, mid + 1, right)\n        inv_count += merge(arr, temp_arr, left, mid, right)\n    return inv_count\ndef merge(arr, temp_arr, left, mid, right):\n    i = left     \n    j = mid + 1 \n    k = left     \n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            k += 1\n            j += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n        \n    return inv_count\ndef get_Inv_Count(arr):\n    n = len(arr)\n    return mergeSort(arr,n)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(array):\n    def mergeSort(arr, n):\n        temp_arr = [0]*n\n        return _mergeSort(arr, temp_arr, 0, n-1)\n\n    def _mergeSort(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right)//2\n            inv_count += _mergeSort(arr, temp_arr, left, mid)\n            inv_count += _mergeSort(arr, temp_arr, mid + 1, right)\n            inv_count += merge(arr, temp_arr, left, mid, right)\n        return inv_count\n\n    def merge(arr, temp_arr, left, mid, right):\n        i = left     \n        j = mid + 1  \n        k = left     \n        inv_count = 0\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                k += 1\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid-i + 1)\n                k += 1\n                j += 1\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        while j <= right:\n            temp_arr[k] = arr[j]\n            k += 1\n            j += 1\n        for loop_var in range(left, right + 1):\n            arr[loop_var] = temp_arr[loop_var]\n        return inv_count\n    n = len(array)\n    return mergeSort(array,n)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inversion_count = 0\n    n = len(arr)\n    for i in range(n): \n        for j in range(i + 1, n): \n            if (arr[i] > arr[j]): \n                inversion_count += 1\n    return inversion_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    def _mergeSort(arr):\n        inv_count = 0\n        if len(arr) > 1:\n            mid = len(arr) // 2\n            left = arr[:mid]\n            right = arr[mid:]\n\n            inv_count += _mergeSort(left)\n            inv_count += _mergeSort(right)\n\n            i = j = k = 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    arr[k] = left[i]\n                    i += 1\n                else:\n                    arr[k] = right[j]\n                    inv_count += len(left) - i\n                    j += 1\n                k += 1\n\n            while i < len(left):\n                arr[k] = left[i]\n                i += 1\n                k += 1\n\n            while j < len(right):\n                arr[k] = right[j]\n                j += 1\n                k += 1\n        return inv_count\n\n    return _mergeSort(arr)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                count += 1\n                \n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0]*n\n    return _mergeSort(arr, temp_arr, 0, n-1)\ndef _mergeSort(arr, temp_arr, left, right):\n    inv_count = 0\n\n    if left < right:\n\n        # Divide the array into two parts\n        mid = (left + right)//2\n\n        # Inversion count will be the sum of inversions in left part,\n        # right part and number of inversions in merging\n        inv_count = _mergeSort(arr, temp_arr, left, mid)\n        inv_count += _mergeSort(arr, temp_arr, mid + 1, right)\n        inv_count += merge(arr, temp_arr, left, mid, right)\n    return inv_count\ndef merge(arr, temp_arr, left, mid, right):\n    i = left     # Starting index of left subarray\n    j = mid + 1  # Starting index of right subarray\n    k = left     # Starting index of to be sorted subarray\n    inv_count = 0\n\n    # Conditions are checked to make sure that i and j do not exceed their subarray limits.\n    while i <= mid and j <= right:\n\n        # There is no inversion if arr[i] <= arr[j]\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            # Inversion found\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            k += 1\n            j += 1\n\n    # Copy the remaining elements of left subarray into temporary array\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n\n    # Copy the remaining elements of right subarray into temporary array\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n\n    # Copy the sorted subarray into original array\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    This function takes an array as input and returns the number of inversions present in it.\n    Inversion Count for an array indicates \u2013 how far (or close) the array is from being sorted. If array is already sorted then inversion count is 0. If array is sorted in reverse order that inversion count is the maximum. \n    Formally speaking, two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j \n    \"\"\"\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n \n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    n = len(arr)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n\n    return count", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": 97.58620689655173, "dps_norm": 66.66666666666667, "pass@1": 46.0, "profiled": [{"solution": "def large_product(list1, list2, k):\n    # Create a list of all possible products\n    products = sorted([i*j for i in list1 for j in list2], reverse=True)\n    \n    # Return the first k elements\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # generate all products from list1 and list2\n    products = [a * b for a in list1 for b in list2]\n\n    # sort the products in descending order\n    products.sort(reverse=True)\n\n    # return the first n elements from the sorted products list\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    return sorted([i * j for i in list1 for j in list2], reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "from typing import List, Union\ndef large_product(a: List[Union[int, float]], b: List[Union[int, float]], n: int) -> List[Union[int, float]]:\n    \"\"\"\n    Finds the 'n' largest products from two given lists.\n\n    Parameters:\n    a (List[Union[int, float]]): First list of numbers.\n    b (List[Union[int, float]]): Second list of numbers.\n    n (int): Number of largest products to be found.\n\n    Returns:\n    List[Union[int, float]]: List of 'n' largest products.\n\n    \"\"\"\n\n    # Get all product combinations\n    products = sorted([i*j for i in a for j in b], reverse=True)\n\n    # Return the 'n' largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    if not (isinstance(list1, list) and isinstance(list2, list) and isinstance(num, int)):\n        raise TypeError(\"Input must be a list and a number.\")\n\n    products = [i*j for i in list1 for j in list2]\n    products.sort(reverse=True)\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [i*j for i in list1 for j in list2]\n\n    # Find the n largest products\n    n_largest = heapq.nlargest(n, products)\n\n    return n_largest", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    \"\"\"\n    This function will return the `num` largest products from two lists.\n    \"\"\"\n    products = [a * b for a in list1 for b in list2]\n    products.sort(reverse=True)\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(lst1, lst2, n):\n    \"\"\"\n    Function to find the specified number of largest products\n    \"\"\"\n    products = [i*j for i in lst1 for j in lst2]\n    products.sort(reverse=True)\n    return products[:n]\nlst1 = [1, 2, 3, 4, 5, 6]\nlst2 = [3, 6, 8, 9, 10, 6]\nn = 3", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Prevent trying to compute more products than possible.\n    if n > len(list1)*len(list2):\n        raise ValueError(\"Can't compute more products than there are elements in the lists\")\n\n    # Generate a list of all possible products.\n    products = [x*y for x in list1 for y in list2]\n\n    # Sort the products in descending order and return the top n.\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(numbers1, numbers2, count):\n    products = sorted([num1 * num2 for num1 in numbers1 for num2 in numbers2], reverse=True)\n    return products[:count]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n    products.sort(reverse=True)\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(l1, l2, k):\n    products = []\n    for i in l1:\n        for j in l2:\n            products.append(i*j)\n    products.sort(reverse=True)\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible pairs of products\n    products = [i*j for i in list1 for j in list2]\n    # Sort in descending order\n    products.sort(reverse=True)\n    # Return the first n elements\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate the product of all factors in lists\n    product_list = [i*j for i in list1 for j in list2]\n    # Sort the list in descending order\n    product_list.sort(reverse=True)\n    # Return the first n elements\n    return product_list[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(lst1, lst2, k):\n    products = [i*j for i in lst1 for j in lst2]\n    products.sort(reverse=True)\n    return products[:k]\nlst1 = [1, 2, 3, 4, 5, 6]\nlst2 = [3, 6, 8, 9, 10, 6]\nk = 3", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, k):\n    \"\"\"\n    Find the specified number of largest products from two given lists\n    by selecting one factor from each list.\n    \"\"\"\n    # create a max-heap\n    heap = []\n    for a in list1:\n        for b in list2:\n            # heap stores negative values to simulate max-heap\n            heapq.heappush(heap, -a * b)\n    # return the largest k values\n    return sorted([-heapq.heappop(heap) for _ in range(k)], reverse=True)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Calculate the product for all combinations\n    products = [a*b for a in list1 for b in list2]\n\n    # Sort products in descending order\n    products.sort(reverse=True)\n\n    # Return the 'num' largest products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    # Create two lists to hold product combinations.\n    products = [i*j for i in list1 for j in list2]\n    \n    # Sort the products in descending order.\n    products.sort(reverse=True)\n    \n    # Return the first k elements from the sorted list.\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products\n    products = [x*y for x in list1 for y in list2]\n    # Sort the list in descending order\n    products.sort(reverse=True)\n    # Return the first n elements\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(lst1, lst2, n):\n    products = []\n    for i in lst1:\n        for j in lst2:\n            products.append(i * j)\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 34.671361502347416, "dps_norm": 45.76923076923077, "pass@1": 50.0, "profiled": [{"solution": "def get_max_sum(n):\n    if n < 0:\n        return 0\n\n    if n == 0 or n == 1:\n        return n\n\n    # Create a list to store the results of sub-problems\n    dp = [0]*(n+1)\n\n    # Base case\n    dp[0] = 0\n    dp[1] = 1\n\n    # Bottom-up DP: Fill up dp[] array in bottom up manner\n    for i in range(2, n+1):\n        dp[i] = max((dp[int(i/2)] + dp[int(i/3)] + dp[int(i/4)] + dp[int(i/5)]), i)\n\n    return dp[n]", "matching_cluster_idx": 9}, {"solution": "def get_max_sum(n):\n    # Base case\n    if n == 0:\n        return 0\n\n    # Initialize list for memoization\n    dp = [0] * (n + 1)\n\n    # Fill the dp list\n    for i in range(1, n + 1):\n        # Include the current index or its divisions\n        dp[i] = max(i, dp[i // 2] + dp[i // 3] + dp[i // 4] + dp[i // 5])\n\n    return dp[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    # Using a lookup table for memoization\n    sum_array = [0, 1]\n\n    # Iterating over the range and filling up the lookup table\n    for i in range(2, n+1):\n        sum_array.append(max(sum_array[int(i/2)] + sum_array[int(i/3)] + sum_array[int(i/4)] + sum_array[int(i/5)], i))\n\n    # Returning the maximum sum possible\n    return sum_array[n]", "matching_cluster_idx": 9}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    else:\n        return max((get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5)), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    if n == 0: \n        return 0\n    else:\n        # Recursive case\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    else:\n        return max((get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5)), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    else:\n        return max((get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5)), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    else:\n        return max((get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5)), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    # a memoization dictionary to save computed subproblem results\n    memo = {0: 0, 1: 1}\n    # recursive function that computes the maximum sum\n    def max_sum(n):\n        # if n is not in memo, compute it and store it in memo\n        if n not in memo:\n            memo[n] = max(max_sum(n//2) + max_sum(n//3) + max_sum(n//4) + max_sum(n//5), n)\n        # return the computed value from memo\n        return memo[n]\n    # return the maximum sum for n\n    return max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    ## A cache to store precomputed values for efficiency\n    cache = {0:0, 1:1}\n\n    def f(n):\n        if n in cache:\n            return cache[n]\n        else:\n            cache[n] = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n            return cache[n]\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def max_sum(n):\n    if n == 0: \n        return 0\n    else:\n        return max(n, max_sum(n//2) + max_sum(n//3) + max_sum(n//4) + max_sum(n//5))\ndef get_max_sum(n):\n    return max_sum(n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    if n < 1:\n        return 0\n    else:\n        return max((get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5)), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Function to find the maximum sum possible by using the given equation \n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \"\"\"\n    if n == 0:\n        return 0\n    if n in memo: \n        return memo[n]\n    else:\n        memo[n] = max((get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + \n                       get_max_sum(n//4, memo) + get_max_sum(n//5, memo)), n)\n        return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n\n    if n < 2:\n        return n\n    \n    # Create a list to store the maximum sum for each number\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    \n    # Fill in the list bottom-up\n    for i in range(2, n + 1):\n        dp[i] = max((dp[int(i/2)] + dp[int(i/3)] + dp[int(i/4)] + dp[int(i/5)]), i)\n    \n    return dp[n]", "matching_cluster_idx": 9}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    if n == 0: \n        return 0\n    else:\n        return max((get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5)), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    if n == 0: \n        return 0\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 2}]}, "Mbpp/395": {"dps": 89.6168582375479, "dps_norm": 73.75, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(string):\n    char_order = []\n    ctr = {}\n    for c in string:\n        if c in ctr:\n            ctr[c] += 1\n        else:\n            ctr[c] = 1 \n            char_order.append(c)\n    for c in char_order:\n        if ctr[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    char_counts = {}\n\n    # Count the number of occurrences of each character\n    for char in input_string:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n\n    # Find the first character that has a count of 1\n    for char in input_string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    char_count = {}\n    for char in input_string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in input_string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_order = []\n    ctr = {}\n    for c in s:\n        if c in ctr:\n            ctr[c] += 1\n        else:\n            ctr[c] = 1\n            char_order.append(c)\n    for c in char_order:\n        if ctr[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char not in char_count:\n            char_count[char] = 1\n        else:\n            char_count[char] += 1\n\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 4}, {"solution": "def first_non_repeating_character(input_string):\n    char_count = {}\n    for char in input_string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in input_string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"Function to find the first non-repeated character in a given string.\"\"\"\n    char_count = {}\n\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    frequency = {}\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    \n    for char in s:\n        if frequency[char] == 1:\n            return char\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_order = []\n    counts = {}\n    for c in string:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n        char_order.append(c)\n    for c in char_order:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 4}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    \n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    char_count = {}\n    for character in input_string:\n        if character in char_count:\n            char_count[character] += 1\n        else:\n            char_count[character] = 1\n\n    for character in input_string:\n        if char_count[character] == 1:\n            return character\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for c in s:\n        if c in char_count:\n            char_count[c] += 1\n        else:\n            char_count[c] = 1\n    for c in s:\n        if char_count[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Function to find the first non-repeated character in a given string.\n    \"\"\"\n    char_order = []\n    ctr = {}\n    for char in string:\n        if char in ctr:\n            ctr[char] += 1\n        else:\n            ctr[char] = 1\n            char_order.append(char)\n    for char in char_order:\n        if ctr[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    # initialize dictionary to store character count\n    count = {}\n    # iterate over the input string\n    for char in input_string:\n        # if the character is not in the count dictionary, add it with count 1\n        # otherwise, increment the count by 1\n        count[char] = count.get(char, 0) + 1\n    # iterate over the input string\n    for char in input_string:\n        # if the count of the character is 1, it is the first non-repeating character\n        if count[char] == 1:\n            return char\n    # if no character is found, return None\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Function to check whether an element exists within a tuple.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, item):\n    \"\"\"\n    Check if an element exists within a tuple.\n    \"\"\"\n    return item in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if element exists within tuple.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    This function checks if an element exists within a tuple.\n    \"\"\"\n    if element in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, char):\n    \"\"\"\n    Check if an element exists within a tuple\n    :param tuplex: The tuple to be checked\n    :param char: The element to look for in the tuple\n    :return: True if element exists, False otherwise\n    \"\"\"\n    if char in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if an element exists within a tuple\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"Check if an element exists within a tuple.\"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, target):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n\n    :param input_tuple: The tuple where you're checking if element exists.\n    :param target: The element you're checking for in the tuple.\n    :return: Returns True if element exists, False otherwise.\n    \"\"\"\n    return target in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, ele):\n    \"\"\"\n    Function to check whether an element exists within a tuple.\n    \"\"\"\n    return ele in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(my_tuple, element):\n    return element in my_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Write a function to check whether an element exists within a tuple.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether a certain element exists within a tuple\n\n    Parameters:\n        tuplex: Tuple to be checked\n        element: Element to be looked for in the tuple\n\n    Returns:\n        bool: True if the element exists in the tuple, False otherwise\n\n    Example:\n    >>> assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'r')==True\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Function to check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to be checked.\n    element (any): The element to be searched.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, element):\n    \"\"\"Check whether an element exists within a tuple\"\"\"\n    return element in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, element):\n    \"\"\"\n    A function to check whether an element exists within a tuple.\n    :param t: tuple\n    :param element: the element to be checked for existence in the tuple\n    :return: True if the element exists in the tuple, False otherwise\n    \"\"\"\n    return element in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, element):\n    return element in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Function to check whether an element exists within a tuple\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Function to check whether an element exists within a tuple\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 89.00621118012423, "dps_norm": 88.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(sequence1, sequence2):\n    \"\"\"\n    Check whether any value in sequence1 exists in sequence2 or not.\n    \"\"\"\n    for val in sequence1:\n        if val in sequence2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Function to check whether any value in a sequence exists in a sequence or not.\n    \"\"\"\n    for value in seq1:\n        if value in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value from seq1 exists in seq2.\n    \"\"\"\n    for el in seq1:\n        if el in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Function to check if any value in seq1 exists in seq2.\n    Returns True if any value exists, otherwise False.\n    \"\"\"\n    # Convert the sequences to sets to speed up the lookup process\n    set1 = set(seq1)\n    set2 = set(seq2)\n\n    # Check each value in set1, if any is found in set2 return True\n    for val in set1:\n        if val in set2:\n            return True\n\n    # If no overlapping values are found return False\n    return False", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    for i in list1:\n        if i in list2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n    :param seq1: first sequence\n    :param seq2: second sequence\n    :return: True if any value in seq1 is in seq2, False otherwise\n    \"\"\"\n    # Use any() function to check if any element in seq1 is in seq2\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    A function to check whether any value in a sequence exists in another sequence\n    :param seq1: First sequence\n    :param seq2: Second sequence\n    :return: True if any value in seq1 exists in seq2, otherwise False\n    \"\"\"\n    # convert seq2 to a set for faster lookup\n    seq2_set = set(seq2)\n    # check if any value in seq1 exists in seq2\n    for val in seq1:\n        if val in seq2_set:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for value in seq1:\n        if value in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    This function checks if any value in seq1 exists in seq2 or not\n    \"\"\"\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    This function checks whether any value in seq1 exists in seq2\n    :param seq1: First sequence to check\n    :param seq2: Second sequence to check\n    :return: Boolean indicating whether any value in seq1 is also in seq2\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for value in seq1:\n        if value in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    for i in list1:\n        if i in list2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2\n\n    Args:\n        seq1 (list or set): a sequence of values\n        seq2 (list or set): a sequence of values\n\n    Returns:\n        bool: True if any value in seq1 exists in seq2, False otherwise\n    \"\"\"\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Function to check whether any value in a sequence exists in another sequence.\n    \"\"\"\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 54.83539094650206, "dps_norm": 82.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(tup, delimiter = \"-\"):\n    # Mapping function to convert each element to string\n    str_tup = map(str, tup)\n    # Joining strings in the tuple by the delimiter\n    return delimiter.join(str_tup)", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    # Check if input is a tuple\n    if not isinstance(t, tuple):\n        raise ValueError(\"Input should be a tuple.\")\n    # Check if delimiter is a string\n    if not isinstance(delimiter, str):\n        raise ValueError(\"Delimiter should be a string.\")\n    # Convert each element of tuple into string, if it is not already a string\n    str_elements = [str(i) for i in t]\n    # Concatenate the elements with the delimiter\n    result = delimiter.join(str_elements)\n    return result", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(str(i) for i in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    This function takes a tuple and a delimiter (default is '-') and \n    concatenates each element of the tuple with the delimiter.\n    \"\"\"\n    # Converting each element to string \n    input_tuple = map(str, input_tuple)\n    # Joining the elements of the tuple with the delimiter\n    result = delimiter.join(input_tuple)\n    return result", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    This function concatenates each element of input_tuple by the delimiter.\n    \"\"\"\n    result = ''\n    for i in input_tuple:\n        result += str(i) + delimiter\n    return result[:-len(delimiter)]", "matching_cluster_idx": 3}, {"solution": "def concatenate_tuple(tuple_val, delimiter='-'):\n    return delimiter.join(map(str,tuple_val))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(str(i) for i in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(str(i) for i in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(str(i) for i in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(i) for i in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple):\n    delimiter = '-'\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    This function takes in a tuple and a delimiter, and returns a string which \n    is the concatenation of all elements of the tuple, separated by the delimiter.\n    \"\"\"\n    # Use the built-in `map()` function to convert all elements to strings\n    # Use the built-in `join()` function to concatenate all strings\n    result = delimiter.join(map(str, input_tuple))\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tpl, delimiter='-'):\n    return delimiter.join(str(ele) for ele in tpl)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    # Convert each element of tuple to string, to handle both string and number types\n    string_elements = map(str, input_tuple)\n    # Concatenate string elements of tuple with the delimiter\n    concatenated_string = delimiter.join(string_elements)\n    return concatenated_string", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tuple_, delimiter='-'):\n    \"\"\"\n    This function concatenates each element of a tuple by the delimiter.\n    \"\"\"\n    # convert each element of the tuple to a string using map()\n    # join the strings with the delimiter using the join() method\n    return delimiter.join(map(str, tuple_))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    return \"-\".join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    return delimiter.join(str(i) for i in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple):\n    # Converting all elements in tuple to string\n    str_tuple = map(str, input_tuple)\n\n    # Concatenating elements in the tuple with '-' delimiter\n    result = \"-\".join(str_tuple)\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    \"\"\"\n    This function concatenates each element of tuple by the delimiter.\n    \"\"\"\n    # Converting tuple to list to allow modifications\n    t = list(t)\n    # Converting each element in the list to string and joining with the delimiter\n    t = delimiter.join(map(str, t))\n    return t", "matching_cluster_idx": 5}]}, "Mbpp/424": {"dps": 80.95667870036101, "dps_norm": 92.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    This function extracts the last character of each string in a given tuple and returns a list of these characters.\n    \"\"\"\n    return [word[-1] for word in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    return [x[-1] for x in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extract the rear index element of each string in the given tuple.\n    \"\"\"\n    return [string[-1] for string in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    result = []\n    for string in input_tuple:\n        result.append(string[-1])\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Initialize an empty list to store the extracted elements\n    result = []\n\n    # Iterate over each string in the given tuple\n    for string in input_tuple:\n        # Extract the rear index element and add it to the result\n        result.append(string[-1])\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    return [string[-1] for string in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_str):\n    \"\"\"\n    Function to extract only the rear index element of each string in the given tuple.\n    \"\"\"\n    return [s[-1] for s in tuple_str]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [word[-1] for word in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    return [string[-1] for string in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    # Initialize an empty list\n    result = []\n\n    # Iterate over each string in the given tuple\n    for string in input_tuple:\n        # Extract the last character and add it to the result list\n        result.append(string[-1])\n\n    # Return the final list\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Function to extract the rear index element of each string in the given tuple\n    \"\"\"\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    return [i[-1] for i in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    return [word[-1] for word in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Function to extract only the rear index element of each string in the given tuple.\n    \"\"\"\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    # Initializing an empty list to store the rear index element of each string\n    rear_elements = []\n\n    # Iterating over the input tuple\n    for item in input_tuple:\n        # If item is a string, add its last character to the rear_elements list\n        if isinstance(item, str):\n            rear_elements.append(item[-1])\n\n    # Return the rear elements list\n    return rear_elements", "matching_cluster_idx": 2}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Function to extract only the rear index element of each string in the given tuple.\n    :param tup: The input tuple of strings.\n    :return: A list with rear index elements of each string.\n    \"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tpl):\n    return [item[-1] for item in tpl]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings_tuple):\n    return [string[-1] for string in strings_tuple]", "matching_cluster_idx": 4}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(lst, elm):\n    count = 0\n    for sublist in lst:\n        if elm in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    \"\"\"\n    Counts the number of sublists in a list that contain a particular element.\n    \n    Args:\n    lst: The main list to be checked.\n    elem: The element to be looked for.\n    \n    Returns:\n    An integer which is the number of sublists in 'lst' that contain 'elem'.\n    \"\"\"\n    \n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(input_list, element):\n    count = 0\n    for sublist in input_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, ele):\n    # Variable to store the count\n    count = 0\n\n    # Iterate over each sublist\n    for sublist in lst:\n        # If the element is in the sublist, increment the count\n        if ele in sublist:\n            count += 1\n\n    # Return the final count\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, target_element):\n    count = 0\n    for sublist in main_list:\n        if target_element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elm):\n    count = 0\n    for sublist in lst:\n        if elm in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum([element in sublist for sublist in lst])", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, target):\n    count = 0\n    for sublist in list_of_lists:\n        if target in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(input_list, target):\n    count = 0\n    for sublist in input_list:\n        if target in sublist:\n            count += 1\n    return count\ninput_list = [[1, 3], [5, 7], [1, 11], [1, 15, 7]]\ntarget = 1", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, ele):\n    \"\"\"Counts the number of sublists that contain a specific element.\n    \n    Arguments:\n    lst -- A list of lists to be searched.\n    ele -- The element to be searched for in the list.\n\n    Returns:\n    count -- The number of sublists containing the specific element.\n\n    Tests:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]],1)\n    3\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if ele in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(input_list, element):\n    count = 0\n    for sublist in input_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    count = 0\n    for sublist in lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    count = 0\n    for sublist in lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.29752066115702, "dps_norm": 55.55555555555556, "pass@1": 99.0, "profiled": [{"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(lst):\n    gap = len(lst) // 2\n    while gap > 0:\n        for i in range(gap, len(lst)):\n            temp = lst[i]\n            j = i\n            while j >= gap and lst[j - gap] > temp:\n                lst[j] = lst[j - gap]\n                j -= gap\n            lst[j] = temp\n        gap //= 2\n    return lst", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    n = len(array)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap,n):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j-gap] >temp:\n                array[j] = array[j-gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(input_list):\n    gap = len(input_list) // 2\n    while gap > 0:\n        for i in range(gap, len(input_list)):\n            temp = input_list[i]\n            j = i\n            while j >= gap and input_list[j - gap] > temp:\n                input_list[j] = input_list[j - gap]\n                j = j-gap\n            input_list[j] = temp\n        gap = gap // 2\n    return input_list", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements a[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n\n        # Reduce the gap for the next iteration\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    # Start with a big gap, then reduce the gap\n    n = len(array)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    while gap > 0:\n        for i in range(gap, n):\n            temp = array[i]\n\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n\n            array[j] = temp\n\n        gap //= 2\n\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(input_array):\n    gap = len(input_array) // 2\n    while gap > 0:\n        for i in range(gap, len(input_array)):\n            temp = input_array[i]\n            j = i\n            while j >= gap and input_array[j - gap] > temp:\n                input_array[j] = input_array[j - gap]\n                j = j-gap\n            input_array[j] = temp\n        gap = gap // 2\n    return input_array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    This function sorts an array using shell sort.\n    \"\"\"\n    n = len(arr)\n    gap = n//2\n\n    # start with a big gap, then reduce the gap\n    while gap > 0:\n\n        # for every gap, do a gapped insertion sort\n        for i in range(gap,n):\n\n            temp = arr[i]\n\n            j = i\n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    # start with a big gap, then reduce the gap\n    while gap > 0:\n\n        # do a gapped insertion sort for this gap size.\n        # the first gap elements a[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, len(arr)):\n\n            # add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    gap = len(array) // 2\n    while gap > 0:\n        for i in range(gap, len(array)):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    n = len(array)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap,n):\n            temp = array[i]\n            j = i\n            while  j >= gap and array[j-gap] >temp:\n                array[j] = array[j-gap]\n                j = j-gap\n            array[j] = temp\n        gap = gap//2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    n = len(array)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j-gap] > temp:\n                array[j] = array[j-gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 71.06382978723404, "dps_norm": 68.0, "pass@1": 58.0, "profiled": [{"solution": "def check_greater(arr, num):\n    \"\"\"\n    Function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Check if the number is greater than all elements in the array.\n\n    :param array: List of integers\n    :param num: Integer\n    :return: Boolean\n    \"\"\"\n    return all(num > i for i in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(input_list, value):\n    \"\"\"\n    Function to check whether the entered number is greater than all elements of the given list.\n    \"\"\"\n    for item in input_list:\n        if item >= value:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(num_list, num):\n    \"\"\"\n    Check whether num is greater than every element in num_list.\n    \"\"\"\n    return all(num > x for x in num_list)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Function to check if a number is greater than elements of an array\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(numbers, num):\n    \"\"\"Check if num is greater than all elements in numbers.\"\"\"\n    return all(num > number for number in numbers)", "matching_cluster_idx": 2}, {"solution": "def check_greater(lst, num):\n    return all(x < num for x in lst)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, n):\n    \"\"\"\n    Function to check if entered number is greater than the elements in given array.\n    \"\"\"\n    for i in arr:\n        if i >= n:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    for element in array:\n        if number <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Check if the entered number is greater than the elements of the given array.\n\n    Parameters:\n    array (list): List of integers.\n    number (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n\n    Example:\n    >>> check_greater([1, 2, 3, 4, 5], 4)\n    False\n    \"\"\"\n    return all(number > element for element in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    \"\"\"Checks if the entered number is greater than any element in the given array.\"\"\"\n    return all(num > i for i in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(input_array, number):\n    \"\"\"\n    Checks if the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(number > element for element in input_array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Check if a number is greater than all the elements in an array.\n    \"\"\"\n    return all(number > elem for elem in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if num is greater than all elements in arr.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    This function checks whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(num > x for x in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Check whether num is greater than elements of the array.\n    \n    Parameters:\n    array (list): Array of integers.\n    num (int): Number to be checked.\n    \n    Returns:\n    bool: True if num is greater than all elements in array, False otherwise.\n    \"\"\"\n\n    for elem in array:\n        if num <= elem:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    return all(num > i for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, n):\n    \"\"\"\n    This function checks whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(n > x for x in arr)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": 86.1029411764706, "dps_norm": 63.0, "pass@1": 50.0, "profiled": [{"solution": "def remove_odd(input_string):\n    return ''.join([input_string[i] for i in range(len(input_string)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return \"\".join([s[i] for i in range(1, len(s), 2)])", "matching_cluster_idx": 2}, {"solution": "def remove_odd(input_string):\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    return \"\".join(char for index, char in enumerate(input_string) if index % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(input_string):\n    return ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 1])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(input_string):\n    return input_string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    return ''.join(string[i] for i in range(len(string)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    return ''.join([input_string[i] for i in range(1, len(input_string), 2)])", "matching_cluster_idx": 2}, {"solution": "def remove_odd(input_string):\n    return ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 1])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(input_str):\n    return input_str[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Write a function to remove odd characters in a string.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(word):\n    return word[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    return \"\".join(string[i] for i in range(len(string)) if i%2 == 1)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return ''.join([s[i] for i in range(1, len(s), 2)])", "matching_cluster_idx": 2}, {"solution": "def remove_odd(input_str):\n    return input_str[1::2]\ninput_str = \"I love programming\"", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 3.0, "profiled": []}, "Mbpp/446": {"dps": 96.45320197044335, "dps_norm": 64.0, "pass@1": 37.0, "profiled": [{"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Returns the count of elements in list that appear in tuple\n\n    Parameters:\n    input_tuple (tuple): Tuple of elements\n    input_list (list): List of elements to count\n\n    Returns:\n    int: Count of elements in list that appear in tuple\n    \"\"\"\n    # Initial count is 0\n    count = 0\n\n    # Iterate over each element in list\n    for element in input_list:\n        # Add the count of each element in tuple to the count\n        count += input_tuple.count(element)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, element_list):\n    return sum([input_tuple.count(el) for el in element_list])", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_, list_):\n    return sum([tuple_.count(x) for x in list_])\ntuple_ = ('a', 'a', 'c', 'b', 'd')\nlist_ = ['a', 'b']", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    return sum([tup.count(item) for item in lst])", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    A function to count the occurrence of all elements of list in a tuple.\n    \"\"\"\n    return sum([tup.count(x) for x in lst])", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tup (tuple): A tuple with elements to be checked.\n    lst (list): A list of elements to check for in the tuple.\n\n    Returns:\n    int: The total count of occurrences of all elements in the list.\n\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'])\n    3\n    \"\"\"\n    # Initialize the count to zero\n    count = 0\n    \n    # Loop through each element in the list\n    for elem in lst:\n        # Count the occurrences in the tuple\n        count += tup.count(elem)\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    return sum([input_tuple.count(i) for i in input_list])", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    This function counts the occurrences of elements from a list within a tuple.\n    \"\"\"\n    count = 0\n    for ele in lst:\n        count += tup.count(ele)\n    return count\ntup = ('a', 'a', 'c', 'b', 'd')\nlst = ['a', 'b']", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    return sum([tup.count(x) for x in lst])", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, element_list):\n    return sum([input_tuple.count(x) for x in element_list])", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, elements):\n    count_tuple = Counter(tup)\n    count_elements = sum(count_tuple[elem] for elem in elements)\n    return count_elements", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(t, lst):\n    # count occurrences of elements in list\n    return sum([t.count(i) for i in lst])", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t, l):\n    count = 0\n    for i in l:\n        count += t.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, check_list):\n    # convert input_tuple into a counter object\n    input_counter = Counter(input_tuple)\n\n    # return the sum of counts for each element in check_list\n    return sum(input_counter[item] for item in check_list)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    # Convert tuple to list\n    tup_list = list(tup)\n\n    # Initialize a counter\n    count = 0\n\n    # Loop over the elements in the list\n    for element in lst:\n        # Count the occurrence of each element in the list\n        count += tup_list.count(element)\n\n    # Return the final count\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    return sum([tpl.count(i) for i in lst])", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t, l):\n    return sum([t.count(i) for i in l])", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t,l):\n    \"\"\"Counts the occurrences of elements of l in t.\"\"\"\n    count = 0\n    for item in l:\n        count += t.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Returns the count of all elements of list_input in tuple_input.\n\n    :param tuple_input: The tuple where elements are to be counted.\n    :param list_input: The list containing the elements to be counted.\n    :returns: The total count of elements in list_input present in tuple_input.\n    \"\"\"\n    \n    return sum([tuple_input.count(i) for i in list_input])", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t,l):\n    \"\"\"\n    This function counts the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    t (tuple): Input tuple to be analyzed.\n    l (list): List of elements to be counted.\n\n    Returns:\n    int: The count of occurrences of the elements of list in the tuple.\n\n    Example:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'])\n    3\n    \"\"\"\n    return sum([t.count(i) for i in l])", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 95.0, "profiled": [{"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    This function takes a string and removes all the whitespace characters from it.\n\n    :param input_string: The string from which whitespaces are to be removed\n    :type input_string: str\n    :return: The input string without any whitespace characters\n    :rtype: str\n    \"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    return string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")\ninput_string = \" Google    Flutter \"", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    return string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    Parameters:\n    s (str): The string from which whitespaces will be removed\n    \n    Returns:\n    str: The string without whitespaces\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \"\"\"\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    return input_str.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Function to remove all whitespaces from the given string.\n    \"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Function to remove all whitespaces from the given string\n    \"\"\"\n    return s.replace(' ', '')", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(str_list):\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    reversed_list = []\n    for string in input_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [i[::-1] for i in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    This function accepts a list of strings as input and returns a new list \n    where each string is reversed.\n    \"\"\"\n    return [i[::-1] for i in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    This function takes a list of strings as input and returns a new list where every string has been reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(list_of_strings):\n    return [s[::-1] for s in list_of_strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    # Use list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses the order of characters in each string in the given list.\n    \"\"\"\n    # List comprehension to create new reversed list\n    reversed_list = [s[::-1] for s in strings]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    reversed_list = [s[::-1] for s in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [item[::-1] for item in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(s_list):\n    return [s[::-1] for s in s_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [i[::-1] for i in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    reversed_list = [x[::-1] for x in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [i[::-1] for i in input_list]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 89.61538461538461, "dps_norm": 96.0, "pass@1": 75.0, "profiled": [{"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublist):\n    # list comprehension to get the first element of each sublist\n    return [i[0] for i in sublist]", "matching_cluster_idx": 4}, {"solution": "def Extract(main_list):\n    return [sub_list[0] for sub_list in main_list]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in the provided list of lists.\n    :param lst: A list of lists.\n    :return: A list of the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(input_list):\n    return [sublist[0] for sublist in input_list]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    # Use a list comprehension to get the first element of each sublist.\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(nested_list):\n    return [sublist[0] for sublist in nested_list]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sub_lst[0] for sub_lst in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(list_of_sublists):\n    \"\"\"\n    Function to get the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"This function takes a list of lists as input and returns a list\n    consisting of the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"Returns the first element of each sublist.\"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(input_list):\n    \"\"\"\n    Function that gets the first element of each sublist\n    \"\"\"\n    return [sublist[0] for sublist in input_list]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sub_lst[0] for sub_lst in lst]", "matching_cluster_idx": 4}]}, "Mbpp/474": {"dps": 93.46341463414635, "dps_norm": 94.28571428571429, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(string, char_to_replace, char_to_insert):\n    return string.replace(char_to_replace, char_to_insert)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    This function replaces the occurrences of old_char with new_char in the input_string.\n    \"\"\"\n    return input_string.replace(old_char, new_char)\ninput_string = \"polygon\"\nold_char = 'y'\nnew_char = 'l'", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old, new):\n    \"\"\"\n    Replaces all occurrences of old character with new character in a string.\n\n    Parameters:\n    string (str): The string to be modified.\n    old (str): The character to be replaced.\n    new (str): The character to replace the old character with.\n\n    Returns:\n    str: The modified string.\n    \"\"\"\n    return string.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    # use built-in replace function\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    This function replaces a character in a string with another character.\n    Args:\n        s (str): The input string.\n        old (str): The character to replace.\n        new (str): The new character.\n    Returns:\n        str: The resulting string with replaced characters.\n    \"\"\"\n\n    # replace characters in the string\n    s = s.replace(old, new)\n\n    return s", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Function to replace characters in a string.\n\n    Parameters:\n    string (str): The input string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character that will replace old_char.\n\n    Returns:\n    str: The string with the replaced characters.\n    \"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, target, replacement):\n    return s.replace(target, replacement)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old, new):\n    \"\"\"\n    Replace old character by new character in a given string.\n    \"\"\"\n    new_string = ''\n\n    for character in string:\n        if character == old:\n            new_string += new\n        else:\n            new_string += character\n\n    return new_string", "matching_cluster_idx": 2}, {"solution": "def replace_char(input_string, old_char, new_char):\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, target_char, replacement_char):\n    \"\"\"\n    This function replaces a target character in the input string with a replacement character.\n    :param input_str: input string to process.\n    :param target_char: character to replace.\n    :param replacement_char: character to replace with.\n    :return: processed string.\n    \"\"\"\n    return input_str.replace(target_char, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(str, old_char, new_char):\n    \"\"\"Replace all occurrences of old_char with new_char in str\"\"\"\n    return str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(str, char_to_replace, char_to_add):\n    \"\"\"\n    Replaces all occurrences of char_to_replace in str with char_to_add\n    \"\"\"\n    result = \"\"\n    for char in str:\n        if char == char_to_replace:\n            result += char_to_add\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_char(string, char_to_replace, new_char):\n    return string.replace(char_to_replace, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, target, replacement):\n    return string.replace(target, replacement)", "matching_cluster_idx": 6}, {"solution": "def replace_char(str, old, new):\n    return str.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replaces all occurrences of character 'old' in a string 's' with 'new'.\n\n    Args:\n    s (str): The input string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n\n    Returns:\n    str: The string with all occurrences of 'old' replaced by 'new'.\n    \"\"\"\n    # Uses the replace() method to replace all occurrences of 'old' with 'new'\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string:str, old_char:str, new_char:str) -> str:\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string: str, char_to_replace: str, new_char: str) -> str:\n    \"\"\"\n    Function to replace characters in a string.\n    \"\"\"\n    return string.replace(char_to_replace, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replaces all occurrences of old character with new character in a string.\n    Args:\n        s (str): The input string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n    Returns:\n        str: The new string with replaced characters.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 93.05369127516778, "dps_norm": 95.83333333333333, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(array):\n    \"\"\"\n    This function finds the sum of the largest and smallest value in a given array.\n    \"\"\"\n    if len(array) == 0:\n        return 0\n    \n    return min(array) + max(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Check if array is not empty\n    if len(arr) > 0:\n        return max(arr) + min(arr)\n    else:\n        raise ValueError('Array is empty')", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) == 0:\n        return 0\n    else:\n        return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(lst):\n    return min(lst) + max(lst)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) == 0:\n        return None\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) == 0:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest value in a given array.\n    \"\"\"\n    # If the array is empty, return 0\n    if not arr:\n        return 0\n    \n    # Initialize the largest and smallest values\n    largest = smallest = arr[0]\n    \n    # Traverse the array to find the largest and smallest values\n    for num in arr:\n        if num > largest:\n            largest = num\n        elif num < smallest:\n            smallest = num\n            \n    # Return the sum of the largest and smallest values\n    return largest + smallest", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    if arr:\n        return min(arr) + max(arr)\n    else:\n        raise ValueError(\"The array is empty.\")", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    if len(array) == 0:\n        return 0\n    return min(array) + max(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(lst):\n    if not lst:\n        return 0\n    return min(lst) + max(lst)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) == 0:\n        return None\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(lst):\n    if not lst:\n        raise ValueError(\"List is empty\")\n    return max(lst) + min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "import random\ndef big_sum(nums):\n    return max(nums) + min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    \"\"\"Return the sum of the largest and smallest value in the array.\"\"\"\n    # check if the list is not empty\n    if not numbers:\n        return None\n    # return the sum of the largest and smallest elements\n    return max(numbers) + min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Check if the array is not empty\n    if len(arr) > 0:\n        return max(arr) + min(arr)\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    if len(array) == 0:\n        return 0\n\n    smallest = array[0]\n    largest = array[0]\n\n    for i in range(1, len(array)):\n        if array[i] < smallest:\n            smallest = array[i]\n        elif array[i] > largest:\n            largest = array[i]\n\n    return smallest + largest", "matching_cluster_idx": 2}, {"solution": "def big_sum(array):\n    if array:\n        return max(array) + min(array)\n    else:\n        return \"Array is empty\"", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 59.0, "profiled": [{"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Convert string to lowercase.\"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    This function converts a given string to lower case\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_str):\n    \"\"\"\n    Function to convert the given string to lower case.\n\n    Args:\n        input_str: the input string to be converted to lowercase\n\n    Returns:\n        the lowercased string\n    \"\"\"\n    return input_str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_str):\n    return input_str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n    :param s: String to be converted\n    :type s: str\n    :return: The string converted to lower case\n    :rtype: str\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    :param s: The string to be converted.\n    :return: The lower case string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 72.40437158469946, "dps_norm": 75.45454545454545, "pass@1": 68.0, "profiled": [{"solution": "def extract_values(s):\n    values = []\n    inside_quote = False\n    temp_val = ''\n    for char in s:\n        if char == '\"':\n            if inside_quote:\n                values.append(temp_val)\n                temp_val = ''\n            inside_quote = not inside_quote\n        elif inside_quote:\n            temp_val += char\n    return values", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_values(s):\n    pattern = re.compile(r'\"(.*?)\"')\n    return pattern.findall(s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values between quotation marks from a string\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regex to find matches between quotation marks\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    This function extracts values between quotation marks from a string.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)\ns = '\"Python\", \"PHP\", \"Java\"'", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Function to extract values between quotation marks from a string.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    pattern = re.compile(r'\"(.*?)\"')\n    matches = pattern.findall(input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    values = []\n    start = end = 0\n    for i, char in enumerate(input_string):\n        if char == '\"' and start == 0:\n            start = i + 1\n        elif char == '\"' and start != 0:\n            end = i\n            values.append(input_string[start:end])\n            start = end = 0\n    return values", "matching_cluster_idx": 3}, {"solution": "import re\ndef extract_values(string):\n    pattern = r'\"(.*?)\"'\n    values = re.findall(pattern, string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Function to extract values between quotation marks from a string\n    \"\"\"\n    # Regular expression pattern to match values between quotation marks\n    pattern = r'\"([^\"]*)\"'\n\n    # Find all matches\n    matches = re.findall(pattern, s)\n\n    # Return the matches\n    return matches", "matching_cluster_idx": 8}, {"solution": "def extract_values(string):\n    \"\"\"\n    A function to extract values between quotation marks from a string.\n    \"\"\"\n    result = []\n    word = ''\n    in_quotes = False\n\n    for char in string:\n        if char == '\"':\n            if in_quotes:\n                result.append(word)\n                word = ''\n            in_quotes = not in_quotes\n        elif in_quotes:\n            word += char\n\n    return result", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_values(input_str):\n    \"\"\"\n    This function extracts values between quotation marks from a string.\n    \"\"\"\n    pattern = re.compile(r'\"(.*?)\"')\n    return pattern.findall(input_str)", "matching_cluster_idx": 8}, {"solution": "def extract_values(string):\n    values = []\n    start = end = 0\n    in_quote = False\n    for i, char in enumerate(string):\n        if char == '\"' and not in_quote:\n            in_quote = True\n            start = i + 1\n        elif char == '\"' and in_quote:\n            in_quote = False\n            end = i\n            values.append(string[start:end])\n    return values", "matching_cluster_idx": 3}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 89.25925925925927, "dps_norm": 80.71428571428571, "pass@1": 73.0, "profiled": [{"solution": "def two_unique_nums(nums):\n    counts = {}\n    for num in nums:\n        if num not in counts:\n            counts[num] = 1\n        else:\n            counts[num] += 1\n\n    unique_nums = [num for num, count in counts.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    return [num for num in lst if lst.count(num) == 1]", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    count_dict = {}\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return [key for key, value in count_dict.items() if value == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    count_dict = {}\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    counts = {}\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    return [num for num, count in counts.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    counts = {}\n    result = []\n\n    for num in nums:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    for num in counts:\n        if counts[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_duplicate_numbers(nums):\n    counts = {}\n    for num in nums:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    return [num for num in counts if counts[num] == 1]\ndef two_unique_nums(nums):\n    return remove_duplicate_numbers(nums)", "matching_cluster_idx": 5}, {"solution": "def remove_duplicates(input_list):\n    # An empty dictionary to store the count of each number in the list\n    count_dict = {}\n\n    # For each number in the list\n    for num in input_list:\n        # If the number is not in the dictionary, add it\n        if num not in count_dict:\n            count_dict[num] = 1\n        # If the number is already in the dictionary, increment its count\n        else:\n            count_dict[num] += 1\n\n    # Filter out the numbers that have a count of more than 1\n    result = [num for num in count_dict if count_dict[num] == 1]\n\n    # Return the result\n    return result\ndef two_unique_nums(input_list):\n    return remove_duplicates(input_list)", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Function to remove duplicate numbers from a given list\n    \"\"\"\n    # Create an empty dictionary\n    num_dict = {}\n    # Iterate over the list\n    for num in nums:\n        # If number is in the dictionary, increment its count\n        if num in num_dict:\n            num_dict[num] += 1\n        # Otherwise, add it to the dictionary\n        else:\n            num_dict[num] = 1\n    # Initialize an empty list to store unique numbers\n    unique_nums = []\n    # Iterate over the dictionary\n    for num, count in num_dict.items():\n        # If count is 1, number is unique so add it to the list\n        if count == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(num_list):\n    counts = {}\n    for num in num_list:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    unique_nums = [key for key, value in counts.items() if value == 1]\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # dict to store frequency of numbers\n    num_freq = {}\n\n    # Count frequency of each number\n    for num in nums:\n        if num in num_freq:\n            num_freq[num] += 1\n        else:\n            num_freq[num] = 1\n\n    # Create a list of numbers that appear once in the original list\n    result = [num for num, freq in num_freq.items() if freq == 1]\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    num_count = {}\n    for num in nums:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    return [key for key, value in num_count.items() if value == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    num_counts = {}\n    for num in lst:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    unique_nums = []\n    for num, count in num_counts.items():\n        if count == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def remove_duplicates(num_list):\n    \"\"\"\n    Function to remove duplicate numbers from a given list\n    :param num_list: list of numbers\n    :return: list of unique numbers\n    \"\"\"\n    counts = {}\n    result = []\n\n    for num in num_list:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    for num, count in counts.items():\n        if count == 1:\n            result.append(num)\n\n    return result\ndef two_unique_nums(num_list):\n    \"\"\"\n    Function to remove duplicate numbers from a given list of numbers\n    :param num_list: list of numbers\n    :return: list of unique numbers\n    \"\"\"\n    return remove_duplicates(num_list)", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    count_dict = {}\n    result = []\n    for num in nums:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    for num in count_dict:\n        if count_dict[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    return [key for key, value in counts.items() if value == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    num_count = {}\n    for num in nums:\n        num_count[num] = num_count.get(num, 0) + 1\n    return [num for num, count in num_count.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(num_list):\n    \"\"\"Function to remove duplicate numbers from a given list of numbers.\"\"\"\n    return [num for num in num_list if num_list.count(num) == 1]", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    num_counts = {}\n\n    # Count occurrence of each number\n    for num in numbers:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n\n    # Return numbers with count 1\n    return [num for num, count in num_counts.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Remove duplicates from the list.\n    Return a list of numbers that appear only once.\n    \"\"\"\n    count = Counter(nums)\n    return [num for num, freq in count.items() if freq == 1]", "matching_cluster_idx": 6}]}, "Mbpp/578": {"dps": 66.09523809523809, "dps_norm": 65.45454545454545, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.extend([list1[i], list2[i], list3[i]])\n    return interleaved\nlist1 = [1,2,3,4,5,6,7]\nlist2 = [10,20,30,40,50,60,70]\nlist3 = [100,200,300,400,500,600,700]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        return \"Input lists are not of the same length.\"\n\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n\n    return result\nlist1 = [1,2,3,4,5,6,7]\nlist2 = [10,20,30,40,50,60,70]\nlist3 = [100,200,300,400,500,600,700]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    interleaved_list = []\n    for i in range(len(lst1)):\n        interleaved_list.append(lst1[i])\n        interleaved_list.append(lst2[i])\n        interleaved_list.append(lst3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for item1, item2, item3 in zip(list1, list2, list3):\n        result.append(item1)\n        result.append(item2)\n        result.append(item3)\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Make sure all lists have the same length\n    assert len(list1) == len(list2) == len(list3), \"All lists must have the same length\"\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list\nlist1 = [1,2,3,4,5,6,7]\nlist2 = [10,20,30,40,50,60,70]\nlist3 = [100,200,300,400,500,600,700]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Function to interleave 3 lists of the same length into a single flat list.\n    \"\"\"\n    # Check if all lists are of the same length\n    assert len(list1) == len(list2) == len(list3), \"All lists must be of same length\"\n    \n    # Interleave the lists\n    interleaved_list = [val for sublist in zip(list1, list2, list3) for val in sublist]\n    \n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(l1, l2, l3):\n    if len(l1) != len(l2) or len(l1) != len(l3) or len(l2) != len(l3):\n        raise ValueError(\"All lists must be of the same length\")\n    res = []\n    for a, b, c in zip(l1, l2, l3):\n        res.append(a)\n        res.append(b)\n        res.append(c)\n    return res", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(l1, l2, l3):\n    result = []\n    for i in range(len(l1)):\n        result.extend([l1[i], l2[i], l3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(l1, l2, l3):\n    if len(l1) != len(l2) or len(l1) != len(l3):\n        raise ValueError(\"All input lists must be of the same length.\")\n    result = []\n    for i in range(len(l1)):\n        result.append(l1[i])\n        result.append(l2[i])\n        result.append(l3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n\n    for a, b, c in zip(list1, list2, list3):\n        interleaved_list.extend([a, b, c])\n\n    return interleaved_list\nlist1 = [1,2,3,4,5,6,7]\nlist2 = [10,20,30,40,50,60,70]\nlist3 = [100,200,300,400,500,600,700]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(l1, l2, l3):\n    interleaved_list = []\n    for i in range(len(l1)):\n        interleaved_list.append(l1[i])\n        interleaved_list.append(l2[i])\n        interleaved_list.append(l3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Input lists must be of equal length\n    assert len(list1) == len(list2) == len(list3)\n\n    # Combine the three lists into one list of tuples\n    combined = zip(list1, list2, list3)\n\n    # Flatten the list of tuples using list comprehension\n    flattened = [num for sublist in combined for num in sublist]\n\n    return flattened\nlist1 = [1,2,3,4,5,6,7]\nlist2 = [10,20,30,40,50,60,70]\nlist3 = [100,200,300,400,500,600,700]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Function to interleave 3 lists of the same length into a single flat list\n    \"\"\"\n    # Make sure all the lists are of the same length\n    assert len(list1) == len(list2) == len(list3), \"All lists should be of the same length\"\n\n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check that all lists are of the same length\n    assert len(list1) == len(list2) == len(list3), \"Input lists are of different lengths\"\n\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n\n    return result\nlist1 = [1,2,3,4,5,6,7]\nlist2 = [10,20,30,40,50,60,70]\nlist3 = [100,200,300,400,500,600,700]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result\nlist1 = [1,2,3,4,5,6,7]\nlist2 = [10,20,30,40,50,60,70]\nlist3 = [100,200,300,400,500,600,700]\nresult = interleave_lists(list1, list2, list3)", "matching_cluster_idx": 6}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 81.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    This function splits the array at the nth element and moves the first part to the end.\n\n    :param arr: The list to split and rearrange\n    :param n: The index at which to split the list\n    :return: The rearranged list\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n < len(arr):\n        return arr[n:] + arr[:n]\n    else:\n        return arr", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # check the length of the array\n    if n > len(arr):\n        print(\"The provided index is bigger than the length of the list\")\n        return None\n    # split the list at the nth position and add the first part to the end\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    if n > len(input_list):\n        return \"Error: n is larger than the length of the list\"\n    return input_list[n:] + input_list[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # split the list at the nth element\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 51.689189189189186, "dps_norm": 86.25, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Function that converts a list to a tuple\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    This function converts a given list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted.\n\n    Returns:\n    tuple: The resulting tuple.\n    \"\"\"\n\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to be converted to a tuple.\n\n    Returns:\n    tuple: A tuple resulting from the conversion of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    This function converts a list to a tuple.\n    \n    :param lst: list\n    :returns: tuple\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"Convert a list to a tuple\"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"Converts a list to a tuple.\n\n    >>> assert list_tuple([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(list):\n    # Convert the list to a tuple\n    return tuple(list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    :param lst: list to be converted\n    :return: tuple of the list elements\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 89.35779816513761, "dps_norm": 95.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(lst):\n    \"\"\"\n    Find the difference between largest and smallest value in a given list.\n    \"\"\"\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(input_list):\n    \"\"\"\n    Function to find the difference between largest and smallest value in a given list.\n    \"\"\"\n    try:\n        # validate that all elements in the list are numbers\n        for item in input_list:\n            if not isinstance(item, (int, float)):\n                raise TypeError\n\n        # find the min and max values in the list and return their difference\n        return max(input_list) - min(input_list)\n\n    except TypeError:\n        print(\"Error: All elements in the input list should be numbers\")\n        return None", "matching_cluster_idx": 1}, {"solution": "def big_diff(numbers):\n    if len(numbers) <= 0:\n        return None\n    else:\n        return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    # Return the difference between max and min element in the list\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(input_list):\n    return max(input_list) - min(input_list)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Function to find the difference between the largest and smallest value in a given list.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if len(nums) == 0:\n        return None\n    max_value = nums[0]\n    min_value = nums[0]\n    for num in nums:\n        if num > max_value:\n            max_value = num\n        if num < min_value:\n            min_value = num\n    return max_value - min_value", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    \"\"\"Function to find the difference between largest and smallest value in a given list.\"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n    \"\"\"\n    if len(lst) == 0:\n        return 0\n    else:\n        return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(num_list):\n    \"\"\"\n    This function finds the difference between the largest and smallest value in a given list.\n    \"\"\"\n    return max(num_list) - min(num_list)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:  # check if list is empty\n        return 0\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    This function returns the difference between the largest and smallest values in a list.\n    \"\"\"\n    # Find the smallest and largest numbers in the list\n    min_val = min(lst)\n    max_val = max(lst)\n    # Return the difference\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(input_list):\n    \"\"\"\n    This function calculates the difference between the largest and smallest\n    number in a given list. If the list is empty, it returns 0.\n    \"\"\"\n    if len(input_list) == 0:\n        return 0\n    return max(input_list) - min(input_list)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:  # If the list is empty, returns 0\n        return 0\n    \n    min_val = lst[0]  # Initialize min_val with the first value of the list\n    max_val = lst[0]  # Initialize max_val with the first value of the list\n    \n    for num in lst:\n        if num < min_val:\n            min_val = num  # Update min_val if a smaller number is found\n        elif num > max_val:\n            max_val = num  # Update max_val if a larger number is found\n    \n    return max_val - min_val  # Return the difference between max and min values", "matching_cluster_idx": 4}, {"solution": "def big_diff(num_list):\n    return max(num_list) - min(num_list)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Function to find the difference between the largest and smallest values in a list.\n    \"\"\"\n    if len(lst) == 0:\n        return 0\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(input_list):\n    if not input_list:\n        return None\n    else:\n        return max(input_list) - min(input_list)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Find the difference between the largest and smallest value in a list\n    :param lst: list of numbers\n    :return: difference between the largest and smallest value\n    \"\"\"\n    if len(lst) == 0:\n        raise ValueError(\"The list cannot be empty\")\n\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 80.2962962962963, "dps_norm": 57.77777777777778, "pass@1": 18.0, "profiled": [{"solution": "import math\ndef sum_Of_product(n):\n    result = 0\n    for i in range(n):\n        result += math.comb(n, i) * math.comb(n, i+1)\n    return result", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    return sum(comb(n, i) * comb(n, i+1) for i in range(n))", "matching_cluster_idx": 5}, {"solution": "def binomial_coefficient(n, k):\n    result = 1\n    if k > n - k: \n        k = n - k\n    for i in range(k):\n        result *= (n - i)\n        result //= (i + 1)\n    return result\ndef sum_Of_product(n):\n    result = 0\n    for k in range(n):\n        result += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return result", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n):\n    sum = 0\n    for i in range(n):\n        sum += math.comb(n, i) * math.comb(n, i+1)\n    return sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total = 0\n    for i in range(n):\n        total += comb(n, i) * comb(n, i+1)\n    return total", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    result = 0\n    for i in range(n):\n        result += comb(n, i) * comb(n, i+1)\n    return result", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    return sum(comb(n,i)*comb(n,i+1) for i in range(n))", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    sum_product = 0\n    for i in range(n+1):\n        product = math.comb(n, i) * math.comb(n, i+1)\n        sum_product += product\n    return sum_product", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    return sum(comb(n, i) * comb(n, i+1) for i in range(n))", "matching_cluster_idx": 5}, {"solution": "def binomial_coefficient(n, k):\n    res = 1\n    if (k > n - k):\n        k = n - k\n    for i in range(0 , k):\n        res = res * (n - i)\n        res = res // (i + 1)\n    return res\ndef sum_Of_product(n):\n    result = 0\n    for i in range(n):\n        result += binomial_coefficient(n, i) * binomial_coefficient(n, i + 1)\n    return result", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n):\n    sum = 0\n    for i in range(n):\n        sum += math.comb(n, i) * math.comb(n, i+1)\n    return sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    This function returns the sum of the product of consecutive binomial co-efficients for the given number.\n    \"\"\"\n    sum_of_product = 0\n    for i in range(n):\n        sum_of_product += comb(n, i) * comb(n, i+1)\n    return sum_of_product", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    result = 0\n    for i in range(n):\n        result += comb(n, i) * comb(n, i+1)\n    return result", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    result = 0\n    for i in range(n):\n        result += math.comb(n, i) * math.comb(n, i + 1)\n    return result", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    result = 0\n    for i in range(n):\n        result += binomial(n, i) * binomial(n, i+1)\n    return result\ndef binomial(n, k):\n    if k > n:\n        return 0\n    if k > n // 2:\n        k = n - k\n    b = 1\n    for x, y in enumerate(range(n, n-k, -1)):\n        b = (b * y) // (x + 1)\n    return b", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n):\n    sum = 0\n    for i in range(n):\n        sum += math.comb(n, i) * math.comb(n, i+1)\n    return sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial co-efficients\"\"\"\n    return sum(comb(n, i)*comb(n, i-1) for i in range(1, n+1))", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    result = 0\n    for i in range(n):\n        result += binomial(n, i) * binomial(n, i+1)\n    return result\ndef binomial(n, k):\n    if k > n:\n        return 0\n    if k > n // 2:\n        k = n - k\n    b = 1\n    for x, y in enumerate(range(n, n - k, -1)):\n        b = (b * y) // (x + 1)\n    return b", "matching_cluster_idx": 4}]}, "Mbpp/597": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 44.0, "profiled": [{"solution": "def find_kth(array1, array2, k):\n    array = sorted(array1 + array2)\n    if k <= len(array):\n        return array[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(array1, array2, k):\n    # merge two sorted arrays into one sorted array\n    array = sorted(array1 + array2)\n\n    # check if k is within the array bounds\n    if k > len(array):\n        return \"Index out of bounds\"\n\n    return array[k - 1]  # return kth element from merged and sorted array", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged_arr = sorted(arr1 + arr2)\n    \n    return merged_arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    arr = sorted(arr1 + arr2)\n    return arr[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Concatenate the two arrays\n    arr = arr1 + arr2\n\n    # Sort the concatenated array\n    arr.sort()\n\n    # Subtract 1 from k because array index starts at 0\n    return arr[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    if k <= len(merged):\n        return merged[k-1]\n    else:\n        return \"k is out of range\"", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # The two arrays are assumed to be sorted, so we can simply concatenate and\n    # sort them. However, a more efficient solution would use a merge-like approach\n    # to find the k-th element in a single pass.\n    result = sorted(arr1 + arr2)\n    # If the k-th element exists, return it, otherwise return None.\n    return result[k-1] if k <= len(result) else None", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the arrays\n    merged_arr = arr1 + arr2\n    # Sort the merged array\n    merged_arr.sort()\n    # Return the kth element\n    return merged_arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(array1, array2, k):\n    merged_array = sorted(array1 + array2)\n    return merged_array[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(array1, array2, k):\n    merged_array = array1 + array2\n    merged_array.sort()\n    return merged_array[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Concatenate two arrays and sort them\n    sorted_array = sorted(arr1 + arr2)\n    \n    # Check if kth element exist\n    if k <= len(sorted_array):\n        return sorted_array[k - 1]\n    else:\n        return None", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\" Find kth element from the given two sorted arrays. \"\"\"\n    merged = sorted(arr1 + arr2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # concatenate the two sorted arrays\n    arr = sorted(arr1 + arr2)\n    # return the kth element, considering the 1-based indexing\n    return arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"Function to find kth element from the given two sorted arrays.\"\"\"\n    merged = sorted(arr1 + arr2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    if k > len(merged):\n        return \"Index out of bounds!\"\n    else:\n        return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge two arrays into one\n    sorted_arr = sorted(arr1 + arr2)\n\n    # Return kth element\n    return sorted_arr[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(array1, array2, k):\n    \"\"\"\n    Function to find kth element from the given two sorted arrays.\n    \"\"\"\n    merged = sorted(array1 + array2)\n    if k <= len(merged):\n        return merged[k-1]\n    else:\n        return None", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "matching_cluster_idx": 3}]}, "Mbpp/604": {"dps": 90.45454545454545, "dps_norm": 98.0, "pass@1": 53.0, "profiled": [{"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str):\n    words = input_str.split()\n    reversed_str = \" \".join(reversed(words))\n    return reversed_str", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    # Split the string into a list of words\n    words = sentence.split()\n\n    # Reverse the list of words\n    words_reversed = words[::-1]\n\n    # Join the reversed words back into a string with spaces\n    sentence_reversed = \" \".join(words_reversed)\n\n    return sentence_reversed", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    words = input_string.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Function to reverse words separated by spaces in a given string.\n    \"\"\"\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    words = string.split()\n    reversed_string = ' '.join(reversed(words))\n    return reversed_string", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # split the string into a list of words\n    words = s.split()\n    # reverse the list of words\n    words = words[::-1]\n    # join the words back into a string with spaces\n    reversed_s = \" \".join(words)\n    return reversed_s", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Write a function to reverse words seperated by spaces in a given string.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    words = input_string.split()\n    words = words[::-1]\n    reversed_string = ' '.join(words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()  # Split string into list of words\n    words = words[::-1]  # Reverse the list of words\n    return ' '.join(words)  # Join words back into a single string with spaces in between", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 77.17391304347827, "dps_norm": 78.57142857142857, "pass@1": 38.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    if k > len(lst) or k < 1:\n        raise ValueError(\"k should be between 1 and the size of the list\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    if k < 1 or k > len(input_list):\n        raise ValueError(\"k is out of bounds\")\n    input_list.pop(k-1)\n    return input_list", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(input_list, k):\n    # Check if the k is valid index for the list\n    if k > len(input_list) or k < 1:\n        return input_list\n    \n    # Create a new list where the k'th element is removed\n    result_list = input_list[:k-1] + input_list[k:]\n    return result_list", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"Remove k'th element from the list and return new list.\"\"\"\n    if k < 1 or k > len(lst):\n        raise ValueError(\"k is out of range\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    if k < 1 or k > len(input_list):\n        return input_list\n\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    if k < 1 or k > len(input_list):\n        raise IndexError('k should be between 1 and length of input list.')\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    if k < 1 or k > len(input_list):\n        raise ValueError('Index k is out of range of the input list')\n    \n    input_list.pop(k - 1)\n    return input_list", "matching_cluster_idx": 5}, {"solution": "def remove_kth_element(input_list, k):\n    if k <= len(input_list):\n        input_list.pop(k-1)\n    return input_list", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    This function removes k'th element from the list and returns the list.\n    \"\"\"\n    # list comprehension approach to avoid mutating list during iteration\n    return [lst[i] for i in range(len(lst)) if i != k-1]", "matching_cluster_idx": 1}, {"solution": "def remove_kth_element(input_list, k):\n    if k > len(input_list) or k < 1:  # k should be a valid index\n        return \"Invalid index\"\n    else:\n        return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k > len(lst):\n        return lst\n    else:\n        lst.pop(k-1)  # pop is 0-indexed\n        return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the given list.\n\n    Parameters:\n    lst (list): The list from which to remove an element\n    k (int): The index of the element to remove (1-based index)\n\n    Returns:\n    list: A new list with the k'th element removed\n    \"\"\"\n    # Check if the index is in range (1-based)\n    if k < 1 or k > len(lst):\n        raise IndexError(\"The provided index is out of range\")\n\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    if k < 1 or k > len(input_list):\n        return input_list\n    del input_list[k-1]\n    return input_list", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(input_list, k):\n    del input_list[k-1]\n    return input_list", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(input_list, k):\n    if k < 1 or k > len(input_list):\n        return input_list\n    del input_list[k-1]\n    return input_list", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(my_list, k):\n    if k <= len(my_list) and k > 0:\n        del my_list[k - 1]\n    return my_list", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(input_list, k):\n    if k < 1 or k > len(input_list):\n        raise IndexError(\"Index out of range\")\n    \n    del input_list[k-1]\n    return input_list\ninput_list = [1,1,2,3,4,4,5,1]\nk = 3", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(input_list, k):\n    # Checking if the provided list is not empty and if k is a valid index of the list\n    if input_list and 0 < k <= len(input_list):\n        # Removing the k'th element\n        del input_list[k-1]\n        return input_list\n    else:\n        return \"Invalid input\"", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(input_list, k):\n    if k > len(input_list) or k < 1:\n        raise ValueError(\"k should be between 1 and length of the list.\")\n    del input_list[k-1]\n    return input_list", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(input_list, k):\n    if k > len(input_list) or k <= 0:\n        raise ValueError(\"The value of k is out of range. It should be in range of 1 to len(list)\")\n\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 32.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Function to find the max of the n'th column in a matrix\n    :param matrix: A matrix represented as a list of lists\n    :param n: The column number\n    :return: The max of the n'th column\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"Return max of the n'th column\"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function returns the max of the n'th column in the matrix.\n    \"\"\"\n    return max(column[n] for column in matrix)\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]\nn = 2", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"Returns the max of the n'th column of a matrix represented as a list of lists.\"\"\"\n    column = [row[n] for row in matrix]\n    return max(column)\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]\nn = 2", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    A function that given a matrix represented as a list of lists returns \n    the max of the n'th column.\n    \"\"\"\n    column = [row[n] for row in matrix]\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Function which given a matrix represented as a list of lists returns the max of the n'th column.\n    \"\"\"\n    return max(column[n] for column in matrix)\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]\nn = 2", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the max of the n'th column from the given matrix.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists and returns the max of the n'th column.\n    \"\"\"\n    # Check if the matrix is not empty and the requested column exists.\n    if len(matrix) == 0 or len(matrix[0]) <= n:\n        raise ValueError(\"Matrix does not have that many columns.\")\n    \n    # Get the n'th column values and return its maximum.\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function takes a matrix represented as a list of lists and an integer n and returns the max value\n    of the n'th column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the max of the n'th column in the given matrix.\n\n    Parameters:\n    matrix (list): A 2D list representing the matrix.\n    n (int): The column number for which the max is to be found. The count starts from 0.\n\n    Returns:\n    int: The maximum value in the n'th column of the matrix.\n\n    Examples:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    nth_col = [row[n] for row in matrix]\n    return max(nth_col)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # get nth column\n    nth_column = [row[n] for row in matrix]\n\n    # return max of nth column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    column = [row[n] for row in matrix]\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Function to get the max of the n'th column of a given matrix.\n\n    :param matrix: list of lists representing the matrix.\n    :param n: column index (0-based).\n    :return: max of the n'th column.\n    \"\"\"\n    column = [row[n] for row in matrix]\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    column = [row[n] for row in matrix]\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"Return max of nth column in the matrix.\"\"\"\n    return max(row[n] for row in matrix)\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 76.87499999999999, "dps_norm": 75.625, "pass@1": 70.0, "profiled": [{"solution": "def replace_spaces(s):\n    new_s = \"\"\n    for i in s:\n        if i == \" \":\n            new_s += \"_\"\n        elif i == \"_\":\n            new_s += \" \"\n        else:\n            new_s += i\n    return new_s", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Function to replace whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    return input_string.replace(' ', '_') if ' ' in input_string else input_string.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscore and vice versa in a given string.\n    \"\"\"\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    result_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            result_string += \"_\"\n        elif char == \"_\":\n            result_string += \" \"\n        else:\n            result_string += char\n    return result_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces whitespaces with underscore and vice versa in a given string.\n    \"\"\"\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_str):\n    \"\"\"Replaces whitespaces with an underscore and vice versa in a given string.\"\"\"\n    return input_str.translate(str.maketrans(\" _\", \"_ \"))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    return input_string.replace(' ', '_') if ' ' in input_string else input_string.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s: str) -> str:\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    return s.replace(\" \", \"_\") if \" \" in s else s.replace(\"_\", \" \")", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    return s.replace(\" \", \"_\") if \" \" in s else s.replace(\"_\", \" \")", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s: str) -> str:\n    # Creating an empty string to hold our result\n    res = ''\n    # Iterating over the characters in the string\n    for char in s:\n        # If the character is a whitespace, replace with an underscore\n        if char == ' ':\n            res += '_'\n        # If the character is an underscore, replace with a whitespace\n        elif char == '_':\n            res += ' '\n        # If the character is not a whitespace or underscore, just add it to the result\n        else:\n            res += char\n    return res", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"Replaces spaces with underscores or underscores with spaces in a string.\"\"\"\n    result = []\n    for ch in s:\n        if ch == ' ':\n            result.append('_')\n        elif ch == '_':\n            result.append(' ')\n        else:\n            result.append(ch)\n    return ''.join(result)\ns = 'Jumanji The Jungle'", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Function to replace whitespaces with underscores and vice versa in a string.\n    \"\"\"\n    # Replace spaces with underscores and vice versa\n    output_string = ''\n    for char in input_string:\n        if char == ' ':\n            output_string += '_'\n        elif char == '_':\n            output_string += ' '\n        else:\n            output_string += char\n    \n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(string: str):\n    return string.replace(' ', '_') if ' ' in string else string.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_str):\n    new_str = \"\"\n    for char in input_str:\n        if char == \" \":\n            new_str += \"_\"\n        elif char == \"_\":\n            new_str += \" \"\n        else:\n            new_str += char\n    return new_str", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Parameters:\n    s (str): Input string.\n    \n    Returns:\n    str: Modified string.\n    \"\"\"\n    if ' ' in s:\n        return s.replace(' ', '_')\n    else:\n        return s.replace('_', ' ')", "matching_cluster_idx": 7}]}, "Mbpp/632": {"dps": 75.60975609756098, "dps_norm": 85.71428571428571, "pass@1": 84.0, "profiled": [{"solution": "def move_zero(num_list):\n    return sorted(num_list, key = lambda x: x==0)", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    zeros = num_list.count(0)\n    num_list = [num for num in num_list if num != 0]\n    num_list += [0] * zeros\n    return num_list", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    for i in arr:\n        if i == 0:\n            arr.remove(i)\n            arr.append(i)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def move_zero(arr):\n    n = arr.count(0)\n    arr = [i for i in arr if i != 0]\n    arr.extend([0]*n)\n    return arr", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \"\"\"\n    for i in nums:\n        if i == 0:\n            nums.remove(i)\n            nums.append(i)\n    return nums", "matching_cluster_idx": 2}, {"solution": "def move_zero(lst):\n    \"\"\"Function to move all zeroes to the end of the given list.\"\"\"\n    new_lst = [num for num in lst if num != 0]\n    zero_count = lst.count(0)\n    new_lst.extend([0]*zero_count)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes in the list to the end.\n    \"\"\"\n    non_zeroes = [num for num in nums if num != 0]\n    zeroes = [num for num in nums if num == 0]\n    return non_zeroes + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Function to move all zeroes to the end of the given list\n    :param nums: input list\n    :return: list after moving zeroes to end\n    \"\"\"\n    for i in nums:\n        if i == 0:\n            nums.remove(i)\n            nums.append(i)\n    return nums", "matching_cluster_idx": 2}, {"solution": "def move_zero(nums):\n    count = nums.count(0) # count the zeroes\n    nums = [num for num in nums if num != 0] # create a new list without zeroes\n    nums += [0]*count # append the zeroes to the end of the list\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    for i in nums:\n        if i == 0:\n            nums.remove(0)\n            nums.append(0)\n    return nums", "matching_cluster_idx": 2}, {"solution": "def move_zero(nums):\n    zero_count = nums.count(0)\n    nums = list(filter(lambda a: a != 0, nums))\n    nums.extend([0]*zero_count)\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    for i in nums:\n        if i == 0:\n            nums.remove(i)\n            nums.append(i)\n    return nums", "matching_cluster_idx": 2}, {"solution": "def move_zero(nums):\n    count = nums.count(0)\n    nums = [num for num in nums if num != 0]\n    nums.extend([0]*count)\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    non_zero = [i for i in input_list if i != 0]\n    zero_count = input_list.count(0)\n    return non_zero + [0]*zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # create two empty lists to hold non-zero and zero elements respectively\n    non_zero = []\n    zero = []\n    # loop through the input list\n    for num in arr:\n        # if the number is not zero, append it to the non_zero list, else append it to zero list\n        if num != 0:\n            non_zero.append(num)\n        else:\n            zero.append(num)\n    # concatenate the non_zero and zero lists and return the result\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    count_zero = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[i], nums[count_zero] = nums[count_zero], nums[i]\n            count_zero += 1\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    non_zero_lst = [x for x in lst if x != 0]\n    zero_lst = [x for x in lst if x == 0]\n    return non_zero_lst + zero_lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    n = len(arr)\n    count = 0\n\n    for i in range(n):\n        if arr[i] != 0:\n\n            # here count is incremented\n            arr[count] = arr[i]\n            count+=1\n\n    while count < n:\n        arr[count] = 0\n        count += 1\n    \n    return arr\narr = [1,0,2,0,3,4]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    zero_count = lst.count(0)\n    lst = [i for i in lst if i != 0]\n    lst.extend([0]*zero_count)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    return [num for num in nums if num] + [0]*nums.count(0)", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 94.3089430894309, "dps_norm": 50.0, "pass@1": 29.0, "profiled": [{"solution": "def pair_xor_Sum(lst, n):\n    res = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            res += lst[i] ^ lst[j]\n    return res", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(num_list, n):\n    \"\"\"\n    Function to find the sum of xor of all pairs of numbers in the given list.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += num_list[i] ^ num_list[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    sum_val = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            sum_val += arr[i] ^ arr[j]\n    return sum_val", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(num_list, n):\n    xor_sum = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            xor_sum += num_list[i] ^ num_list[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    xor_sum = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            xor_sum += lst[i] ^ lst[j]\n    return xor_sum\nlst = [5, 9, 7, 6]\nn = len(lst)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, length):\n    result = 0\n    for i in range(0, length):\n        for j in range(i + 1, length):\n            result += nums[i] ^ nums[j]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr,n):\n    sum = 0\n    for i in range(0,n):\n        for j in range(i+1,n):\n            sum += arr[i] ^ arr[j]\n    return sum\narr = [5,9,7,6]\nn = 4", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, length):\n    xor_sum = 0\n    for i in range(0,length):\n        for j in range(i+1, length):\n            xor_sum += (lst[i] ^ lst[j])\n\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Function to find the sum of xor of all pairs of numbers in the given list.\n    \"\"\"\n    sum_xor = 0\n\n    for i in range(0, n):\n        for j in range(i+1, n):\n            sum_xor += numbers[i] ^ numbers[j]\n\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    xor_sum = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            xor_sum += lst[i] ^ lst[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    result = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            result += nums[i] ^ nums[j]\n\n    return result\nnums = [5,9,7,6]\nn = 4", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            total += arr[i] ^ arr[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    sum = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            sum += lst[i] ^ lst[j]\n    return sum\nlst = [5,9,7,6]\nn = 4", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    \"\"\"\n    This function takes in a list of numbers and their count as input, \n    returns the sum of xor of all pairs of numbers in the given list\n    \"\"\"\n\n    xor_sum = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            xor_sum += lst[i] ^ lst[j]\n\n    return xor_sum\nlst = [5, 9, 7, 6]\nn = len(lst)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    sum_xor = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            sum_xor += numbers[i] ^ numbers[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    sum_xor = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            sum_xor += nums[i] ^ nums[j]\n    return sum_xor\nnums = [5,9,7,6]\nn = len(nums)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            total += arr[i] ^ arr[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    sum = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            sum += lst[i] ^ lst[j]\n\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    xor_sum = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            xor_sum += lst[i] ^ lst[j]\n    return xor_sum", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 82.57978723404254, "dps_norm": 84.66666666666666, "pass@1": 99.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    # Check if the position is valid\n    if k > len(arr) or k < 0:\n        raise ValueError(\"Invalid position\")\n        \n    # Reverse the array upto the given position\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    # Split array into 2 parts at position k\n    first_part = array[:k]\n    second_part = array[k:]\n    \n    # Reverse the first part\n    first_part = first_part[::-1]\n    \n    # Join both parts\n    reversed_array = first_part + second_part\n    \n    return reversed_array", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Function to reverse an array upto a given position.\n    \"\"\"\n    # Check the validity of the inputs\n    if not isinstance(arr, list) or not isinstance(k, int) or k < 0 or k > len(arr):\n        raise ValueError(\"Invalid inputs. Please provide a valid list and an integer k.\")\n\n    # Reverse the array upto k\n    arr[:k] = arr[k-1::-1]\n\n    return arr", "matching_cluster_idx": 14}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    A python function to reverse an array upto a given position.\n    \"\"\"\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the list upto k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Check if the position is within the valid range of the array\n    if k > len(arr) or k < 0:\n        return \"Invalid position, please enter a valid position\"\n\n    # Reverse the elements upto the given position\n    arr[:k] = arr[k-1::-1]\n    \n    return arr", "matching_cluster_idx": 14}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Function to reverse an array upto a given position.\n    \"\"\"\n    # slicing the array upto position k and reverse it, and concat it with the rest of the array\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse first k elements of array\n    arr[:k] = arr[k-1::-1]\n    return arr", "matching_cluster_idx": 14}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    This function reverses an array upto a given position.\n    \"\"\"\n    # Make sure that the given position is valid\n    assert k > 0 and k <= len(arr), 'Position should be within array length'\n\n    # Reverse the array upto the given position\n    arr[:k] = arr[:k][::-1]\n\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[k-1::-1]\n    return arr", "matching_cluster_idx": 14}, {"solution": "def reverse_Array_Upto_K(array, k):\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    This function reverses the first k elements in the given array and returns the modified array.\n    \"\"\"\n    # Check if k is less than or equal to the size of the array\n    if k <= len(arr):\n        # Reverse first k elements in-place\n        for i in range(k//2):\n            arr[i], arr[k-i-1] = arr[k-i-1], arr[i]\n    return arr\narr = [1, 2, 3, 4, 5, 6]\nk = 4", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = reversed(arr[:k])\n    return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[k-1::-1]\n    return arr", "matching_cluster_idx": 14}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Function to reverse an array upto a given position.\n    \"\"\"\n    # array slicing method\n    arr[:k] = arr[k-1::-1]\n    return arr", "matching_cluster_idx": 14}]}, "Mbpp/720": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    This function takes a tuple and a dictionary as input and returns a new tuple that concatenates the tuple and the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"\n    This function adds a dictionary to the end of a tuple.\n    \"\"\"\n    tup += (dic,)\n    return tup", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, dict_to_add):\n    return input_tuple + (dict_to_add,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict):\n    \"\"\"\n    Adds a dictionary to a tuple.\n\n    :param tup: original tuple\n    :param dict: dictionary to add\n    :return: resulting tuple\n    \"\"\"\n    return tup + (dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, d):\n    \"\"\"\n    This function takes a tuple and a dictionary as arguments and returns a new tuple\n    with the elements from the dictionary appended to the original tuple.\n    \"\"\"\n    return tup + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dict):\n    \"\"\"\n    Function to add a dictionary to a tuple\n    \"\"\"\n    return tpl + (dict, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict):\n    return tup + (dict,)\ntup = (4, 5, 6)\ndict = {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3}", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict):\n    return tup + (dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict):\n    \"\"\"\n    Adds dictionary to tuple and returns a new tuple.\n    \"\"\"\n    return tup + (dict, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"\n    This function adds a dictionary to a tuple and returns the resulting tuple.\n    \"\"\"\n    # Add dictionary to the tuple\n    tup += (dic, )\n    return tup", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(original_tuple, dictionary):\n    return original_tuple + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)\nt = (4, 5, 6)\nd = {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3}", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"\n    Function to add a dictionary to the tuple. The output is a tuple.\n    \"\"\"\n    return tup + (dic,)\ntup = (4, 5, 6)\ndic = {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3}", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    This function adds a dictionary to a tuple.\n    \"\"\"\n    return t + (d, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(original_tuple, dict_to_add):\n    \"\"\"\n    A function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return original_tuple + (dict_to_add,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Add a dictionary to a tuple\n    \"\"\"\n    return input_tuple + (input_dict, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(initial_tuple, dict_to_add):\n    \"\"\"\n    Function to add a dictionary to a tuple.\n    :param initial_tuple: The initial tuple.\n    :param dict_to_add: The dictionary to add.\n    :return: A new tuple that contains the dictionary.\n    \"\"\"\n    return initial_tuple + (dict_to_add,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Function to add a dictionary to the tuple\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 94.20765027322403, "dps_norm": 85.0, "pass@1": 92.0, "profiled": [{"solution": "import re\ndef extract_quotation(string):\n    return re.findall('\"([^\"]*)\"', string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    pattern = r'\"([^\"]*)\"'\n    return re.findall(pattern, string)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    pattern = '\\\"(.*?)\\\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    pattern = r'\"([^\"]*)\"'\n    return re.findall(pattern, text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(input_str):\n    return re.findall(r'\"([^\"]*)\"', input_str)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    A function to extract values between quotation marks \" \" of the given string.\n    \"\"\"\n    # Use regex to find all substrings enclosed by quotes\n    matches = re.findall(r'\"([^\"]*)\"', string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(input_string):\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(string):\n    return re.findall('\"([^\"]*)\"', string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Function to extract values between quotation marks \" \" of the given string.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    This function returns a list of values between quotation marks of a given string\n\n    Parameters:\n        s (str): The input string\n\n    Returns:\n        list: a list of strings extracted from between quotation marks\n    \"\"\"\n    # Using regular expression to find the strings enclosed in quotation marks\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    \n    # Return the list of matches\n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall('\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(input_string):\n    pattern = r'\"([^\"]*)\"'\n    return re.findall(pattern, input_string)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(input_string):\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(input_string):\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}]}, "Mbpp/732": {"dps": 68.17829457364341, "dps_norm": 80.5, "pass@1": 100.0, "profiled": [{"solution": "def replace_specialchar(s):\n    for char in [',', '.', ' ']:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Write a function to replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    to_replace = [\" \", \",\", \".\"]\n    for char in to_replace:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(input_string):\n    # Using regular expressions to replace all occurrences of spaces, commas, or dots\n    result = re.sub(r'[ ,.]', ':', input_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(s):\n    for char in [' ', ',', '.']:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(text):\n    # Replace all spaces, commas and dots with a colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(input_string):\n    \"\"\"\n    Function to replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    pattern = r\"[\\s.,]\"\n    replacement = \":\"\n    return re.sub(pattern, replacement, input_string)", "matching_cluster_idx": 2}, {"solution": "def replace_specialchar(s):\n    chars_to_replace = [' ', ',', '.']\n    for char in chars_to_replace:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(input_str):\n    # replace all spaces, commas and dots using regex\n    output_str = re.sub(r'[\\s,.]', ':', input_str)\n    return output_str", "matching_cluster_idx": 2}, {"solution": "def replace_specialchar(s):\n    for ch in [',', '.', ' ']:\n        if ch in s:\n            s = s.replace(ch, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    special_chars = [' ', ',', '.']\n    for char in special_chars:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    # Use the Python string translate method\n    return s.translate(str.maketrans(\" ,.\", \":::\"))", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(string: str) -> str:\n    return string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    for char in [',', '.', ' ']:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(string):\n    for ch in [',', '.', ' ']:\n        if ch in string:\n            string = string.replace(ch, ':')\n    return string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(string):\n    # Use the re.sub function from regular expressions module to replace all occurrences of the given special characters with a colon\n    result = re.sub('[ ,.]', ':', string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(input_string):\n    # Define the characters to be replaced\n    special_characters = [\" \", \",\", \".\"]\n    # Iterate over the list of special characters and replace them with a colon\n    for char in special_characters:\n        input_string = input_string.replace(char, \":\")\n    return input_string", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 83.63636363636364, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n\n    Parameters:\n    input_tuple (tuple): A tuple of integers.\n\n    Returns:\n    dict: A dictionary where every two adjacent elements in the tuple\n          form a key-value pair in the dictionary.\n    \"\"\"\n    output_dict = {}\n\n    for i in range(0, len(input_tuple) - 1, 2):\n        output_dict[input_tuple[i]] = input_tuple[i + 1]\n\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Function to convert a given tuple to a dictionary using adjacent elements\n    \"\"\"\n\n    # Asserting that the tuple contains even number of elements\n    assert len(input_tuple) % 2 == 0, \"Input tuple should contain even number of elements\"\n\n    # Initializing an empty dictionary\n    output_dict = {}\n\n    # Iterating over the input tuple, 2 elements at a time\n    for i in range(0, len(input_tuple), 2):\n        # Adding the pair of adjacent elements as a key-value pair to the dictionary\n        output_dict[input_tuple[i]] = input_tuple[i + 1]\n\n    # Returning the output dictionary\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tpl):\n    return {tpl[i]: tpl[i + 1] for i in range(0, len(tpl), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    This function converts a tuple into a dictionary. The even elements of the tuple are used as keys\n    and the next odd elements are used as corresponding values.\n    \"\"\"\n    # Create an empty dictionary\n    dictionary = {}\n    \n    # Go through the tuple by iterating over each 2 elements (since we are using adjacent pairs)\n    for i in range(0, len(tup), 2):\n        # Add the key-value pair to the dictionary\n        dictionary[tup[i]] = tup[i+1]\n    \n    # Return the created dictionary\n    return dictionary", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Length of input tuple must be even.\")\n        \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n\n    result = {}\n    for i in range(0, len(input_tuple), 2):\n        result[input_tuple[i]] = input_tuple[i+1]\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n\n    Parameters:\n    tup (tuple): Input tuple\n\n    Returns:\n    dict: Resulting dictionary\n\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    # create a new dictionary using dict comprehension\n    new_dict = {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}\n    return new_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even length.\")\n\n    result = {}\n    for i in range(0, len(input_tuple), 2):\n        result[input_tuple[i]] = input_tuple[i+1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple to a key-value dictionary using adjacent elements. \n    \"\"\"\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 61.33561643835616, "dps_norm": 73.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def check_none(input_tuple):\n    \"\"\"Check if the given tuple has any None value\"\"\"\n    return any(item is None for item in input_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Returns True if any None value is found in the input tuple, else False.\n    \"\"\"\n    return any(item is None for item in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if the given tuple has any None value or not.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"Function to check if the given tuple has any None value\"\"\"\n    return any(value is None for value in input_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(input_tuple):\n    if None in input_tuple:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    # Go through each element in the tuple\n    for x in t:\n        # If None found, return True\n        if x is None:\n            return True\n    # If None not found, return False\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(tpl):\n    \"\"\"\n    Checks if the given tuple has any None value or not.\n    \"\"\"\n    return None in tpl", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Function to check if the given tuple has any none value or not.\n    \"\"\"\n    # Using 'None' keyword in tuple because 'None' is also a keyword in python.\n    return any(x is None for x in t)", "matching_cluster_idx": 1}, {"solution": "def check_none(tpl):\n    \"\"\"\n    This function checks if the given tuple has any none value or not.\n    \"\"\"\n    return any(item is None for item in tpl)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Function to check if the given tuple has any None value or not\n    \"\"\"\n    return any(x is None for x in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if a tuple has any None value\n    \"\"\"\n    if None in tup:\n        return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Function to check if the given tuple has any none value or not.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return any(x is None for x in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Function to check if the given tuple has any none value or not\n    \"\"\"\n    return any(item is None for item in input_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(input_tuple):\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(my_tuple):\n    return None in my_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Function to check if the given tuple has any None value or not.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(num_tuple):\n    \"\"\"\n    Check if the given tuple has any none value or not.\n    \n    Arguments:\n    num_tuple -- The tuple to check.\n    \n    Returns:\n    True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in num_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"Check if the given tuple has any None value.\"\"\"\n    return None in tup", "matching_cluster_idx": 5}]}, "Mbpp/750": {"dps": 53.53741496598639, "dps_norm": 51.666666666666664, "pass@1": 99.0, "profiled": [{"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    This function adds a given tuple to the end of a given list.\n\n    Parameters:\n        input_list (list): The list to add a tuple to.\n        input_tuple (tuple): The tuple to add to the list.\n    \n    Returns:\n        list: The updated list.\n    \"\"\"\n\n    return input_list + list(input_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list_input, tuple_input):\n    return list_input + list(tuple_input)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(given_list, given_tuple):\n    return given_list + list(given_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Function to add a tuple to a list\n    \"\"\"\n    if not isinstance(input_list, list) or not isinstance(input_tuple, tuple):\n        raise TypeError(\"Invalid input type. The first argument should be a list, and the second argument should be a tuple.\")\n    return input_list + list(input_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(numbers_list, numbers_tuple):\n    \"\"\"\n    A function to add a tuple to a list\n    \"\"\"\n    if not isinstance(numbers_list, list):\n        raise TypeError(\"Expected a list as argument, got {} instead.\".format(type(numbers_list)))\n    if not isinstance(numbers_tuple, tuple):\n        raise TypeError(\"Expected a tuple as argument, got {} instead.\".format(type(numbers_tuple)))\n    return numbers_list + list(numbers_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(initial_list, tuple_to_add):\n    \"\"\"\n    A function to add the given tuple to the given list.\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    # For every item in the tuple, append to the list.\n    for item in tuple_to_add:\n        initial_list.append(item)\n    return initial_list", "matching_cluster_idx": 0}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    A function that concatenates a given tuple to a list.\n    \n    Parameters:\n    lst (list): The list to which the tuple will be concatenated.\n    tup (tuple): The tuple to be concatenated to the list.\n    \n    Returns:\n    list: The concatenated list with tuple's elements.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the given list.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"Add the given tuple to the given list.\"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the given tuple to the given list.\n    \n    Args:\n    lst (list): The list to append the tuple to.\n    tup (tuple): The tuple to append to the list.\n    \n    Returns:\n    list: The resulting list after appending the tuple to the given list.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list, tuple):\n    \"\"\"\n    This function adds the given tuple to the given list.\n    \"\"\"\n    # Using the extend() function to add each element of the tuple to the list.\n    list.extend(tuple)\n    # Return the modified list\n    return list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Function to add a tuple to a list.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_, tuple_):\n    \"\"\"This function takes a list and a tuple as input, appends elements from the tuple to the list, and returns the combined list.\"\"\"\n\n    # Check if the input is a list and a tuple\n    if not isinstance(list_, list) or not isinstance(tuple_, tuple):\n        raise ValueError('Input must be a list and a tuple')\n\n    # Add elements from the tuple to the list\n    for element in tuple_:\n        list_.append(element)\n\n    return list_", "matching_cluster_idx": 0}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 2}]}, "Mbpp/753": {"dps": 97.31543624161074, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def min_k(tuple_list, k):\n    tuple_list.sort(key = lambda x: x[1])\n    return tuple_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # Sort the list of tuples by second item in each tuple\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    # Return the first k tuples\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    records.sort(key = lambda x: x[1])\n    return records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    \"\"\"\n    Function to find minimum k records from tuple list.\n    \"\"\"\n    # Sort the list of tuples by second item in each tuple (in ascending order)\n    tuples.sort(key = lambda x: x[1])\n    # Return the first k tuples\n    return tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(data, k):\n    data.sort(key=lambda x: x[1])\n    return data[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    tuples.sort(key = lambda x: x[1])\n    return tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    \"\"\"\n    Find the k minimum records from a list of tuples\n    \"\"\"\n    # sort the list by second element in tuple\n    lst.sort(key=lambda x: x[1])\n    \n    # return the first k elements from sorted list\n    return lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(input_list, k):\n    # Sort the list based on second item of tuple\n    sorted_list = sorted(input_list, key=lambda x: x[1])\n    # Return the first k elements\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(input_list, k):\n    input_list.sort(key = lambda x: x[1])\n    return input_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    tuples_list.sort(key=lambda x: x[1])  # Sort the list of tuples by the second element of each tuple\n    return tuples_list[:k]  # Return the first k elements", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    lst.sort(key = lambda x: x[1])\n    return lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Function to find minimum k records from tuple list.\n    \"\"\"\n    tuples_list.sort(key=lambda x: x[1])\n    return tuples_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Function to find minimum k records from tuple list\n    \"\"\"\n    # Sort the list by second item in tuple (number) in ascending order\n    records.sort(key=lambda x: x[1])\n\n    # Return the first k records\n    return records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    records.sort(key=lambda x: x[1])\n    return records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(input_list, k):\n    # Sorting the list based on second item of tuple\n    input_list.sort(key = lambda x: x[1])\n    \n    # Returning first k records\n    return input_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Given a list of tuples, this function returns the minimum k records from the list.\n\n    Parameters:\n    tuple_list (list): A list of tuples where each tuple contains a name and a number.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list: A list of minimum k records from the tuple_list.\n    \"\"\"\n    # Sort the list in ascending order according to the second element in each tuple\n    tuple_list.sort(key = lambda x: x[1])\n\n    # Return the first k records from the sorted list\n    return tuple_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(data, k):\n    return sorted(data, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # Sort the tuple list based on the second element of each tuple (values)\n    tuples.sort(key=lambda x: x[1])\n\n    # return the first k elements from the sorted list\n    return tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    tuple_list.sort(key=lambda x: x[1])\n    return tuple_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    lst.sort(key=lambda x: x[1])\n    return lst[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 78.27586206896552, "dps_norm": 82.5, "pass@1": 62.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    common = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common.append(l1[i])\n    return common\nl1 = [1, 1, 3, 4, 5, 6, 7]\nl2 = [0, 1, 2, 3, 4, 5, 7]\nl3 = [0, 1, 2, 3, 4, 5, 7]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements\nl1 = [1, 1, 3, 4, 5, 6, 7]\nl2 = [0, 1, 2, 3, 4, 5, 7]\nl3 = [0, 1, 2, 3, 4, 5, 7]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common.append(l1[i])\n    return common", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements\nl1 = [1, 1, 3, 4, 5, 6, 7]\nl2 = [0, 1, 2, 3, 4, 5, 7]\nl3 = [0, 1, 2, 3, 4, 5, 7]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"Find common elements from three lists.\n    \n    Parameters:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n    \n    Returns:\n    list: A list of common elements.\n    \"\"\"\n    assert isinstance(l1, list), \"l1 must be a list\"\n    assert isinstance(l2, list), \"l2 must be a list\"\n    assert isinstance(l3, list), \"l3 must be a list\"\n    \n    common_list = []\n    \n    # Iterating over each list simultaneously and checking if the elements are same\n    for i, j, k in zip(l1, l2, l3):\n        if i == j == k:\n            common_list.append(i)\n            \n    return common_list", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(len(l1)):\n        if i < len(l2) and i < len(l3) and l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    result = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common.append(l1[i])\n    return common\nl1 = [1, 1, 3, 4, 5, 6, 7]\nl2 = [0, 1, 2, 3, 4, 5, 7]\nl3 = [0, 1, 2, 3, 4, 5, 7]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements\nl1 = [1, 1, 3, 4, 5, 6, 7]\nl2 = [0, 1, 2, 3, 4, 5, 7]\nl3 = [0, 1, 2, 3, 4, 5, 7]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(len(l1)):\n        if i < len(l2) and i < len(l3) and l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements\nl1 = [1, 1, 3, 4, 5, 6, 7]\nl2 = [0, 1, 2, 3, 4, 5, 7]\nl3 = [0, 1, 2, 3, 4, 5, 7]", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    common = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common.append(l1[i])\n    return common\nl1 = [1, 1, 3, 4, 5, 6, 7]\nl2 = [0, 1, 2, 3, 4, 5, 7]\nl3 = [0, 1, 2, 3, 4, 5, 7]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = [value for index, value in enumerate(l1) if index < len(l2) and index < len(l3) and value == l2[index] == l3[index]]\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements\nl1 = [1, 1, 3, 4, 5, 6, 7]\nl2 = [0, 1, 2, 3, 4, 5, 7]\nl3 = [0, 1, 2, 3, 4, 5, 7]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    length = min(len(l1), len(l2), len(l3))\n    for i in range(length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements\nl1 = [1, 1, 3, 4, 5, 6, 7]\nl2 = [0, 1, 2, 3, 4, 5, 7]\nl3 = [0, 1, 2, 3, 4, 5, 7]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    result = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(len(l1)):\n        if i < len(l2) and i < len(l3) and l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 4}]}, "Mbpp/755": {"dps": 63.49557522123894, "dps_norm": 80.0, "pass@1": 29.0, "profiled": [{"solution": "def second_smallest(lst):\n    # Remove duplicate values from the list\n    unique_lst = list(set(lst))\n    \n    # If the list only has one unique value or none\n    if len(unique_lst) < 2:\n        return None\n    \n    # Sort the list in ascending order and return the second element\n    unique_lst.sort()\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    \"\"\"\n    Function to find the second smallest number in a list.\n    \"\"\"\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] > nums[0]:\n            return nums[i]\n    return None", "matching_cluster_idx": 2}, {"solution": "def second_smallest(nums):\n    \"\"\"\n    Find the second smallest number in a list.\n    \"\"\"\n    # Remove duplicates by converting list to set\n    nums = list(set(nums))\n\n    # If list contains only one or zero element\n    if len(nums) < 2:\n        return None\n    else:\n        # sort the list and return the second element\n        nums.sort()\n        return nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates from the list\n    numbers = list(set(numbers))\n\n    # Check if there are less than 2 unique numbers\n    if len(numbers) < 2:\n        return None\n\n    # Initialize the smallest and second smallest numbers\n    smallest = min(numbers[0], numbers[1])\n    second_smallest = max(numbers[0], numbers[1])\n\n    # Iterate over the remaining numbers in the list\n    for num in numbers[2:]:\n        # If the current number is smaller than the smallest number\n        if num < smallest:\n            # Update the smallest and second smallest numbers\n            second_smallest = smallest\n            smallest = num\n        # If the current number is between the smallest and second smallest numbers\n        elif num < second_smallest:\n            # Update the second smallest number\n            second_smallest = num\n\n    return second_smallest\nnumbers = [1, 2, -8, -2, 0, -2]", "matching_cluster_idx": 3}, {"solution": "def second_smallest(num_list):\n    # Making sure that the list has at least two elements\n    if len(num_list) < 2:\n        return None\n    \n    # Initializing the smallest and second smallest as maximum number\n    smallest = float('inf')\n    second_smallest = float('inf')\n    \n    # Go through the list once\n    for num in num_list:\n        # If current number is less than the smallest number\n        if num < smallest:\n            # Update the smallest and second smallest\n            second_smallest = smallest\n            smallest = num\n        # If current number is between smallest and second smallest\n        elif num < second_smallest and num > smallest:\n            # Update the second smallest number\n            second_smallest = num\n            \n    # Return the second smallest if found, else return None\n    if second_smallest < float('inf'):\n        return second_smallest\n    else:\n        return None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(nums):\n    \"\"\"\n    Function to find the second smallest number in a list.\n    \"\"\"\n    if len(nums) < 2:\n        return None\n    nums = sorted(set(nums))\n    if len(nums) < 2:\n        return None\n    else:\n        return nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    \"\"\"\n    Function to find the second smallest number in a list.\n    If the list has less than 2 elements, it will return None.\n    \"\"\"\n    if len(nums) < 2:\n        return None\n\n    # Initialize the first and second smallest numbers\n    first, second = float('inf'), float('inf')\n\n    # Iterate over the list\n    for num in nums:\n        # Check if this number is smaller than the smallest number so far\n        if num < first:\n            second = first\n            first = num\n        # Check if this number is the second smallest and not equal to the smallest\n        elif first < num < second:\n            second = num\n\n    # If the second smallest number is still equal to infinity after the iteration, it means\n    # there is no second smallest number\n    if second == float('inf'):\n        return None\n\n    return second", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Remove duplicate elements from list\n    numbers = list(set(numbers))\n    \n    # Check if there are at least 2 distinct numbers\n    if len(numbers)<2:\n        return None\n    \n    # Find the two smallest numbers\n    smallest = min(numbers)\n    numbers.remove(smallest)\n    second_smallest_num = min(numbers)\n    \n    return second_smallest_num", "matching_cluster_idx": 4}, {"solution": "def second_smallest(nums):\n    \"\"\"\n    Finds the second smallest number in a list of numbers\n\n    Parameters:\n    nums (list): List of numbers\n\n    Returns:\n    Second smallest number in the list. If the list is less than 2 elements or\n    does not contain a second smallest number, it returns None\n    \"\"\"\n\n    # if the list is less than 2 elements\n    if len(nums) < 2:\n        return None\n    \n    # initialize the first and second variables\n    first, second = float('inf'), float('inf')\n\n    # iterate over the list\n    for num in nums:\n        # ignore if the number is non-numeric\n        if not isinstance(num, (int, float)):\n            continue\n        # update the first and second smallest if the current number is smaller\n        if num < first:\n            first, second = num, first\n        elif first < num < second:\n            second = num\n\n    # if after iterating we couldn't find a second smallest\n    if second == float('inf'):\n        return None\n    \n    # return the second smallest\n    return second", "matching_cluster_idx": 0}, {"solution": "def second_smallest(lst):\n    \"\"\"\n    This function returns the second smallest number in a list.\n    \"\"\"\n    # Remove duplicate values in list\n    lst = list(dict.fromkeys(lst))\n    \n    # If there are fewer than 2 distinct numbers in the list\n    if len(lst) < 2:\n        return None\n    \n    # Sort the list in ascending order\n    lst.sort()\n    \n    # Return the second number in the list\n    return lst[1]", "matching_cluster_idx": 2}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns the second smallest number in the list.\n    If the list has less than two distinct numbers, it returns None.\n    \"\"\"\n    # Remove duplicates by converting list to set\n    numbers_set = set(numbers)\n\n    # Convert back to list and sort in ascending order\n    sorted_numbers = sorted(list(numbers_set))\n\n    # Return second number if it exists, else return None\n    if len(sorted_numbers) >= 2:\n        return sorted_numbers[1]\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(num_list):\n    \"\"\"\n    This function returns the second smallest number in a list.\n    \"\"\"\n\n    # Remove duplicates from the list\n    num_list = list(set(num_list))\n    \n    # If there are less than 2 unique numbers, we return None\n    if len(num_list) < 2:\n        return None\n\n    # Sort the list in ascending order\n    num_list.sort()\n    \n    # Return the second number in the sorted list\n    return num_list[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Function to find the second smallest number in a list.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    first_smallest = second_smallest = float('inf')\n    for number in numbers:\n        if number < first_smallest:\n            first_smallest, second_smallest = number, first_smallest\n        elif first_smallest < number < second_smallest:\n            second_smallest = number\n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 3}, {"solution": "def second_smallest(lst):\n    \"\"\"\n    Function to find the second smallest number in a list.\n    \"\"\"\n    # remove duplicates and sort the list\n    lst = sorted(set(lst))\n    # return the second smallest number\n    return lst[1] if len(lst) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Remove duplicates from list\n    nums = list(set(nums))\n    # Sort the list\n    nums.sort()\n    # If the list has less than 2 elements, there is no second smallest element\n    if len(nums) < 2:\n        return None\n    else:\n        # Return the second element of sorted list\n        return nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Remove duplicates by using set and then convert back to list\n    nums = list(set(nums))\n    # Sort the list\n    nums.sort()\n    # If list has at least two elements, return the second one\n    if len(nums) > 1:\n        return nums[1]\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates from the list.\n    unique_numbers = list(set(lst))\n\n    # Initialize the smallest and second smallest as positive infinity.\n    smallest, second_smallest = float('inf'), float('inf')\n    \n    # If the list has less than 2 distinct numbers, return None.\n    if len(unique_numbers) < 2:\n        return None\n\n    # Find the smallest and second smallest numbers in the list.\n    for number in unique_numbers:\n        if number < smallest:\n            smallest = number\n    unique_numbers.remove(smallest)\n    for number in unique_numbers:\n        if number < second_smallest:\n            second_smallest = number\n\n    return second_smallest", "matching_cluster_idx": 3}, {"solution": "def second_smallest(nums):\n    nums = set(nums)\n    if len(nums) < 2:\n        return None\n    nums.remove(min(nums))\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def second_smallest(nums):\n    \"\"\"Function to find the second smallest number in a list.\"\"\"\n\n    # Remove duplicates.\n    nums = list(set(nums))\n\n    # Check if the list contains at least two unique numbers.\n    if len(nums) < 2:\n        return None\n\n    # Sort the list in ascending order and return the second element.\n    nums.sort()\n\n    return nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    smallest = None\n    second_smallest = None\n    \n    for num in nums:\n        if smallest is None:\n            smallest = num\n        elif num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif (second_smallest is None or second_smallest > num) and num != smallest:\n            second_smallest = num\n            \n    return second_smallest", "matching_cluster_idx": 3}]}, "Mbpp/757": {"dps": 82.71028037383178, "dps_norm": 23.076923076923077, "pass@1": 15.0, "profiled": [{"solution": "def count_reverse_pairs(words):\n    count = 0\n    for i in range(len(words)):\n        for j in range(i+1, len(words)):\n            if words[i] == words[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    pairs = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                pairs.append((lst[i], lst[j]))\n    return len(pairs)", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(words):\n    count = 0\n    for i in range(len(words)):\n        for j in range(i+1, len(words)):\n            if words[i][::-1] == words[j]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i][::-1] == lst[j]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(arr):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if is_reverse(arr[i], arr[j]):\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i+1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(words):\n    count = 0\n    for i in range(len(words)):\n        for j in range(i+1, len(words)):\n            if words[i] == words[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(list_of_strings):\n    count = 0\n    for i in range(len(list_of_strings)):\n        for j in range(i + 1, len(list_of_strings)):\n            if list_of_strings[i] == list_of_strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(word_list):\n    \"\"\"\n    Function to count the pairs of reverse strings in the given string list.\n    \"\"\"\n    count = 0\n    for i in range(len(word_list)):\n        for j in range(i+1, len(word_list)):\n            # check if a word is the reverse of the other\n            if word_list[i] == word_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(input_list):\n    counter = 0\n    for i in range(len(input_list)):\n        for j in range(i+1, len(input_list)):\n            if input_list[i][::-1] == input_list[j]:\n                counter += 1\n    return counter", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    reverse_pairs_count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                reverse_pairs_count += 1\n    return reverse_pairs_count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i][::-1] == lst[j]:\n                count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 87.8185328185328, "dps_norm": 83.125, "pass@1": 96.0, "profiled": [{"solution": "def unique_sublists(lst):\n    res = {}\n    for i in lst:\n        i = tuple(i)\n        if i in res:\n            res[i] += 1\n        else:\n            res[i] = 1\n    return res", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        # convert each sublist to a tuple\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    result_dict = {}\n    for sublist in lst:\n        tup = tuple(sublist)\n        if tup in result_dict:\n            result_dict[tup] += 1\n        else:\n            result_dict[tup] = 1\n    return result_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    from collections import defaultdict\n    dict_count = defaultdict(int)\n    for sublist in lst:\n        dict_count[tuple(sublist)] += 1\n    return dict_count", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        sublist_as_tuple = tuple(sublist)\n        if sublist_as_tuple in result:\n            result[sublist_as_tuple] += 1\n        else:\n            result[sublist_as_tuple] = 1\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(sublists):\n    sublists_dict = {}\n    for sublist in sublists:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublists_dict:\n            sublists_dict[sublist_tuple] += 1\n        else:\n            sublists_dict[sublist_tuple] = 1\n    return sublists_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sub_lst in lst:\n        sub_tup = tuple(sub_lst)\n        if sub_tup in result:\n            result[sub_tup] += 1\n        else:\n            result[sub_tup] = 1\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    freq_dict = {}\n    for sub_list in lst:\n        sub_tuple = tuple(sub_list)\n        if sub_tuple in freq_dict:\n            freq_dict[sub_tuple] += 1\n        else:\n            freq_dict[sub_tuple] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    dic = {}\n    for sublist in lst:\n        t = tuple(sublist)\n        if t in dic:\n            dic[t] += 1\n        else:\n            dic[t] = 1\n    return dic", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Convert each sublist to a tuple\n    lst = [tuple(i) for i in lst]\n    \n    # Create a dictionary with tuples as keys and their counts as values\n    unique_dict = {}\n    for i in lst:\n        if i in unique_dict:\n            unique_dict[i] += 1\n        else:\n            unique_dict[i] = 1\n    \n    return unique_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    tupled_lst = [tuple(sublist) for sublist in lst]\n    return dict(Counter(tupled_lst))", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    return {tuple(sublist): lst.count(sublist) for sublist in lst}", "matching_cluster_idx": 3}, {"solution": "def unique_sublists(lists):\n    # Convert each list to a tuple, and count its occurrences in the original list\n    return {tuple(lst): lists.count(lst) for lst in [list(x) for x in set(tuple(x) for x in lists)]}", "matching_cluster_idx": 3}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublst in lst:\n        sublst = tuple(sublst)\n        if sublst in count_dict:\n            count_dict[sublst] += 1\n        else:\n            count_dict[sublst] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(list_of_lists):\n    from collections import Counter\n    tuple_list = [tuple(sublist) for sublist in list_of_lists]\n    count_dict = dict(Counter(tuple_list))\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(input_list):\n    output_dict = {}\n    for sublist in input_list:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple not in output_dict:\n            output_dict[sublist_tuple] = 1\n        else:\n            output_dict[sublist_tuple] += 1\n    return output_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    dict_out = {}\n    for sublist in lst:\n        tup = tuple(sublist)\n        if tup in dict_out:\n            dict_out[tup] += 1\n        else:\n            dict_out[tup] = 1\n    return dict_out\nlst = [[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]]", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    dic = {}\n    for sublist in lst:\n        tup = tuple(sublist)\n        if tup in dic:\n            dic[tup] += 1\n        else:\n            dic[tup] = 1\n    return dic", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 99.27007299270073, "dps_norm": 87.5, "pass@1": 70.0, "profiled": [{"solution": "def unique_Element(num_list):\n    \"\"\"\n    Function to check whether a list of numbers contains only one distinct element or not\n    \"\"\"\n    return len(set(num_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(num_list):\n    \"\"\"\n    Function to check whether a list contains only one distinct element or not.\n    \"\"\"\n    # Create a set from the list\n    set_list = set(num_list)\n    \n    # If the length of the set is 1, return True (the list contains only unique elements)\n    if len(set_list) == 1:\n        return True\n    else:\n        return False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(num_list):\n    return len(set(num_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(num_list):\n    \"\"\"\n    A function to check if a list contains only one distinct element or not\n    :param num_list: list\n    :return: bool\n    \"\"\"\n    return len(set(num_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(num_list):\n    # Check if all elements in the list are the same\n    return len(set(num_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Check if all elements in the list are the same\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Function to check if a list of numbers contains only one distinct element\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(string):\n    return sum(c.isdigit() for c in string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_str):\n    \"\"\"\n    A python function to count number of digits in a given string.\n    \"\"\"\n    return sum(c.isdigit() for c in input_str)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(text):\n    count = 0\n    for char in text:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_str):\n    return sum(c.isdigit() for c in input_str)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    count = 0\n    for char in string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    A function to count the number of digits in a string.\n    \n    Parameters:\n    string (str): The string in which to count the digits.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    # Initialize count to 0\n    count = 0\n\n    # Iterate over each character in the string\n    for char in string:\n        # Check if character is a digit\n        if char.isdigit():\n            # Increase count by 1\n            count += 1\n\n    # Return count\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"Count number of digits in a given string.\"\"\"\n    return sum(character.isdigit() for character in string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    return sum(character.isdigit() for character in string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    return sum(c.isdigit() for c in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Function to count number of digits in a given string.\n    \"\"\"\n    # Initialize counter\n    digit_ctr = 0\n\n    # Iterate over each character in the string\n    for char in s:\n\n        # If the character is a digit, increment counter\n        if char.isdigit():\n            digit_ctr += 1\n\n    return digit_ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string: str) -> int:\n    return sum(character.isdigit() for character in string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 58.925233644859816, "dps_norm": 52.5, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    result = [(input_list[n], input_list[n + 1]) for n in range(len(input_list) - 1)]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(nums):\n    \"\"\"Returns a list of all pairs of consecutive items in a given list.\"\"\"\n    return [(nums[i], nums[i+1]) for i in range(len(nums)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(items):\n    return [(items[i], items[i+1]) for i in range(len(items)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"Return a list of all pairs of consecutive items in a given list.\"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(arr):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    return [(arr[i], arr[i+1]) for i in range(len(arr)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(list_):\n    return [(list_[i], list_[i + 1]) for i in range(len(list_) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(arr):\n    \"\"\"\n    This function returns a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    result = []\n    for i in range(len(arr) - 1):\n        result.append((arr[i], arr[i + 1]))\n    return result", "matching_cluster_idx": 2}]}, "Mbpp/775": {"dps": 69.91999999999999, "dps_norm": 47.14285714285714, "pass@1": 89.0, "profiled": [{"solution": "def odd_position(lst):\n    return all(i % 2 == 1 for i in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every odd index contains odd numbers in the given list.\n    \"\"\"\n    return all(n % 2 != 0 for i, n in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(num_list):\n    for i in range(len(num_list)):\n        if i % 2 != 0 and num_list[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Function to check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(v % 2 != 0 for i, v in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 == 1 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(value % 2 != 0 for index, value in enumerate(lst) if index % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    This function checks whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    for i in range(len(lst)):\n        # Check if index is odd and element on that index is not odd\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every odd index contains odd numbers from a given list.\n\n    Parameters:\n    lst (list): input list of integers.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(input_list):\n    # Initialize odd_count to 0\n    odd_count = 0\n\n    # Iterate over odd indices\n    for i in range(1, len(input_list), 2):\n        # If number at odd index is odd, increment odd_count\n        if input_list[i] % 2 != 0:\n            odd_count += 1\n\n    # If odd_count equals half of length of list (rounded down), return True, else False\n    return odd_count == len(input_list) // 2", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    # Check every odd indexed element in the list for oddness.\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(input_list):\n    \"\"\"\n    Check if every odd index contains odd numbers.\n    \"\"\"\n    return all(num % 2 != 0 for i, num in enumerate(input_list) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(arr):\n    # filter odd indices and store in a new list\n    odd_indices = [arr[i] for i in range(len(arr)) if i % 2 != 0]\n\n    # check whether every element of the new list is odd\n    for i in odd_indices:\n        if i % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(input_list):\n    for i in range(len(input_list)):\n        if i % 2 != 0 and input_list[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(input_list):\n    # Start checking from index 1 with step 2\n    for i in range(1, len(input_list), 2):\n        if input_list[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        # Skip even indices\n        if i % 2 == 0:\n            continue\n        # Check if number on odd index is odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(v % 2 != 0 for i, v in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}]}, "Mbpp/777": {"dps": null, "dps_norm": null, "pass@1": 8.0, "profiled": []}, "Mbpp/781": {"dps": 67.4015748031496, "dps_norm": 66.0, "pass@1": 91.0, "profiled": [{"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(num):\n    \"\"\"Return whether the count of divisors is even.\"\"\"\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(num):\n    \"\"\"\n    Function that counts the number of divisors of an integer and checks whether the count is even\n    \"\"\"\n    divisors_count = 0\n    for i in range(1, int(num**0.5) + 1):\n        if num % i == 0:\n            divisors_count += 1\n            if num / i != i:\n                divisors_count += 1\n    return divisors_count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function takes an integer n and returns True if the count of its divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):  # Loop up to the square root of n\n        if n % i == 0:  # If i is a divisor of n\n            if n / i == i:  # If divisors are equal\n                count += 1\n            else:  # If divisors are different\n                count += 2\n    return count % 2 == 0  # Return True if count of divisors is even, False otherwise", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n        i += 1\n    return count % 2 == 0", "matching_cluster_idx": 2}, {"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while i <= n :\n        if (n % i == 0) :\n            count += 1\n        i += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Return True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(num):\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors is even.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while i <= n:\n        if n % i == 0:\n            count += 1\n        i += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function counts the number of divisors of a number.\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Counts the number of divisors for a number n.\n    :param n: the number to check for number of divisors\n    :returns: True if the count of divisors is even, else False\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(num):\n    \"\"\"\n    This function counts the number of divisors of an integer\n    and checks if the count is even or not.\n\n    Arguments:\n    num -- integer number to check its divisors\n\n    Returns:\n    True -- if the count of divisors is even\n    False -- otherwise\n    \"\"\"\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}]}, "Mbpp/800": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_all_spaces(string):\n    \"\"\"Remove all whitespaces from a string.\"\"\"\n    return string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from a string.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Function to remove all whitespaces from a string.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    Remove all whitespaces from a string.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str):\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str):\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    This function removes all white spaces from a string\n    \"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s: str) -> str:\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Function to remove all whitespaces from a string.\n    \"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(string):\n    return string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 95.03436426116839, "dps_norm": 96.0, "pass@1": 92.0, "profiled": [{"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    max_sum = -float('inf')\n    max_list = []\n    for sublist in lst:\n        if sum(sublist) > max_sum:\n            max_sum = sum(sublist)\n            max_list = sublist\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Function that returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    max_sum = sum(lists[0])\n    max_list = lists[0]\n    for l in lists:\n        if sum(l) > max_sum:\n            max_sum = sum(l)\n            max_list = l\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    max_sum_index = max(range(len(list_of_lists)), key=lambda index: sum(list_of_lists[index]))\n    return list_of_lists[max_sum_index]", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    \"\"\"\n    Function to return the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Function to find the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst_of_lst):\n    return max(lst_of_lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"Function to return the list with the highest sum of elements\"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    max_sum = sum(lst[0])\n    max_list = lst[0]\n\n    for sublist in lst[1:]:\n        if sum(sublist) > max_sum:\n            max_sum = sum(sublist)\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Return None if list is empty\n    if not lst: return None\n    # The first sublist is assumed to have the highest sum initially\n    max_sum_sublist = lst[0]\n    max_sum = sum(max_sum_sublist)\n    # Iterate through the rest of the list\n    for sublist in lst[1:]:\n        if sum(sublist) > max_sum:\n            max_sum = sum(sublist)\n            max_sum_sublist = sublist\n    return max_sum_sublist", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    This function returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    if not all(isinstance(i, list) for i in list_of_lists):\n        raise ValueError(\"Input should be a list of lists\")\n    \n    if not all(all(isinstance(j, (int, float)) for j in i) for i in list_of_lists):\n        raise ValueError(\"Sub-lists should contain only integers or floats\")\n\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 0}]}, "Mbpp/808": {"dps": 96.53508771929825, "dps_norm": 99.16666666666667, "pass@1": 98.0, "profiled": [{"solution": "def check_K(t, k):\n    \"\"\"\n    Function to check if the given tuple contains the k or not.\n    \"\"\"\n    return k in t\nt = (10, 4, 5, 6, 8)\nk = 6", "matching_cluster_idx": 5}, {"solution": "def check_K(numbers, k):\n    \"\"\"\n    Function to check if the given tuple contains the number 'k'\n    \"\"\"\n    # Check if tuple 'numbers' contains number 'k'\n    if k in numbers:\n        return True\n    else:\n        return False", "matching_cluster_idx": 4}, {"solution": "def check_K(t, k):\n    \"\"\"\n    Checks if given tuple contains the value k or not.\n    \"\"\"\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Function to check if the given tuple contains k or not.\n    :param tup: The input tuple\n    :param k: The key to be searched for\n    :return: True if k is in the tuple, otherwise False\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    \"\"\"\n    This function checks if the given tuple contains the element k or not.\n    \"\"\"\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    \"\"\"\n    Function to check if the given tuples contain the k or not.\n\n    Parameters:\n    tpl (tuple): Tuple to check for the element 'k'.\n    k (int): The element to be checked in the tuple 'tpl'.\n\n    Returns:\n    bool: True if the 'k' is found in the tuple 'tpl', otherwise False.\n\n    \"\"\"\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    The function checks whether the given element k exists in the given tuple or not.\n    \n    Parameters:\n    input_tuple (tuple): Input tuple to be searched.\n    k: element to be searched in the tuple.\n\n    Returns:\n    bool: Return True if element k is found in the tuple, else False.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Function to check if the given tuples contain the k or not.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if a tuple contains a given number.\n\n    :param tup: The tuple to check.\n    :param k: The number to look for.\n    :return: True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Checks if the given tuples contain the k or not.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    \"\"\"\n    This function checks whether a given tuple contains a specific number.\n\n    Args:\n    t (tuple): A tuple of numbers.\n    k (int): The number to check for.\n\n    Returns:\n    bool: True if the number k is in the tuple t, False otherwise.\n    \"\"\"\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Function to check if the given tuple contains the k or not\n    \"\"\"\n    # Return True if k is in the tuple, else return False\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    This function checks whether the given k is present in the tuple or not.\n    \"\"\"\n    # The built-in Python function to check if an element is in the tuple\n    if k in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple, k):\n    \"\"\"\n    This function checks if the given tuple contains the given value k.\n    \"\"\"\n    return k in tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    This function checks if the given tuple contains the number k or not.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    return k in tpl", "matching_cluster_idx": 5}]}}}
